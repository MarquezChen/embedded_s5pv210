
u-boot:     file format elf32-littlearm


Disassembly of section .text:

34800000 <__image_copy_start>:
#include <version.h>
#include <asm/system.h>
#include <linux/linkage.h>

.globl _start
_start: b	reset
34800000:	ea000014 	b	34800058 <reset>
	ldr	pc, _undefined_instruction
34800004:	e59ff014 	ldr	pc, [pc, #20]	; 34800020 <_undefined_instruction>
	ldr	pc, _software_interrupt
34800008:	e59ff014 	ldr	pc, [pc, #20]	; 34800024 <_software_interrupt>
	ldr	pc, _prefetch_abort
3480000c:	e59ff014 	ldr	pc, [pc, #20]	; 34800028 <_prefetch_abort>
	ldr	pc, _data_abort
34800010:	e59ff014 	ldr	pc, [pc, #20]	; 3480002c <_data_abort>
	ldr	pc, _not_used
34800014:	e59ff014 	ldr	pc, [pc, #20]	; 34800030 <_not_used>
	ldr	pc, _irq
34800018:	e59ff014 	ldr	pc, [pc, #20]	; 34800034 <_irq>
	ldr	pc, _fiq
3480001c:	e59ff014 	ldr	pc, [pc, #20]	; 34800038 <_fiq>

34800020 <_undefined_instruction>:
34800020:	34800200 	.word	0x34800200

34800024 <_software_interrupt>:
34800024:	34800260 	.word	0x34800260

34800028 <_prefetch_abort>:
34800028:	348002c0 	.word	0x348002c0

3480002c <_data_abort>:
3480002c:	34800320 	.word	0x34800320

34800030 <_not_used>:
34800030:	34800380 	.word	0x34800380

34800034 <_irq>:
34800034:	348003e0 	.word	0x348003e0

34800038 <_fiq>:
34800038:	34800440 	.word	0x34800440

3480003c <_pad>:
3480003c:	12345678 	.word	0x12345678

34800040 <_TEXT_BASE>:
34800040:	34800000 	.word	0x34800000

34800044 <_bss_start_ofs>:
34800044:	00029900 	.word	0x00029900

34800048 <_image_copy_end_ofs>:
34800048:	00029900 	.word	0x00029900

3480004c <_bss_end_ofs>:
3480004c:	0002bc68 	.word	0x0002bc68

34800050 <_end_ofs>:
34800050:	0002dc40 	.word	0x0002dc40

34800054 <IRQ_STACK_START_IN>:
34800054:	0badc0de 	.word	0x0badc0de

34800058 <reset>:
/*
 * the actual reset code
 */

reset:
	bl	save_boot_params
34800058:	eb000056 	bl	348001b8 <save_boot_params>
	/*
	 * set the cpu to SVC32 mode
	 */
	mrs	r0, cpsr
3480005c:	e10f0000 	mrs	r0, CPSR
	bic	r0, r0, #0x1f
34800060:	e3c0001f 	bic	r0, r0, #31
	orr	r0, r0, #0xd3
34800064:	e38000d3 	orr	r0, r0, #211	; 0xd3
	msr	cpsr,r0
34800068:	e129f000 	msr	CPSR_fc, r0
 * (OMAP4 spl TEXT_BASE is not 32 byte aligned.
 * Continue to use ROM code vector only in OMAP4 spl)
 */
#if !(defined(CONFIG_OMAP44XX) && defined(CONFIG_SPL_BUILD))
	/* Set V=0 in CP15 SCTRL register - for VBAR to point to vector */
	mrc	p15, 0, r0, c1, c0, 0	@ Read CP15 SCTRL Register
3480006c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, #CR_V		@ V = 0
34800070:	e3c00a02 	bic	r0, r0, #8192	; 0x2000
	mcr	p15, 0, r0, c1, c0, 0	@ Write CP15 SCTRL Register
34800074:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}

	/* Set vector address in CP15 VBAR register */
	ldr	r0, =_start
34800078:	e59f0408 	ldr	r0, [pc, #1032]	; 34800488 <fiq+0x48>
	mcr	p15, 0, r0, c12, c0, 0	@Set VBAR
3480007c:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
#endif

	/* the mask ROM code should have PLL and others stable */
#ifndef CONFIG_SKIP_LOWLEVEL_INIT
	bl	cpu_init_cp15
34800080:	eb00004d 	bl	348001bc <cpu_init_cp15>
	bl	cpu_init_crit
34800084:	eb00005a 	bl	348001f4 <cpu_init_crit>

34800088 <call_board_init_f>:
#endif

/* Set stackpointer in internal RAM to call board_init_f */
call_board_init_f:
	ldr	sp, =(CONFIG_SYS_INIT_SP_ADDR)
34800088:	e3a0d433 	mov	sp, #855638016	; 0x33000000
	bic	sp, sp, #7 /* 8-byte alignment for ABI compliance */
3480008c:	e3cdd007 	bic	sp, sp, #7
	ldr	r0,=0x00000000
34800090:	e3a00000 	mov	r0, #0
	bl	board_init_f
34800094:	eb000446 	bl	348011b4 <board_init_f>

34800098 <relocate_code>:
 * This "function" does not return, instead it continues in RAM
 * after relocating the monitor code.
 *
 */
ENTRY(relocate_code)
	mov	r4, r0	/* save addr_sp */
34800098:	e1a04000 	mov	r4, r0
	mov	r5, r1	/* save addr of gd */
3480009c:	e1a05001 	mov	r5, r1
	mov	r6, r2	/* save addr of destination */
348000a0:	e1a06002 	mov	r6, r2

348000a4 <stack_setup>:

	/* Set up the stack						    */
stack_setup:
	mov	sp, r4
348000a4:	e1a0d004 	mov	sp, r4

	adr	r0, _start
348000a8:	e24f00b0 	sub	r0, pc, #176	; 0xb0
	cmp	r0, r6
348000ac:	e1500006 	cmp	r0, r6
	moveq	r9, #0		/* no relocation. relocation offset(r9) = 0 */
348000b0:	03a09000 	moveq	r9, #0
	beq	clear_bss		/* skip relocation */
348000b4:	0a000026 	beq	34800154 <clear_bss>
	mov	r1, r6			/* r1 <- scratch for copy_loop */
348000b8:	e1a01006 	mov	r1, r6
	ldr	r3, _image_copy_end_ofs
348000bc:	e51f307c 	ldr	r3, [pc, #-124]	; 34800048 <_image_copy_end_ofs>
	add	r2, r0, r3		/* r2 <- source end address	    */
348000c0:	e0802003 	add	r2, r0, r3

348000c4 <copy_loop>:

copy_loop:
	ldmia	r0!, {r9-r10}		/* copy from source address [r0]    */
348000c4:	e8b00600 	ldm	r0!, {r9, sl}
	stmia	r1!, {r9-r10}		/* copy to   target address [r1]    */
348000c8:	e8a10600 	stmia	r1!, {r9, sl}
	cmp	r0, r2			/* until source end address [r2]    */
348000cc:	e1500002 	cmp	r0, r2
	blo	copy_loop
348000d0:	3afffffb 	bcc	348000c4 <copy_loop>

	/*
	 * fix .rel.dyn relocations
	 */
	ldr	r0, _TEXT_BASE		/* r0 <- Text base */
348000d4:	e51f009c 	ldr	r0, [pc, #-156]	; 34800040 <_TEXT_BASE>
	sub	r9, r6, r0		/* r9 <- relocation offset */
348000d8:	e0469000 	sub	r9, r6, r0
	ldr	r10, _dynsym_start_ofs	/* r10 <- sym table ofs */
348000dc:	e59fa06c 	ldr	sl, [pc, #108]	; 34800150 <_dynsym_start_ofs>
	add	r10, r10, r0		/* r10 <- sym table in FLASH */
348000e0:	e08aa000 	add	sl, sl, r0
	ldr	r2, _rel_dyn_start_ofs	/* r2 <- rel dyn start ofs */
348000e4:	e59f205c 	ldr	r2, [pc, #92]	; 34800148 <_rel_dyn_start_ofs>
	add	r2, r2, r0		/* r2 <- rel dyn start in FLASH */
348000e8:	e0822000 	add	r2, r2, r0
	ldr	r3, _rel_dyn_end_ofs	/* r3 <- rel dyn end ofs */
348000ec:	e59f3058 	ldr	r3, [pc, #88]	; 3480014c <_rel_dyn_end_ofs>
	add	r3, r3, r0		/* r3 <- rel dyn end in FLASH */
348000f0:	e0833000 	add	r3, r3, r0

348000f4 <fixloop>:
fixloop:
	ldr	r0, [r2]		/* r0 <- location to fix up, IN FLASH! */
348000f4:	e5920000 	ldr	r0, [r2]
	add	r0, r0, r9		/* r0 <- location to fix up in RAM */
348000f8:	e0800009 	add	r0, r0, r9
	ldr	r1, [r2, #4]
348000fc:	e5921004 	ldr	r1, [r2, #4]
	and	r7, r1, #0xff
34800100:	e20170ff 	and	r7, r1, #255	; 0xff
	cmp	r7, #23			/* relative fixup? */
34800104:	e3570017 	cmp	r7, #23
	beq	fixrel
34800108:	0a000007 	beq	3480012c <fixrel>
	cmp	r7, #2			/* absolute fixup? */
3480010c:	e3570002 	cmp	r7, #2
	beq	fixabs
34800110:	0a000000 	beq	34800118 <fixabs>
	/* ignore unknown type of fixup */
	b	fixnext
34800114:	ea000006 	b	34800134 <fixnext>

34800118 <fixabs>:
fixabs:
	/* absolute fix: set location to (offset) symbol value */
	mov	r1, r1, LSR #4		/* r1 <- symbol index in .dynsym */
34800118:	e1a01221 	lsr	r1, r1, #4
	add	r1, r10, r1		/* r1 <- address of symbol in table */
3480011c:	e08a1001 	add	r1, sl, r1
	ldr	r1, [r1, #4]		/* r1 <- symbol value */
34800120:	e5911004 	ldr	r1, [r1, #4]
	add	r1, r1, r9		/* r1 <- relocated sym addr */
34800124:	e0811009 	add	r1, r1, r9
	b	fixnext
34800128:	ea000001 	b	34800134 <fixnext>

3480012c <fixrel>:
fixrel:
	/* relative fix: increase location by offset */
	ldr	r1, [r0]
3480012c:	e5901000 	ldr	r1, [r0]
	add	r1, r1, r9
34800130:	e0811009 	add	r1, r1, r9

34800134 <fixnext>:
fixnext:
	str	r1, [r0]
34800134:	e5801000 	str	r1, [r0]
	add	r2, r2, #8		/* each rel.dyn entry is 8 bytes */
34800138:	e2822008 	add	r2, r2, #8
	cmp	r2, r3
3480013c:	e1520003 	cmp	r2, r3
	blo	fixloop
34800140:	3affffeb 	bcc	348000f4 <fixloop>
	b	clear_bss
34800144:	ea000002 	b	34800154 <clear_bss>

34800148 <_rel_dyn_start_ofs>:
34800148:	00029900 	.word	0x00029900

3480014c <_rel_dyn_end_ofs>:
3480014c:	0002dc10 	.word	0x0002dc10

34800150 <_dynsym_start_ofs>:
34800150:	0002dc10 	.word	0x0002dc10

34800154 <clear_bss>:
	.word __rel_dyn_end - _start
_dynsym_start_ofs:
	.word __dynsym_start - _start

clear_bss:
	ldr	r0, _bss_start_ofs
34800154:	e51f0118 	ldr	r0, [pc, #-280]	; 34800044 <_bss_start_ofs>
	ldr	r1, _bss_end_ofs
34800158:	e51f1114 	ldr	r1, [pc, #-276]	; 3480004c <_bss_end_ofs>
	mov	r4, r6			/* reloc addr */
3480015c:	e1a04006 	mov	r4, r6
	add	r0, r0, r4
34800160:	e0800004 	add	r0, r0, r4
	add	r1, r1, r4
34800164:	e0811004 	add	r1, r1, r4
	mov	r2, #0x00000000		/* clear			    */
34800168:	e3a02000 	mov	r2, #0

3480016c <clbss_l>:

clbss_l:cmp	r0, r1			/* clear loop... */
3480016c:	e1500001 	cmp	r0, r1
	bhs	clbss_e			/* if reached end of bss, exit */
34800170:	2a000002 	bcs	34800180 <clbss_e>
	str	r2, [r0]
34800174:	e5802000 	str	r2, [r0]
	add	r0, r0, #4
34800178:	e2800004 	add	r0, r0, #4
	b	clbss_l
3480017c:	eafffffa 	b	3480016c <clbss_l>

34800180 <clbss_e>:
jump_2_ram:
/*
 * If I-cache is enabled invalidate it
 */
#ifndef CONFIG_SYS_ICACHE_OFF
	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
34800180:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
	mcr     p15, 0, r0, c7, c10, 4	@ DSB
34800184:	ee070f9a 	mcr	15, 0, r0, cr7, cr10, {4}
	mcr     p15, 0, r0, c7, c5, 4	@ ISB
34800188:	ee070f95 	mcr	15, 0, r0, cr7, cr5, {4}
/*
 * Move vector table
 */
#if !defined(CONFIG_TEGRA20)
	/* Set vector address in CP15 VBAR register */
	ldr     r0, =_start
3480018c:	e59f02f4 	ldr	r0, [pc, #756]	; 34800488 <fiq+0x48>
	add     r0, r0, r9
34800190:	e0800009 	add	r0, r0, r9
	mcr     p15, 0, r0, c12, c0, 0  @Set VBAR
34800194:	ee0c0f10 	mcr	15, 0, r0, cr12, cr0, {0}
#endif /* !Tegra20 */

	ldr	r0, _board_init_r_ofs
34800198:	e59f0014 	ldr	r0, [pc, #20]	; 348001b4 <_board_init_r_ofs>
	adr	r1, _start
3480019c:	e24f1f69 	sub	r1, pc, #420	; 0x1a4
	add	lr, r0, r1
348001a0:	e080e001 	add	lr, r0, r1
	add	lr, lr, r9
348001a4:	e08ee009 	add	lr, lr, r9
	/* setup parameters for board_init_r */
	mov	r0, r5		/* gd_t */
348001a8:	e1a00005 	mov	r0, r5
	mov	r1, r6		/* dest_addr */
348001ac:	e1a01006 	mov	r1, r6
	/* jump to it ... */
	mov	pc, lr
348001b0:	e1a0f00e 	mov	pc, lr

348001b4 <_board_init_r_ofs>:
348001b4:	00001100 	.word	0x00001100

348001b8 <save_boot_params>:
 * Stack pointer is not yet initialized at this moment
 * Don't save anything to stack even if compiled with -O0
 *
 *************************************************************************/
ENTRY(save_boot_params)
	bx	lr			@ back to my caller
348001b8:	e12fff1e 	bx	lr

348001bc <cpu_init_cp15>:
 *************************************************************************/
ENTRY(cpu_init_cp15)
	/*
	 * Invalidate L1 I/D
	 */
	mov	r0, #0			@ set up for MCR
348001bc:	e3a00000 	mov	r0, #0
	mcr	p15, 0, r0, c8, c7, 0	@ invalidate TLBs
348001c0:	ee080f17 	mcr	15, 0, r0, cr8, cr7, {0}
	mcr	p15, 0, r0, c7, c5, 0	@ invalidate icache
348001c4:	ee070f15 	mcr	15, 0, r0, cr7, cr5, {0}
	mcr	p15, 0, r0, c7, c5, 6	@ invalidate BP array
348001c8:	ee070fd5 	mcr	15, 0, r0, cr7, cr5, {6}
	mcr     p15, 0, r0, c7, c10, 4	@ DSB
348001cc:	ee070f9a 	mcr	15, 0, r0, cr7, cr10, {4}
	mcr     p15, 0, r0, c7, c5, 4	@ ISB
348001d0:	ee070f95 	mcr	15, 0, r0, cr7, cr5, {4}

	/*
	 * disable MMU stuff and caches
	 */
	mrc	p15, 0, r0, c1, c0, 0
348001d4:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
	bic	r0, r0, #0x00002000	@ clear bits 13 (--V-)
348001d8:	e3c00a02 	bic	r0, r0, #8192	; 0x2000
	bic	r0, r0, #0x00000007	@ clear bits 2:0 (-CAM)
348001dc:	e3c00007 	bic	r0, r0, #7
	orr	r0, r0, #0x00000002	@ set bit 1 (--A-) Align
348001e0:	e3800002 	orr	r0, r0, #2
	orr	r0, r0, #0x00000800	@ set bit 11 (Z---) BTB
348001e4:	e3800b02 	orr	r0, r0, #2048	; 0x800
#ifdef CONFIG_SYS_ICACHE_OFF
	bic	r0, r0, #0x00001000	@ clear bit 12 (I) I-cache
#else
	orr	r0, r0, #0x00001000	@ set bit 12 (I) I-cache
348001e8:	e3800a01 	orr	r0, r0, #4096	; 0x1000
#endif
	mcr	p15, 0, r0, c1, c0, 0
348001ec:	ee010f10 	mcr	15, 0, r0, cr1, cr0, {0}
	mov	pc, lr			@ back to my caller
348001f0:	e1a0f00e 	mov	pc, lr

348001f4 <cpu_init_crit>:
	 * Jump to board specific initialization...
	 * The Mask ROM will have already initialized
	 * basic memory. Go here to bump up clock rate and handle
	 * wake up conditions.
	 */
	b	lowlevel_init		@ go setup pll,mux,memory
348001f4:	ea007c96 	b	3481f454 <lowlevel_init>
348001f8:	e320f000 	nop	{0}
348001fc:	e320f000 	nop	{0}

34800200 <undefined_instruction>:
/*
 * exception handlers
 */
	.align	5
undefined_instruction:
	get_bad_stack
34800200:	e51fd1b4 	ldr	sp, [pc, #-436]	; 34800054 <IRQ_STACK_START_IN>
34800204:	e58de000 	str	lr, [sp]
34800208:	e14fe000 	mrs	lr, SPSR
3480020c:	e58de004 	str	lr, [sp, #4]
34800210:	e3a0d013 	mov	sp, #19
34800214:	e169f00d 	msr	SPSR_fc, sp
34800218:	e1a0e00f 	mov	lr, pc
3480021c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800220:	e24dd048 	sub	sp, sp, #72	; 0x48
34800224:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800228:	e51f21dc 	ldr	r2, [pc, #-476]	; 34800054 <IRQ_STACK_START_IN>
3480022c:	e892000c 	ldm	r2, {r2, r3}
34800230:	e28d0048 	add	r0, sp, #72	; 0x48
34800234:	e28d5034 	add	r5, sp, #52	; 0x34
34800238:	e1a0100e 	mov	r1, lr
3480023c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800240:	e1a0000d 	mov	r0, sp
	bl	do_undefined_instruction
34800244:	eb00051d 	bl	348016c0 <do_undefined_instruction>
34800248:	e320f000 	nop	{0}
3480024c:	e320f000 	nop	{0}
34800250:	e320f000 	nop	{0}
34800254:	e320f000 	nop	{0}
34800258:	e320f000 	nop	{0}
3480025c:	e320f000 	nop	{0}

34800260 <software_interrupt>:

	.align	5
software_interrupt:
	get_bad_stack_swi
34800260:	e24dd004 	sub	sp, sp, #4
34800264:	e58d0000 	str	r0, [sp]
34800268:	e51f021c 	ldr	r0, [pc, #-540]	; 34800054 <IRQ_STACK_START_IN>
3480026c:	e580e000 	str	lr, [r0]
34800270:	e14f0000 	mrs	r0, SPSR
34800274:	e580e004 	str	lr, [r0, #4]
34800278:	e59d0000 	ldr	r0, [sp]
3480027c:	e28dd004 	add	sp, sp, #4
	bad_save_user_regs
34800280:	e24dd048 	sub	sp, sp, #72	; 0x48
34800284:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800288:	e51f223c 	ldr	r2, [pc, #-572]	; 34800054 <IRQ_STACK_START_IN>
3480028c:	e892000c 	ldm	r2, {r2, r3}
34800290:	e28d0048 	add	r0, sp, #72	; 0x48
34800294:	e28d5034 	add	r5, sp, #52	; 0x34
34800298:	e1a0100e 	mov	r1, lr
3480029c:	e885000f 	stm	r5, {r0, r1, r2, r3}
348002a0:	e1a0000d 	mov	r0, sp
	bl	do_software_interrupt
348002a4:	eb00050e 	bl	348016e4 <do_software_interrupt>
348002a8:	e320f000 	nop	{0}
348002ac:	e320f000 	nop	{0}
348002b0:	e320f000 	nop	{0}
348002b4:	e320f000 	nop	{0}
348002b8:	e320f000 	nop	{0}
348002bc:	e320f000 	nop	{0}

348002c0 <prefetch_abort>:

	.align	5
prefetch_abort:
	get_bad_stack
348002c0:	e51fd274 	ldr	sp, [pc, #-628]	; 34800054 <IRQ_STACK_START_IN>
348002c4:	e58de000 	str	lr, [sp]
348002c8:	e14fe000 	mrs	lr, SPSR
348002cc:	e58de004 	str	lr, [sp, #4]
348002d0:	e3a0d013 	mov	sp, #19
348002d4:	e169f00d 	msr	SPSR_fc, sp
348002d8:	e1a0e00f 	mov	lr, pc
348002dc:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
348002e0:	e24dd048 	sub	sp, sp, #72	; 0x48
348002e4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
348002e8:	e51f229c 	ldr	r2, [pc, #-668]	; 34800054 <IRQ_STACK_START_IN>
348002ec:	e892000c 	ldm	r2, {r2, r3}
348002f0:	e28d0048 	add	r0, sp, #72	; 0x48
348002f4:	e28d5034 	add	r5, sp, #52	; 0x34
348002f8:	e1a0100e 	mov	r1, lr
348002fc:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800300:	e1a0000d 	mov	r0, sp
	bl	do_prefetch_abort
34800304:	eb0004ff 	bl	34801708 <do_prefetch_abort>
34800308:	e320f000 	nop	{0}
3480030c:	e320f000 	nop	{0}
34800310:	e320f000 	nop	{0}
34800314:	e320f000 	nop	{0}
34800318:	e320f000 	nop	{0}
3480031c:	e320f000 	nop	{0}

34800320 <data_abort>:

	.align	5
data_abort:
	get_bad_stack
34800320:	e51fd2d4 	ldr	sp, [pc, #-724]	; 34800054 <IRQ_STACK_START_IN>
34800324:	e58de000 	str	lr, [sp]
34800328:	e14fe000 	mrs	lr, SPSR
3480032c:	e58de004 	str	lr, [sp, #4]
34800330:	e3a0d013 	mov	sp, #19
34800334:	e169f00d 	msr	SPSR_fc, sp
34800338:	e1a0e00f 	mov	lr, pc
3480033c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800340:	e24dd048 	sub	sp, sp, #72	; 0x48
34800344:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800348:	e51f22fc 	ldr	r2, [pc, #-764]	; 34800054 <IRQ_STACK_START_IN>
3480034c:	e892000c 	ldm	r2, {r2, r3}
34800350:	e28d0048 	add	r0, sp, #72	; 0x48
34800354:	e28d5034 	add	r5, sp, #52	; 0x34
34800358:	e1a0100e 	mov	r1, lr
3480035c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800360:	e1a0000d 	mov	r0, sp
	bl	do_data_abort
34800364:	eb0004f0 	bl	3480172c <do_data_abort>
34800368:	e320f000 	nop	{0}
3480036c:	e320f000 	nop	{0}
34800370:	e320f000 	nop	{0}
34800374:	e320f000 	nop	{0}
34800378:	e320f000 	nop	{0}
3480037c:	e320f000 	nop	{0}

34800380 <not_used>:

	.align	5
not_used:
	get_bad_stack
34800380:	e51fd334 	ldr	sp, [pc, #-820]	; 34800054 <IRQ_STACK_START_IN>
34800384:	e58de000 	str	lr, [sp]
34800388:	e14fe000 	mrs	lr, SPSR
3480038c:	e58de004 	str	lr, [sp, #4]
34800390:	e3a0d013 	mov	sp, #19
34800394:	e169f00d 	msr	SPSR_fc, sp
34800398:	e1a0e00f 	mov	lr, pc
3480039c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
348003a0:	e24dd048 	sub	sp, sp, #72	; 0x48
348003a4:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
348003a8:	e51f235c 	ldr	r2, [pc, #-860]	; 34800054 <IRQ_STACK_START_IN>
348003ac:	e892000c 	ldm	r2, {r2, r3}
348003b0:	e28d0048 	add	r0, sp, #72	; 0x48
348003b4:	e28d5034 	add	r5, sp, #52	; 0x34
348003b8:	e1a0100e 	mov	r1, lr
348003bc:	e885000f 	stm	r5, {r0, r1, r2, r3}
348003c0:	e1a0000d 	mov	r0, sp
	bl	do_not_used
348003c4:	eb0004e1 	bl	34801750 <do_not_used>
348003c8:	e320f000 	nop	{0}
348003cc:	e320f000 	nop	{0}
348003d0:	e320f000 	nop	{0}
348003d4:	e320f000 	nop	{0}
348003d8:	e320f000 	nop	{0}
348003dc:	e320f000 	nop	{0}

348003e0 <irq>:

#else

	.align	5
irq:
	get_bad_stack
348003e0:	e51fd394 	ldr	sp, [pc, #-916]	; 34800054 <IRQ_STACK_START_IN>
348003e4:	e58de000 	str	lr, [sp]
348003e8:	e14fe000 	mrs	lr, SPSR
348003ec:	e58de004 	str	lr, [sp, #4]
348003f0:	e3a0d013 	mov	sp, #19
348003f4:	e169f00d 	msr	SPSR_fc, sp
348003f8:	e1a0e00f 	mov	lr, pc
348003fc:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800400:	e24dd048 	sub	sp, sp, #72	; 0x48
34800404:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800408:	e51f23bc 	ldr	r2, [pc, #-956]	; 34800054 <IRQ_STACK_START_IN>
3480040c:	e892000c 	ldm	r2, {r2, r3}
34800410:	e28d0048 	add	r0, sp, #72	; 0x48
34800414:	e28d5034 	add	r5, sp, #52	; 0x34
34800418:	e1a0100e 	mov	r1, lr
3480041c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800420:	e1a0000d 	mov	r0, sp
	bl	do_irq
34800424:	eb0004db 	bl	34801798 <do_irq>
34800428:	e320f000 	nop	{0}
3480042c:	e320f000 	nop	{0}
34800430:	e320f000 	nop	{0}
34800434:	e320f000 	nop	{0}
34800438:	e320f000 	nop	{0}
3480043c:	e320f000 	nop	{0}

34800440 <fiq>:

	.align	5
fiq:
	get_bad_stack
34800440:	e51fd3f4 	ldr	sp, [pc, #-1012]	; 34800054 <IRQ_STACK_START_IN>
34800444:	e58de000 	str	lr, [sp]
34800448:	e14fe000 	mrs	lr, SPSR
3480044c:	e58de004 	str	lr, [sp, #4]
34800450:	e3a0d013 	mov	sp, #19
34800454:	e169f00d 	msr	SPSR_fc, sp
34800458:	e1a0e00f 	mov	lr, pc
3480045c:	e1b0f00e 	movs	pc, lr
	bad_save_user_regs
34800460:	e24dd048 	sub	sp, sp, #72	; 0x48
34800464:	e88d1fff 	stm	sp, {r0, r1, r2, r3, r4, r5, r6, r7, r8, r9, sl, fp, ip}
34800468:	e51f241c 	ldr	r2, [pc, #-1052]	; 34800054 <IRQ_STACK_START_IN>
3480046c:	e892000c 	ldm	r2, {r2, r3}
34800470:	e28d0048 	add	r0, sp, #72	; 0x48
34800474:	e28d5034 	add	r5, sp, #52	; 0x34
34800478:	e1a0100e 	mov	r1, lr
3480047c:	e885000f 	stm	r5, {r0, r1, r2, r3}
34800480:	e1a0000d 	mov	r0, sp
	bl	do_fiq
34800484:	eb0004ba 	bl	34801774 <do_fiq>
34800488:	34800000 	.word	0x34800000
3480048c:	e320f000 	nop	{0}
34800490:	e320f000 	nop	{0}
34800494:	e320f000 	nop	{0}
34800498:	e320f000 	nop	{0}
3480049c:	e320f000 	nop	{0}

348004a0 <v7_maint_dcache_all>:
						   way_shift, log2_line_len);
	}
}

static void v7_maint_dcache_all(u32 operation)
{
348004a0:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
static u32 get_clidr(void)
{
	u32 clidr;

	/* Read current CP15 Cache Level ID Register */
	asm volatile ("mrc p15,1,%0,c0,c0,1" : "=r" (clidr));
348004a4:	ee301f30 	mrc	15, 1, r1, cr0, cr0, {1}
	}
}

static void v7_maint_dcache_all(u32 operation)
{
	u32 level, cache_type, level_start_bit = 0;
348004a8:	e3a03000 	mov	r3, #0
static u32 get_clidr(void)
{
	u32 clidr;

	/* Read current CP15 Cache Level ID Register */
	asm volatile ("mrc p15,1,%0,c0,c0,1" : "=r" (clidr));
348004ac:	e58d1004 	str	r1, [sp, #4]
{
	u32 level, cache_type, level_start_bit = 0;

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
348004b0:	e1a0c003 	mov	ip, r3
			asm volatile ("	mcr p15, 0, %0, c7, c14, 2"
					: : "r" (setway));
		}
	}
	/* DSB to make sure the operation is complete */
	CP15DSB;
348004b4:	e1a05003 	mov	r5, r3
	u32 level, cache_type, level_start_bit = 0;

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
		cache_type = (clidr >> level_start_bit) & 0x7;
348004b8:	e59d1004 	ldr	r1, [sp, #4]
348004bc:	e1a02331 	lsr	r2, r1, r3
348004c0:	e2022007 	and	r2, r2, #7
		if ((cache_type == ARMV7_CLIDR_CTYPE_DATA_ONLY) ||
		    (cache_type == ARMV7_CLIDR_CTYPE_INSTRUCTION_DATA) ||
348004c4:	e2422002 	sub	r2, r2, #2

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
		cache_type = (clidr >> level_start_bit) & 0x7;
		if ((cache_type == ARMV7_CLIDR_CTYPE_DATA_ONLY) ||
348004c8:	e3520002 	cmp	r2, #2
348004cc:	8a00002a 	bhi	3480057c <v7_maint_dcache_all+0xdc>
/*
 * Write the level and type you want to Cache Size Selection Register(CSSELR)
 * to get size details from Current Cache Size ID Register(CCSIDR)
 */
static void set_csselr(u32 level, u32 type)
{	u32 csselr = level << 1 | type;
348004d0:	e1a0408c 	lsl	r4, ip, #1

	/* Write to Cache Size Selection Register(CSSELR) */
	asm volatile ("mcr p15, 2, %0, c0, c0, 0" : : "r" (csselr));
348004d4:	ee404f10 	mcr	15, 2, r4, cr0, cr0, {0}
static u32 get_ccsidr(void)
{
	u32 ccsidr;

	/* Read current CP15 Cache Size ID Register */
	asm volatile ("mrc p15, 1, %0, c0, c0, 0" : "=r" (ccsidr));
348004d8:	ee307f10 	mrc	15, 1, r7, cr0, cr0, {0}
	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
348004dc:	e7e921d7 	ubfx	r2, r7, #3, #10

	set_csselr(level, ARMV7_CSSELR_IND_DATA_UNIFIED);

	ccsidr = get_ccsidr();

	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
348004e0:	e2076007 	and	r6, r7, #7
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
348004e4:	e2829001 	add	r9, r2, #1
	ccsidr = get_ccsidr();

	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;
348004e8:	e2866004 	add	r6, r6, #4

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
			CCSIDR_ASSOCIATIVITY_OFFSET) + 1;
	num_sets  = ((ccsidr & CCSIDR_NUM_SETS_MASK) >>
348004ec:	e7ee76d7 	ubfx	r7, r7, #13, #15
	log2_line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
				CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	log2_line_len += 2;

	num_ways  = ((ccsidr & CCSIDR_ASSOCIATIVITY_MASK) >>
348004f0:	e1a01009 	mov	r1, r9
#ifndef _UTILS_H_
#define _UTILS_H_

static inline s32 log_2_n_round_up(u32 n)
{
	s32 log2n = -1;
348004f4:	e3e0a000 	mvn	sl, #0
	u32 temp = n;

	while (temp) {
348004f8:	e1b010a1 	lsrs	r1, r1, #1
		log2n++;
348004fc:	e28aa001 	add	sl, sl, #1
static inline s32 log_2_n_round_up(u32 n)
{
	s32 log2n = -1;
	u32 temp = n;

	while (temp) {
34800500:	1afffffc 	bne	348004f8 <v7_maint_dcache_all+0x58>
		log2n++;
		temp >>= 1;
	}

	if (n & (n - 1))
34800504:	e1190002 	tst	r9, r2
		return log2n + 1; /* not power of 2 - round up */
34800508:	128aa001 	addne	sl, sl, #1
	 * not be a power of 2
	 */
	log2_num_ways = log_2_n_round_up(num_ways);

	way_shift = (32 - log2_num_ways);
	if (operation == ARMV7_DCACHE_INVAL_ALL) {
3480050c:	e3500001 	cmp	r0, #1
	 * According to ARMv7 ARM number of sets and number of ways need
	 * not be a power of 2
	 */
	log2_num_ways = log_2_n_round_up(num_ways);

	way_shift = (32 - log2_num_ways);
34800510:	e26aa020 	rsb	sl, sl, #32
	if (operation == ARMV7_DCACHE_INVAL_ALL) {
34800514:	1a00000b 	bne	34800548 <v7_maint_dcache_all+0xa8>
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
			setway = (level << 1) | (set << log2_line_len) |
34800518:	e184ba12 	orr	fp, r4, r2, lsl sl
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
3480051c:	e1a01007 	mov	r1, r7
			setway = (level << 1) | (set << log2_line_len) |
34800520:	e1a09004 	mov	r9, r4
34800524:	e18b4611 	orr	r4, fp, r1, lsl r6
				 (way << way_shift);
			/* Invalidate data/unified cache line by set/way */
			asm volatile ("	mcr p15, 0, %0, c7, c6, 2"
34800528:	ee074f56 	mcr	15, 0, r4, cr7, cr6, {2}
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
3480052c:	e2511001 	subs	r1, r1, #1
34800530:	2afffffb 	bcs	34800524 <v7_maint_dcache_all+0x84>
	/*
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
34800534:	e2522001 	subs	r2, r2, #1
34800538:	e1a04009 	mov	r4, r9
3480053c:	2afffff5 	bcs	34800518 <v7_maint_dcache_all+0x78>
			asm volatile ("	mcr p15, 0, %0, c7, c6, 2"
					: : "r" (setway));
		}
	}
	/* DSB to make sure the operation is complete */
	CP15DSB;
34800540:	ee075f9a 	mcr	15, 0, r5, cr7, cr10, {4}
34800544:	ea00000c 	b	3480057c <v7_maint_dcache_all+0xdc>

	way_shift = (32 - log2_num_ways);
	if (operation == ARMV7_DCACHE_INVAL_ALL) {
		v7_inval_dcache_level_setway(level, num_sets, num_ways,
				      way_shift, log2_line_len);
	} else if (operation == ARMV7_DCACHE_CLEAN_INVAL_ALL) {
34800548:	e3500002 	cmp	r0, #2
3480054c:	1a00000a 	bne	3480057c <v7_maint_dcache_all+0xdc>
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
			setway = (level << 1) | (set << log2_line_len) |
34800550:	e184ba12 	orr	fp, r4, r2, lsl sl
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
34800554:	e1a01007 	mov	r1, r7
			setway = (level << 1) | (set << log2_line_len) |
34800558:	e1a09004 	mov	r9, r4
3480055c:	e18b4611 	orr	r4, fp, r1, lsl r6
				 (way << way_shift);
			/*
			 * Clean & Invalidate data/unified
			 * cache line by set/way
			 */
			asm volatile ("	mcr p15, 0, %0, c7, c14, 2"
34800560:	ee074f5e 	mcr	15, 0, r4, cr7, cr14, {2}
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
		for (set = num_sets - 1; set >= 0; set--) {
34800564:	e2511001 	subs	r1, r1, #1
34800568:	2afffffb 	bcs	3480055c <v7_maint_dcache_all+0xbc>
	/*
	 * For optimal assembly code:
	 *	a. count down
	 *	b. have bigger loop inside
	 */
	for (way = num_ways - 1; way >= 0 ; way--) {
3480056c:	e2522001 	subs	r2, r2, #1
34800570:	e1a04009 	mov	r4, r9
34800574:	2afffff5 	bcs	34800550 <v7_maint_dcache_all+0xb0>
			asm volatile ("	mcr p15, 0, %0, c7, c14, 2"
					: : "r" (setway));
		}
	}
	/* DSB to make sure the operation is complete */
	CP15DSB;
34800578:	ee075f9a 	mcr	15, 0, r5, cr7, cr10, {4}
{
	u32 level, cache_type, level_start_bit = 0;

	u32 clidr = get_clidr();

	for (level = 0; level < 7; level++) {
3480057c:	e3530012 	cmp	r3, #18
34800580:	e28cc001 	add	ip, ip, #1
		cache_type = (clidr >> level_start_bit) & 0x7;
		if ((cache_type == ARMV7_CLIDR_CTYPE_DATA_ONLY) ||
		    (cache_type == ARMV7_CLIDR_CTYPE_INSTRUCTION_DATA) ||
		    (cache_type == ARMV7_CLIDR_CTYPE_UNIFIED))
			v7_maint_dcache_level_setway(level, operation);
		level_start_bit += 3;
34800584:	12833003 	addne	r3, r3, #3
34800588:	1affffca 	bne	348004b8 <v7_maint_dcache_all+0x18>
	}
}
3480058c:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

34800590 <v7_dcache_maint_range>:
		asm volatile ("mcr p15, 0, %0, c7, c6, 1" : : "r" (mva));
	}
}

static void v7_dcache_maint_range(u32 start, u32 stop, u32 range_op)
{
34800590:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34800594:	e1a04000 	mov	r4, r0
34800598:	e1a06001 	mov	r6, r1
static u32 get_ccsidr(void)
{
	u32 ccsidr;

	/* Read current CP15 Cache Size ID Register */
	asm volatile ("mrc p15, 1, %0, c0, c0, 0" : "=r" (ccsidr));
3480059c:	ee305f10 	mrc	15, 1, r5, cr0, cr0, {0}
static void v7_dcache_maint_range(u32 start, u32 stop, u32 range_op)
{
	u32 line_len, ccsidr;

	ccsidr = get_ccsidr();
	line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
348005a0:	e2055007 	and	r5, r5, #7
			CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	line_len += 2;
348005a4:	e2855004 	add	r5, r5, #4
	/* converting from log2(linelen) to linelen */
	line_len = 1 << line_len;
348005a8:	e3a03001 	mov	r3, #1

	switch (range_op) {
348005ac:	e3520003 	cmp	r2, #3
	line_len = ((ccsidr & CCSIDR_LINE_SIZE_MASK) >>
			CCSIDR_LINE_SIZE_OFFSET) + 2;
	/* Converting from words to bytes */
	line_len += 2;
	/* converting from log2(linelen) to linelen */
	line_len = 1 << line_len;
348005b0:	e1a05513 	lsl	r5, r3, r5

	switch (range_op) {
348005b4:	0a000009 	beq	348005e0 <v7_dcache_maint_range+0x50>
348005b8:	e3520004 	cmp	r2, #4
					u32 stop, u32 line_len)
{
	u32 mva;

	/* Align start to cache line boundary */
	start &= ~(line_len - 1);
348005bc:	02653000 	rsbeq	r3, r5, #0
348005c0:	00034000 	andeq	r4, r3, r0
	/* Converting from words to bytes */
	line_len += 2;
	/* converting from log2(linelen) to linelen */
	line_len = 1 << line_len;

	switch (range_op) {
348005c4:	1a00001d 	bne	34800640 <v7_dcache_maint_range+0xb0>
348005c8:	ea000001 	b	348005d4 <v7_dcache_maint_range+0x44>

	/* Align start to cache line boundary */
	start &= ~(line_len - 1);
	for (mva = start; mva < stop; mva = mva + line_len) {
		/* DCCIMVAC - Clean & Invalidate data cache by MVA to PoC */
		asm volatile ("mcr p15, 0, %0, c7, c14, 1" : : "r" (mva));
348005cc:	ee074f3e 	mcr	15, 0, r4, cr7, cr14, {1}
{
	u32 mva;

	/* Align start to cache line boundary */
	start &= ~(line_len - 1);
	for (mva = start; mva < stop; mva = mva + line_len) {
348005d0:	e0844005 	add	r4, r4, r5
348005d4:	e1540006 	cmp	r4, r6
348005d8:	3afffffb 	bcc	348005cc <v7_dcache_maint_range+0x3c>
348005dc:	ea000017 	b	34800640 <v7_dcache_maint_range+0xb0>

	/*
	 * If start address is not aligned to cache-line do not
	 * invalidate the first cache-line
	 */
	if (start & (line_len - 1)) {
348005e0:	e2457001 	sub	r7, r5, #1
348005e4:	e1170000 	tst	r7, r0
348005e8:	0a000007 	beq	3480060c <v7_dcache_maint_range+0x7c>
		printf("ERROR: %s - start address is not aligned - 0x%08x\n",
348005ec:	e1a02004 	mov	r2, r4
348005f0:	e59f0054 	ldr	r0, [pc, #84]	; 3480064c <v7_dcache_maint_range+0xbc>
348005f4:	e59f1054 	ldr	r1, [pc, #84]	; 34800650 <v7_dcache_maint_range+0xc0>
			__func__, start);
		/* move to next cache line */
		start = (start + line_len - 1) & ~(line_len - 1);
348005f8:	e2444001 	sub	r4, r4, #1
	/*
	 * If start address is not aligned to cache-line do not
	 * invalidate the first cache-line
	 */
	if (start & (line_len - 1)) {
		printf("ERROR: %s - start address is not aligned - 0x%08x\n",
348005fc:	eb0022d8 	bl	34809164 <printf>
			__func__, start);
		/* move to next cache line */
		start = (start + line_len - 1) & ~(line_len - 1);
34800600:	e0844005 	add	r4, r4, r5
34800604:	e2653000 	rsb	r3, r5, #0
34800608:	e0034004 	and	r4, r3, r4

	/*
	 * If stop address is not aligned to cache-line do not
	 * invalidate the last cache-line
	 */
	if (stop & (line_len - 1)) {
3480060c:	e1170006 	tst	r7, r6
34800610:	0a000008 	beq	34800638 <v7_dcache_maint_range+0xa8>
		printf("ERROR: %s - stop address is not aligned - 0x%08x\n",
34800614:	e1a02006 	mov	r2, r6
34800618:	e59f0034 	ldr	r0, [pc, #52]	; 34800654 <v7_dcache_maint_range+0xc4>
3480061c:	e59f102c 	ldr	r1, [pc, #44]	; 34800650 <v7_dcache_maint_range+0xc0>
34800620:	eb0022cf 	bl	34809164 <printf>
			__func__, stop);
		/* align to the beginning of this cache line */
		stop &= ~(line_len - 1);
34800624:	e2653000 	rsb	r3, r5, #0
34800628:	e0066003 	and	r6, r6, r3
3480062c:	ea000001 	b	34800638 <v7_dcache_maint_range+0xa8>
	}

	for (mva = start; mva < stop; mva = mva + line_len) {
		/* DCIMVAC - Invalidate data cache by MVA to PoC */
		asm volatile ("mcr p15, 0, %0, c7, c6, 1" : : "r" (mva));
34800630:	ee074f36 	mcr	15, 0, r4, cr7, cr6, {1}
			__func__, stop);
		/* align to the beginning of this cache line */
		stop &= ~(line_len - 1);
	}

	for (mva = start; mva < stop; mva = mva + line_len) {
34800634:	e0844005 	add	r4, r4, r5
34800638:	e1540006 	cmp	r4, r6
3480063c:	3afffffb 	bcc	34800630 <v7_dcache_maint_range+0xa0>
		v7_dcache_inval_range(start, stop, line_len);
		break;
	}

	/* DSB to make sure the operation is complete */
	CP15DSB;
34800640:	e3a03000 	mov	r3, #0
34800644:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
}
34800648:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3480064c:	348227d4 	.word	0x348227d4
34800650:	34820050 	.word	0x34820050
34800654:	34822807 	.word	0x34822807

34800658 <invalidate_dcache_all>:
	/* Full system ISB - make sure the instruction stream sees it */
	CP15ISB;
}

void invalidate_dcache_all(void)
{
34800658:	e92d4010 	push	{r4, lr}
	v7_maint_dcache_all(ARMV7_DCACHE_INVAL_ALL);
3480065c:	e3a00001 	mov	r0, #1
34800660:	ebffff8e 	bl	348004a0 <v7_maint_dcache_all>

	v7_outer_cache_inval_all();
}
34800664:	e8bd4010 	pop	{r4, lr}

void invalidate_dcache_all(void)
{
	v7_maint_dcache_all(ARMV7_DCACHE_INVAL_ALL);

	v7_outer_cache_inval_all();
34800668:	ea00002b 	b	3480071c <__v7_outer_cache_inval_all>

3480066c <flush_dcache_all>:
/*
 * Performs a clean & invalidation of the entire data cache
 * at all levels
 */
void flush_dcache_all(void)
{
3480066c:	e92d4010 	push	{r4, lr}
	v7_maint_dcache_all(ARMV7_DCACHE_CLEAN_INVAL_ALL);
34800670:	e3a00002 	mov	r0, #2
34800674:	ebffff89 	bl	348004a0 <v7_maint_dcache_all>

	v7_outer_cache_flush_all();
}
34800678:	e8bd4010 	pop	{r4, lr}
 */
void flush_dcache_all(void)
{
	v7_maint_dcache_all(ARMV7_DCACHE_CLEAN_INVAL_ALL);

	v7_outer_cache_flush_all();
3480067c:	ea000025 	b	34800718 <__v7_outer_cache_flush_all>

34800680 <invalidate_dcache_range>:
/*
 * Invalidates range in all levels of D-cache/unified cache used:
 * Affects the range [start, stop - 1]
 */
void invalidate_dcache_range(unsigned long start, unsigned long stop)
{
34800680:	e92d4070 	push	{r4, r5, r6, lr}

	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);
34800684:	e3a02003 	mov	r2, #3
/*
 * Invalidates range in all levels of D-cache/unified cache used:
 * Affects the range [start, stop - 1]
 */
void invalidate_dcache_range(unsigned long start, unsigned long stop)
{
34800688:	e1a05000 	mov	r5, r0
3480068c:	e1a04001 	mov	r4, r1

	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);
34800690:	ebffffbe 	bl	34800590 <v7_dcache_maint_range>

	v7_outer_cache_inval_range(start, stop);
34800694:	e1a00005 	mov	r0, r5
34800698:	e1a01004 	mov	r1, r4
}
3480069c:	e8bd4070 	pop	{r4, r5, r6, lr}
void invalidate_dcache_range(unsigned long start, unsigned long stop)
{

	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_INVAL_RANGE);

	v7_outer_cache_inval_range(start, stop);
348006a0:	ea00001f 	b	34800724 <__v7_outer_cache_inval_range>

348006a4 <flush_dcache_range>:
 * Flush range(clean & invalidate) from all levels of D-cache/unified
 * cache used:
 * Affects the range [start, stop - 1]
 */
void flush_dcache_range(unsigned long start, unsigned long stop)
{
348006a4:	e92d4070 	push	{r4, r5, r6, lr}
	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_CLEAN_INVAL_RANGE);
348006a8:	e3a02004 	mov	r2, #4
 * Flush range(clean & invalidate) from all levels of D-cache/unified
 * cache used:
 * Affects the range [start, stop - 1]
 */
void flush_dcache_range(unsigned long start, unsigned long stop)
{
348006ac:	e1a05000 	mov	r5, r0
348006b0:	e1a04001 	mov	r4, r1
	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_CLEAN_INVAL_RANGE);
348006b4:	ebffffb5 	bl	34800590 <v7_dcache_maint_range>

	v7_outer_cache_flush_range(start, stop);
348006b8:	e1a00005 	mov	r0, r5
348006bc:	e1a01004 	mov	r1, r4
}
348006c0:	e8bd4070 	pop	{r4, r5, r6, lr}
 */
void flush_dcache_range(unsigned long start, unsigned long stop)
{
	v7_dcache_maint_range(start, stop, ARMV7_DCACHE_CLEAN_INVAL_RANGE);

	v7_outer_cache_flush_range(start, stop);
348006c4:	ea000015 	b	34800720 <__v7_outer_cache_flush_range>

348006c8 <arm_init_before_mmu>:
}

void arm_init_before_mmu(void)
{
348006c8:	e92d4008 	push	{r3, lr}
	v7_outer_cache_enable();
348006cc:	eb00023b 	bl	34800fc0 <v7_outer_cache_enable>
	invalidate_dcache_all();
348006d0:	ebffffe0 	bl	34800658 <invalidate_dcache_all>

/* Invalidate TLB */
static void v7_inval_tlb(void)
{
	/* Invalidate entire unified TLB */
	asm volatile ("mcr p15, 0, %0, c8, c7, 0" : : "r" (0));
348006d4:	e3a03000 	mov	r3, #0
348006d8:	ee083f17 	mcr	15, 0, r3, cr8, cr7, {0}
	/* Invalidate entire data TLB */
	asm volatile ("mcr p15, 0, %0, c8, c6, 0" : : "r" (0));
348006dc:	ee083f16 	mcr	15, 0, r3, cr8, cr6, {0}
	/* Invalidate entire instruction TLB */
	asm volatile ("mcr p15, 0, %0, c8, c5, 0" : : "r" (0));
348006e0:	ee083f15 	mcr	15, 0, r3, cr8, cr5, {0}
	/* Full system DSB - make sure that the invalidation is complete */
	CP15DSB;
348006e4:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}
	/* Full system ISB - make sure the instruction stream sees it */
	CP15ISB;
348006e8:	ee073f95 	mcr	15, 0, r3, cr7, cr5, {4}
void arm_init_before_mmu(void)
{
	v7_outer_cache_enable();
	invalidate_dcache_all();
	v7_inval_tlb();
}
348006ec:	e8bd8008 	pop	{r3, pc}

348006f0 <flush_cache>:
 * Flush range from all levels of d-cache/unified-cache used:
 * Affects the range [start, start + size - 1]
 */
void  flush_cache(unsigned long start, unsigned long size)
{
	flush_dcache_range(start, start + size);
348006f0:	e0811000 	add	r1, r1, r0
348006f4:	eaffffea 	b	348006a4 <flush_dcache_range>

348006f8 <invalidate_icache_all>:
{
	/*
	 * Invalidate all instruction caches to PoU.
	 * Also flushes branch target cache.
	 */
	asm volatile ("mcr p15, 0, %0, c7, c5, 0" : : "r" (0));
348006f8:	e3a03000 	mov	r3, #0
348006fc:	ee073f15 	mcr	15, 0, r3, cr7, cr5, {0}

	/* Invalidate entire branch predictor array */
	asm volatile ("mcr p15, 0, %0, c7, c5, 6" : : "r" (0));
34800700:	ee073fd5 	mcr	15, 0, r3, cr7, cr5, {6}

	/* Full system DSB - make sure that the invalidation is complete */
	CP15DSB;
34800704:	ee073f9a 	mcr	15, 0, r3, cr7, cr10, {4}

	/* ISB - make sure the instruction stream sees it */
	CP15ISB;
34800708:	ee073f95 	mcr	15, 0, r3, cr7, cr5, {4}
}
3480070c:	e12fff1e 	bx	lr

34800710 <__v7_outer_cache_enable>:
/*
 * Stub implementations for outer cache operations
 */
void __v7_outer_cache_enable(void)
{
}
34800710:	e12fff1e 	bx	lr

34800714 <__v7_outer_cache_disable>:
void v7_outer_cache_enable(void)
	__attribute__((weak, alias("__v7_outer_cache_enable")));

void __v7_outer_cache_disable(void)
{
}
34800714:	e12fff1e 	bx	lr

34800718 <__v7_outer_cache_flush_all>:
void v7_outer_cache_disable(void)
	__attribute__((weak, alias("__v7_outer_cache_disable")));

void __v7_outer_cache_flush_all(void)
{
}
34800718:	e12fff1e 	bx	lr

3480071c <__v7_outer_cache_inval_all>:
void v7_outer_cache_flush_all(void)
	__attribute__((weak, alias("__v7_outer_cache_flush_all")));

void __v7_outer_cache_inval_all(void)
{
}
3480071c:	e12fff1e 	bx	lr

34800720 <__v7_outer_cache_flush_range>:
void v7_outer_cache_inval_all(void)
	__attribute__((weak, alias("__v7_outer_cache_inval_all")));

void __v7_outer_cache_flush_range(u32 start, u32 end)
{
}
34800720:	e12fff1e 	bx	lr

34800724 <__v7_outer_cache_inval_range>:
void v7_outer_cache_flush_range(u32 start, u32 end)
	__attribute__((weak, alias("__v7_outer_cache_flush_range")));

void __v7_outer_cache_inval_range(u32 start, u32 end)
{
}
34800724:	e12fff1e 	bx	lr

34800728 <cpu_cache_initialization>:
#include <asm/system.h>
#include <asm/cache.h>
#include <asm/armv7.h>
#include <linux/compiler.h>

void __weak cpu_cache_initialization(void){}
34800728:	e12fff1e 	bx	lr

3480072c <cleanup_before_linux>:

int cleanup_before_linux(void)
{
3480072c:	e92d4008 	push	{r3, lr}
	 * it prepares the processor for linux
	 *
	 * we turn off caches etc ...
	 */
#ifndef CONFIG_SPL_BUILD
	disable_interrupts();
34800730:	eb00038c 	bl	34801568 <disable_interrupts>
#endif

	/*
	 * Turn off I-cache and invalidate it
	 */
	icache_disable();
34800734:	eb000483 	bl	34801948 <icache_disable>
	invalidate_icache_all();
34800738:	ebffffee 	bl	348006f8 <invalidate_icache_all>

	/*
	 * turn off D-cache
	 * dcache_disable() in turn flushes the d-cache and disables MMU
	 */
	dcache_disable();
3480073c:	eb000488 	bl	34801964 <dcache_disable>
	v7_outer_cache_disable();
34800740:	eb000223 	bl	34800fd4 <v7_outer_cache_disable>
	 * is all we did during this. We have not pushed anything on to the
	 * stack. Neither have we affected any static data)
	 * So just invalidate the entire d-cache again to avoid coherency
	 * problems for kernel
	 */
	invalidate_dcache_all();
34800744:	ebffffc3 	bl	34800658 <invalidate_dcache_all>

	/*
	 * Some CPU need more cache attention before starting the kernel.
	 */
	cpu_cache_initialization();
34800748:	ebfffff6 	bl	34800728 <cpu_cache_initialization>

	return 0;
}
3480074c:	e3a00000 	mov	r0, #0
34800750:	e8bd8008 	pop	{r3, pc}

34800754 <sdelay>:
 *
 *  not inline to increase chances its in cache when called
 *************************************************************/
void sdelay(unsigned long loops)
{
	__asm__ volatile ("1:\n" "subs %0, %1, #1\n"
34800754:	e2500001 	subs	r0, r0, #1
34800758:	1afffffd 	bne	34800754 <sdelay>
			  "bne 1b":"=r" (loops):"0"(loops));
}
3480075c:	e12fff1e 	bx	lr

34800760 <sr32>:
 * sr32 - clear & set a value in a bit range for a 32 bit address
 *****************************************************************/
void sr32(void *addr, u32 start_bit, u32 num_bits, u32 value)
{
	u32 tmp, msk = 0;
	msk = 1 << num_bits;
34800760:	e3a0c001 	mov	ip, #1

/*****************************************************************
 * sr32 - clear & set a value in a bit range for a 32 bit address
 *****************************************************************/
void sr32(void *addr, u32 start_bit, u32 num_bits, u32 value)
{
34800764:	e92d4010 	push	{r4, lr}
	u32 tmp, msk = 0;
	msk = 1 << num_bits;
34800768:	e1a0c21c 	lsl	ip, ip, r2
	--msk;
	tmp = readl((u32)addr) & ~(msk << start_bit);
3480076c:	e5904000 	ldr	r4, [r0]
 *****************************************************************/
void sr32(void *addr, u32 start_bit, u32 num_bits, u32 value)
{
	u32 tmp, msk = 0;
	msk = 1 << num_bits;
	--msk;
34800770:	e24cc001 	sub	ip, ip, #1
	tmp = readl((u32)addr) & ~(msk << start_bit);
34800774:	e1c4c11c 	bic	ip, r4, ip, lsl r1
	tmp |= value << start_bit;
34800778:	e18c1113 	orr	r1, ip, r3, lsl r1
	writel(tmp, (u32)addr);
3480077c:	e5801000 	str	r1, [r0]
}
34800780:	e8bd8010 	pop	{r4, pc}

34800784 <wait_on_value>:
 * wait_on_value() - common routine to allow waiting for changes in
 *   volatile regs.
 *********************************************************************/
u32 wait_on_value(u32 read_bit_mask, u32 match_value, void *read_addr,
		  u32 bound)
{
34800784:	e92d4010 	push	{r4, lr}
	u32 i = 0, val;
34800788:	e3a0c000 	mov	ip, #0
	do {
		++i;
		val = readl((u32)read_addr) & read_bit_mask;
3480078c:	e5924000 	ldr	r4, [r2]
34800790:	e0044000 	and	r4, r4, r0
		if (val == match_value)
34800794:	e1540001 	cmp	r4, r1
34800798:	0a000004 	beq	348007b0 <wait_on_value+0x2c>
u32 wait_on_value(u32 read_bit_mask, u32 match_value, void *read_addr,
		  u32 bound)
{
	u32 i = 0, val;
	do {
		++i;
3480079c:	e28cc001 	add	ip, ip, #1
		val = readl((u32)read_addr) & read_bit_mask;
		if (val == match_value)
			return 1;
		if (i == bound)
348007a0:	e15c0003 	cmp	ip, r3
348007a4:	1afffff8 	bne	3480078c <wait_on_value+0x8>
			return 0;
348007a8:	e3a00000 	mov	r0, #0
348007ac:	e8bd8010 	pop	{r4, pc}
	u32 i = 0, val;
	do {
		++i;
		val = readl((u32)read_addr) & read_bit_mask;
		if (val == match_value)
			return 1;
348007b0:	e3a00001 	mov	r0, #1
		if (i == bound)
			return 0;
	} while (1);
}
348007b4:	e8bd8010 	pop	{r4, pc}

348007b8 <arch_cpu_init>:
/* CPU detection macros */
extern unsigned int s5p_cpu_id;

static inline void s5p_set_cpu_id(void)
{
	s5p_cpu_id = readl(S5PC100_PRO_ID);
348007b8:	e3a0320e 	mov	r3, #-536870912	; 0xe0000000
348007bc:	e5932000 	ldr	r2, [r3]
	s5p_cpu_id = 0xC000 | ((s5p_cpu_id & 0x00FFF000) >> 12);
348007c0:	e59f3010 	ldr	r3, [pc, #16]	; 348007d8 <arch_cpu_init+0x20>
348007c4:	e7eb2652 	ubfx	r2, r2, #12, #12
348007c8:	e3822903 	orr	r2, r2, #49152	; 0xc000
348007cc:	e5832000 	str	r2, [r3]
int arch_cpu_init(void)
{
	s5p_set_cpu_id();

	return 0;
}
348007d0:	e3a00000 	mov	r0, #0
348007d4:	e12fff1e 	bx	lr
348007d8:	348282ec 	.word	0x348282ec

348007dc <get_device_type>:
#endif

u32 get_device_type(void)
{
	return s5p_cpu_id;
}
348007dc:	e59f3004 	ldr	r3, [pc, #4]	; 348007e8 <get_device_type+0xc>
348007e0:	e5930000 	ldr	r0, [r3]
348007e4:	e12fff1e 	bx	lr
348007e8:	348282ec 	.word	0x348282ec

348007ec <print_cpuinfo>:

#ifdef CONFIG_DISPLAY_CPUINFO
int print_cpuinfo(void)
{
348007ec:	e92d4010 	push	{r4, lr}
	char buf[32];

	printf("CPU:\t%s%X@%sMHz\n",
348007f0:	e59f3034 	ldr	r3, [pc, #52]	; 3480082c <print_cpuinfo+0x40>
	return s5p_cpu_id;
}

#ifdef CONFIG_DISPLAY_CPUINFO
int print_cpuinfo(void)
{
348007f4:	e24dd020 	sub	sp, sp, #32
	char buf[32];

	printf("CPU:\t%s%X@%sMHz\n",
348007f8:	e5934000 	ldr	r4, [r3]
348007fc:	eb0001c3 	bl	34800f10 <get_arm_clk>
34800800:	e1a01000 	mov	r1, r0
34800804:	e1a0000d 	mov	r0, sp
34800808:	eb006e41 	bl	3481c114 <strmhz>
3480080c:	e59f101c 	ldr	r1, [pc, #28]	; 34800830 <print_cpuinfo+0x44>
34800810:	e1a03000 	mov	r3, r0
34800814:	e1a02004 	mov	r2, r4
34800818:	e59f0014 	ldr	r0, [pc, #20]	; 34800834 <print_cpuinfo+0x48>
3480081c:	eb002250 	bl	34809164 <printf>
			s5p_get_cpu_name(), s5p_cpu_id,
			strmhz(buf, get_arm_clk()));

	return 0;
}
34800820:	e3a00000 	mov	r0, #0
34800824:	e28dd020 	add	sp, sp, #32
34800828:	e8bd8010 	pop	{r4, pc}
3480082c:	348282ec 	.word	0x348282ec
34800830:	3482284a 	.word	0x3482284a
34800834:	34822839 	.word	0x34822839

34800838 <s5p_get_base_timer>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34800838:	e59f3028 	ldr	r3, [pc, #40]	; 34800868 <s5p_get_base_timer+0x30>
3480083c:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
34800840:	e3530cc1 	cmp	r3, #49408	; 0xc100
34800844:	0a000005 	beq	34800860 <s5p_get_base_timer+0x28>
34800848:	e30c0110 	movw	r0, #49424	; 0xc110
3480084c:	e59f2018 	ldr	r2, [pc, #24]	; 3480086c <s5p_get_base_timer+0x34>
34800850:	e1530000 	cmp	r3, r0
34800854:	01a00002 	moveq	r0, r2
34800858:	13a00000 	movne	r0, #0
3480085c:	e12fff1e 	bx	lr
34800860:	e3a004ea 	mov	r0, #-369098752	; 0xea000000

/* macro to read the 16 bit timer */
static inline struct s5p_timer *s5p_get_base_timer(void)
{
	return (struct s5p_timer *)samsung_get_base_timer();
}
34800864:	e12fff1e 	bx	lr
34800868:	348282ec 	.word	0x348282ec
3480086c:	e2500000 	.word	0xe2500000

34800870 <reset_timer_masked>:
	while (get_current_tick() < tmo)
		;	/* nop */
}

void reset_timer_masked(void)
{
34800870:	e92d4008 	push	{r3, lr}
	struct s5p_timer *const timer = s5p_get_base_timer();
34800874:	ebffffef 	bl	34800838 <s5p_get_base_timer>

	/* reset time */
	gd->lastinc = readl(&timer->tcnto4);
34800878:	e5902040 	ldr	r2, [r0, #64]	; 0x40
3480087c:	e5882030 	str	r2, [r8, #48]	; 0x30
	gd->tbl = 0;
34800880:	e3a02000 	mov	r2, #0
34800884:	e5882020 	str	r2, [r8, #32]
}
34800888:	e8bd8008 	pop	{r3, pc}

3480088c <timer_init>:
{
	return (struct s5p_timer *)samsung_get_base_timer();
}

int timer_init(void)
{
3480088c:	e92d4008 	push	{r3, lr}
	/* PWM Timer 4 */
	pwm_init(4, MUX_DIV_2, 0);
34800890:	e3a01001 	mov	r1, #1
34800894:	e3a02000 	mov	r2, #0
34800898:	e3a00004 	mov	r0, #4
3480089c:	eb0000f2 	bl	34800c6c <pwm_init>
	pwm_config(4, 0, 0);
348008a0:	e3a01000 	mov	r1, #0
348008a4:	e1a02001 	mov	r2, r1
348008a8:	e3a00004 	mov	r0, #4
348008ac:	eb0000a3 	bl	34800b40 <pwm_config>
	pwm_enable(4);
348008b0:	e3a00004 	mov	r0, #4
348008b4:	eb000088 	bl	34800adc <pwm_enable>

	reset_timer_masked();
348008b8:	ebffffec 	bl	34800870 <reset_timer_masked>

	return 0;
}
348008bc:	e3a00000 	mov	r0, #0
348008c0:	e8bd8008 	pop	{r3, pc}

348008c4 <get_current_tick>:

	return get_current_tick() / count_value;
}

unsigned long get_current_tick(void)
{
348008c4:	e92d4008 	push	{r3, lr}
	struct s5p_timer *const timer = s5p_get_base_timer();
348008c8:	ebffffda 	bl	34800838 <s5p_get_base_timer>
	unsigned long now = readl(&timer->tcnto4);
348008cc:	e5902040 	ldr	r2, [r0, #64]	; 0x40
	unsigned long count_value = readl(&timer->tcntb4);
348008d0:	e590103c 	ldr	r1, [r0, #60]	; 0x3c

	if (gd->lastinc >= now)
348008d4:	e5980030 	ldr	r0, [r8, #48]	; 0x30
348008d8:	e1500002 	cmp	r0, r2
		gd->tbl += gd->lastinc - now;
	else
		gd->tbl += gd->lastinc + count_value - now;
348008dc:	3598c020 	ldrcc	ip, [r8, #32]
	struct s5p_timer *const timer = s5p_get_base_timer();
	unsigned long now = readl(&timer->tcnto4);
	unsigned long count_value = readl(&timer->tcntb4);

	if (gd->lastinc >= now)
		gd->tbl += gd->lastinc - now;
348008e0:	25981020 	ldrcs	r1, [r8, #32]
	else
		gd->tbl += gd->lastinc + count_value - now;
348008e4:	35980030 	ldrcc	r0, [r8, #48]	; 0x30
	struct s5p_timer *const timer = s5p_get_base_timer();
	unsigned long now = readl(&timer->tcnto4);
	unsigned long count_value = readl(&timer->tcntb4);

	if (gd->lastinc >= now)
		gd->tbl += gd->lastinc - now;
348008e8:	25980030 	ldrcs	r0, [r8, #48]	; 0x30
	else
		gd->tbl += gd->lastinc + count_value - now;
348008ec:	308c1001 	addcc	r1, ip, r1
348008f0:	e0811000 	add	r1, r1, r0
348008f4:	e0621001 	rsb	r1, r2, r1
348008f8:	e5881020 	str	r1, [r8, #32]

	gd->lastinc = now;
348008fc:	e5882030 	str	r2, [r8, #48]	; 0x30

	return gd->tbl;
34800900:	e5980020 	ldr	r0, [r8, #32]
}
34800904:	e8bd8008 	pop	{r3, pc}

34800908 <get_timer_masked>:
	gd->lastinc = readl(&timer->tcnto4);
	gd->tbl = 0;
}

unsigned long get_timer_masked(void)
{
34800908:	e92d4010 	push	{r4, lr}
	struct s5p_timer *const timer = s5p_get_base_timer();
3480090c:	ebffffc9 	bl	34800838 <s5p_get_base_timer>
	unsigned long count_value = readl(&timer->tcntb4);
34800910:	e590403c 	ldr	r4, [r0, #60]	; 0x3c

	return get_current_tick() / count_value;
34800914:	ebffffea 	bl	348008c4 <get_current_tick>
34800918:	e1a01004 	mov	r1, r4
3480091c:	eb007c9f 	bl	3481fba0 <__udivsi3>
}
34800920:	e8bd8010 	pop	{r4, pc}

34800924 <get_timer>:

/*
 * timer without interrupts
 */
unsigned long get_timer(unsigned long base)
{
34800924:	e92d4010 	push	{r4, lr}
34800928:	e1a04000 	mov	r4, r0
	return get_timer_masked() - base;
3480092c:	ebfffff5 	bl	34800908 <get_timer_masked>
}
34800930:	e0640000 	rsb	r0, r4, r0
34800934:	e8bd8010 	pop	{r4, pc}

34800938 <__udelay>:

/* delay x useconds */
void __udelay(unsigned long usec)
{
34800938:	e92d4038 	push	{r3, r4, r5, lr}
3480093c:	e1a05000 	mov	r5, r0
	struct s5p_timer *const timer = s5p_get_base_timer();
34800940:	ebffffbc 	bl	34800838 <s5p_get_base_timer>
	unsigned long tmo, tmp, count_value;

	count_value = readl(&timer->tcntb4);
34800944:	e590403c 	ldr	r4, [r0, #60]	; 0x3c

	if (usec >= 1000) {
34800948:	e3550ffa 	cmp	r5, #1000	; 0x3e8
3480094c:	3a000006 	bcc	3480096c <__udelay+0x34>
		 * to seconds
		 * 1. start to normalize for usec to ticks per sec
		 * 2. find number of "ticks" to wait to achieve target
		 * 3. finish normalize.
		 */
		tmo = usec / 1000;
34800950:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34800954:	e1a00005 	mov	r0, r5
34800958:	eb007c90 	bl	3481fba0 <__udivsi3>
		tmo *= (CONFIG_SYS_HZ * count_value);
3480095c:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34800960:	e0040491 	mul	r4, r1, r4
		tmo /= 1000;
34800964:	e0000490 	mul	r0, r0, r4
34800968:	ea000003 	b	3480097c <__udelay+0x44>
	} else {
		/* else small number, don't kill it prior to HZ multiply */
		tmo = usec * CONFIG_SYS_HZ * count_value;
3480096c:	e3a03ffa 	mov	r3, #1000	; 0x3e8
34800970:	e0040493 	mul	r4, r3, r4
		tmo /= (1000 * 1000);
34800974:	e0000495 	mul	r0, r5, r4
34800978:	e59f1030 	ldr	r1, [pc, #48]	; 348009b0 <__udelay+0x78>
3480097c:	eb007c87 	bl	3481fba0 <__udivsi3>
34800980:	e1a05000 	mov	r5, r0
	}

	/* get current timestamp */
	tmp = get_current_tick();
34800984:	ebffffce 	bl	348008c4 <get_current_tick>

	/* if setting this fordward will roll time stamp */
	/* reset "advancing" timestamp to 0, set lastinc value */
	/* else, set advancing stamp wake up time */
	if ((tmo + tmp + 1) < tmp)
34800988:	e0804005 	add	r4, r0, r5
3480098c:	e2843001 	add	r3, r4, #1
34800990:	e1530000 	cmp	r3, r0
34800994:	2a000001 	bcs	348009a0 <__udelay+0x68>
		reset_timer_masked();
34800998:	ebffffb4 	bl	34800870 <reset_timer_masked>
3480099c:	e1a04005 	mov	r4, r5
	else
		tmo += tmp;

	/* loop till event */
	while (get_current_tick() < tmo)
348009a0:	ebffffc7 	bl	348008c4 <get_current_tick>
348009a4:	e1500004 	cmp	r0, r4
348009a8:	3afffffc 	bcc	348009a0 <__udelay+0x68>
		;	/* nop */
}
348009ac:	e8bd8038 	pop	{r3, r4, r5, pc}
348009b0:	000f4240 	.word	0x000f4240

348009b4 <get_ticks>:
/*
 * This function is derived from PowerPC code (read timebase as long long).
 * On ARM it just returns the timer value.
 */
unsigned long long get_ticks(void)
{
348009b4:	e92d4008 	push	{r3, lr}
/*
 * timer without interrupts
 */
unsigned long get_timer(unsigned long base)
{
	return get_timer_masked() - base;
348009b8:	ebffffd2 	bl	34800908 <get_timer_masked>
 * On ARM it just returns the timer value.
 */
unsigned long long get_ticks(void)
{
	return get_timer(0);
}
348009bc:	e3a01000 	mov	r1, #0
348009c0:	e8bd8008 	pop	{r3, pc}

348009c4 <get_tbclk>:
 * On ARM it returns the number of timer ticks per second.
 */
unsigned long get_tbclk(void)
{
	return CONFIG_SYS_HZ;
}
348009c4:	e3a00ffa 	mov	r0, #1000	; 0x3e8
348009c8:	e12fff1e 	bx	lr

348009cc <s5p_config_sromc>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
348009cc:	e59f3040 	ldr	r3, [pc, #64]	; 34800a14 <s5p_config_sromc+0x48>
 * srom_bank	- SROM
 * srom_bw_conf  - SMC Band witdh reg configuration value
 * srom_bc_conf  - SMC Bank Control reg configuration value
 */
void s5p_config_sromc(u32 srom_bank, u32 srom_bw_conf, u32 srom_bc_conf)
{
348009d0:	e92d4010 	push	{r4, lr}
348009d4:	e5933000 	ldr	r3, [r3]

SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
348009d8:	e3530cc1 	cmp	r3, #49408	; 0xc100
348009dc:	03a034e7 	moveq	r3, #-419430400	; 0xe7000000
348009e0:	0a000003 	beq	348009f4 <s5p_config_sromc+0x28>
348009e4:	e30cc110 	movw	ip, #49424	; 0xc110
348009e8:	e153000c 	cmp	r3, ip
348009ec:	03a0333a 	moveq	r3, #-402653184	; 0xe8000000
348009f0:	13a03000 	movne	r3, #0
	u32 tmp;
	struct s5p_sromc *srom =
		(struct s5p_sromc *)samsung_get_base_sromc();

	/* Configure SMC_BW register to handle proper SROMC bank */
	tmp = srom->bw;
348009f4:	e593c000 	ldr	ip, [r3]
	tmp &= ~(0xF << (srom_bank * 4));
348009f8:	e1a00100 	lsl	r0, r0, #2
348009fc:	e3a0400f 	mov	r4, #15
34800a00:	e1ccc014 	bic	ip, ip, r4, lsl r0
	tmp |= srom_bw_conf;
34800a04:	e18c1001 	orr	r1, ip, r1
	srom->bw = tmp;
34800a08:	e6831000 	str	r1, [r3], r0

	/* Configure SMC_BC register */
	srom->bc[srom_bank] = srom_bc_conf;
34800a0c:	e5832004 	str	r2, [r3, #4]
}
34800a10:	e8bd8010 	pop	{r4, pc}
34800a14:	348282ec 	.word	0x348282ec

34800a18 <samsung_get_base_watchdog>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34800a18:	e59f3028 	ldr	r3, [pc, #40]	; 34800a48 <samsung_get_base_watchdog+0x30>
34800a1c:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
SAMSUNG_BASE(uart, UART_BASE)
SAMSUNG_BASE(watchdog, WATCHDOG_BASE)
34800a20:	e3530cc1 	cmp	r3, #49408	; 0xc100
34800a24:	0a000005 	beq	34800a40 <samsung_get_base_watchdog+0x28>
34800a28:	e30c0110 	movw	r0, #49424	; 0xc110
34800a2c:	e59f2018 	ldr	r2, [pc, #24]	; 34800a4c <samsung_get_base_watchdog+0x34>
34800a30:	e1530000 	cmp	r3, r0
34800a34:	01a00002 	moveq	r0, r2
34800a38:	13a00000 	movne	r0, #0
34800a3c:	e12fff1e 	bx	lr
34800a40:	e59f0008 	ldr	r0, [pc, #8]	; 34800a50 <samsung_get_base_watchdog+0x38>
34800a44:	e12fff1e 	bx	lr
34800a48:	348282ec 	.word	0x348282ec
34800a4c:	e2700000 	.word	0xe2700000
34800a50:	ea200000 	.word	0xea200000

34800a54 <wdt_stop>:
#include <asm/arch/watchdog.h>

#define PRESCALER_VAL 255

void wdt_stop(void)
{
34800a54:	e92d4008 	push	{r3, lr}
	struct s5p_watchdog *wdt =
		(struct s5p_watchdog *)samsung_get_base_watchdog();
34800a58:	ebffffee 	bl	34800a18 <samsung_get_base_watchdog>
	unsigned int wtcon;

	wtcon = readl(&wdt->wtcon);
34800a5c:	e5903000 	ldr	r3, [r0]
	wtcon &= ~(WTCON_EN | WTCON_INT | WTCON_RESET);
34800a60:	e3c33025 	bic	r3, r3, #37	; 0x25

	writel(wtcon, &wdt->wtcon);
34800a64:	e5803000 	str	r3, [r0]
}
34800a68:	e8bd8008 	pop	{r3, pc}

34800a6c <wdt_start>:

void wdt_start(unsigned int timeout)
{
34800a6c:	e92d4038 	push	{r3, r4, r5, lr}
34800a70:	e1a04000 	mov	r4, r0
	struct s5p_watchdog *wdt =
		(struct s5p_watchdog *)samsung_get_base_watchdog();
34800a74:	ebffffe7 	bl	34800a18 <samsung_get_base_watchdog>
34800a78:	e1a05000 	mov	r5, r0
	unsigned int wtcon;

	wdt_stop();
34800a7c:	ebfffff4 	bl	34800a54 <wdt_stop>

	wtcon = readl(&wdt->wtcon);
34800a80:	e5953000 	ldr	r3, [r5]
	wtcon |= (WTCON_EN | WTCON_CLK(WTCON_CLK_128));
34800a84:	e3833038 	orr	r3, r3, #56	; 0x38
	wtcon &= ~WTCON_INT;
34800a88:	e3c33004 	bic	r3, r3, #4
	wtcon |= WTCON_RESET;
	wtcon |= WTCON_PRESCALER(PRESCALER_VAL);
34800a8c:	e3833cff 	orr	r3, r3, #65280	; 0xff00
34800a90:	e3833001 	orr	r3, r3, #1

	writel(timeout, &wdt->wtdat);
34800a94:	e5854004 	str	r4, [r5, #4]
	writel(timeout, &wdt->wtcnt);
34800a98:	e5854008 	str	r4, [r5, #8]
	writel(wtcon, &wdt->wtcon);
34800a9c:	e5853000 	str	r3, [r5]
}
34800aa0:	e8bd8038 	pop	{r3, r4, r5, pc}

34800aa4 <samsung_get_base_timer>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34800aa4:	e59f3028 	ldr	r3, [pc, #40]	; 34800ad4 <samsung_get_base_timer+0x30>
34800aa8:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
34800aac:	e3530cc1 	cmp	r3, #49408	; 0xc100
34800ab0:	0a000005 	beq	34800acc <samsung_get_base_timer+0x28>
34800ab4:	e30c0110 	movw	r0, #49424	; 0xc110
34800ab8:	e59f2018 	ldr	r2, [pc, #24]	; 34800ad8 <samsung_get_base_timer+0x34>
34800abc:	e1530000 	cmp	r3, r0
34800ac0:	01a00002 	moveq	r0, r2
34800ac4:	13a00000 	movne	r0, #0
34800ac8:	e12fff1e 	bx	lr
34800acc:	e3a004ea 	mov	r0, #-369098752	; 0xea000000
34800ad0:	e12fff1e 	bx	lr
34800ad4:	348282ec 	.word	0x348282ec
34800ad8:	e2500000 	.word	0xe2500000

34800adc <pwm_enable>:
#include <asm/io.h>
#include <asm/arch/pwm.h>
#include <asm/arch/clk.h>

int pwm_enable(int pwm_id)
{
34800adc:	e92d4010 	push	{r4, lr}
34800ae0:	e1a04000 	mov	r4, r0
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
34800ae4:	ebffffee 	bl	34800aa4 <samsung_get_base_timer>
	unsigned long tcon;

	tcon = readl(&pwm->tcon);
34800ae8:	e5903008 	ldr	r3, [r0, #8]
	tcon |= TCON_START(pwm_id);
34800aec:	e3540000 	cmp	r4, #0
34800af0:	12844001 	addne	r4, r4, #1
34800af4:	03a04000 	moveq	r4, #0
34800af8:	e3a02001 	mov	r2, #1
34800afc:	e1a04104 	lsl	r4, r4, #2
34800b00:	e1834412 	orr	r4, r3, r2, lsl r4

	writel(tcon, &pwm->tcon);
34800b04:	e5804008 	str	r4, [r0, #8]

	return 0;
}
34800b08:	e3a00000 	mov	r0, #0
34800b0c:	e8bd8010 	pop	{r4, pc}

34800b10 <pwm_disable>:

void pwm_disable(int pwm_id)
{
34800b10:	e92d4010 	push	{r4, lr}
34800b14:	e1a04000 	mov	r4, r0
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
34800b18:	ebffffe1 	bl	34800aa4 <samsung_get_base_timer>
	unsigned long tcon;

	tcon = readl(&pwm->tcon);
34800b1c:	e5903008 	ldr	r3, [r0, #8]
	tcon &= ~TCON_START(pwm_id);
34800b20:	e3540000 	cmp	r4, #0
34800b24:	12844001 	addne	r4, r4, #1
34800b28:	03a04000 	moveq	r4, #0
34800b2c:	e3a02001 	mov	r2, #1
34800b30:	e1a04104 	lsl	r4, r4, #2
34800b34:	e1c34412 	bic	r4, r3, r2, lsl r4

	writel(tcon, &pwm->tcon);
34800b38:	e5804008 	str	r4, [r0, #8]
}
34800b3c:	e8bd8010 	pop	{r4, pc}

34800b40 <pwm_config>:
}

#define NS_IN_HZ (1000000000UL)

int pwm_config(int pwm_id, int duty_ns, int period_ns)
{
34800b40:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
34800b44:	e1a05001 	mov	r5, r1
34800b48:	e1a07002 	mov	r7, r2
34800b4c:	e1a04000 	mov	r4, r0
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
34800b50:	ebffffd3 	bl	34800aa4 <samsung_get_base_timer>
34800b54:	e1a06000 	mov	r6, r0
	/*
	 * We currently avoid using 64bit arithmetic by using the
	 * fact that anything faster than 1GHz is easily representable
	 * by 32bits.
	 */
	if (period_ns > NS_IN_HZ || duty_ns > NS_IN_HZ)
34800b58:	e59f0108 	ldr	r0, [pc, #264]	; 34800c68 <pwm_config+0x128>
34800b5c:	e1550000 	cmp	r5, r0
34800b60:	91570000 	cmpls	r7, r0
		return -ERANGE;
34800b64:	83e00021 	mvnhi	r0, #33	; 0x21
	/*
	 * We currently avoid using 64bit arithmetic by using the
	 * fact that anything faster than 1GHz is easily representable
	 * by 32bits.
	 */
	if (period_ns > NS_IN_HZ || duty_ns > NS_IN_HZ)
34800b68:	8a00003d 	bhi	34800c64 <pwm_config+0x124>
		return -ERANGE;

	if (duty_ns > period_ns)
34800b6c:	e1550007 	cmp	r5, r7
		return -EINVAL;
34800b70:	c3e00015 	mvngt	r0, #21
	 * by 32bits.
	 */
	if (period_ns > NS_IN_HZ || duty_ns > NS_IN_HZ)
		return -ERANGE;

	if (duty_ns > period_ns)
34800b74:	ca00003a 	bgt	34800c64 <pwm_config+0x124>
		return -EINVAL;

	period = NS_IN_HZ / period_ns;
34800b78:	e1a01007 	mov	r1, r7
34800b7c:	eb007c07 	bl	3481fba0 <__udivsi3>
34800b80:	e58d0004 	str	r0, [sp, #4]
static unsigned long pwm_calc_tin(int pwm_id, unsigned long freq)
{
	unsigned long tin_parent_rate;
	unsigned int div;

	tin_parent_rate = get_pwm_clk();
34800b84:	eb0000fb 	bl	34800f78 <get_pwm_clk>
34800b88:	e3a0b004 	mov	fp, #4
34800b8c:	e1a09000 	mov	r9, r0

	for (div = 2; div <= 16; div *= 2) {
34800b90:	e3a0a002 	mov	sl, #2
		if ((tin_parent_rate / (div << 16)) < freq)
34800b94:	e1a00009 	mov	r0, r9
34800b98:	e1a0180a 	lsl	r1, sl, #16
34800b9c:	eb007bff 	bl	3481fba0 <__udivsi3>
34800ba0:	e59d3004 	ldr	r3, [sp, #4]
34800ba4:	e1500003 	cmp	r0, r3
34800ba8:	2a000004 	bcs	34800bc0 <pwm_config+0x80>
			return tin_parent_rate / div;
34800bac:	e1a0100a 	mov	r1, sl
34800bb0:	e1a00009 	mov	r0, r9
34800bb4:	eb007bf9 	bl	3481fba0 <__udivsi3>
34800bb8:	e1a01000 	mov	r1, r0
34800bbc:	ea000003 	b	34800bd0 <pwm_config+0x90>
	unsigned long tin_parent_rate;
	unsigned int div;

	tin_parent_rate = get_pwm_clk();

	for (div = 2; div <= 16; div *= 2) {
34800bc0:	e25bb001 	subs	fp, fp, #1
34800bc4:	e1a0a08a 	lsl	sl, sl, #1
34800bc8:	1afffff1 	bne	34800b94 <pwm_config+0x54>
		if ((tin_parent_rate / (div << 16)) < freq)
			return tin_parent_rate / div;
	}

	return tin_parent_rate / 16;
34800bcc:	e1a01229 	lsr	r1, r9, #4
	period = NS_IN_HZ / period_ns;

	/* Check to see if we are changing the clock rate of the PWM */
	tin_rate = pwm_calc_tin(pwm_id, period);

	tin_ns = NS_IN_HZ / tin_rate;
34800bd0:	e59f0090 	ldr	r0, [pc, #144]	; 34800c68 <pwm_config+0x128>
34800bd4:	eb007bf1 	bl	3481fba0 <__udivsi3>
34800bd8:	e1a0a000 	mov	sl, r0
	tcnt = period_ns / tin_ns;
34800bdc:	e1a0100a 	mov	r1, sl
34800be0:	e1a00007 	mov	r0, r7
34800be4:	eb007bed 	bl	3481fba0 <__udivsi3>

	/* Note, counters count down */
	tcmp = duty_ns / tin_ns;
34800be8:	e1a0100a 	mov	r1, sl

	/* Check to see if we are changing the clock rate of the PWM */
	tin_rate = pwm_calc_tin(pwm_id, period);

	tin_ns = NS_IN_HZ / tin_rate;
	tcnt = period_ns / tin_ns;
34800bec:	e1a07000 	mov	r7, r0

	/* Note, counters count down */
	tcmp = duty_ns / tin_ns;
34800bf0:	e1a00005 	mov	r0, r5
34800bf4:	eb007be9 	bl	3481fba0 <__udivsi3>
	tcmp = tcnt - tcmp;
34800bf8:	e0600007 	rsb	r0, r0, r7

	/*
	 * the pwm hw only checks the compare register after a decrement,
	 * so the pin never toggles if tcmp = tcnt
	 */
	if (tcmp == tcnt)
34800bfc:	e1500007 	cmp	r0, r7
		tcmp--;
34800c00:	02400001 	subeq	r0, r0, #1
	if (tcmp < 0)
		tcmp = 0;

	/* Update the PWM register block. */
	offset = pwm_id * 3;
	if (pwm_id < 4) {
34800c04:	e3540003 	cmp	r4, #3
34800c08:	ca000004 	bgt	34800c20 <pwm_config+0xe0>

	if (tcmp < 0)
		tcmp = 0;

	/* Update the PWM register block. */
	offset = pwm_id * 3;
34800c0c:	e0843084 	add	r3, r4, r4, lsl #1
	if (pwm_id < 4) {
		writel(tcnt, &pwm->tcntb0 + offset);
34800c10:	e286200c 	add	r2, r6, #12
34800c14:	e7827103 	str	r7, [r2, r3, lsl #2]
		writel(tcmp, &pwm->tcmpb0 + offset);
34800c18:	e2862010 	add	r2, r6, #16
34800c1c:	e7820103 	str	r0, [r2, r3, lsl #2]
	}

	tcon = readl(&pwm->tcon);
34800c20:	e5961008 	ldr	r1, [r6, #8]
	tcon |= TCON_UPDATE(pwm_id);
34800c24:	e3540000 	cmp	r4, #0
34800c28:	1284c001 	addne	ip, r4, #1
34800c2c:	03a0c000 	moveq	ip, #0
34800c30:	e1a0c10c 	lsl	ip, ip, #2
34800c34:	e3a00001 	mov	r0, #1
34800c38:	e28c2001 	add	r2, ip, #1
34800c3c:	e1a02210 	lsl	r2, r0, r2
	if (pwm_id < 4)
34800c40:	e3540003 	cmp	r4, #3
		writel(tcnt, &pwm->tcntb0 + offset);
		writel(tcmp, &pwm->tcmpb0 + offset);
	}

	tcon = readl(&pwm->tcon);
	tcon |= TCON_UPDATE(pwm_id);
34800c44:	e1821001 	orr	r1, r2, r1
	if (pwm_id < 4)
		tcon |= TCON_AUTO_RELOAD(pwm_id);
34800c48:	d28c3003 	addle	r3, ip, #3
34800c4c:	d1813310 	orrle	r3, r1, r0, lsl r3
	else
		tcon |= TCON4_AUTO_RELOAD;
34800c50:	c3813501 	orrgt	r3, r1, #4194304	; 0x400000
	writel(tcon, &pwm->tcon);
34800c54:	e5863008 	str	r3, [r6, #8]

	tcon &= ~TCON_UPDATE(pwm_id);
34800c58:	e1c33002 	bic	r3, r3, r2
	writel(tcon, &pwm->tcon);

	return 0;
34800c5c:	e3a00000 	mov	r0, #0
	else
		tcon |= TCON4_AUTO_RELOAD;
	writel(tcon, &pwm->tcon);

	tcon &= ~TCON_UPDATE(pwm_id);
	writel(tcon, &pwm->tcon);
34800c60:	e5863008 	str	r3, [r6, #8]

	return 0;
}
34800c64:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34800c68:	3b9aca00 	.word	0x3b9aca00

34800c6c <pwm_init>:

int pwm_init(int pwm_id, int div, int invert)
{
34800c6c:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
34800c70:	e1a04000 	mov	r4, r0
34800c74:	e1a07001 	mov	r7, r1
34800c78:	e1a0a002 	mov	sl, r2
	u32 val;
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
34800c7c:	ebffff88 	bl	34800aa4 <samsung_get_base_timer>
	/*
	 * Timer Freq(HZ) =
	 *	PWM_CLK / { (prescaler_value + 1) * (divider_value) }
	 */

	val = readl(&pwm->tcfg0);
34800c80:	e5903000 	ldr	r3, [r0]

int pwm_init(int pwm_id, int div, int invert)
{
	u32 val;
	const struct s5p_timer *pwm =
			(struct s5p_timer *)samsung_get_base_timer();
34800c84:	e1a05000 	mov	r5, r0
	 * Timer Freq(HZ) =
	 *	PWM_CLK / { (prescaler_value + 1) * (divider_value) }
	 */

	val = readl(&pwm->tcfg0);
	if (pwm_id < 2) {
34800c88:	e3540001 	cmp	r4, #1
		prescaler = PRESCALER_0;
		val &= ~0xff;
34800c8c:	d3c330ff 	bicle	r3, r3, #255	; 0xff
		val |= (prescaler & 0xff);
	} else {
		prescaler = PRESCALER_1;
		val &= ~(0xff << 8);
34800c90:	c3c33cff 	bicgt	r3, r3, #65280	; 0xff00

	val = readl(&pwm->tcfg0);
	if (pwm_id < 2) {
		prescaler = PRESCALER_0;
		val &= ~0xff;
		val |= (prescaler & 0xff);
34800c94:	d3833007 	orrle	r3, r3, #7
	 *	PWM_CLK / { (prescaler_value + 1) * (divider_value) }
	 */

	val = readl(&pwm->tcfg0);
	if (pwm_id < 2) {
		prescaler = PRESCALER_0;
34800c98:	d3a09007 	movle	r9, #7
		val &= ~0xff;
		val |= (prescaler & 0xff);
	} else {
		prescaler = PRESCALER_1;
		val &= ~(0xff << 8);
		val |= (prescaler & 0xff) << 8;
34800c9c:	c3833c0f 	orrgt	r3, r3, #3840	; 0xf00
	if (pwm_id < 2) {
		prescaler = PRESCALER_0;
		val &= ~0xff;
		val |= (prescaler & 0xff);
	} else {
		prescaler = PRESCALER_1;
34800ca0:	c3a0900f 	movgt	r9, #15
		val &= ~(0xff << 8);
		val |= (prescaler & 0xff) << 8;
	}
	writel(val, &pwm->tcfg0);
34800ca4:	e5803000 	str	r3, [r0]
	val = readl(&pwm->tcfg1);
34800ca8:	e5902004 	ldr	r2, [r0, #4]
	val &= ~(0xf << MUX_DIV_SHIFT(pwm_id));
34800cac:	e3a0600f 	mov	r6, #15
34800cb0:	e1a03104 	lsl	r3, r4, #2
34800cb4:	e1c22316 	bic	r2, r2, r6, lsl r3
	val |= (div & 0xf) << MUX_DIV_SHIFT(pwm_id);
34800cb8:	e0071006 	and	r1, r7, r6
34800cbc:	e1823311 	orr	r3, r2, r1, lsl r3
	writel(val, &pwm->tcfg1);
34800cc0:	e5803004 	str	r3, [r0, #4]

	timer_rate_hz = get_pwm_clk() / ((prescaler + 1) *
34800cc4:	eb0000ab 	bl	34800f78 <get_pwm_clk>
34800cc8:	e2899001 	add	r9, r9, #1
			(div + 1));
34800ccc:	e2871001 	add	r1, r7, #1
	val = readl(&pwm->tcfg1);
	val &= ~(0xf << MUX_DIV_SHIFT(pwm_id));
	val |= (div & 0xf) << MUX_DIV_SHIFT(pwm_id);
	writel(val, &pwm->tcfg1);

	timer_rate_hz = get_pwm_clk() / ((prescaler + 1) *
34800cd0:	e0010991 	mul	r1, r1, r9
34800cd4:	eb007bb1 	bl	3481fba0 <__udivsi3>
			(div + 1));

	timer_rate_hz = timer_rate_hz / CONFIG_SYS_HZ;
34800cd8:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34800cdc:	eb007baf 	bl	3481fba0 <__udivsi3>

	/* set count value */
	offset = pwm_id * 3;
34800ce0:	e0842084 	add	r2, r4, r4, lsl #1
	writel(timer_rate_hz, &pwm->tcntb0 + offset);
34800ce4:	e285300c 	add	r3, r5, #12
34800ce8:	e7830102 	str	r0, [r3, r2, lsl #2]

	val = readl(&pwm->tcon) & ~(0xf << TCON_OFFSET(pwm_id));
34800cec:	e5952008 	ldr	r2, [r5, #8]
34800cf0:	e3540000 	cmp	r4, #0
34800cf4:	12843001 	addne	r3, r4, #1
34800cf8:	03a03000 	moveq	r3, #0
34800cfc:	e1a03103 	lsl	r3, r3, #2
34800d00:	e1c26316 	bic	r6, r2, r6, lsl r3
	if (invert && (pwm_id < 4))
34800d04:	e25aa000 	subs	sl, sl, #0
34800d08:	13a0a001 	movne	sl, #1
34800d0c:	e3540003 	cmp	r4, #3
34800d10:	c3a0a000 	movgt	sl, #0
34800d14:	e35a0000 	cmp	sl, #0
		val |= TCON_INVERTER(pwm_id);
34800d18:	12833002 	addne	r3, r3, #2
34800d1c:	13a02001 	movne	r2, #1
34800d20:	11866312 	orrne	r6, r6, r2, lsl r3
	writel(val, &pwm->tcon);
34800d24:	e5856008 	str	r6, [r5, #8]

	pwm_enable(pwm_id);
34800d28:	e1a00004 	mov	r0, r4
34800d2c:	ebffff6a 	bl	34800adc <pwm_enable>

	return 0;
}
34800d30:	e3a00000 	mov	r0, #0
34800d34:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	...

34800d40 <samsung_get_base_clock>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34800d40:	e59f3028 	ldr	r3, [pc, #40]	; 34800d70 <samsung_get_base_clock+0x30>
34800d44:	e5933000 	ldr	r3, [r3]
		return S5PC110_##base;				\
	else							\
		return 0;					\
}

SAMSUNG_BASE(clock, CLOCK_BASE)
34800d48:	e3530cc1 	cmp	r3, #49408	; 0xc100
34800d4c:	0a000005 	beq	34800d68 <samsung_get_base_clock+0x28>
34800d50:	e30c0110 	movw	r0, #49424	; 0xc110
34800d54:	e59f2018 	ldr	r2, [pc, #24]	; 34800d74 <samsung_get_base_clock+0x34>
34800d58:	e1530000 	cmp	r3, r0
34800d5c:	01a00002 	moveq	r0, r2
34800d60:	13a00000 	movne	r0, #0
34800d64:	e12fff1e 	bx	lr
34800d68:	e59f0004 	ldr	r0, [pc, #4]	; 34800d74 <samsung_get_base_clock+0x34>
34800d6c:	e12fff1e 	bx	lr
34800d70:	348282ec 	.word	0x348282ec
34800d74:	e0100000 	.word	0xe0100000

34800d78 <get_pll_clk>:
	else
		return s5pc100_get_pclk();
}

unsigned long get_pll_clk(int pllreg)
{
34800d78:	e92d4038 	push	{r3, r4, r5, lr}
	if (cpu_is_s5pc110())
34800d7c:	e59f3114 	ldr	r3, [pc, #276]	; 34800e98 <get_pll_clk+0x120>
	else
		return s5pc100_get_pclk();
}

unsigned long get_pll_clk(int pllreg)
{
34800d80:	e1a05000 	mov	r5, r0
	if (cpu_is_s5pc110())
34800d84:	e5932000 	ldr	r2, [r3]
34800d88:	e30c3110 	movw	r3, #49424	; 0xc110
34800d8c:	e1520003 	cmp	r2, r3
34800d90:	1a000020 	bne	34800e18 <get_pll_clk+0xa0>

/* s5pc100: return pll clock frequency */
static unsigned long s5pc110_get_pll_clk(int pllreg)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
34800d94:	ebffffe9 	bl	34800d40 <samsung_get_base_clock>
	unsigned long r, m, p, s, mask, fout;
	unsigned int freq;

	switch (pllreg) {
34800d98:	e3550004 	cmp	r5, #4
34800d9c:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
34800da0:	ea00002d 	b	34800e5c <get_pll_clk+0xe4>
34800da4:	34800db8 	.word	0x34800db8
34800da8:	34800dc0 	.word	0x34800dc0
34800dac:	34800dc8 	.word	0x34800dc8
34800db0:	34800e5c 	.word	0x34800e5c
34800db4:	34800dd0 	.word	0x34800dd0
	case APLL:
		r = readl(&clk->apll_con);
34800db8:	e5903100 	ldr	r3, [r0, #256]	; 0x100
34800dbc:	ea000004 	b	34800dd4 <get_pll_clk+0x5c>
		break;
	case MPLL:
		r = readl(&clk->mpll_con);
34800dc0:	e5903108 	ldr	r3, [r0, #264]	; 0x108
34800dc4:	ea000002 	b	34800dd4 <get_pll_clk+0x5c>
		break;
	case EPLL:
		r = readl(&clk->epll_con);
34800dc8:	e5903110 	ldr	r3, [r0, #272]	; 0x110
34800dcc:	ea000000 	b	34800dd4 <get_pll_clk+0x5c>
		break;
	case VPLL:
		r = readl(&clk->vpll_con);
34800dd0:	e5903120 	ldr	r3, [r0, #288]	; 0x120
	 * MPLL_CON: MIDV [25:16]
	 * EPLL_CON: MIDV [24:16]
	 * VPLL_CON: MIDV [24:16]
	 */
	if (pllreg == APLL || pllreg == MPLL)
		mask = 0x3ff;
34800dd4:	e3550001 	cmp	r5, #1
34800dd8:	e30023ff 	movw	r2, #1023	; 0x3ff
34800ddc:	e30041ff 	movw	r4, #511	; 0x1ff
34800de0:	91a04002 	movls	r4, r2
	p = (r >> 8) & 0x3f;
	/* SDIV [2:0] */
	s = r & 0x7;

	freq = CONFIG_SYS_CLK_FREQ_C110;
	if (pllreg == APLL) {
34800de4:	e3550000 	cmp	r5, #0
	if (pllreg == APLL || pllreg == MPLL)
		mask = 0x3ff;
	else
		mask = 0x1ff;

	m = (r >> 16) & mask;
34800de8:	e0044823 	and	r4, r4, r3, lsr #16

	/* PDIV [13:8] */
	p = (r >> 8) & 0x3f;
34800dec:	e7e51453 	ubfx	r1, r3, #8, #6
	/* SDIV [2:0] */
	s = r & 0x7;
34800df0:	e2033007 	and	r3, r3, #7

	freq = CONFIG_SYS_CLK_FREQ_C110;
	if (pllreg == APLL) {
34800df4:	1a000002 	bne	34800e04 <get_pll_clk+0x8c>
		if (s < 1)
			s = 1;
34800df8:	e3530000 	cmp	r3, #0
34800dfc:	03a03001 	moveq	r3, #1
		/* FOUT = MDIV * FIN / (PDIV * 2^(SDIV - 1)) */
		fout = m * (freq / (p * (1 << (s - 1))));
34800e00:	e2433001 	sub	r3, r3, #1
	} else
		/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
		fout = m * (freq / (p * (1 << s)));
34800e04:	e59f0090 	ldr	r0, [pc, #144]	; 34800e9c <get_pll_clk+0x124>
34800e08:	e1a01311 	lsl	r1, r1, r3
34800e0c:	eb007b63 	bl	3481fba0 <__udivsi3>
34800e10:	e0000490 	mul	r0, r0, r4
34800e14:	e8bd8038 	pop	{r3, r4, r5, pc}

/* s5pc110: return pll clock frequency */
static unsigned long s5pc100_get_pll_clk(int pllreg)
{
	struct s5pc100_clock *clk =
		(struct s5pc100_clock *)samsung_get_base_clock();
34800e18:	ebffffc8 	bl	34800d40 <samsung_get_base_clock>
	unsigned long r, m, p, s, mask, fout;
	unsigned int freq;

	switch (pllreg) {
34800e1c:	e3550003 	cmp	r5, #3
34800e20:	979ff105 	ldrls	pc, [pc, r5, lsl #2]
34800e24:	ea00000c 	b	34800e5c <get_pll_clk+0xe4>
34800e28:	34800e38 	.word	0x34800e38
34800e2c:	34800e44 	.word	0x34800e44
34800e30:	34800e4c 	.word	0x34800e4c
34800e34:	34800e54 	.word	0x34800e54
	case APLL:
		r = readl(&clk->apll_con);
34800e38:	e5904100 	ldr	r4, [r0, #256]	; 0x100
	 * MPLL_CON: MIDV [23:16]
	 * EPLL_CON: MIDV [23:16]
	 * HPLL_CON: MIDV [23:16]
	 */
	if (pllreg == APLL)
		mask = 0x3ff;
34800e3c:	e30053ff 	movw	r5, #1023	; 0x3ff
34800e40:	ea00000a 	b	34800e70 <get_pll_clk+0xf8>
	switch (pllreg) {
	case APLL:
		r = readl(&clk->apll_con);
		break;
	case MPLL:
		r = readl(&clk->mpll_con);
34800e44:	e5904104 	ldr	r4, [r0, #260]	; 0x104
34800e48:	ea000010 	b	34800e90 <get_pll_clk+0x118>
		break;
	case EPLL:
		r = readl(&clk->epll_con);
34800e4c:	e5904108 	ldr	r4, [r0, #264]	; 0x108
34800e50:	ea00000e 	b	34800e90 <get_pll_clk+0x118>
		break;
	case HPLL:
		r = readl(&clk->hpll_con);
34800e54:	e590410c 	ldr	r4, [r0, #268]	; 0x10c
34800e58:	ea00000c 	b	34800e90 <get_pll_clk+0x118>
		break;
	default:
		printf("Unsupported PLL (%d)\n", pllreg);
34800e5c:	e59f003c 	ldr	r0, [pc, #60]	; 34800ea0 <get_pll_clk+0x128>
34800e60:	e1a01005 	mov	r1, r5
34800e64:	eb0020be 	bl	34809164 <printf>
		return 0;
34800e68:	e3a00000 	mov	r0, #0
34800e6c:	e8bd8038 	pop	{r3, r4, r5, pc}
	m = (r >> 16) & mask;

	/* PDIV [13:8] */
	p = (r >> 8) & 0x3f;
	/* SDIV [2:0] */
	s = r & 0x7;
34800e70:	e2043007 	and	r3, r4, #7
		mask = 0x0ff;

	m = (r >> 16) & mask;

	/* PDIV [13:8] */
	p = (r >> 8) & 0x3f;
34800e74:	e7e51454 	ubfx	r1, r4, #8, #6
	/* SDIV [2:0] */
	s = r & 0x7;

	/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
	freq = CONFIG_SYS_CLK_FREQ_C100;
	fout = m * (freq / (p * (1 << s)));
34800e78:	e1a01311 	lsl	r1, r1, r3
34800e7c:	e59f0020 	ldr	r0, [pc, #32]	; 34800ea4 <get_pll_clk+0x12c>
34800e80:	eb007b46 	bl	3481fba0 <__udivsi3>
	if (pllreg == APLL)
		mask = 0x3ff;
	else
		mask = 0x0ff;

	m = (r >> 16) & mask;
34800e84:	e0054824 	and	r4, r5, r4, lsr #16
	/* SDIV [2:0] */
	s = r & 0x7;

	/* FOUT = MDIV * FIN / (PDIV * 2^SDIV) */
	freq = CONFIG_SYS_CLK_FREQ_C100;
	fout = m * (freq / (p * (1 << s)));
34800e88:	e0000094 	mul	r0, r4, r0
{
	if (cpu_is_s5pc110())
		return s5pc110_get_pll_clk(pllreg);
	else
		return s5pc100_get_pll_clk(pllreg);
}
34800e8c:	e8bd8038 	pop	{r3, r4, r5, pc}
	 * HPLL_CON: MIDV [23:16]
	 */
	if (pllreg == APLL)
		mask = 0x3ff;
	else
		mask = 0x0ff;
34800e90:	e3a050ff 	mov	r5, #255	; 0xff
34800e94:	eafffff5 	b	34800e70 <get_pll_clk+0xf8>
34800e98:	348282ec 	.word	0x348282ec
34800e9c:	016e3600 	.word	0x016e3600
34800ea0:	3482284e 	.word	0x3482284e
34800ea4:	00b71b00 	.word	0x00b71b00

34800ea8 <s5pc100_get_pclk>:
	return get_pclk_sys(CLK_P);
}

/* s5pc100: return peripheral clock frequency */
static unsigned long s5pc100_get_pclk(void)
{
34800ea8:	e92d4010 	push	{r4, lr}

/* s5pc100: return PCLKD1 frequency */
static unsigned long get_pclkd1(void)
{
	struct s5pc100_clock *clk =
		(struct s5pc100_clock *)samsung_get_base_clock();
34800eac:	ebffffa3 	bl	34800d40 <samsung_get_base_clock>
	unsigned long d1_bus, pclkd1;
	uint div, d1_bus_ratio, pclkd1_ratio;

	div = readl(&clk->div0);
34800eb0:	e5904300 	ldr	r4, [r0, #768]	; 0x300
	d1_bus_ratio = (div >> 12) & 0x7;
	/* PCLKD1_RATIO: [18:16] */
	pclkd1_ratio = (div >> 16) & 0x7;

	/* ASYNC Mode */
	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
34800eb4:	e3a00001 	mov	r0, #1
34800eb8:	ebffffae 	bl	34800d78 <get_pll_clk>
	unsigned long d1_bus, pclkd1;
	uint div, d1_bus_ratio, pclkd1_ratio;

	div = readl(&clk->div0);
	/* D1_BUS_RATIO: [14:12] */
	d1_bus_ratio = (div >> 12) & 0x7;
34800ebc:	e7e21654 	ubfx	r1, r4, #12, #3
	/* PCLKD1_RATIO: [18:16] */
	pclkd1_ratio = (div >> 16) & 0x7;

	/* ASYNC Mode */
	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
34800ec0:	e2811001 	add	r1, r1, #1
34800ec4:	eb007b35 	bl	3481fba0 <__udivsi3>

	div = readl(&clk->div0);
	/* D1_BUS_RATIO: [14:12] */
	d1_bus_ratio = (div >> 12) & 0x7;
	/* PCLKD1_RATIO: [18:16] */
	pclkd1_ratio = (div >> 16) & 0x7;
34800ec8:	e7e21854 	ubfx	r1, r4, #16, #3

	/* ASYNC Mode */
	d1_bus = get_pll_clk(MPLL) / (d1_bus_ratio + 1);
	pclkd1 = d1_bus / (pclkd1_ratio + 1);
34800ecc:	e2811001 	add	r1, r1, #1
34800ed0:	eb007b32 	bl	3481fba0 <__udivsi3>

/* s5pc100: return peripheral clock frequency */
static unsigned long s5pc100_get_pclk(void)
{
	return get_pclkd1();
}
34800ed4:	e8bd8010 	pop	{r4, pc}

34800ed8 <s5pc110_get_pclk>:
	return pclk;
}

/* s5pc110: return peripheral clock frequency */
static unsigned long s5pc110_get_pclk(void)
{
34800ed8:	e92d4038 	push	{r3, r4, r5, lr}

/* s5pc110: return PCLKs frequency */
static unsigned long get_pclk_sys(int dom)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
34800edc:	ebffff97 	bl	34800d40 <samsung_get_base_clock>
	unsigned long pclk;
	unsigned int div;
	unsigned int offset;
	unsigned int pclk_sys_ratio;

	div = readl(&clk->div0);
34800ee0:	e5904300 	ldr	r4, [r0, #768]	; 0x300

/* s5pc110: return HCLKs frequency */
static unsigned long get_hclk_sys(int dom)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
34800ee4:	ebffff95 	bl	34800d40 <samsung_get_base_clock>
	unsigned int hclk_sys_ratio;

	if (dom == CLK_M)
		return get_hclk();

	div = readl(&clk->div0);
34800ee8:	e5905300 	ldr	r5, [r0, #768]	; 0x300
	 */
	offset = 8 + (dom << 0x3);

	hclk_sys_ratio = (div >> offset) & 0xf;

	hclk = get_pll_clk(MPLL) / (hclk_sys_ratio + 1);
34800eec:	e3a00001 	mov	r0, #1
34800ef0:	ebffffa0 	bl	34800d78 <get_pll_clk>
	 * HCLK_DSYS_RATIO: [19:16]
	 * HCLK_PSYS_RATIO: [27:24]
	 */
	offset = 8 + (dom << 0x3);

	hclk_sys_ratio = (div >> offset) & 0xf;
34800ef4:	e7e31c55 	ubfx	r1, r5, #24, #4

	hclk = get_pll_clk(MPLL) / (hclk_sys_ratio + 1);
34800ef8:	e2811001 	add	r1, r1, #1
34800efc:	eb007b27 	bl	3481fba0 <__udivsi3>
	 * PCLK_DSYS_RATIO: [22:20]
	 * PCLK_PSYS_RATIO: [30:28]
	 */
	offset = 12 + (dom << 0x3);

	pclk_sys_ratio = (div >> offset) & 0x7;
34800f00:	e7e21e54 	ubfx	r1, r4, #28, #3

	pclk = get_hclk_sys(dom) / (pclk_sys_ratio + 1);
34800f04:	e2811001 	add	r1, r1, #1
34800f08:	eb007b24 	bl	3481fba0 <__udivsi3>

/* s5pc110: return peripheral clock frequency */
static unsigned long s5pc110_get_pclk(void)
{
	return get_pclk_sys(CLK_P);
}
34800f0c:	e8bd8038 	pop	{r3, r4, r5, pc}

34800f10 <get_arm_clk>:
		return s5pc100_get_pll_clk(pllreg);
}

unsigned long get_arm_clk(void)
{
	if (cpu_is_s5pc110())
34800f10:	e59f305c 	ldr	r3, [pc, #92]	; 34800f74 <get_arm_clk+0x64>
	else
		return s5pc100_get_pll_clk(pllreg);
}

unsigned long get_arm_clk(void)
{
34800f14:	e92d4010 	push	{r4, lr}
	if (cpu_is_s5pc110())
34800f18:	e5932000 	ldr	r2, [r3]
34800f1c:	e30c3110 	movw	r3, #49424	; 0xc110
34800f20:	e1520003 	cmp	r2, r3
34800f24:	1a000007 	bne	34800f48 <get_arm_clk+0x38>

/* s5pc110: return ARM clock frequency */
static unsigned long s5pc110_get_arm_clk(void)
{
	struct s5pc110_clock *clk =
		(struct s5pc110_clock *)samsung_get_base_clock();
34800f28:	ebffff84 	bl	34800d40 <samsung_get_base_clock>
	unsigned long div;
	unsigned long dout_apll, armclk;
	unsigned int apll_ratio;

	div = readl(&clk->div0);
34800f2c:	e5904300 	ldr	r4, [r0, #768]	; 0x300

	/* APLL_RATIO: [2:0] */
	apll_ratio = div & 0x7;

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
34800f30:	e3a00000 	mov	r0, #0
34800f34:	ebffff8f 	bl	34800d78 <get_pll_clk>
	unsigned int apll_ratio;

	div = readl(&clk->div0);

	/* APLL_RATIO: [2:0] */
	apll_ratio = div & 0x7;
34800f38:	e2041007 	and	r1, r4, #7

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
34800f3c:	e2811001 	add	r1, r1, #1
34800f40:	eb007b16 	bl	3481fba0 <__udivsi3>
}

unsigned long get_arm_clk(void)
{
	if (cpu_is_s5pc110())
		return s5pc110_get_arm_clk();
34800f44:	e8bd8010 	pop	{r4, pc}

/* s5pc100: return ARM clock frequency */
static unsigned long s5pc100_get_arm_clk(void)
{
	struct s5pc100_clock *clk =
		(struct s5pc100_clock *)samsung_get_base_clock();
34800f48:	ebffff7c 	bl	34800d40 <samsung_get_base_clock>
	unsigned long div;
	unsigned long dout_apll, armclk;
	unsigned int apll_ratio, arm_ratio;

	div = readl(&clk->div0);
34800f4c:	e5904300 	ldr	r4, [r0, #768]	; 0x300
	/* ARM_RATIO: [6:4] */
	arm_ratio = (div >> 4) & 0x7;
	/* APLL_RATIO: [0] */
	apll_ratio = div & 0x1;

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
34800f50:	e3a00000 	mov	r0, #0
34800f54:	ebffff87 	bl	34800d78 <get_pll_clk>
	div = readl(&clk->div0);

	/* ARM_RATIO: [6:4] */
	arm_ratio = (div >> 4) & 0x7;
	/* APLL_RATIO: [0] */
	apll_ratio = div & 0x1;
34800f58:	e2041001 	and	r1, r4, #1

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
34800f5c:	e2811001 	add	r1, r1, #1
34800f60:	eb007b0e 	bl	3481fba0 <__udivsi3>
	unsigned int apll_ratio, arm_ratio;

	div = readl(&clk->div0);

	/* ARM_RATIO: [6:4] */
	arm_ratio = (div >> 4) & 0x7;
34800f64:	e7e21254 	ubfx	r1, r4, #4, #3
	/* APLL_RATIO: [0] */
	apll_ratio = div & 0x1;

	dout_apll = get_pll_clk(APLL) / (apll_ratio + 1);
	armclk = dout_apll / (arm_ratio + 1);
34800f68:	e2811001 	add	r1, r1, #1
34800f6c:	eb007b0b 	bl	3481fba0 <__udivsi3>
{
	if (cpu_is_s5pc110())
		return s5pc110_get_arm_clk();
	else
		return s5pc100_get_arm_clk();
}
34800f70:	e8bd8010 	pop	{r4, pc}
34800f74:	348282ec 	.word	0x348282ec

34800f78 <get_pwm_clk>:
}

/* s5pc1xx: return pwm clock frequency */
static unsigned long s5pc1xx_get_pwm_clk(void)
{
	if (cpu_is_s5pc110())
34800f78:	e59f3014 	ldr	r3, [pc, #20]	; 34800f94 <get_pwm_clk+0x1c>
34800f7c:	e5932000 	ldr	r2, [r3]
34800f80:	e30c3110 	movw	r3, #49424	; 0xc110
34800f84:	e1520003 	cmp	r2, r3
34800f88:	1a000000 	bne	34800f90 <get_pwm_clk+0x18>
		return s5pc110_get_pclk();
34800f8c:	eaffffd1 	b	34800ed8 <s5pc110_get_pclk>
	else
		return s5pc100_get_pclk();
34800f90:	eaffffc4 	b	34800ea8 <s5pc100_get_pclk>
34800f94:	348282ec 	.word	0x348282ec

34800f98 <get_uart_clk>:
}

/* s5pc1xx: return uart clock frequency */
static unsigned long s5pc1xx_get_uart_clk(int dev_index)
{
	if (cpu_is_s5pc110())
34800f98:	e59f3014 	ldr	r3, [pc, #20]	; 34800fb4 <get_uart_clk+0x1c>
34800f9c:	e5932000 	ldr	r2, [r3]
34800fa0:	e30c3110 	movw	r3, #49424	; 0xc110
34800fa4:	e1520003 	cmp	r2, r3
34800fa8:	1a000000 	bne	34800fb0 <get_uart_clk+0x18>
		return s5pc110_get_pclk();
34800fac:	eaffffc9 	b	34800ed8 <s5pc110_get_pclk>
	else
		return s5pc100_get_pclk();
34800fb0:	eaffffbc 	b	34800ea8 <s5pc100_get_pclk>
34800fb4:	348282ec 	.word	0x348282ec

34800fb8 <set_mmc_clk>:
}

void set_mmc_clk(int dev_index, unsigned int div)
{
	/* Do NOTHING */
}
34800fb8:	e12fff1e 	bx	lr
34800fbc:	00000000 	andeq	r0, r0, r0

34800fc0 <v7_outer_cache_enable>:

#include <linux/linkage.h>

#ifndef CONFIG_SYS_L2CACHE_OFF
ENTRY(v7_outer_cache_enable)
	push	{r0, r1, r2, lr}
34800fc0:	e92d4007 	push	{r0, r1, r2, lr}
	mrc	15, 0, r3, cr1, cr0, 1
34800fc4:	ee113f30 	mrc	15, 0, r3, cr1, cr0, {1}
	orr	r3, r3, #2
34800fc8:	e3833002 	orr	r3, r3, #2
	mcr	15, 0, r3, cr1, cr0, 1
34800fcc:	ee013f30 	mcr	15, 0, r3, cr1, cr0, {1}
	pop	{r1, r2, r3, pc}
34800fd0:	e8bd800e 	pop	{r1, r2, r3, pc}

34800fd4 <v7_outer_cache_disable>:
ENDPROC(v7_outer_cache_enable)

ENTRY(v7_outer_cache_disable)
	push	{r0, r1, r2, lr}
34800fd4:	e92d4007 	push	{r0, r1, r2, lr}
	mrc	15, 0, r3, cr1, cr0, 1
34800fd8:	ee113f30 	mrc	15, 0, r3, cr1, cr0, {1}
	bic	r3, r3, #2
34800fdc:	e3c33002 	bic	r3, r3, #2
	mcr	15, 0, r3, cr1, cr0, 1
34800fe0:	ee013f30 	mcr	15, 0, r3, cr1, cr0, {1}
	pop	{r1, r2, r3, pc}
34800fe4:	e8bd800e 	pop	{r1, r2, r3, pc}
34800fe8:	e320f000 	nop	{0}
34800fec:	e320f000 	nop	{0}
34800ff0:	e320f000 	nop	{0}
34800ff4:	e320f000 	nop	{0}
34800ff8:	e320f000 	nop	{0}
34800ffc:	e320f000 	nop	{0}

34801000 <reset_cpu>:

#define S5PC100_SWRESET			0xE0200000
#define S5PC110_SWRESET			0xE0102000

ENTRY(reset_cpu)
	ldr	r1, =S5PC100_PRO_ID
34801000:	e3a0120e 	mov	r1, #-536870912	; 0xe0000000
	ldr	r2, [r1]
34801004:	e5912000 	ldr	r2, [r1]
	ldr	r4, =0x00010000
34801008:	e3a04801 	mov	r4, #65536	; 0x10000
	and	r4, r2, r4
3480100c:	e0024004 	and	r4, r2, r4
	cmp	r4, #0
34801010:	e3540000 	cmp	r4, #0
	bne	110f
34801014:	1a000002 	bne	34801024 <reset_cpu+0x24>
	/* S5PC100 */
	ldr	r1, =S5PC100_SWRESET
34801018:	e59f1014 	ldr	r1, [pc, #20]	; 34801034 <_loop_forever+0x4>
	ldr	r2, =0xC100
3480101c:	e3a02cc1 	mov	r2, #49408	; 0xc100
	b	200f
34801020:	ea000001 	b	3480102c <reset_cpu+0x2c>
110:	/* S5PC110 */
	ldr	r1, =S5PC110_SWRESET
34801024:	e59f100c 	ldr	r1, [pc, #12]	; 34801038 <_loop_forever+0x8>
	mov	r2, #1
34801028:	e3a02001 	mov	r2, #1
200:
	str	r2, [r1]
3480102c:	e5812000 	str	r2, [r1]

34801030 <_loop_forever>:
_loop_forever:
	b	_loop_forever
34801030:	eafffffe 	b	34801030 <_loop_forever>
34801034:	e0200000 	.word	0xe0200000
34801038:	e0102000 	.word	0xe0102000

3480103c <init_func_i2c>:
	return (0);
}

#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
static int init_func_i2c(void)
{
3480103c:	e92d4008 	push	{r3, lr}
	puts("I2C:   ");
34801040:	e59f001c 	ldr	r0, [pc, #28]	; 34801064 <init_func_i2c+0x28>
34801044:	eb00203c 	bl	3480913c <puts>
	i2c_init(CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
34801048:	e3a010fe 	mov	r1, #254	; 0xfe
3480104c:	e30c0350 	movw	r0, #50000	; 0xc350
34801050:	eb003c3f 	bl	34810154 <i2c_init>
	puts("ready\n");
34801054:	e59f000c 	ldr	r0, [pc, #12]	; 34801068 <init_func_i2c+0x2c>
34801058:	eb002037 	bl	3480913c <puts>
	return (0);
}
3480105c:	e3a00000 	mov	r0, #0
34801060:	e8bd8008 	pop	{r3, pc}
34801064:	34822864 	.word	0x34822864
34801068:	34826fa2 	.word	0x34826fa2

3480106c <display_banner>:
	gd->baudrate = getenv_ulong("baudrate", 10, CONFIG_BAUDRATE);
	return 0;
}

static int display_banner(void)
{
3480106c:	e92d4008 	push	{r3, lr}
	printf("\n\n%s\n\n", version_string);
34801070:	e59f100c 	ldr	r1, [pc, #12]	; 34801084 <display_banner+0x18>
34801074:	e59f000c 	ldr	r0, [pc, #12]	; 34801088 <display_banner+0x1c>
34801078:	eb002039 	bl	34809164 <printf>
	debug("IRQ Stack: %08lx\n", IRQ_STACK_START);
	debug("FIQ Stack: %08lx\n", FIQ_STACK_START);
#endif

	return (0);
}
3480107c:	e3a00000 	mov	r0, #0
34801080:	e8bd8008 	pop	{r3, pc}
34801084:	34820238 	.word	0x34820238
34801088:	3482286c 	.word	0x3482286c

3480108c <init_baudrate>:
#if defined(CONFIG_ARM_DCC) && !defined(CONFIG_BAUDRATE)
#define CONFIG_BAUDRATE 115200
#endif

static int init_baudrate(void)
{
3480108c:	e92d4010 	push	{r4, lr}
	gd->baudrate = getenv_ulong("baudrate", 10, CONFIG_BAUDRATE);
34801090:	e3a0100a 	mov	r1, #10
34801094:	e59f2014 	ldr	r2, [pc, #20]	; 348010b0 <init_baudrate+0x24>
34801098:	e59f0014 	ldr	r0, [pc, #20]	; 348010b4 <init_baudrate+0x28>
3480109c:	e1a04008 	mov	r4, r8
348010a0:	eb00195c 	bl	34807618 <getenv_ulong>
348010a4:	e5840008 	str	r0, [r4, #8]
	return 0;
}
348010a8:	e3a00000 	mov	r0, #0
348010ac:	e8bd8010 	pop	{r4, pc}
348010b0:	0001c200 	.word	0x0001c200
348010b4:	34822873 	.word	0x34822873

348010b8 <__coloured_LED_init>:
/************************************************************************
 * Coloured LED functionality
 ************************************************************************
 * May be supplied by boards if desired
 */
inline void __coloured_LED_init(void) {}
348010b8:	e12fff1e 	bx	lr

348010bc <__red_led_on>:
void coloured_LED_init(void)
	__attribute__((weak, alias("__coloured_LED_init")));
inline void __red_led_on(void) {}
348010bc:	e12fff1e 	bx	lr

348010c0 <__red_led_off>:
void red_led_on(void) __attribute__((weak, alias("__red_led_on")));
inline void __red_led_off(void) {}
348010c0:	e12fff1e 	bx	lr

348010c4 <__green_led_on>:
void red_led_off(void) __attribute__((weak, alias("__red_led_off")));
inline void __green_led_on(void) {}
348010c4:	e12fff1e 	bx	lr

348010c8 <__green_led_off>:
void green_led_on(void) __attribute__((weak, alias("__green_led_on")));
inline void __green_led_off(void) {}
348010c8:	e12fff1e 	bx	lr

348010cc <__yellow_led_on>:
void green_led_off(void) __attribute__((weak, alias("__green_led_off")));
inline void __yellow_led_on(void) {}
348010cc:	e12fff1e 	bx	lr

348010d0 <__yellow_led_off>:
void yellow_led_on(void) __attribute__((weak, alias("__yellow_led_on")));
inline void __yellow_led_off(void) {}
348010d0:	e12fff1e 	bx	lr

348010d4 <__blue_led_on>:
void yellow_led_off(void) __attribute__((weak, alias("__yellow_led_off")));
inline void __blue_led_on(void) {}
348010d4:	e12fff1e 	bx	lr

348010d8 <__blue_led_off>:
void blue_led_on(void) __attribute__((weak, alias("__blue_led_on")));
inline void __blue_led_off(void) {}
348010d8:	e12fff1e 	bx	lr

348010dc <__dram_init_banksize>:

int print_cpuinfo(void);

void __dram_init_banksize(void)
{
	gd->bd->bi_dram[0].start = CONFIG_SYS_SDRAM_BASE;
348010dc:	e5982000 	ldr	r2, [r8]
348010e0:	e3a01203 	mov	r1, #805306368	; 0x30000000
348010e4:	e5821018 	str	r1, [r2, #24]
	gd->bd->bi_dram[0].size =  gd->ram_size;
348010e8:	e5982000 	ldr	r2, [r8]
348010ec:	e5983038 	ldr	r3, [r8, #56]	; 0x38
348010f0:	e582301c 	str	r3, [r2, #28]
}
348010f4:	e12fff1e 	bx	lr

348010f8 <__arch_cpu_init>:
	__attribute__((weak, alias("__dram_init_banksize")));

int __arch_cpu_init(void)
{
	return 0;
}
348010f8:	e3a00000 	mov	r0, #0
348010fc:	e12fff1e 	bx	lr

34801100 <board_init_r>:
	ulong malloc_start;
#if !defined(CONFIG_SYS_NO_FLASH)
	ulong flash_size;
#endif

	gd = id;
34801100:	e1a08000 	mov	r8, r0
 *
 ************************************************************************
 */

void board_init_r(gd_t *id, ulong dest_addr)
{
34801104:	e92d4008 	push	{r3, lr}
	ulong flash_size;
#endif

	gd = id;

	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
34801108:	e5983004 	ldr	r3, [r8, #4]
 *
 ************************************************************************
 */

void board_init_r(gd_t *id, ulong dest_addr)
{
3480110c:	e1a04001 	mov	r4, r1
	ulong flash_size;
#endif

	gd = id;

	gd->flags |= GD_FLG_RELOC;	/* tell others: relocation done */
34801110:	e3833001 	orr	r3, r3, #1
34801114:	e5883004 	str	r3, [r8, #4]
	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_R, "board_init_r");

	monitor_flash_len = _end_ofs;
34801118:	e59f306c 	ldr	r3, [pc, #108]	; 3480118c <board_init_r+0x8c>
3480111c:	e5932000 	ldr	r2, [r3]
34801120:	e59f3068 	ldr	r3, [pc, #104]	; 34801190 <board_init_r+0x90>
34801124:	e5832000 	str	r2, [r3]

	/* Enable caches */
	enable_caches();
34801128:	eb0001b2 	bl	348017f8 <__enable_caches>

	debug("monitor flash len: %08lX\n", monitor_flash_len);
	board_init();	/* Setup chipselects */
3480112c:	eb007a2f 	bl	3481f9f0 <board_init>
	 */
#ifdef CONFIG_CLOCKS
	set_cpu_clk_info(); /* Setup clock information */
#endif
#ifdef CONFIG_SERIAL_MULTI
	serial_initialize();
34801130:	eb00352c 	bl	3480e5e8 <serial_initialize>
	post_output_backlog();
#endif

	/* The Malloc area is immediately below the monitor copy in DRAM */
	malloc_start = dest_addr - TOTAL_MALLOC_LEN;
	mem_malloc_init (malloc_start, TOTAL_MALLOC_LEN);
34801134:	e3a01706 	mov	r1, #1572864	; 0x180000
34801138:	e2440706 	sub	r0, r4, #1572864	; 0x180000
3480113c:	eb00210a 	bl	3480956c <mem_malloc_init>
	puts("NAND:  ");
	nand_init();		/* go init the NAND */
#endif

#if defined(CONFIG_CMD_ONENAND)
	onenand_init();
34801140:	eb004af0 	bl	34813d08 <onenand_init>
#endif

#ifdef CONFIG_GENERIC_MMC
       puts("MMC:   ");
34801144:	e59f0048 	ldr	r0, [pc, #72]	; 34801194 <board_init_r+0x94>
34801148:	eb001ffb 	bl	3480913c <puts>
       mmc_initialize(gd->bd);
3480114c:	e5980000 	ldr	r0, [r8]
34801150:	eb0044b0 	bl	34812418 <mmc_initialize>
	AT91F_DataflashInit();
	dataflash_print_info();
#endif

	/* initialize environment */
	env_relocate();
34801154:	eb00258d 	bl	3480a790 <env_relocate>

#if defined(CONFIG_CMD_PCI) || defined(CONFIG_PCI)
	arm_pci_init();
#endif

	stdio_init();	/* get the devices list going. */
34801158:	eb00359e 	bl	3480e7d8 <stdio_init>

	jumptable_init();
3480115c:	eb00261e 	bl	3480a9dc <jumptable_init>
#if defined(CONFIG_API)
	/* Initialize API */
	api_init();
#endif

	console_init_r();	/* fully init console as a device */
34801160:	eb002095 	bl	348093bc <console_init_r>
		smc_set_mac_addr(enetaddr);
	}
#endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */

	/* Initialize from environment */
	load_addr = getenv_ulong("loadaddr", 16, load_addr);
34801164:	e59f402c 	ldr	r4, [pc, #44]	; 34801198 <board_init_r+0x98>
	/* miscellaneous platform dependent initialisations */
	misc_init_r();
#endif

	 /* set up exceptions */
	interrupt_init();
34801168:	eb0000f6 	bl	34801548 <interrupt_init>
	/* enable exceptions */
	enable_interrupts();
3480116c:	eb0000fc 	bl	34801564 <enable_interrupts>
		smc_set_mac_addr(enetaddr);
	}
#endif /* CONFIG_DRIVER_SMC91111 || CONFIG_DRIVER_LAN91C96 */

	/* Initialize from environment */
	load_addr = getenv_ulong("loadaddr", 16, load_addr);
34801170:	e59f0024 	ldr	r0, [pc, #36]	; 3480119c <board_init_r+0x9c>
34801174:	e3a01010 	mov	r1, #16
34801178:	e5942000 	ldr	r2, [r4]
3480117c:	eb001925 	bl	34807618 <getenv_ulong>
34801180:	e5840000 	str	r0, [r4]
	}
#endif

	/* main_loop() can return to retry autoboot, if so just run it again. */
	for (;;) {
		main_loop();
34801184:	eb003370 	bl	3480df4c <main_loop>
34801188:	eafffffd 	b	34801184 <board_init_r+0x84>
3480118c:	34800050 	.word	0x34800050
34801190:	34829900 	.word	0x34829900
34801194:	3482287c 	.word	0x3482287c
34801198:	348284b4 	.word	0x348284b4
3480119c:	34822884 	.word	0x34822884

348011a0 <hang>:

	/* NOTREACHED - no way out of command loop except booting */
}

void hang(void)
{
348011a0:	e92d4008 	push	{r3, lr}
	puts("### ERROR ### Please RESET the board ###\n");
348011a4:	e59f0004 	ldr	r0, [pc, #4]	; 348011b0 <hang+0x10>
348011a8:	eb001fe3 	bl	3480913c <puts>
348011ac:	eafffffe 	b	348011ac <hang+0xc>
348011b0:	3482288d 	.word	0x3482288d

348011b4 <board_init_f>:
	dram_init,		/* configure available RAM banks */
	NULL,
};

void board_init_f(ulong bootflag)
{
348011b4:	e92d4080 	push	{r7, lr}
#endif

	bootstage_mark_name(BOOTSTAGE_ID_START_UBOOT_F, "board_init_f");

	/* Pointer is writable since we allocated a register for it */
	gd = (gd_t *) ((CONFIG_SYS_INIT_SP_ADDR) & ~0x07);
348011b8:	e3a08433 	mov	r8, #855638016	; 0x33000000
	/* compiler optimization barrier needed for GCC >= 3.4 */
	__asm__ __volatile__("": : :"memory");

	memset((void *)gd, 0, sizeof(gd_t));
348011bc:	e3a01000 	mov	r1, #0
348011c0:	e3a02078 	mov	r2, #120	; 0x78
348011c4:	e1a00008 	mov	r0, r8
348011c8:	eb006b3d 	bl	3481bec4 <memset>

	gd->mon_len = _bss_end_ofs;
348011cc:	e59f3100 	ldr	r3, [pc, #256]	; 348012d4 <board_init_f+0x120>
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
348011d0:	e59f0100 	ldr	r0, [pc, #256]	; 348012d8 <board_init_f+0x124>
	/* compiler optimization barrier needed for GCC >= 3.4 */
	__asm__ __volatile__("": : :"memory");

	memset((void *)gd, 0, sizeof(gd_t));

	gd->mon_len = _bss_end_ofs;
348011d4:	e5933000 	ldr	r3, [r3]
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
348011d8:	e3a01010 	mov	r1, #16
	/* compiler optimization barrier needed for GCC >= 3.4 */
	__asm__ __volatile__("": : :"memory");

	memset((void *)gd, 0, sizeof(gd_t));

	gd->mon_len = _bss_end_ofs;
348011dc:	e588303c 	str	r3, [r8, #60]	; 0x3c
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
						(uintptr_t)gd->fdt_blob);
348011e0:	e5982050 	ldr	r2, [r8, #80]	; 0x50
	/* compiler optimization barrier needed for GCC >= 3.4 */
	__asm__ __volatile__("": : :"memory");

	memset((void *)gd, 0, sizeof(gd_t));

	gd->mon_len = _bss_end_ofs;
348011e4:	e1a04008 	mov	r4, r8
#elif defined CONFIG_OF_SEPARATE
	/* FDT is at end of image */
	gd->fdt_blob = (void *)(_end_ofs + _TEXT_BASE);
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
348011e8:	eb00190a 	bl	34807618 <getenv_ulong>
348011ec:	e5840050 	str	r0, [r4, #80]	; 0x50
348011f0:	e59f40e4 	ldr	r4, [pc, #228]	; 348012dc <board_init_f+0x128>
						(uintptr_t)gd->fdt_blob);

	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
348011f4:	ea000003 	b	34801208 <board_init_f+0x54>
		if ((*init_fnc_ptr)() != 0) {
348011f8:	e12fff37 	blx	r7
348011fc:	e3500000 	cmp	r0, #0
34801200:	0a000000 	beq	34801208 <board_init_f+0x54>
			hang ();
34801204:	ebffffe5 	bl	348011a0 <hang>
#endif
	/* Allow the early environment to override the fdt address */
	gd->fdt_blob = (void *)getenv_ulong("fdtcontroladdr", 16,
						(uintptr_t)gd->fdt_blob);

	for (init_fnc_ptr = init_sequence; *init_fnc_ptr; ++init_fnc_ptr) {
34801208:	e5b47004 	ldr	r7, [r4, #4]!
3480120c:	e3570000 	cmp	r7, #0
34801210:	1afffff8 	bne	348011f8 <board_init_f+0x44>
	 * get fixed.
	 */
	gd->ram_size -= CONFIG_SYS_MEM_TOP_HIDE;
#endif

	addr = CONFIG_SYS_SDRAM_BASE + gd->ram_size;
34801214:	e5984038 	ldr	r4, [r8, #56]	; 0x38
	debug("Reserving %ldk for protected RAM at %08lx\n", reg, addr);
#endif /* CONFIG_PRAM */

#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	/* reserve TLB table */
	addr -= (4096 * 4);
34801218:	e28445bf 	add	r4, r4, #801112064	; 0x2fc00000
3480121c:	e28449ff 	add	r4, r4, #4177920	; 0x3fc000

	/* round down to next 64 kB limit */
	addr &= ~(0x10000 - 1);
34801220:	e1a04824 	lsr	r4, r4, #16
34801224:	e1a04804 	lsl	r4, r4, #16

	gd->tlb_addr = addr;
34801228:	e588404c 	str	r4, [r8, #76]	; 0x4c

	/*
	 * reserve memory for U-Boot code, data & bss
	 * round down to next 4 kB limit
	 */
	addr -= gd->mon_len;
3480122c:	e598203c 	ldr	r2, [r8, #60]	; 0x3c
34801230:	e0624004 	rsb	r4, r2, r4
	addr &= ~(4096 - 1);
34801234:	e3c44eff 	bic	r4, r4, #4080	; 0xff0
34801238:	e3c4400f 	bic	r4, r4, #15
			TOTAL_MALLOC_LEN >> 10, addr_sp);
	/*
	 * (permanently) allocate a Board Info struct
	 * and a permanent copy of the "global" data
	 */
	addr_sp -= sizeof (bd_t);
3480123c:	e2446706 	sub	r6, r4, #1572864	; 0x180000

#ifdef CONFIG_MACH_TYPE
	gd->bd->bi_arch_number = CONFIG_MACH_TYPE; /* board id for Linux */
#endif

	addr_sp -= sizeof (gd_t);
34801240:	e24650a8 	sub	r5, r6, #168	; 0xa8
			TOTAL_MALLOC_LEN >> 10, addr_sp);
	/*
	 * (permanently) allocate a Board Info struct
	 * and a permanent copy of the "global" data
	 */
	addr_sp -= sizeof (bd_t);
34801244:	e2462030 	sub	r2, r6, #48	; 0x30
	bd = (bd_t *) addr_sp;
	gd->bd = bd;
34801248:	e5882000 	str	r2, [r8]
	id = (gd_t *) addr_sp;
	debug("Reserving %zu Bytes for Global Data at: %08lx\n",
			sizeof (gd_t), addr_sp);

	/* setup stackpointer for exeptions */
	gd->irq_sp = addr_sp;
3480124c:	e5885040 	str	r5, [r8, #64]	; 0x40
#ifdef CONFIG_POST
	post_bootmode_init();
	post_run(NULL, POST_ROM | post_bootmode_get(0));
#endif

	gd->bd->bi_baudrate = gd->baudrate;
34801250:	e5982000 	ldr	r2, [r8]
34801254:	e5983008 	ldr	r3, [r8, #8]
#endif
	/* leave 3 words for abort-stack    */
	addr_sp -= 12;

	/* 8-byte alignment for ABI compliance */
	addr_sp &= ~0x07;
34801258:	e24660b8 	sub	r6, r6, #184	; 0xb8
#ifdef CONFIG_POST
	post_bootmode_init();
	post_run(NULL, POST_ROM | post_bootmode_get(0));
#endif

	gd->bd->bi_baudrate = gd->baudrate;
3480125c:	e5823000 	str	r3, [r2]
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
34801260:	eb0079f6 	bl	3481fa40 <dram_init_banksize>
	}
#else
	ulong size = 0;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++)
		size += gd->bd->bi_dram[i].size;
34801264:	e5981000 	ldr	r1, [r8]
34801268:	e5982000 	ldr	r2, [r8]
3480126c:	e5983000 	ldr	r3, [r8]
34801270:	e591a01c 	ldr	sl, [r1, #28]
34801274:	e5922024 	ldr	r2, [r2, #36]	; 0x24
34801278:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
3480127c:	e08aa002 	add	sl, sl, r2
34801280:	e08aa003 	add	sl, sl, r3

	puts("DRAM:  ");
34801284:	e59f0054 	ldr	r0, [pc, #84]	; 348012e0 <board_init_f+0x12c>
34801288:	eb001fab 	bl	3480913c <puts>
	print_size(size, "\n");
3480128c:	e1a0000a 	mov	r0, sl
34801290:	e1a01007 	mov	r1, r7
34801294:	e59f2048 	ldr	r2, [pc, #72]	; 348012e4 <board_init_f+0x130>
34801298:	eb0063c3 	bl	3481a1ac <print_size>
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
	gd->start_addr_sp = addr_sp;
	gd->reloc_off = addr - _TEXT_BASE;
3480129c:	e59f3044 	ldr	r3, [pc, #68]	; 348012e8 <board_init_f+0x134>
	gd->bd->bi_baudrate = gd->baudrate;
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
348012a0:	e5884034 	str	r4, [r8, #52]	; 0x34
	gd->start_addr_sp = addr_sp;
	gd->reloc_off = addr - _TEXT_BASE;
348012a4:	e5933000 	ldr	r3, [r3]
	gd->bd->bi_baudrate = gd->baudrate;
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
348012a8:	e1a01008 	mov	r1, r8
	gd->start_addr_sp = addr_sp;
	gd->reloc_off = addr - _TEXT_BASE;
348012ac:	e0633004 	rsb	r3, r3, r4
	/* Ram ist board specific, so move it to board code ... */
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
	gd->start_addr_sp = addr_sp;
348012b0:	e5886044 	str	r6, [r8, #68]	; 0x44
	gd->reloc_off = addr - _TEXT_BASE;
	debug("relocation Offset is: %08lx\n", gd->reloc_off);
	memcpy(id, (void *)gd, sizeof(gd_t));
348012b4:	e3a02078 	mov	r2, #120	; 0x78
	dram_init_banksize();
	display_dram_config();	/* and display it */

	gd->relocaddr = addr;
	gd->start_addr_sp = addr_sp;
	gd->reloc_off = addr - _TEXT_BASE;
348012b8:	e5883048 	str	r3, [r8, #72]	; 0x48
	debug("relocation Offset is: %08lx\n", gd->reloc_off);
	memcpy(id, (void *)gd, sizeof(gd_t));
348012bc:	e1a00005 	mov	r0, r5
348012c0:	eb006b23 	bl	3481bf54 <memcpy>

	relocate_code(addr_sp, id, addr);
348012c4:	e1a00006 	mov	r0, r6
348012c8:	e1a01005 	mov	r1, r5
348012cc:	e1a02004 	mov	r2, r4
348012d0:	ebfffb70 	bl	34800098 <relocate_code>
348012d4:	3480004c 	.word	0x3480004c
348012d8:	348228b7 	.word	0x348228b7
348012dc:	348282f0 	.word	0x348282f0
348012e0:	348228c6 	.word	0x348228c6
348012e4:	34826214 	.word	0x34826214
348012e8:	34800040 	.word	0x34800040

348012ec <boot_prep_linux>:
}
#endif

/* Subcommand: PREP */
static void boot_prep_linux(bootm_headers_t *images)
{
348012ec:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
348012f0:	e1a05000 	mov	r5, r0
#ifdef CONFIG_CMDLINE_TAG
	char *commandline = getenv("bootargs");
348012f4:	e59f0144 	ldr	r0, [pc, #324]	; 34801440 <boot_prep_linux+0x154>
348012f8:	eb0018ab 	bl	348075ac <getenv>
	defined(CONFIG_CMDLINE_TAG) || \
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
		debug("using: ATAGS\n");
		setup_start_tag(gd->bd);
348012fc:	e5983000 	ldr	r3, [r8]

	params->u.core.flags = 0;
	params->u.core.pagesize = 0;
	params->u.core.rootdev = 0;

	params = tag_next (params);
34801300:	e59f113c 	ldr	r1, [pc, #316]	; 34801444 <boot_prep_linux+0x158>
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
static void setup_start_tag (bd_t *bd)
{
	params = (struct tag *)bd->bi_boot_params;
34801304:	e5934008 	ldr	r4, [r3, #8]

	params->hdr.tag = ATAG_CORE;
34801308:	e59f3138 	ldr	r3, [pc, #312]	; 34801448 <boot_prep_linux+0x15c>
#ifdef CONFIG_CMDLINE_TAG
static void setup_commandline_tag(bd_t *bd, char *commandline)
{
	char *p;

	if (!commandline)
3480130c:	e3500000 	cmp	r0, #0
	defined(CONFIG_REVISION_TAG)
static void setup_start_tag (bd_t *bd)
{
	params = (struct tag *)bd->bi_boot_params;

	params->hdr.tag = ATAG_CORE;
34801310:	e5843004 	str	r3, [r4, #4]
	params->hdr.size = tag_size (tag_core);
34801314:	e3a03005 	mov	r3, #5
34801318:	e5843000 	str	r3, [r4]

	params->u.core.flags = 0;
3480131c:	e3a03000 	mov	r3, #0
34801320:	e5843008 	str	r3, [r4, #8]
	params->u.core.pagesize = 0;
34801324:	e584300c 	str	r3, [r4, #12]
	params->u.core.rootdev = 0;
34801328:	e5843010 	str	r3, [r4, #16]

	params = tag_next (params);
3480132c:	e2843014 	add	r3, r4, #20
34801330:	e5813000 	str	r3, [r1]
		setup_start_tag(gd->bd);
#ifdef CONFIG_SERIAL_TAG
		setup_serial_tag(&params);
#endif
#ifdef CONFIG_CMDLINE_TAG
		setup_commandline_tag(gd->bd, commandline);
34801334:	e5982000 	ldr	r2, [r8]
#ifdef CONFIG_CMDLINE_TAG
static void setup_commandline_tag(bd_t *bd, char *commandline)
{
	char *p;

	if (!commandline)
34801338:	0a000015 	beq	34801394 <boot_prep_linux+0xa8>
3480133c:	e1a06000 	mov	r6, r0
		return;

	/* eat leading white space */
	for (p = commandline; *p == ' '; p++);
34801340:	e4d02001 	ldrb	r2, [r0], #1
34801344:	e3520020 	cmp	r2, #32
34801348:	0afffffb 	beq	3480133c <boot_prep_linux+0x50>

	/* skip non-existent command lines so the kernel will still
	 * use its default command line.
	 */
	if (*p == '\0')
3480134c:	e3520000 	cmp	r2, #0
34801350:	0a00000f 	beq	34801394 <boot_prep_linux+0xa8>
		return;

	params->hdr.tag = ATAG_CMDLINE;
34801354:	e59f20f0 	ldr	r2, [pc, #240]	; 3480144c <boot_prep_linux+0x160>
	params->hdr.size =
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
34801358:	e1a00006 	mov	r0, r6
	 * use its default command line.
	 */
	if (*p == '\0')
		return;

	params->hdr.tag = ATAG_CMDLINE;
3480135c:	e5832004 	str	r2, [r3, #4]
	params->hdr.size =
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;
34801360:	eb006a37 	bl	3481bc44 <strlen>
34801364:	e280000d 	add	r0, r0, #13
34801368:	e1a00120 	lsr	r0, r0, #2
	 */
	if (*p == '\0')
		return;

	params->hdr.tag = ATAG_CMDLINE;
	params->hdr.size =
3480136c:	e5840014 	str	r0, [r4, #20]
		(sizeof (struct tag_header) + strlen (p) + 1 + 4) >> 2;

	strcpy (params->u.cmdline.cmdline, p);
34801370:	e59f40cc 	ldr	r4, [pc, #204]	; 34801444 <boot_prep_linux+0x158>
34801374:	e1a01006 	mov	r1, r6
34801378:	e5940000 	ldr	r0, [r4]
3480137c:	e2800008 	add	r0, r0, #8
34801380:	eb0069ca 	bl	3481bab0 <strcpy>

	params = tag_next (params);
34801384:	e5943000 	ldr	r3, [r4]
34801388:	e5932000 	ldr	r2, [r3]
3480138c:	e0833102 	add	r3, r3, r2, lsl #2
34801390:	e5843000 	str	r3, [r4]
#endif
#ifdef CONFIG_REVISION_TAG
		setup_revision_tag(&params);
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
34801394:	e59f30a8 	ldr	r3, [pc, #168]	; 34801444 <boot_prep_linux+0x158>
34801398:	e5981000 	ldr	r1, [r8]
3480139c:	e5932000 	ldr	r2, [r3]
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
348013a0:	e59f40a8 	ldr	r4, [pc, #168]	; 34801450 <boot_prep_linux+0x164>
#endif
#ifdef CONFIG_REVISION_TAG
		setup_revision_tag(&params);
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
348013a4:	e1a00008 	mov	r0, r8
	return 0;
}
#endif

/* Subcommand: PREP */
static void boot_prep_linux(bootm_headers_t *images)
348013a8:	e2823010 	add	r3, r2, #16
348013ac:	e3a0c003 	mov	ip, #3
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
		params->hdr.size = tag_size (tag_mem32);
348013b0:	e3a06004 	mov	r6, #4

		params->u.mem.start = bd->bi_dram[i].start;
348013b4:	e5917018 	ldr	r7, [r1, #24]
#ifdef CONFIG_SETUP_MEMORY_TAGS
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
348013b8:	e25cc001 	subs	ip, ip, #1
		params->hdr.tag = ATAG_MEM;
		params->hdr.size = tag_size (tag_mem32);

		params->u.mem.start = bd->bi_dram[i].start;
348013bc:	e5037004 	str	r7, [r3, #-4]
		params->u.mem.size = bd->bi_dram[i].size;
348013c0:	e591701c 	ldr	r7, [r1, #28]
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
		params->hdr.tag = ATAG_MEM;
348013c4:	e503400c 	str	r4, [r3, #-12]
		params->hdr.size = tag_size (tag_mem32);
348013c8:	e5036010 	str	r6, [r3, #-16]

		params->u.mem.start = bd->bi_dram[i].start;
		params->u.mem.size = bd->bi_dram[i].size;
348013cc:	e5037008 	str	r7, [r3, #-8]
348013d0:	e2811008 	add	r1, r1, #8
348013d4:	e2833010 	add	r3, r3, #16
#ifdef CONFIG_SETUP_MEMORY_TAGS
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
348013d8:	1afffff5 	bne	348013b4 <boot_prep_linux+0xc8>
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
348013dc:	e5951064 	ldr	r1, [r5, #100]	; 0x64
#ifdef CONFIG_SETUP_MEMORY_TAGS
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
348013e0:	e59fc05c 	ldr	ip, [pc, #92]	; 34801444 <boot_prep_linux+0x158>
348013e4:	e2823030 	add	r3, r2, #48	; 0x30
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
348013e8:	e3510000 	cmp	r1, #0
#ifdef CONFIG_SETUP_MEMORY_TAGS
static void setup_memory_tags(bd_t *bd)
{
	int i;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
348013ec:	e58c3000 	str	r3, [ip]
#endif
#ifdef CONFIG_SETUP_MEMORY_TAGS
		setup_memory_tags(gd->bd);
#endif
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
348013f0:	0a00000b 	beq	34801424 <boot_prep_linux+0x138>
348013f4:	e5954068 	ldr	r4, [r5, #104]	; 0x68
348013f8:	e3540000 	cmp	r4, #0
348013fc:	0a000008 	beq	34801424 <boot_prep_linux+0x138>
			setup_initrd_tag(gd->bd, images->rd_start,
34801400:	e5905000 	ldr	r5, [r0]
static void setup_initrd_tag(bd_t *bd, ulong initrd_start, ulong initrd_end)
{
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
34801404:	e59f5048 	ldr	r5, [pc, #72]	; 34801454 <boot_prep_linux+0x168>
	params->hdr.size = tag_size (tag_initrd);
34801408:	e5826030 	str	r6, [r2, #48]	; 0x30

	params->u.initrd.start = initrd_start;
3480140c:	e5831008 	str	r1, [r3, #8]
	params->u.initrd.size = initrd_end - initrd_start;

	params = tag_next (params);
34801410:	e2822040 	add	r2, r2, #64	; 0x40
	 */
	params->hdr.tag = ATAG_INITRD2;
	params->hdr.size = tag_size (tag_initrd);

	params->u.initrd.start = initrd_start;
	params->u.initrd.size = initrd_end - initrd_start;
34801414:	e0611004 	rsb	r1, r1, r4
static void setup_initrd_tag(bd_t *bd, ulong initrd_start, ulong initrd_end)
{
	/* an ATAG_INITRD node tells the kernel where the compressed
	 * ramdisk can be found. ATAG_RDIMG is a better name, actually.
	 */
	params->hdr.tag = ATAG_INITRD2;
34801418:	e5835004 	str	r5, [r3, #4]
	params->hdr.size = tag_size (tag_initrd);

	params->u.initrd.start = initrd_start;
	params->u.initrd.size = initrd_end - initrd_start;
3480141c:	e583100c 	str	r1, [r3, #12]

	params = tag_next (params);
34801420:	e58c2000 	str	r2, [ip]
#ifdef CONFIG_INITRD_TAG
		if (images->rd_start && images->rd_end)
			setup_initrd_tag(gd->bd, images->rd_start,
			images->rd_end);
#endif
		setup_end_tag(gd->bd);
34801424:	e5903000 	ldr	r3, [r0]
	defined(CONFIG_INITRD_TAG) || \
	defined(CONFIG_SERIAL_TAG) || \
	defined(CONFIG_REVISION_TAG)
static void setup_end_tag(bd_t *bd)
{
	params->hdr.tag = ATAG_NONE;
34801428:	e59f3014 	ldr	r3, [pc, #20]	; 34801444 <boot_prep_linux+0x158>
3480142c:	e3a02000 	mov	r2, #0
34801430:	e5933000 	ldr	r3, [r3]
34801434:	e5832004 	str	r2, [r3, #4]
	params->hdr.size = 0;
34801438:	e5832000 	str	r2, [r3]
#else /* all tags */
		printf("FDT and ATAGS support not compiled in - hanging\n");
		hang();
#endif /* all tags */
	}
}
3480143c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34801440:	348228ce 	.word	0x348228ce
34801444:	34829904 	.word	0x34829904
34801448:	54410001 	.word	0x54410001
3480144c:	54410009 	.word	0x54410009
34801450:	54410002 	.word	0x54410002
34801454:	54420005 	.word	0x54420005

34801458 <boot_jump_linux.clone.5>:

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
34801458:	e92d4013 	push	{r0, r1, r4, lr}
{
	unsigned long machid = gd->bd->bi_arch_number;
3480145c:	e5983000 	ldr	r3, [r8]
#endif /* all tags */
	}
}

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
34801460:	e1a04000 	mov	r4, r0
{
	unsigned long machid = gd->bd->bi_arch_number;
34801464:	e5933004 	ldr	r3, [r3, #4]
	void (*kernel_entry)(int zero, int arch, uint params);
	unsigned long r2;

	kernel_entry = (void (*)(int, int, uint))images->ep;

	s = getenv("machid");
34801468:	e59f0050 	ldr	r0, [pc, #80]	; 348014c0 <boot_jump_linux.clone.5+0x68>
}

/* Subcommand: GO */
static void boot_jump_linux(bootm_headers_t *images)
{
	unsigned long machid = gd->bd->bi_arch_number;
3480146c:	e58d3004 	str	r3, [sp, #4]
	void (*kernel_entry)(int zero, int arch, uint params);
	unsigned long r2;

	kernel_entry = (void (*)(int, int, uint))images->ep;

	s = getenv("machid");
34801470:	eb00184d 	bl	348075ac <getenv>
	if (s) {
34801474:	e3500000 	cmp	r0, #0
34801478:	0a000005 	beq	34801494 <boot_jump_linux.clone.5+0x3c>
		strict_strtoul(s, 16, &machid);
3480147c:	e3a01010 	mov	r1, #16
34801480:	e28d2004 	add	r2, sp, #4
34801484:	eb006dac 	bl	3481cb3c <strict_strtoul>
		printf("Using machid 0x%lx from environment\n", machid);
34801488:	e59f0034 	ldr	r0, [pc, #52]	; 348014c4 <boot_jump_linux.clone.5+0x6c>
3480148c:	e59d1004 	ldr	r1, [sp, #4]
34801490:	eb001f33 	bl	34809164 <printf>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34801494:	e3a0000f 	mov	r0, #15
34801498:	eb00302c 	bl	3480d550 <__show_boot_progress>
}
#endif

static void announce_and_cleanup(void)
{
	printf("\nStarting kernel ...\n\n");
3480149c:	e59f0024 	ldr	r0, [pc, #36]	; 348014c8 <boot_jump_linux.clone.5+0x70>
348014a0:	eb001f2f 	bl	34809164 <printf>
#endif

#ifdef CONFIG_USB_DEVICE
	udc_disconnect();
#endif
	cleanup_before_linux();
348014a4:	ebfffca0 	bl	3480072c <cleanup_before_linux>
#ifdef CONFIG_OF_LIBFDT
	if (images->ft_len)
		r2 = (unsigned long)images->ft_addr;
	else
#endif
		r2 = gd->bd->bi_boot_params;
348014a8:	e5983000 	ldr	r3, [r8]

	kernel_entry(0, machid, r2);
348014ac:	e3a00000 	mov	r0, #0
348014b0:	e59d1004 	ldr	r1, [sp, #4]
348014b4:	e5932008 	ldr	r2, [r3, #8]
348014b8:	e12fff34 	blx	r4
}
348014bc:	e8bd801c 	pop	{r2, r3, r4, pc}
348014c0:	348228d7 	.word	0x348228d7
348014c4:	348228de 	.word	0x348228de
348014c8:	34822903 	.word	0x34822903

348014cc <arch_lmb_reserve>:
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
	lmb_reserve(lmb, sp,
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
348014cc:	e598c000 	ldr	ip, [r8]
348014d0:	e5983000 	ldr	r3, [r8]

static ulong get_sp(void)
{
	ulong ret;

	asm("mov %0, sp" : "=r"(ret) : );
348014d4:	e1a0100d 	mov	r1, sp
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
	lmb_reserve(lmb, sp,
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
348014d8:	e593201c 	ldr	r2, [r3, #28]
348014dc:	e59c3018 	ldr	r3, [ip, #24]
	 */
	sp = get_sp();
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
348014e0:	e2411a01 	sub	r1, r1, #4096	; 0x1000
	lmb_reserve(lmb, sp,
		    gd->bd->bi_dram[0].start + gd->bd->bi_dram[0].size - sp);
348014e4:	e0822003 	add	r2, r2, r3
	sp = get_sp();
	debug("## Current stack ends at 0x%08lx ", sp);

	/* adjust sp by 4K to be safe */
	sp -= 4096;
	lmb_reserve(lmb, sp,
348014e8:	e0612002 	rsb	r2, r1, r2
348014ec:	ea00688b 	b	3481b720 <lmb_reserve>

348014f0 <do_bootm_linux>:
 * Modeled after the powerpc implementation
 * DIFFERENCE: Instead of calling prep and go at the end
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
348014f0:	e92d4070 	push	{r4, r5, r6, lr}
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
348014f4:	e2105030 	ands	r5, r0, #48	; 0x30
 * Modeled after the powerpc implementation
 * DIFFERENCE: Instead of calling prep and go at the end
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
348014f8:	e1a04003 	mov	r4, r3
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
		return -1;
348014fc:	13e05000 	mvnne	r5, #0
 * they are called if subcommand is equal 0.
 */
int do_bootm_linux(int flag, int argc, char *argv[], bootm_headers_t *images)
{
	/* No need for those on ARM */
	if (flag & BOOTM_STATE_OS_BD_T || flag & BOOTM_STATE_OS_CMDLINE)
34801500:	1a00000e 	bne	34801540 <do_bootm_linux+0x50>
		return -1;

	if (flag & BOOTM_STATE_OS_PREP) {
34801504:	e2106040 	ands	r6, r0, #64	; 0x40
34801508:	0a000002 	beq	34801518 <do_bootm_linux+0x28>
		boot_prep_linux(images);
3480150c:	e1a00003 	mov	r0, r3
34801510:	ebffff75 	bl	348012ec <boot_prep_linux>
		return 0;
34801514:	ea000009 	b	34801540 <do_bootm_linux+0x50>
	}

	if (flag & BOOTM_STATE_OS_GO) {
34801518:	e2105080 	ands	r5, r0, #128	; 0x80
3480151c:	0a000003 	beq	34801530 <do_bootm_linux+0x40>
		boot_jump_linux(images);
34801520:	e5930060 	ldr	r0, [r3, #96]	; 0x60
34801524:	ebffffcb 	bl	34801458 <boot_jump_linux.clone.5>
		return 0;
34801528:	e1a05006 	mov	r5, r6
3480152c:	ea000003 	b	34801540 <do_bootm_linux+0x50>
	}

	boot_prep_linux(images);
34801530:	e1a00003 	mov	r0, r3
34801534:	ebffff6c 	bl	348012ec <boot_prep_linux>
	boot_jump_linux(images);
34801538:	e5940060 	ldr	r0, [r4, #96]	; 0x60
3480153c:	ebffffc5 	bl	34801458 <boot_jump_linux.clone.5>
	return 0;
}
34801540:	e1a00005 	mov	r0, r5
34801544:	e8bd8070 	pop	{r4, r5, r6, pc}

34801548 <interrupt_init>:
int interrupt_init (void)
{
	/*
	 * setup up stacks if necessary
	 */
	IRQ_STACK_START_IN = gd->irq_sp + 8;
34801548:	e5982040 	ldr	r2, [r8, #64]	; 0x40
3480154c:	e59f300c 	ldr	r3, [pc, #12]	; 34801560 <interrupt_init+0x18>
34801550:	e2822008 	add	r2, r2, #8
34801554:	e5832000 	str	r2, [r3]

	return 0;
}
34801558:	e3a00000 	mov	r0, #0
3480155c:	e12fff1e 	bx	lr
34801560:	34800054 	.word	0x34800054

34801564 <enable_interrupts>:

void enable_interrupts (void)
{
	return;
}
34801564:	e12fff1e 	bx	lr

34801568 <disable_interrupts>:
int disable_interrupts (void)
{
	return 0;
}
34801568:	e3a00000 	mov	r0, #0
3480156c:	e12fff1e 	bx	lr

34801570 <bad_mode>:
#endif


void bad_mode (void)
{
34801570:	e92d4008 	push	{r3, lr}
	panic ("Resetting CPU ...\n");
34801574:	e59f0000 	ldr	r0, [pc, #0]	; 3480157c <bad_mode+0xc>
34801578:	eb006df3 	bl	3481cd4c <panic>
3480157c:	3482291a 	.word	0x3482291a

34801580 <show_regs>:
	reset_cpu (0);
}

void show_regs (struct pt_regs *regs)
{
34801580:	e92d4070 	push	{r4, r5, r6, lr}
34801584:	e24dd088 	sub	sp, sp, #136	; 0x88
34801588:	e1a04000 	mov	r4, r0
	unsigned long flags;
	const char *processor_modes[] = {
3480158c:	e59f1104 	ldr	r1, [pc, #260]	; 34801698 <show_regs+0x118>
34801590:	e28d0008 	add	r0, sp, #8
34801594:	e3a02080 	mov	r2, #128	; 0x80
34801598:	eb006a6d 	bl	3481bf54 <memcpy>
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);

	printf ("pc : [<%08lx>]	   lr : [<%08lx>]\n"
3480159c:	e5943030 	ldr	r3, [r4, #48]	; 0x30
348015a0:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
348015a4:	e58d3000 	str	r3, [sp]
348015a8:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
348015ac:	e5942038 	ldr	r2, [r4, #56]	; 0x38
348015b0:	e58d3004 	str	r3, [sp, #4]
348015b4:	e59f00e0 	ldr	r0, [pc, #224]	; 3480169c <show_regs+0x11c>
348015b8:	e5943034 	ldr	r3, [r4, #52]	; 0x34
	"UK4_32",	"UK5_32",	"UK6_32",	"ABT_32",
	"UK8_32",	"UK9_32",	"UK10_32",	"UND_32",
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);
348015bc:	e5945040 	ldr	r5, [r4, #64]	; 0x40

	printf ("pc : [<%08lx>]	   lr : [<%08lx>]\n"
348015c0:	eb001ee7 	bl	34809164 <printf>
		"sp : %08lx  ip : %08lx	 fp : %08lx\n",
		instruction_pointer (regs),
		regs->ARM_lr, regs->ARM_sp, regs->ARM_ip, regs->ARM_fp);
	printf ("r10: %08lx  r9 : %08lx	 r8 : %08lx\n",
348015c4:	e5941028 	ldr	r1, [r4, #40]	; 0x28
348015c8:	e5942024 	ldr	r2, [r4, #36]	; 0x24
348015cc:	e5943020 	ldr	r3, [r4, #32]
348015d0:	e59f00c8 	ldr	r0, [pc, #200]	; 348016a0 <show_regs+0x120>
348015d4:	eb001ee2 	bl	34809164 <printf>
		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
	printf ("r7 : %08lx  r6 : %08lx	 r5 : %08lx  r4 : %08lx\n",
348015d8:	e5943010 	ldr	r3, [r4, #16]
348015dc:	e594101c 	ldr	r1, [r4, #28]
348015e0:	e58d3000 	str	r3, [sp]
348015e4:	e5942018 	ldr	r2, [r4, #24]
348015e8:	e5943014 	ldr	r3, [r4, #20]
348015ec:	e59f00b0 	ldr	r0, [pc, #176]	; 348016a4 <show_regs+0x124>
348015f0:	eb001edb 	bl	34809164 <printf>
		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
	printf ("r3 : %08lx  r2 : %08lx	 r1 : %08lx  r0 : %08lx\n",
348015f4:	e5943000 	ldr	r3, [r4]
348015f8:	e594100c 	ldr	r1, [r4, #12]
348015fc:	e58d3000 	str	r3, [sp]
34801600:	e5942008 	ldr	r2, [r4, #8]
34801604:	e5943004 	ldr	r3, [r4, #4]
34801608:	e59f0098 	ldr	r0, [pc, #152]	; 348016a8 <show_regs+0x128>
3480160c:	eb001ed4 	bl	34809164 <printf>
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
34801610:	e3150101 	tst	r5, #1073741824	; 0x40000000
34801614:	03a0207a 	moveq	r2, #122	; 0x7a
34801618:	13a0205a 	movne	r2, #90	; 0x5a
3480161c:	e3150202 	tst	r5, #536870912	; 0x20000000
34801620:	03a03063 	moveq	r3, #99	; 0x63
34801624:	13a03043 	movne	r3, #67	; 0x43
	"UK4_32",	"UK5_32",	"UK6_32",	"ABT_32",
	"UK8_32",	"UK9_32",	"UK10_32",	"UND_32",
	"UK12_32",	"UK13_32",	"UK14_32",	"SYS_32",
	};

	flags = condition_codes (regs);
34801628:	e205620f 	and	r6, r5, #-268435456	; 0xf0000000
		regs->ARM_r10, regs->ARM_r9, regs->ARM_r8);
	printf ("r7 : %08lx  r6 : %08lx	 r5 : %08lx  r4 : %08lx\n",
		regs->ARM_r7, regs->ARM_r6, regs->ARM_r5, regs->ARM_r4);
	printf ("r3 : %08lx  r2 : %08lx	 r1 : %08lx  r0 : %08lx\n",
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
3480162c:	e3150201 	tst	r5, #268435456	; 0x10000000
34801630:	03a01076 	moveq	r1, #118	; 0x76
34801634:	13a01056 	movne	r1, #86	; 0x56
34801638:	e3560000 	cmp	r6, #0
3480163c:	e58d1000 	str	r1, [sp]
34801640:	e59f0064 	ldr	r0, [pc, #100]	; 348016ac <show_regs+0x12c>
34801644:	a3a0106e 	movge	r1, #110	; 0x6e
34801648:	b3a0104e 	movlt	r1, #78	; 0x4e
3480164c:	eb001ec4 	bl	34809164 <printf>
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
		interrupts_enabled (regs) ? "on" : "off",
34801650:	e5943040 	ldr	r3, [r4, #64]	; 0x40
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
34801654:	e59fc054 	ldr	ip, [pc, #84]	; 348016b0 <show_regs+0x130>
34801658:	e59f2054 	ldr	r2, [pc, #84]	; 348016b4 <show_regs+0x134>
3480165c:	e3130080 	tst	r3, #128	; 0x80
34801660:	01a0100c 	moveq	r1, ip
34801664:	11a01002 	movne	r1, r2
34801668:	e28d0088 	add	r0, sp, #136	; 0x88
3480166c:	e3130040 	tst	r3, #64	; 0x40
		interrupts_enabled (regs) ? "on" : "off",
		fast_interrupts_enabled (regs) ? "on" : "off",
		processor_modes[processor_mode (regs)],
34801670:	e203301f 	and	r3, r3, #31
		regs->ARM_r3, regs->ARM_r2, regs->ARM_r1, regs->ARM_r0);
	printf ("Flags: %c%c%c%c",
		flags & CC_N_BIT ? 'N' : 'n',
		flags & CC_Z_BIT ? 'Z' : 'z',
		flags & CC_C_BIT ? 'C' : 'c', flags & CC_V_BIT ? 'V' : 'v');
	printf ("  IRQs %s  FIQs %s  Mode %s%s\n",
34801674:	e0803103 	add	r3, r0, r3, lsl #2
34801678:	e59f0038 	ldr	r0, [pc, #56]	; 348016b8 <show_regs+0x138>
3480167c:	01a0200c 	moveq	r2, ip
34801680:	e58d0000 	str	r0, [sp]
34801684:	e5133080 	ldr	r3, [r3, #-128]	; 0x80
34801688:	e59f002c 	ldr	r0, [pc, #44]	; 348016bc <show_regs+0x13c>
3480168c:	eb001eb4 	bl	34809164 <printf>
		interrupts_enabled (regs) ? "on" : "off",
		fast_interrupts_enabled (regs) ? "on" : "off",
		processor_modes[processor_mode (regs)],
		thumb_mode (regs) ? " (T)" : "");
}
34801690:	e28dd088 	add	sp, sp, #136	; 0x88
34801694:	e8bd8070 	pop	{r4, r5, r6, pc}
34801698:	34820068 	.word	0x34820068
3480169c:	3482292d 	.word	0x3482292d
348016a0:	34822972 	.word	0x34822972
348016a4:	34822996 	.word	0x34822996
348016a8:	348229c6 	.word	0x348229c6
348016ac:	348229f6 	.word	0x348229f6
348016b0:	3482828b 	.word	0x3482828b
348016b4:	34822c18 	.word	0x34822c18
348016b8:	34823cce 	.word	0x34823cce
348016bc:	34822a06 	.word	0x34822a06

348016c0 <do_undefined_instruction>:

void do_undefined_instruction (struct pt_regs *pt_regs)
{
348016c0:	e92d4010 	push	{r4, lr}
348016c4:	e1a04000 	mov	r4, r0
	printf ("undefined instruction\n");
348016c8:	e59f0010 	ldr	r0, [pc, #16]	; 348016e0 <do_undefined_instruction+0x20>
348016cc:	eb001ea4 	bl	34809164 <printf>
	show_regs (pt_regs);
348016d0:	e1a00004 	mov	r0, r4
348016d4:	ebffffa9 	bl	34801580 <show_regs>
	bad_mode ();
}
348016d8:	e8bd4010 	pop	{r4, lr}

void do_undefined_instruction (struct pt_regs *pt_regs)
{
	printf ("undefined instruction\n");
	show_regs (pt_regs);
	bad_mode ();
348016dc:	eaffffa3 	b	34801570 <bad_mode>
348016e0:	34822a25 	.word	0x34822a25

348016e4 <do_software_interrupt>:
}

void do_software_interrupt (struct pt_regs *pt_regs)
{
348016e4:	e92d4010 	push	{r4, lr}
348016e8:	e1a04000 	mov	r4, r0
	printf ("software interrupt\n");
348016ec:	e59f0010 	ldr	r0, [pc, #16]	; 34801704 <do_software_interrupt+0x20>
348016f0:	eb001e9b 	bl	34809164 <printf>
	show_regs (pt_regs);
348016f4:	e1a00004 	mov	r0, r4
348016f8:	ebffffa0 	bl	34801580 <show_regs>
	bad_mode ();
}
348016fc:	e8bd4010 	pop	{r4, lr}

void do_software_interrupt (struct pt_regs *pt_regs)
{
	printf ("software interrupt\n");
	show_regs (pt_regs);
	bad_mode ();
34801700:	eaffff9a 	b	34801570 <bad_mode>
34801704:	34822a3c 	.word	0x34822a3c

34801708 <do_prefetch_abort>:
}

void do_prefetch_abort (struct pt_regs *pt_regs)
{
34801708:	e92d4010 	push	{r4, lr}
3480170c:	e1a04000 	mov	r4, r0
	printf ("prefetch abort\n");
34801710:	e59f0010 	ldr	r0, [pc, #16]	; 34801728 <do_prefetch_abort+0x20>
34801714:	eb001e92 	bl	34809164 <printf>
	show_regs (pt_regs);
34801718:	e1a00004 	mov	r0, r4
3480171c:	ebffff97 	bl	34801580 <show_regs>
	bad_mode ();
}
34801720:	e8bd4010 	pop	{r4, lr}

void do_prefetch_abort (struct pt_regs *pt_regs)
{
	printf ("prefetch abort\n");
	show_regs (pt_regs);
	bad_mode ();
34801724:	eaffff91 	b	34801570 <bad_mode>
34801728:	34822a50 	.word	0x34822a50

3480172c <do_data_abort>:
}

void do_data_abort (struct pt_regs *pt_regs)
{
3480172c:	e92d4010 	push	{r4, lr}
34801730:	e1a04000 	mov	r4, r0
	printf ("data abort\n");
34801734:	e59f0010 	ldr	r0, [pc, #16]	; 3480174c <do_data_abort+0x20>
34801738:	eb001e89 	bl	34809164 <printf>
	show_regs (pt_regs);
3480173c:	e1a00004 	mov	r0, r4
34801740:	ebffff8e 	bl	34801580 <show_regs>
	bad_mode ();
}
34801744:	e8bd4010 	pop	{r4, lr}

void do_data_abort (struct pt_regs *pt_regs)
{
	printf ("data abort\n");
	show_regs (pt_regs);
	bad_mode ();
34801748:	eaffff88 	b	34801570 <bad_mode>
3480174c:	34822a60 	.word	0x34822a60

34801750 <do_not_used>:
}

void do_not_used (struct pt_regs *pt_regs)
{
34801750:	e92d4010 	push	{r4, lr}
34801754:	e1a04000 	mov	r4, r0
	printf ("not used\n");
34801758:	e59f0010 	ldr	r0, [pc, #16]	; 34801770 <do_not_used+0x20>
3480175c:	eb001e80 	bl	34809164 <printf>
	show_regs (pt_regs);
34801760:	e1a00004 	mov	r0, r4
34801764:	ebffff85 	bl	34801580 <show_regs>
	bad_mode ();
}
34801768:	e8bd4010 	pop	{r4, lr}

void do_not_used (struct pt_regs *pt_regs)
{
	printf ("not used\n");
	show_regs (pt_regs);
	bad_mode ();
3480176c:	eaffff7f 	b	34801570 <bad_mode>
34801770:	34822a6c 	.word	0x34822a6c

34801774 <do_fiq>:
}

void do_fiq (struct pt_regs *pt_regs)
{
34801774:	e92d4010 	push	{r4, lr}
34801778:	e1a04000 	mov	r4, r0
	printf ("fast interrupt request\n");
3480177c:	e59f0010 	ldr	r0, [pc, #16]	; 34801794 <do_fiq+0x20>
34801780:	eb001e77 	bl	34809164 <printf>
	show_regs (pt_regs);
34801784:	e1a00004 	mov	r0, r4
34801788:	ebffff7c 	bl	34801580 <show_regs>
	bad_mode ();
}
3480178c:	e8bd4010 	pop	{r4, lr}

void do_fiq (struct pt_regs *pt_regs)
{
	printf ("fast interrupt request\n");
	show_regs (pt_regs);
	bad_mode ();
34801790:	eaffff76 	b	34801570 <bad_mode>
34801794:	34822a76 	.word	0x34822a76

34801798 <do_irq>:
}

#ifndef CONFIG_USE_IRQ
void do_irq (struct pt_regs *pt_regs)
{
34801798:	e92d4010 	push	{r4, lr}
3480179c:	e1a04000 	mov	r4, r0
	printf ("interrupt request\n");
348017a0:	e59f0010 	ldr	r0, [pc, #16]	; 348017b8 <do_irq+0x20>
348017a4:	eb001e6e 	bl	34809164 <printf>
	show_regs (pt_regs);
348017a8:	e1a00004 	mov	r0, r4
348017ac:	ebffff73 	bl	34801580 <show_regs>
	bad_mode ();
}
348017b0:	e8bd4010 	pop	{r4, lr}
#ifndef CONFIG_USE_IRQ
void do_irq (struct pt_regs *pt_regs)
{
	printf ("interrupt request\n");
	show_regs (pt_regs);
	bad_mode ();
348017b4:	eaffff6d 	b	34801570 <bad_mode>
348017b8:	34822a7b 	.word	0x34822a7b

348017bc <do_reset>:
 */

#include <common.h>

int do_reset(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348017bc:	e92d4008 	push	{r3, lr}
	puts ("resetting ...\n");
348017c0:	e59f001c 	ldr	r0, [pc, #28]	; 348017e4 <do_reset+0x28>
348017c4:	eb001e5c 	bl	3480913c <puts>

	udelay (50000);				/* wait 50 ms */
348017c8:	e30c0350 	movw	r0, #50000	; 0xc350
348017cc:	eb006a6b 	bl	3481c180 <udelay>

	disable_interrupts();
348017d0:	ebffff64 	bl	34801568 <disable_interrupts>
	reset_cpu(0);
348017d4:	e3a00000 	mov	r0, #0
348017d8:	ebfffe08 	bl	34801000 <reset_cpu>

	/*NOTREACHED*/
	return 0;
}
348017dc:	e3a00000 	mov	r0, #0
348017e0:	e8bd8008 	pop	{r3, pc}
348017e4:	34822b7a 	.word	0x34822b7a

348017e8 <__flush_cache>:
	asm("0: mrc p15, 0, r15, c7, c10, 3\n\t" "bne 0b\n" : : : "memory");
	/* disable write buffer as well (page 2-22) */
	asm("mcr p15, 0, %0, c7, c10, 4" : : "r" (0));
#endif
	return;
}
348017e8:	e12fff1e 	bx	lr

348017ec <__flush_dcache_all>:
 * Default implementation:
 * do a range flush for the entire range
 */
void	__flush_dcache_all(void)
{
	flush_cache(0, ~0);
348017ec:	e3a00000 	mov	r0, #0
348017f0:	e3e01000 	mvn	r1, #0
348017f4:	eafffbbd 	b	348006f0 <flush_cache>

348017f8 <__enable_caches>:
 * Default implementation of enable_caches()
 * Real implementation should be in platform code
 */
void __enable_caches(void)
{
	puts("WARNING: Caches not enabled\n");
348017f8:	e59f0000 	ldr	r0, [pc, #0]	; 34801800 <__enable_caches+0x8>
348017fc:	ea001e4e 	b	3480913c <puts>
34801800:	34822b89 	.word	0x34822b89

34801804 <cp_delay>:
}
void arm_init_before_mmu(void)
	__attribute__((weak, alias("__arm_init_before_mmu")));

static void cp_delay (void)
{
34801804:	e24dd008 	sub	sp, sp, #8
	volatile int i;

	/* copro seems to need some delay between reading and writing */
	for (i = 0; i < 100; i++)
34801808:	e3a03000 	mov	r3, #0
3480180c:	ea000002 	b	3480181c <cp_delay+0x18>
		nop();
34801810:	e1a00000 	nop			; (mov r0, r0)
static void cp_delay (void)
{
	volatile int i;

	/* copro seems to need some delay between reading and writing */
	for (i = 0; i < 100; i++)
34801814:	e59d3004 	ldr	r3, [sp, #4]
34801818:	e2833001 	add	r3, r3, #1
3480181c:	e58d3004 	str	r3, [sp, #4]
34801820:	e59d3004 	ldr	r3, [sp, #4]
34801824:	e3530063 	cmp	r3, #99	; 0x63
34801828:	dafffff8 	ble	34801810 <cp_delay+0xc>
		nop();
	asm volatile("" : : : "memory");
}
3480182c:	e28dd008 	add	sp, sp, #8
34801830:	e12fff1e 	bx	lr

34801834 <cache_enable>:
static void cache_enable(uint32_t cache_bit)
{
	uint32_t reg;

	/* The data cache is not active unless the mmu is enabled too */
	if ((cache_bit == CR_C) && !mmu_enabled())
34801834:	e3500004 	cmp	r0, #4
	return get_cr() & CR_M;
}

/* cache_bit must be either CR_I or CR_C */
static void cache_enable(uint32_t cache_bit)
{
34801838:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3480183c:	e1a05000 	mov	r5, r0
	uint32_t reg;

	/* The data cache is not active unless the mmu is enabled too */
	if ((cache_bit == CR_C) && !mmu_enabled())
34801840:	1a00002b 	bne	348018f4 <cache_enable+0xc0>
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
34801844:	ee117f10 	mrc	15, 0, r7, cr1, cr0, {0}
34801848:	e2177001 	ands	r7, r7, #1
3480184c:	1a000028 	bne	348018f4 <cache_enable+0xc0>
}

/* to activate the MMU we need to set up virtual memory: use 1M areas */
static inline void mmu_setup(void)
{
	u32 *page_table = (u32 *)gd->tlb_addr;
34801850:	e598404c 	ldr	r4, [r8, #76]	; 0x4c
34801854:	e1a06004 	mov	r6, r4
	int i;
	u32 reg;

	arm_init_before_mmu();
34801858:	ebfffb9a 	bl	348006c8 <arm_init_before_mmu>
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
		page_table[i] = i << 20 | (3 << 10) | 0x12;
3480185c:	e1a03a07 	lsl	r3, r7, #20
34801860:	e3833ec1 	orr	r3, r3, #3088	; 0xc10
	int i;
	u32 reg;

	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
34801864:	e2877001 	add	r7, r7, #1
		page_table[i] = i << 20 | (3 << 10) | 0x12;
34801868:	e3833002 	orr	r3, r3, #2
	int i;
	u32 reg;

	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
3480186c:	e3570a01 	cmp	r7, #4096	; 0x1000
		page_table[i] = i << 20 | (3 << 10) | 0x12;
34801870:	e4843004 	str	r3, [r4], #4
	int i;
	u32 reg;

	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
34801874:	1afffff8 	bne	3480185c <cache_enable+0x28>
	asm volatile("" : : : "memory");
}

static inline void dram_bank_mmu_setup(int bank)
{
	u32 *page_table = (u32 *)gd->tlb_addr;
34801878:	e1a01008 	mov	r1, r8
3480187c:	e3a02000 	mov	r2, #0
34801880:	e591004c 	ldr	r0, [r1, #76]	; 0x4c
	bd_t *bd = gd->bd;
34801884:	e591e000 	ldr	lr, [r1]
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
34801888:	e2824003 	add	r4, r2, #3
3480188c:	e79ec184 	ldr	ip, [lr, r4, lsl #3]
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
34801890:	e08ee184 	add	lr, lr, r4, lsl #3
34801894:	e59ee004 	ldr	lr, [lr, #4]
	u32 *page_table = (u32 *)gd->tlb_addr;
	bd_t *bd = gd->bd;
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
34801898:	e1a03a2c 	lsr	r3, ip, #20
{
	return get_cr() & CR_M;
}

/* cache_bit must be either CR_I or CR_C */
static void cache_enable(uint32_t cache_bit)
3480189c:	e2400004 	sub	r0, r0, #4
	bd_t *bd = gd->bd;
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
348018a0:	e08cc00e 	add	ip, ip, lr
348018a4:	e1a0ca2c 	lsr	ip, ip, #20
348018a8:	e0800103 	add	r0, r0, r3, lsl #2
348018ac:	ea000004 	b	348018c4 <cache_enable+0x90>
	     i++) {
		page_table[i] = i << 20 | (3 << 10) | CACHE_SETUP;
348018b0:	e1a0ea03 	lsl	lr, r3, #20
348018b4:	e38eeec1 	orr	lr, lr, #3088	; 0xc10
348018b8:	e38ee00e 	orr	lr, lr, #14
348018bc:	e5a0e004 	str	lr, [r0, #4]!
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
	     i < (bd->bi_dram[bank].start + bd->bi_dram[bank].size) >> 20;
	     i++) {
348018c0:	e2833001 	add	r3, r3, #1
	u32 *page_table = (u32 *)gd->tlb_addr;
	bd_t *bd = gd->bd;
	int	i;

	debug("%s: bank: %d\n", __func__, bank);
	for (i = bd->bi_dram[bank].start >> 20;
348018c4:	e153000c 	cmp	r3, ip
348018c8:	3afffff8 	bcc	348018b0 <cache_enable+0x7c>
	arm_init_before_mmu();
	/* Set up an identity-mapping for all 4GB, rw for everyone */
	for (i = 0; i < 4096; i++)
		page_table[i] = i << 20 | (3 << 10) | 0x12;

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; i++) {
348018cc:	e2822001 	add	r2, r2, #1
348018d0:	e3520003 	cmp	r2, #3
348018d4:	1affffe9 	bne	34801880 <cache_enable+0x4c>
		dram_bank_mmu_setup(i);
	}

	/* Copy the page table address to cp15 */
	asm volatile("mcr p15, 0, %0, c2, c0, 0"
348018d8:	ee026f10 	mcr	15, 0, r6, cr2, cr0, {0}
		     : : "r" (page_table) : "memory");
	/* Set the access control to all-supervisor */
	asm volatile("mcr p15, 0, %0, c3, c0, 0"
348018dc:	e3e03000 	mvn	r3, #0
348018e0:	ee033f10 	mcr	15, 0, r3, cr3, cr0, {0}
		     : : "r" (~0));
	/* and enable the mmu */
	reg = get_cr();	/* get control reg. */
	cp_delay();
348018e4:	ebffffc6 	bl	34801804 <cp_delay>
348018e8:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}
	set_cr(reg | CR_M);
348018ec:	e3844001 	orr	r4, r4, #1
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
348018f0:	ee014f10 	mcr	15, 0, r4, cr1, cr0, {0}
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
348018f4:	ee114f10 	mrc	15, 0, r4, cr1, cr0, {0}

	/* The data cache is not active unless the mmu is enabled too */
	if ((cache_bit == CR_C) && !mmu_enabled())
		mmu_setup();
	reg = get_cr();	/* get control reg. */
	cp_delay();
348018f8:	ebffffc1 	bl	34801804 <cp_delay>
	set_cr(reg | cache_bit);
348018fc:	e1845005 	orr	r5, r4, r5
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
34801900:	ee015f10 	mcr	15, 0, r5, cr1, cr0, {0}
}
34801904:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

34801908 <cache_disable>:

/* cache_bit must be either CR_I or CR_C */
static void cache_disable(uint32_t cache_bit)
{
34801908:	e92d4038 	push	{r3, r4, r5, lr}
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
3480190c:	ee115f10 	mrc	15, 0, r5, cr1, cr0, {0}
34801910:	e1a04000 	mov	r4, r0
	uint32_t reg;

	reg = get_cr();
	cp_delay();
34801914:	ebffffba 	bl	34801804 <cp_delay>

	if (cache_bit == CR_C) {
34801918:	e3540004 	cmp	r4, #4
3480191c:	1a000003 	bne	34801930 <cache_disable+0x28>
		/* if cache isn;t enabled no need to disable */
		if ((reg & CR_C) != CR_C)
34801920:	e3150004 	tst	r5, #4
34801924:	08bd8038 	popeq	{r3, r4, r5, pc}
			return;
		/* if disabling data cache, disable mmu too */
		cache_bit |= CR_M;
		flush_dcache_all();
34801928:	ebfffb4f 	bl	3480066c <flush_dcache_all>
	if (cache_bit == CR_C) {
		/* if cache isn;t enabled no need to disable */
		if ((reg & CR_C) != CR_C)
			return;
		/* if disabling data cache, disable mmu too */
		cache_bit |= CR_M;
3480192c:	e2844001 	add	r4, r4, #1
		flush_dcache_all();
	}
	set_cr(reg & ~cache_bit);
34801930:	e1c54004 	bic	r4, r5, r4
	return val;
}

static inline void set_cr(unsigned int val)
{
	asm volatile("mcr p15, 0, %0, c1, c0, 0	@ set CR"
34801934:	ee014f10 	mcr	15, 0, r4, cr1, cr0, {0}
	  : : "r" (val) : "cc");
	isb();
34801938:	e8bd8038 	pop	{r3, r4, r5, pc}

3480193c <__arm_init_before_mmu>:

DECLARE_GLOBAL_DATA_PTR;

void __arm_init_before_mmu(void)
{
}
3480193c:	e12fff1e 	bx	lr

34801940 <icache_enable>:
	return 0;					/* always off */
}
#else
void icache_enable(void)
{
	cache_enable(CR_I);
34801940:	e3a00a01 	mov	r0, #4096	; 0x1000
34801944:	eaffffba 	b	34801834 <cache_enable>

34801948 <icache_disable>:
}

void icache_disable(void)
{
	cache_disable(CR_I);
34801948:	e3a00a01 	mov	r0, #4096	; 0x1000
3480194c:	eaffffed 	b	34801908 <cache_disable>

34801950 <icache_status>:
#define nop() __asm__ __volatile__("mov\tr0,r0\t@ nop\n\t");

static inline unsigned int get_cr(void)
{
	unsigned int val;
	asm("mrc p15, 0, %0, c1, c0, 0	@ get CR" : "=r" (val) : : "cc");
34801950:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
}

int icache_status(void)
{
	return (get_cr() & CR_I) != 0;
}
34801954:	e7e00650 	ubfx	r0, r0, #12, #1
34801958:	e12fff1e 	bx	lr

3480195c <dcache_enable>:
	return 0;					/* always off */
}
#else
void dcache_enable(void)
{
	cache_enable(CR_C);
3480195c:	e3a00004 	mov	r0, #4
34801960:	eaffffb3 	b	34801834 <cache_enable>

34801964 <dcache_disable>:
}

void dcache_disable(void)
{
	cache_disable(CR_C);
34801964:	e3a00004 	mov	r0, #4
34801968:	eaffffe6 	b	34801908 <cache_disable>

3480196c <dcache_status>:
3480196c:	ee110f10 	mrc	15, 0, r0, cr1, cr0, {0}
}

int dcache_status(void)
{
	return (get_cr() & CR_C) != 0;
}
34801970:	e7e00150 	ubfx	r0, r0, #2, #1
34801974:	e12fff1e 	bx	lr

34801978 <do_bdinfo>:
}

#elif defined(CONFIG_ARM)

int do_bdinfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34801978:	e92d4070 	push	{r4, r5, r6, lr}
	int i;
	bd_t *bd = gd->bd;
3480197c:	e5984000 	ldr	r4, [r8]
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
34801980:	e59f10d4 	ldr	r1, [pc, #212]	; 34801a5c <do_bdinfo+0xe4>
34801984:	e5942004 	ldr	r2, [r4, #4]
34801988:	e59f00d0 	ldr	r0, [pc, #208]	; 34801a60 <do_bdinfo+0xe8>
3480198c:	eb001df4 	bl	34809164 <printf>
34801990:	e59f00c8 	ldr	r0, [pc, #200]	; 34801a60 <do_bdinfo+0xe8>
34801994:	e59f10c8 	ldr	r1, [pc, #200]	; 34801a64 <do_bdinfo+0xec>
34801998:	e5942008 	ldr	r2, [r4, #8]
3480199c:	eb001df0 	bl	34809164 <printf>
348019a0:	e1a06004 	mov	r6, r4
	bd_t *bd = gd->bd;

	print_num("arch_number",	bd->bi_arch_number);
	print_num("boot_params",	(ulong)bd->bi_boot_params);

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; ++i) {
348019a4:	e3a05000 	mov	r5, #0
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
348019a8:	e1a02005 	mov	r2, r5
348019ac:	e59f10b4 	ldr	r1, [pc, #180]	; 34801a68 <do_bdinfo+0xf0>
348019b0:	e59f00a8 	ldr	r0, [pc, #168]	; 34801a60 <do_bdinfo+0xe8>
348019b4:	eb001dea 	bl	34809164 <printf>
348019b8:	e5962018 	ldr	r2, [r6, #24]
348019bc:	e59f10a8 	ldr	r1, [pc, #168]	; 34801a6c <do_bdinfo+0xf4>
348019c0:	e59f0098 	ldr	r0, [pc, #152]	; 34801a60 <do_bdinfo+0xe8>
348019c4:	eb001de6 	bl	34809164 <printf>
	bd_t *bd = gd->bd;

	print_num("arch_number",	bd->bi_arch_number);
	print_num("boot_params",	(ulong)bd->bi_boot_params);

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; ++i) {
348019c8:	e2855001 	add	r5, r5, #1
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
348019cc:	e596201c 	ldr	r2, [r6, #28]
348019d0:	e59f0088 	ldr	r0, [pc, #136]	; 34801a60 <do_bdinfo+0xe8>
348019d4:	e59f1094 	ldr	r1, [pc, #148]	; 34801a70 <do_bdinfo+0xf8>
348019d8:	eb001de1 	bl	34809164 <printf>
	bd_t *bd = gd->bd;

	print_num("arch_number",	bd->bi_arch_number);
	print_num("boot_params",	(ulong)bd->bi_boot_params);

	for (i = 0; i < CONFIG_NR_DRAM_BANKS; ++i) {
348019dc:	e3550003 	cmp	r5, #3
348019e0:	e2866008 	add	r6, r6, #8
348019e4:	1affffef 	bne	348019a8 <do_bdinfo+0x30>

#if defined(CONFIG_CMD_NET)
	print_eth(0);
	printf("ip_addr     = %s\n", getenv("ipaddr"));
#endif
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
348019e8:	e5941000 	ldr	r1, [r4]
348019ec:	e59f0080 	ldr	r0, [pc, #128]	; 34801a74 <do_bdinfo+0xfc>
348019f0:	eb001ddb 	bl	34809164 <printf>
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
348019f4:	e59f107c 	ldr	r1, [pc, #124]	; 34801a78 <do_bdinfo+0x100>
	print_eth(0);
	printf("ip_addr     = %s\n", getenv("ipaddr"));
#endif
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
348019f8:	e598204c 	ldr	r2, [r8, #76]	; 0x4c
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
348019fc:	e59f005c 	ldr	r0, [pc, #92]	; 34801a60 <do_bdinfo+0xe8>
34801a00:	eb001dd7 	bl	34809164 <printf>
34801a04:	e59f1070 	ldr	r1, [pc, #112]	; 34801a7c <do_bdinfo+0x104>
#endif
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
34801a08:	e5982034 	ldr	r2, [r8, #52]	; 0x34
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
34801a0c:	e59f004c 	ldr	r0, [pc, #76]	; 34801a60 <do_bdinfo+0xe8>
34801a10:	eb001dd3 	bl	34809164 <printf>
34801a14:	e59f1064 	ldr	r1, [pc, #100]	; 34801a80 <do_bdinfo+0x108>
	printf("baudrate    = %d bps\n", bd->bi_baudrate);
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
34801a18:	e5982048 	ldr	r2, [r8, #72]	; 0x48
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
34801a1c:	e59f003c 	ldr	r0, [pc, #60]	; 34801a60 <do_bdinfo+0xe8>
34801a20:	eb001dcf 	bl	34809164 <printf>
34801a24:	e59f1058 	ldr	r1, [pc, #88]	; 34801a84 <do_bdinfo+0x10c>
#if !(defined(CONFIG_SYS_ICACHE_OFF) && defined(CONFIG_SYS_DCACHE_OFF))
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
34801a28:	e5982040 	ldr	r2, [r8, #64]	; 0x40
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
34801a2c:	e59f002c 	ldr	r0, [pc, #44]	; 34801a60 <do_bdinfo+0xe8>
34801a30:	eb001dcb 	bl	34809164 <printf>
34801a34:	e59f104c 	ldr	r1, [pc, #76]	; 34801a88 <do_bdinfo+0x110>
	print_num("TLB addr", gd->tlb_addr);
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
	print_num("sp start ", gd->start_addr_sp);
34801a38:	e5982044 	ldr	r2, [r8, #68]	; 0x44
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
34801a3c:	e59f001c 	ldr	r0, [pc, #28]	; 34801a60 <do_bdinfo+0xe8>
34801a40:	eb001dc7 	bl	34809164 <printf>
34801a44:	e59f1040 	ldr	r1, [pc, #64]	; 34801a8c <do_bdinfo+0x114>
#endif
	print_num("relocaddr", gd->relocaddr);
	print_num("reloc off", gd->reloc_off);
	print_num("irq_sp", gd->irq_sp);	/* irq stack pointer */
	print_num("sp start ", gd->start_addr_sp);
	print_num("FB base  ", gd->fb_base);
34801a48:	e5982018 	ldr	r2, [r8, #24]
DECLARE_GLOBAL_DATA_PTR;

__maybe_unused
static void print_num(const char *name, ulong value)
{
	printf("%-12s= 0x%08lX\n", name, value);
34801a4c:	e59f000c 	ldr	r0, [pc, #12]	; 34801a60 <do_bdinfo+0xe8>
34801a50:	eb001dc3 	bl	34809164 <printf>
	printf("ARM frequency = %ld MHz\n", gd->bd->bi_arm_freq);
	printf("DSP frequency = %ld MHz\n", gd->bd->bi_dsp_freq);
	printf("DDR frequency = %ld MHz\n", gd->bd->bi_ddr_freq);
#endif
	return 0;
}
34801a54:	e3a00000 	mov	r0, #0
34801a58:	e8bd8070 	pop	{r4, r5, r6, pc}
34801a5c:	34822bb6 	.word	0x34822bb6
34801a60:	34822ba6 	.word	0x34822ba6
34801a64:	34822bc2 	.word	0x34822bc2
34801a68:	34822bce 	.word	0x34822bce
34801a6c:	34822bd8 	.word	0x34822bd8
34801a70:	34822be1 	.word	0x34822be1
34801a74:	34822be9 	.word	0x34822be9
34801a78:	34822bff 	.word	0x34822bff
34801a7c:	34822c08 	.word	0x34822c08
34801a80:	34822c12 	.word	0x34822c12
34801a84:	34822c1c 	.word	0x34822c1c
34801a88:	34822c23 	.word	0x34822c23
34801a8c:	34822c2d 	.word	0x34822c2d

34801a90 <do_go_exec>:
#ifdef CONFIG_CMD_GO

/* Allow ports to override the default behavior */
__attribute__((weak))
unsigned long do_go_exec (ulong (*entry)(int, char * const []), int argc, char * const argv[])
{
34801a90:	e92d4008 	push	{r3, lr}
34801a94:	e1a03000 	mov	r3, r0
	return entry (argc, argv);
34801a98:	e1a00001 	mov	r0, r1
34801a9c:	e1a01002 	mov	r1, r2
34801aa0:	e12fff33 	blx	r3
}
34801aa4:	e8bd8008 	pop	{r3, pc}

34801aa8 <do_go>:
int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
34801aa8:	e3520001 	cmp	r2, #1
{
	return entry (argc, argv);
}

int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34801aac:	e92d4070 	push	{r4, r5, r6, lr}
34801ab0:	e1a04002 	mov	r4, r2
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
		return CMD_RET_USAGE;
34801ab4:	d3e04000 	mvnle	r4, #0
int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;

	if (argc < 2)
34801ab8:	da000011 	ble	34801b04 <do_go+0x5c>
		return CMD_RET_USAGE;

	addr = simple_strtoul(argv[1], NULL, 16);
34801abc:	e5930004 	ldr	r0, [r3, #4]
34801ac0:	e3a02010 	mov	r2, #16
34801ac4:	e3a01000 	mov	r1, #0
34801ac8:	e2835004 	add	r5, r3, #4
34801acc:	eb006bef 	bl	3481ca90 <simple_strtoul>
34801ad0:	e1a06000 	mov	r6, r0

	printf ("## Starting application at 0x%08lX ...\n", addr);
34801ad4:	e1a01006 	mov	r1, r6
34801ad8:	e59f002c 	ldr	r0, [pc, #44]	; 34801b0c <do_go+0x64>
34801adc:	eb001da0 	bl	34809164 <printf>

	/*
	 * pass address parameter as argv[0] (aka command name),
	 * and all remaining args
	 */
	rc = do_go_exec ((void *)addr, argc - 1, argv + 1);
34801ae0:	e2441001 	sub	r1, r4, #1
34801ae4:	e1a00006 	mov	r0, r6
34801ae8:	e1a02005 	mov	r2, r5
34801aec:	ebffffe7 	bl	34801a90 <do_go_exec>
}

int do_go (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, rc;
	int     rcode = 0;
34801af0:	e1a01000 	mov	r1, r0
34801af4:	e2504000 	subs	r4, r0, #0
34801af8:	13a04001 	movne	r4, #1
	 * and all remaining args
	 */
	rc = do_go_exec ((void *)addr, argc - 1, argv + 1);
	if (rc != 0) rcode = 1;

	printf ("## Application terminated, rc = 0x%lX\n", rc);
34801afc:	e59f000c 	ldr	r0, [pc, #12]	; 34801b10 <do_go+0x68>
34801b00:	eb001d97 	bl	34809164 <printf>
	return rcode;
}
34801b04:	e1a00004 	mov	r0, r4
34801b08:	e8bd8070 	pop	{r4, r5, r6, pc}
34801b0c:	34822c59 	.word	0x34822c59
34801b10:	34822c81 	.word	0x34822c81

34801b14 <__fswab32>:
}

static __inline__ __attribute__((const)) __u32 __fswab32(__u32 x)
{
	return __arch__swab32(x);
}
34801b14:	e6bf0f30 	rev	r0, r0
34801b18:	e12fff1e 	bx	lr

34801b1c <do_bootd>:
/*******************************************************************/
/* bootd - boot default image */
/*******************************************************************/
#if defined(CONFIG_CMD_BOOTD)
int do_bootd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34801b1c:	e92d4010 	push	{r4, lr}
	int rcode = 0;

	if (run_command(getenv("bootcmd"), flag) < 0)
34801b20:	e59f0014 	ldr	r0, [pc, #20]	; 34801b3c <do_bootd+0x20>
/*******************************************************************/
/* bootd - boot default image */
/*******************************************************************/
#if defined(CONFIG_CMD_BOOTD)
int do_bootd(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34801b24:	e1a04001 	mov	r4, r1
	int rcode = 0;

	if (run_command(getenv("bootcmd"), flag) < 0)
34801b28:	eb00169f 	bl	348075ac <getenv>
34801b2c:	e1a01004 	mov	r1, r4
34801b30:	eb0030ec 	bl	3480dee8 <run_command>
		rcode = 1;
	return rcode;
}
34801b34:	e1a00fa0 	lsr	r0, r0, #31
34801b38:	e8bd8010 	pop	{r4, pc}
34801b3c:	34822d48 	.word	0x34822d48

34801b40 <do_bootm_rtems>:
static int do_bootm_rtems(int flag, int argc, char * const argv[],
			   bootm_headers_t *images)
{
	void (*entry_point)(bd_t *);

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
34801b40:	e3500080 	cmp	r0, #128	; 0x80
34801b44:	13500000 	cmpne	r0, #0
#endif /* CONFIG_LYNXKDI */

#ifdef CONFIG_BOOTM_RTEMS
static int do_bootm_rtems(int flag, int argc, char * const argv[],
			   bootm_headers_t *images)
{
34801b48:	e92d4010 	push	{r4, lr}
	void (*entry_point)(bd_t *);

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
34801b4c:	1a000007 	bne	34801b70 <do_bootm_rtems+0x30>
		fit_unsupported_reset("RTEMS");
		return 1;
	}
#endif

	entry_point = (void (*)(bd_t *))images->ep;
34801b50:	e5934060 	ldr	r4, [r3, #96]	; 0x60

	printf("## Transferring control to RTEMS (at address %08lx) ...\n",
34801b54:	e59f001c 	ldr	r0, [pc, #28]	; 34801b78 <do_bootm_rtems+0x38>
34801b58:	e1a01004 	mov	r1, r4
34801b5c:	eb001d80 	bl	34809164 <printf>
34801b60:	e3a0000f 	mov	r0, #15
34801b64:	eb002e79 	bl	3480d550 <__show_boot_progress>

	/*
	 * RTEMS Parameters:
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);
34801b68:	e5980000 	ldr	r0, [r8]
34801b6c:	e12fff34 	blx	r4

	return 1;
}
34801b70:	e3a00001 	mov	r0, #1
34801b74:	e8bd8010 	pop	{r4, pc}
34801b78:	34822d50 	.word	0x34822d50

34801b7c <do_bootm_netbsd>:
	image_header_t *os_hdr, *hdr;
	ulong kernel_data, kernel_len;
	char *consdev;
	char *cmdline;

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
34801b7c:	e3500080 	cmp	r0, #128	; 0x80
34801b80:	13500000 	cmpne	r0, #0
/*******************************************************************/

#ifdef CONFIG_BOOTM_NETBSD
static int do_bootm_netbsd(int flag, int argc, char * const argv[],
			    bootm_headers_t *images)
{
34801b84:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
34801b88:	e1a05001 	mov	r5, r1
34801b8c:	e1a07002 	mov	r7, r2
34801b90:	e1a04003 	mov	r4, r3
	image_header_t *os_hdr, *hdr;
	ulong kernel_data, kernel_len;
	char *consdev;
	char *cmdline;

	if ((flag != 0) && (flag != BOOTM_STATE_OS_GO))
34801b94:	03a00000 	moveq	r0, #0
34801b98:	13a00001 	movne	r0, #1
34801b9c:	1a00003e 	bne	34801c9c <do_bootm_netbsd+0x120>
	if (!images->legacy_hdr_valid) {
		fit_unsupported_reset("NetBSD");
		return 1;
	}
#endif
	hdr = images->legacy_hdr_os;
34801ba0:	e5936000 	ldr	r6, [r3]
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */
	os_hdr = NULL;
	if (image_check_type(&images->legacy_hdr_os_copy, IH_TYPE_MULTI)) {
34801ba4:	e5d33022 	ldrb	r3, [r3, #34]	; 0x22
34801ba8:	e3530004 	cmp	r3, #4
	 * kernel.  The only differences are the parameters being passed:
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */
	os_hdr = NULL;
34801bac:	11a06000 	movne	r6, r0
	if (image_check_type(&images->legacy_hdr_os_copy, IH_TYPE_MULTI)) {
34801bb0:	1a000007 	bne	34801bd4 <do_bootm_netbsd+0x58>
		image_multi_getimg(hdr, 1, &kernel_data, &kernel_len);
34801bb4:	e1a00006 	mov	r0, r6
34801bb8:	e28d3008 	add	r3, sp, #8
34801bbc:	e3a01001 	mov	r1, #1
34801bc0:	e28d200c 	add	r2, sp, #12
34801bc4:	eb002bfb 	bl	3480cbb8 <image_multi_getimg>
	 * kernel.  The only differences are the parameters being passed:
	 * besides the board info strucure, the loader expects a command
	 * line, the name of the console device, and (optionally) the
	 * address of the original image header.
	 */
	os_hdr = NULL;
34801bc8:	e59d3008 	ldr	r3, [sp, #8]
34801bcc:	e3530000 	cmp	r3, #0
34801bd0:	03a06000 	moveq	r6, #0
	consdev = "scc2";
#elif defined(CONFIG_8xx_CONS_SCC3)
	consdev = "scc3";
#endif

	if (argc > 2) {
34801bd4:	e3550002 	cmp	r5, #2
34801bd8:	da00001f 	ble	34801c5c <do_bootm_netbsd+0xe0>
/*******************************************************************/
/* OS booting routines */
/*******************************************************************/

#ifdef CONFIG_BOOTM_NETBSD
static int do_bootm_netbsd(int flag, int argc, char * const argv[],
34801bdc:	e287b004 	add	fp, r7, #4
34801be0:	e3a09002 	mov	r9, #2
34801be4:	e3a0a000 	mov	sl, #0
	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
34801be8:	e5bb0004 	ldr	r0, [fp, #4]!
34801bec:	eb006814 	bl	3481bc44 <strlen>

	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
34801bf0:	e2899001 	add	r9, r9, #1
			len += strlen(argv[i]) + 1;
34801bf4:	e080a00a 	add	sl, r0, sl

	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
34801bf8:	e1590005 	cmp	r9, r5
			len += strlen(argv[i]) + 1;
34801bfc:	e28aa001 	add	sl, sl, #1

	if (argc > 2) {
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
34801c00:	bafffff8 	blt	34801be8 <do_bootm_netbsd+0x6c>
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);
34801c04:	e1a0000a 	mov	r0, sl
34801c08:	eb001f1c 	bl	34809880 <malloc>
/*******************************************************************/
/* OS booting routines */
/*******************************************************************/

#ifdef CONFIG_BOOTM_NETBSD
static int do_bootm_netbsd(int flag, int argc, char * const argv[],
34801c0c:	e2877008 	add	r7, r7, #8
		ulong len;
		int   i;

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);
34801c10:	e1a0a000 	mov	sl, r0

		for (i = 2, len = 0; i < argc; i += 1) {
34801c14:	e3a0b002 	mov	fp, #2
34801c18:	e3a09000 	mov	r9, #0
			if (i > 2)
				cmdline[len++] = ' ';
34801c1c:	e3a03020 	mov	r3, #32
34801c20:	ea000002 	b	34801c30 <do_bootm_netbsd+0xb4>
			strcpy(&cmdline[len], argv[i]);
			len += strlen(argv[i]);
34801c24:	e0809009 	add	r9, r0, r9
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);

		for (i = 2, len = 0; i < argc; i += 1) {
			if (i > 2)
				cmdline[len++] = ' ';
34801c28:	e7ca3009 	strb	r3, [sl, r9]
34801c2c:	e2899001 	add	r9, r9, #1
			strcpy(&cmdline[len], argv[i]);
34801c30:	e5971000 	ldr	r1, [r7]
34801c34:	e08a0009 	add	r0, sl, r9
34801c38:	e58d3004 	str	r3, [sp, #4]

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);

		for (i = 2, len = 0; i < argc; i += 1) {
34801c3c:	e28bb001 	add	fp, fp, #1
			if (i > 2)
				cmdline[len++] = ' ';
			strcpy(&cmdline[len], argv[i]);
34801c40:	eb00679a 	bl	3481bab0 <strcpy>
			len += strlen(argv[i]);
34801c44:	e4970004 	ldr	r0, [r7], #4
34801c48:	eb0067fd 	bl	3481bc44 <strlen>

		for (i = 2, len = 0; i < argc; i += 1)
			len += strlen(argv[i]) + 1;
		cmdline = malloc(len);

		for (i = 2, len = 0; i < argc; i += 1) {
34801c4c:	e15b0005 	cmp	fp, r5
34801c50:	e59d3004 	ldr	r3, [sp, #4]
34801c54:	bafffff2 	blt	34801c24 <do_bootm_netbsd+0xa8>
34801c58:	ea000004 	b	34801c70 <do_bootm_netbsd+0xf4>
			if (i > 2)
				cmdline[len++] = ' ';
			strcpy(&cmdline[len], argv[i]);
			len += strlen(argv[i]);
		}
	} else if ((cmdline = getenv("bootargs")) == NULL) {
34801c5c:	e59f0044 	ldr	r0, [pc, #68]	; 34801ca8 <do_bootm_netbsd+0x12c>
34801c60:	eb001651 	bl	348075ac <getenv>
		cmdline = "";
34801c64:	e3500000 	cmp	r0, #0
34801c68:	e59fa03c 	ldr	sl, [pc, #60]	; 34801cac <do_bootm_netbsd+0x130>
34801c6c:	11a0a000 	movne	sl, r0
	}

	loader = (void (*)(bd_t *, image_header_t *, char *, char *))images->ep;
34801c70:	e5944060 	ldr	r4, [r4, #96]	; 0x60

	printf("## Transferring control to NetBSD stage-2 loader "
34801c74:	e59f0034 	ldr	r0, [pc, #52]	; 34801cb0 <do_bootm_netbsd+0x134>
34801c78:	e1a01004 	mov	r1, r4
34801c7c:	eb001d38 	bl	34809164 <printf>
34801c80:	e3a0000f 	mov	r0, #15
34801c84:	eb002e31 	bl	3480d550 <__show_boot_progress>
	 *   r3: ptr to board info data
	 *   r4: image address
	 *   r5: console device
	 *   r6: boot args string
	 */
	(*loader)(gd->bd, os_hdr, consdev, cmdline);
34801c88:	e1a01006 	mov	r1, r6
34801c8c:	e5980000 	ldr	r0, [r8]
34801c90:	e59f2014 	ldr	r2, [pc, #20]	; 34801cac <do_bootm_netbsd+0x130>
34801c94:	e1a0300a 	mov	r3, sl
34801c98:	e12fff34 	blx	r4

	return 1;
}
34801c9c:	e3a00001 	mov	r0, #1
34801ca0:	e28dd010 	add	sp, sp, #16
34801ca4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34801ca8:	348228ce 	.word	0x348228ce
34801cac:	34823cce 	.word	0x34823cce
34801cb0:	34822d89 	.word	0x34822d89

34801cb4 <image_check_magic.clone.9>:
phys_size_t getenv_bootm_size(void);
phys_size_t getenv_bootm_mapsize(void);
void memmove_wd(void *to, void *from, size_t len, ulong chunksz);
#endif

static inline int image_check_magic(const image_header_t *hdr)
34801cb4:	e92d4008 	push	{r3, lr}
#define image_get_hdr_l(f) \
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
34801cb8:	ebffff95 	bl	34801b14 <__fswab32>
#endif

static inline int image_check_magic(const image_header_t *hdr)
{
	return (image_get_magic(hdr) == IH_MAGIC);
}
34801cbc:	e59f300c 	ldr	r3, [pc, #12]	; 34801cd0 <image_check_magic.clone.9+0x1c>
34801cc0:	e1500003 	cmp	r0, r3
34801cc4:	13a00000 	movne	r0, #0
34801cc8:	03a00001 	moveq	r0, #1
34801ccc:	e8bd8008 	pop	{r3, pc}
34801cd0:	27051956 	.word	0x27051956

34801cd4 <image_info>:
	}
	return rcode;
}

static int image_info(ulong addr)
{
34801cd4:	e92d4038 	push	{r3, r4, r5, lr}
34801cd8:	e1a04000 	mov	r4, r0
	void *hdr = (void *)addr;

	printf("\n## Checking Image at %08lx ...\n", addr);
34801cdc:	e1a01004 	mov	r1, r4
34801ce0:	e59f0094 	ldr	r0, [pc, #148]	; 34801d7c <image_info+0xa8>
34801ce4:	eb001d1e 	bl	34809164 <printf>

	switch (genimg_get_format(hdr)) {
34801ce8:	e1a00004 	mov	r0, r4
34801cec:	eb002cc6 	bl	3480d00c <genimg_get_format>
34801cf0:	e3500001 	cmp	r0, #1
34801cf4:	e1a05000 	mov	r5, r0
34801cf8:	1a00001a 	bne	34801d68 <image_info+0x94>
	case IMAGE_FORMAT_LEGACY:
		puts("   Legacy image found\n");
34801cfc:	e59f007c 	ldr	r0, [pc, #124]	; 34801d80 <image_info+0xac>
34801d00:	eb001d0d 	bl	3480913c <puts>
		if (!image_check_magic(hdr)) {
34801d04:	e5940000 	ldr	r0, [r4]
34801d08:	ebffffe9 	bl	34801cb4 <image_check_magic.clone.9>
34801d0c:	e3500000 	cmp	r0, #0
			puts("   Bad Magic Number\n");
34801d10:	059f006c 	ldreq	r0, [pc, #108]	; 34801d84 <image_info+0xb0>
	printf("\n## Checking Image at %08lx ...\n", addr);

	switch (genimg_get_format(hdr)) {
	case IMAGE_FORMAT_LEGACY:
		puts("   Legacy image found\n");
		if (!image_check_magic(hdr)) {
34801d14:	0a000004 	beq	34801d2c <image_info+0x58>
			puts("   Bad Magic Number\n");
			return 1;
		}

		if (!image_check_hcrc(hdr)) {
34801d18:	e1a00004 	mov	r0, r4
34801d1c:	eb002b79 	bl	3480cb08 <image_check_hcrc>
34801d20:	e3500000 	cmp	r0, #0
34801d24:	1a000002 	bne	34801d34 <image_info+0x60>
			puts("   Bad Header Checksum\n");
34801d28:	e59f0058 	ldr	r0, [pc, #88]	; 34801d88 <image_info+0xb4>
34801d2c:	eb001d02 	bl	3480913c <puts>
			return 1;
34801d30:	ea00000f 	b	34801d74 <image_info+0xa0>
		}

		image_print_contents(hdr);
34801d34:	e1a00004 	mov	r0, r4
34801d38:	eb002c2a 	bl	3480cde8 <image_print_contents>

		puts("   Verifying Checksum ... ");
34801d3c:	e59f0048 	ldr	r0, [pc, #72]	; 34801d8c <image_info+0xb8>
34801d40:	eb001cfd 	bl	3480913c <puts>
		if (!image_check_dcrc(hdr)) {
34801d44:	e1a00004 	mov	r0, r4
34801d48:	eb002b82 	bl	3480cb58 <image_check_dcrc>
34801d4c:	e3500000 	cmp	r0, #0
			puts("   Bad Data CRC\n");
34801d50:	059f0038 	ldreq	r0, [pc, #56]	; 34801d90 <image_info+0xbc>
		}

		image_print_contents(hdr);

		puts("   Verifying Checksum ... ");
		if (!image_check_dcrc(hdr)) {
34801d54:	0afffff4 	beq	34801d2c <image_info+0x58>
			puts("   Bad Data CRC\n");
			return 1;
		}
		puts("OK\n");
34801d58:	e59f0034 	ldr	r0, [pc, #52]	; 34801d94 <image_info+0xc0>
34801d5c:	eb001cf6 	bl	3480913c <puts>
		return 0;
34801d60:	e3a05000 	mov	r5, #0
34801d64:	ea000002 	b	34801d74 <image_info+0xa0>
		}

		return 0;
#endif
	default:
		puts("Unknown image format!\n");
34801d68:	e59f0028 	ldr	r0, [pc, #40]	; 34801d98 <image_info+0xc4>
34801d6c:	eb001cf2 	bl	3480913c <puts>
		break;
	}

	return 1;
34801d70:	e3a05001 	mov	r5, #1
}
34801d74:	e1a00005 	mov	r0, r5
34801d78:	e8bd8038 	pop	{r3, r4, r5, pc}
34801d7c:	34822dd2 	.word	0x34822dd2
34801d80:	34822df3 	.word	0x34822df3
34801d84:	34822e0a 	.word	0x34822e0a
34801d88:	34822e1f 	.word	0x34822e1f
34801d8c:	34822e37 	.word	0x34822e37
34801d90:	34822e52 	.word	0x34822e52
34801d94:	34822e63 	.word	0x34822e63
34801d98:	34822e67 	.word	0x34822e67

34801d9c <do_iminfo>:
{
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
34801d9c:	e3520001 	cmp	r2, #1
/*******************************************************************/
/* iminfo - print header info for a requested image */
/*******************************************************************/
#if defined(CONFIG_CMD_IMI)
int do_iminfo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34801da0:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
34801da4:	e1a04002 	mov	r4, r2
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
		return image_info(load_addr);
34801da8:	c1a07003 	movgt	r7, r3
{
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
34801dac:	c3a05000 	movgt	r5, #0
34801db0:	c3a06001 	movgt	r6, #1
34801db4:	ca000003 	bgt	34801dc8 <do_iminfo+0x2c>
		return image_info(load_addr);
34801db8:	e59f3038 	ldr	r3, [pc, #56]	; 34801df8 <do_iminfo+0x5c>
34801dbc:	e5930000 	ldr	r0, [r3]
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info(addr) != 0)
			rcode = 1;
	}
	return rcode;
}
34801dc0:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
	int	arg;
	ulong	addr;
	int	rcode = 0;

	if (argc < 2) {
		return image_info(load_addr);
34801dc4:	eaffffc2 	b	34801cd4 <image_info>
	}

	for (arg = 1; arg < argc; ++arg) {
		addr = simple_strtoul(argv[arg], NULL, 16);
34801dc8:	e3a01000 	mov	r1, #0
34801dcc:	e3a02010 	mov	r2, #16
34801dd0:	e5b70004 	ldr	r0, [r7, #4]!
34801dd4:	eb006b2d 	bl	3481ca90 <simple_strtoul>
		if (image_info(addr) != 0)
34801dd8:	ebffffbd 	bl	34801cd4 <image_info>

	if (argc < 2) {
		return image_info(load_addr);
	}

	for (arg = 1; arg < argc; ++arg) {
34801ddc:	e2866001 	add	r6, r6, #1
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info(addr) != 0)
			rcode = 1;
34801de0:	e3500000 	cmp	r0, #0
34801de4:	13a05001 	movne	r5, #1

	if (argc < 2) {
		return image_info(load_addr);
	}

	for (arg = 1; arg < argc; ++arg) {
34801de8:	e1560004 	cmp	r6, r4
34801dec:	bafffff5 	blt	34801dc8 <do_iminfo+0x2c>
		addr = simple_strtoul(argv[arg], NULL, 16);
		if (image_info(addr) != 0)
			rcode = 1;
	}
	return rcode;
}
34801df0:	e1a00005 	mov	r0, r5
34801df4:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
34801df8:	348284b4 	.word	0x348284b4

34801dfc <image_get_size.clone.10>:
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
34801dfc:	eaffff44 	b	34801b14 <__fswab32>

34801e00 <bootm_load_os.clone.18>:
}

#define BOOTM_ERR_RESET		-1
#define BOOTM_ERR_OVERLAP	-2
#define BOOTM_ERR_UNIMPLEMENTED	-3
static int bootm_load_os(image_info_t os, ulong *load_end, int boot_progress)
34801e00:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
34801e04:	e1a07000 	mov	r7, r0
34801e08:	e5dd0030 	ldrb	r0, [sp, #48]	; 0x30
34801e0c:	e1a09001 	mov	r9, r1
34801e10:	e5dd602c 	ldrb	r6, [sp, #44]	; 0x2c
34801e14:	e1a0a002 	mov	sl, r2
34801e18:	e59d4028 	ldr	r4, [sp, #40]	; 0x28
34801e1c:	e59d5034 	ldr	r5, [sp, #52]	; 0x34
	uint8_t comp = os.comp;
	ulong load = os.load;
	ulong blob_start = os.start;
	ulong blob_end = os.end;
	ulong image_start = os.image_start;
	ulong image_len = os.image_len;
34801e20:	e58d3004 	str	r3, [sp, #4]
	int no_overlap = 0;
#if defined(CONFIG_LZMA) || defined(CONFIG_LZO)
	int ret;
#endif /* defined(CONFIG_LZMA) || defined(CONFIG_LZO) */

	const char *type_name = genimg_get_type_name(os.type);
34801e24:	eb002be3 	bl	3480cdb8 <genimg_get_type_name>

	switch (comp) {
34801e28:	e3560000 	cmp	r6, #0
	int no_overlap = 0;
#if defined(CONFIG_LZMA) || defined(CONFIG_LZO)
	int ret;
#endif /* defined(CONFIG_LZMA) || defined(CONFIG_LZO) */

	const char *type_name = genimg_get_type_name(os.type);
34801e2c:	e1a01000 	mov	r1, r0

	switch (comp) {
34801e30:	0a000002 	beq	34801e40 <bootm_load_os.clone.18+0x40>
34801e34:	e3560001 	cmp	r6, #1
34801e38:	1a00002a 	bne	34801ee8 <bootm_load_os.clone.18+0xe8>
34801e3c:	ea000015 	b	34801e98 <bootm_load_os.clone.18+0x98>
	case IH_COMP_NONE:
		if (load == blob_start || load == image_start) {
34801e40:	e1540007 	cmp	r4, r7
34801e44:	1154000a 	cmpne	r4, sl
34801e48:	13a06000 	movne	r6, #0
34801e4c:	03a06001 	moveq	r6, #1
34801e50:	1a000003 	bne	34801e64 <bootm_load_os.clone.18+0x64>
			printf("   XIP %s ... ", type_name);
34801e54:	e59f00f8 	ldr	r0, [pc, #248]	; 34801f54 <bootm_load_os.clone.18+0x154>
34801e58:	eb001cc1 	bl	34809164 <printf>
			no_overlap = 1;
34801e5c:	e3a06001 	mov	r6, #1
34801e60:	ea000006 	b	34801e80 <bootm_load_os.clone.18+0x80>
		} else {
			printf("   Loading %s ... ", type_name);
34801e64:	e59f00ec 	ldr	r0, [pc, #236]	; 34801f58 <bootm_load_os.clone.18+0x158>
34801e68:	eb001cbd 	bl	34809164 <printf>
			memmove_wd((void *)load, (void *)image_start,
34801e6c:	e1a00004 	mov	r0, r4
34801e70:	e1a0100a 	mov	r1, sl
34801e74:	e59d2004 	ldr	r2, [sp, #4]
34801e78:	e3a03801 	mov	r3, #65536	; 0x10000
34801e7c:	eb002ba7 	bl	3480cd20 <memmove_wd>
					image_len, CHUNKSZ);
		}
		*load_end = load + image_len;
34801e80:	e59d3004 	ldr	r3, [sp, #4]
		puts("OK\n");
34801e84:	e59f00d0 	ldr	r0, [pc, #208]	; 34801f5c <bootm_load_os.clone.18+0x15c>
		} else {
			printf("   Loading %s ... ", type_name);
			memmove_wd((void *)load, (void *)image_start,
					image_len, CHUNKSZ);
		}
		*load_end = load + image_len;
34801e88:	e0843003 	add	r3, r4, r3
34801e8c:	e5853000 	str	r3, [r5]
		puts("OK\n");
34801e90:	eb001ca9 	bl	3480913c <puts>
34801e94:	ea000018 	b	34801efc <bootm_load_os.clone.18+0xfc>
		break;
#ifdef CONFIG_GZIP
	case IH_COMP_GZIP:
		printf("   Uncompressing %s ... ", type_name);
34801e98:	e59f00c0 	ldr	r0, [pc, #192]	; 34801f60 <bootm_load_os.clone.18+0x160>
34801e9c:	eb001cb0 	bl	34809164 <printf>
		if (gunzip((void *)load, unc_len,
34801ea0:	e28d3004 	add	r3, sp, #4
34801ea4:	e1a00004 	mov	r0, r4
34801ea8:	e3a01502 	mov	r1, #8388608	; 0x800000
34801eac:	e1a0200a 	mov	r2, sl
34801eb0:	eb0061eb 	bl	3481a664 <gunzip>
34801eb4:	e2506000 	subs	r6, r0, #0
			if (boot_progress)
				bootstage_error(BOOTSTAGE_ID_DECOMP_IMAGE);
			return BOOTM_ERR_RESET;
		}

		*load_end = load + image_len;
34801eb8:	059d3004 	ldreq	r3, [sp, #4]
34801ebc:	00843003 	addeq	r3, r4, r3
34801ec0:	05853000 	streq	r3, [r5]
		puts("OK\n");
		break;
#ifdef CONFIG_GZIP
	case IH_COMP_GZIP:
		printf("   Uncompressing %s ... ", type_name);
		if (gunzip((void *)load, unc_len,
34801ec4:	0a00000c 	beq	34801efc <bootm_load_os.clone.18+0xfc>
				(uchar *)image_start, &image_len) != 0) {
			puts("GUNZIP: uncompress, out-of-mem or overwrite "
34801ec8:	e59f0094 	ldr	r0, [pc, #148]	; 34801f64 <bootm_load_os.clone.18+0x164>
34801ecc:	eb001c9a 	bl	3480913c <puts>
				"error - must RESET board to recover\n");
			if (boot_progress)
34801ed0:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
34801ed4:	e3530000 	cmp	r3, #0
34801ed8:	0a00001b 	beq	34801f4c <bootm_load_os.clone.18+0x14c>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34801edc:	e3e00005 	mvn	r0, #5
34801ee0:	eb002d9a 	bl	3480d550 <__show_boot_progress>
34801ee4:	ea000018 	b	34801f4c <bootm_load_os.clone.18+0x14c>

		*load_end = load + unc_len;
		break;
#endif /* CONFIG_LZO */
	default:
		printf("Unimplemented compression type %d\n", comp);
34801ee8:	e59f0078 	ldr	r0, [pc, #120]	; 34801f68 <bootm_load_os.clone.18+0x168>
34801eec:	e1a01006 	mov	r1, r6
34801ef0:	eb001c9b 	bl	34809164 <printf>
		return BOOTM_ERR_UNIMPLEMENTED;
34801ef4:	e3e00002 	mvn	r0, #2
34801ef8:	ea000014 	b	34801f50 <bootm_load_os.clone.18+0x150>
	}

	flush_cache(load, (*load_end - load) * sizeof(ulong));
34801efc:	e5951000 	ldr	r1, [r5]
34801f00:	e1a00004 	mov	r0, r4
34801f04:	e0641001 	rsb	r1, r4, r1
34801f08:	e1a01101 	lsl	r1, r1, #2
34801f0c:	ebfff9f7 	bl	348006f0 <flush_cache>

	puts("OK\n");
34801f10:	e59f0044 	ldr	r0, [pc, #68]	; 34801f5c <bootm_load_os.clone.18+0x15c>
34801f14:	eb001c88 	bl	3480913c <puts>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34801f18:	e3a00007 	mov	r0, #7
34801f1c:	eb002d8b 	bl	3480d550 <__show_boot_progress>
	debug("   kernel loaded at 0x%08lx, end = 0x%08lx\n", load, *load_end);
	bootstage_mark(BOOTSTAGE_ID_KERNEL_LOADED);

	if (!no_overlap && (load < blob_end) && (*load_end > blob_start)) {
34801f20:	e2760001 	rsbs	r0, r6, #1
34801f24:	33a00000 	movcc	r0, #0
34801f28:	e1540009 	cmp	r4, r9
34801f2c:	23a00000 	movcs	r0, #0
34801f30:	e3500000 	cmp	r0, #0
34801f34:	0a000005 	beq	34801f50 <bootm_load_os.clone.18+0x150>
34801f38:	e5953000 	ldr	r3, [r5]
34801f3c:	e1530007 	cmp	r3, r7
			*load_end);

		return BOOTM_ERR_OVERLAP;
	}

	return 0;
34801f40:	83e00001 	mvnhi	r0, #1
34801f44:	93a00000 	movls	r0, #0
34801f48:	ea000000 	b	34801f50 <bootm_load_os.clone.18+0x150>
				(uchar *)image_start, &image_len) != 0) {
			puts("GUNZIP: uncompress, out-of-mem or overwrite "
				"error - must RESET board to recover\n");
			if (boot_progress)
				bootstage_error(BOOTSTAGE_ID_DECOMP_IMAGE);
			return BOOTM_ERR_RESET;
34801f4c:	e3e00000 	mvn	r0, #0

		return BOOTM_ERR_OVERLAP;
	}

	return 0;
}
34801f50:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
34801f54:	34822e7e 	.word	0x34822e7e
34801f58:	34822e8d 	.word	0x34822e8d
34801f5c:	34822e63 	.word	0x34822e63
34801f60:	34822ea0 	.word	0x34822ea0
34801f64:	34822eb9 	.word	0x34822eb9
34801f68:	34822f0a 	.word	0x34822f0a

34801f6c <bootm_start.clone.17>:
#else
#define lmb_reserve(lmb, base, size)
static inline void boot_start_lmb(bootm_headers_t *images) { }
#endif

static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
34801f6c:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
{
	void		*os_hdr;
	int		ret;

	memset((void *)&images, 0, sizeof(images));
34801f70:	e59f4358 	ldr	r4, [pc, #856]	; 348022d0 <bootm_start.clone.17+0x364>
#else
#define lmb_reserve(lmb, base, size)
static inline void boot_start_lmb(bootm_headers_t *images) { }
#endif

static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
34801f74:	e1a07001 	mov	r7, r1
34801f78:	e1a0a000 	mov	sl, r0
{
	void		*os_hdr;
	int		ret;

	memset((void *)&images, 0, sizeof(images));
34801f7c:	e3a01000 	mov	r1, #0
34801f80:	e1a00004 	mov	r0, r4
#else
#define lmb_reserve(lmb, base, size)
static inline void boot_start_lmb(bootm_headers_t *images) { }
#endif

static int bootm_start(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
34801f84:	e1a06002 	mov	r6, r2
{
	void		*os_hdr;
	int		ret;

	memset((void *)&images, 0, sizeof(images));
34801f88:	e3a02f4b 	mov	r2, #300	; 0x12c
34801f8c:	eb0067cc 	bl	3481bec4 <memset>
	images.verify = getenv_yesno("verify");
34801f90:	e59f033c 	ldr	r0, [pc, #828]	; 348022d4 <bootm_start.clone.17+0x368>
34801f94:	eb002b28 	bl	3480cc3c <getenv_yesno>
34801f98:	e5840084 	str	r0, [r4, #132]	; 0x84
static void boot_start_lmb(bootm_headers_t *images)
{
	ulong		mem_start;
	phys_size_t	mem_size;

	lmb_init(&images->lmb);
34801f9c:	e284008c 	add	r0, r4, #140	; 0x8c
34801fa0:	eb006589 	bl	3481b5cc <lmb_init>

	mem_start = getenv_bootm_low();
34801fa4:	eb002b2e 	bl	3480cc64 <getenv_bootm_low>
34801fa8:	e1a05000 	mov	r5, r0
	mem_size = getenv_bootm_size();
34801fac:	eb002b38 	bl	3480cc94 <getenv_bootm_size>

	lmb_add(&images->lmb, (phys_addr_t)mem_start, mem_size);
34801fb0:	e1a01005 	mov	r1, r5
	phys_size_t	mem_size;

	lmb_init(&images->lmb);

	mem_start = getenv_bootm_low();
	mem_size = getenv_bootm_size();
34801fb4:	e1a02000 	mov	r2, r0

	lmb_add(&images->lmb, (phys_addr_t)mem_start, mem_size);
34801fb8:	e284008c 	add	r0, r4, #140	; 0x8c
34801fbc:	eb00658c 	bl	3481b5f4 <lmb_add>

	arch_lmb_reserve(&images->lmb);
34801fc0:	e284008c 	add	r0, r4, #140	; 0x8c
34801fc4:	ebfffd40 	bl	348014cc <arch_lmb_reserve>
	board_lmb_reserve(&images->lmb);
34801fc8:	e284008c 	add	r0, r4, #140	; 0x8c
34801fcc:	eb00665d 	bl	3481b948 <__board_lmb_reserve>
	int		cfg_noffset;
	int		os_noffset;
#endif

	/* find out kernel image address */
	if (argc < 2) {
34801fd0:	e3570001 	cmp	r7, #1
		img_addr = load_addr;
34801fd4:	d59f32fc 	ldrle	r3, [pc, #764]	; 348022d8 <bootm_start.clone.17+0x36c>
34801fd8:	d5934000 	ldrle	r4, [r3]
	int		cfg_noffset;
	int		os_noffset;
#endif

	/* find out kernel image address */
	if (argc < 2) {
34801fdc:	da000004 	ble	34801ff4 <bootm_start.clone.17+0x88>
							&fit_uname_kernel)) {
		debug("*  kernel: subimage '%s' from image at 0x%08lx\n",
				fit_uname_kernel, img_addr);
#endif
	} else {
		img_addr = simple_strtoul(argv[1], NULL, 16);
34801fe0:	e5960004 	ldr	r0, [r6, #4]
34801fe4:	e3a01000 	mov	r1, #0
34801fe8:	e3a02010 	mov	r2, #16
34801fec:	eb006aa7 	bl	3481ca90 <simple_strtoul>
34801ff0:	e1a04000 	mov	r4, r0
34801ff4:	e3a00001 	mov	r0, #1
34801ff8:	eb002d54 	bl	3480d550 <__show_boot_progress>
	}

	bootstage_mark(BOOTSTAGE_ID_CHECK_MAGIC);

	/* copy from dataflash if needed */
	img_addr = genimg_get_image(img_addr);
34801ffc:	e1a00004 	mov	r0, r4
34802000:	eb002c07 	bl	3480d024 <genimg_get_image>

	/* check image type, for FIT images get FIT kernel node */
	*os_data = *os_len = 0;
34802004:	e59fb2c4 	ldr	fp, [pc, #708]	; 348022d0 <bootm_start.clone.17+0x364>
34802008:	e3a09000 	mov	r9, #0
3480200c:	e58b9054 	str	r9, [fp, #84]	; 0x54
34802010:	e58b9050 	str	r9, [fp, #80]	; 0x50
	}

	bootstage_mark(BOOTSTAGE_ID_CHECK_MAGIC);

	/* copy from dataflash if needed */
	img_addr = genimg_get_image(img_addr);
34802014:	e1a04000 	mov	r4, r0

	/* check image type, for FIT images get FIT kernel node */
	*os_data = *os_len = 0;
	switch (genimg_get_format((void *)img_addr)) {
34802018:	e1a05000 	mov	r5, r0
3480201c:	eb002bfa 	bl	3480d00c <genimg_get_format>
34802020:	e3500001 	cmp	r0, #1
34802024:	1a00005c 	bne	3480219c <bootm_start.clone.17+0x230>
	case IMAGE_FORMAT_LEGACY:
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
34802028:	e1a01004 	mov	r1, r4
3480202c:	e59f02a8 	ldr	r0, [pc, #680]	; 348022dc <bootm_start.clone.17+0x370>
34802030:	eb001c4b 	bl	34809164 <printf>
 */
static image_header_t *image_get_kernel(ulong img_addr, int verify)
{
	image_header_t *hdr = (image_header_t *)img_addr;

	if (!image_check_magic(hdr)) {
34802034:	e5940000 	ldr	r0, [r4]
34802038:	ebffff1d 	bl	34801cb4 <image_check_magic.clone.9>
3480203c:	e3500000 	cmp	r0, #0
	*os_data = *os_len = 0;
	switch (genimg_get_format((void *)img_addr)) {
	case IMAGE_FORMAT_LEGACY:
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
				img_addr);
		hdr = image_get_kernel(img_addr, images->verify);
34802040:	e59b9084 	ldr	r9, [fp, #132]	; 0x84
 */
static image_header_t *image_get_kernel(ulong img_addr, int verify)
{
	image_header_t *hdr = (image_header_t *)img_addr;

	if (!image_check_magic(hdr)) {
34802044:	1a000003 	bne	34802058 <bootm_start.clone.17+0xec>
		puts("Bad Magic Number\n");
34802048:	e59f0290 	ldr	r0, [pc, #656]	; 348022e0 <bootm_start.clone.17+0x374>
3480204c:	eb001c3a 	bl	3480913c <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802050:	e3e00000 	mvn	r0, #0
34802054:	ea000023 	b	348020e8 <bootm_start.clone.17+0x17c>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802058:	e3a00002 	mov	r0, #2
3480205c:	eb002d3b 	bl	3480d550 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_CHECK_MAGIC);
		return NULL;
	}
	bootstage_mark(BOOTSTAGE_ID_CHECK_HEADER);

	if (!image_check_hcrc(hdr)) {
34802060:	e1a00004 	mov	r0, r4
34802064:	eb002aa7 	bl	3480cb08 <image_check_hcrc>
34802068:	e3500000 	cmp	r0, #0
3480206c:	1a000003 	bne	34802080 <bootm_start.clone.17+0x114>
		puts("Bad Header Checksum\n");
34802070:	e59f026c 	ldr	r0, [pc, #620]	; 348022e4 <bootm_start.clone.17+0x378>
34802074:	eb001c30 	bl	3480913c <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802078:	e3e00001 	mvn	r0, #1
3480207c:	ea000019 	b	348020e8 <bootm_start.clone.17+0x17c>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802080:	e3a00003 	mov	r0, #3
34802084:	eb002d31 	bl	3480d550 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_CHECK_HEADER);
		return NULL;
	}

	bootstage_mark(BOOTSTAGE_ID_CHECK_CHECKSUM);
	image_print_contents(hdr);
34802088:	e1a00004 	mov	r0, r4
3480208c:	eb002b55 	bl	3480cde8 <image_print_contents>

	if (verify) {
34802090:	e3590000 	cmp	r9, #0
34802094:	0a00000b 	beq	348020c8 <bootm_start.clone.17+0x15c>
		puts("   Verifying Checksum ... ");
34802098:	e59f0248 	ldr	r0, [pc, #584]	; 348022e8 <bootm_start.clone.17+0x37c>
3480209c:	eb001c26 	bl	3480913c <puts>
		if (!image_check_dcrc(hdr)) {
348020a0:	e1a00004 	mov	r0, r4
348020a4:	eb002aab 	bl	3480cb58 <image_check_dcrc>
348020a8:	e3500000 	cmp	r0, #0
348020ac:	1a000003 	bne	348020c0 <bootm_start.clone.17+0x154>
			printf("Bad Data CRC\n");
348020b0:	e59f0234 	ldr	r0, [pc, #564]	; 348022ec <bootm_start.clone.17+0x380>
348020b4:	eb001c2a 	bl	34809164 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
348020b8:	e3e00002 	mvn	r0, #2
348020bc:	ea000009 	b	348020e8 <bootm_start.clone.17+0x17c>
			bootstage_error(BOOTSTAGE_ID_CHECK_CHECKSUM);
			return NULL;
		}
		puts("OK\n");
348020c0:	e59f0228 	ldr	r0, [pc, #552]	; 348022f0 <bootm_start.clone.17+0x384>
348020c4:	eb001c1c 	bl	3480913c <puts>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
348020c8:	e3a00004 	mov	r0, #4
348020cc:	eb002d1f 	bl	3480d550 <__show_boot_progress>
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
348020d0:	e5d4101d 	ldrb	r1, [r4, #29]
		}
		puts("OK\n");
	}
	bootstage_mark(BOOTSTAGE_ID_CHECK_ARCH);

	if (!image_check_target_arch(hdr)) {
348020d4:	e3510002 	cmp	r1, #2
348020d8:	0a000005 	beq	348020f4 <bootm_start.clone.17+0x188>
		printf("Unsupported Architecture 0x%x\n", image_get_arch(hdr));
348020dc:	e59f0210 	ldr	r0, [pc, #528]	; 348022f4 <bootm_start.clone.17+0x388>
348020e0:	eb001c1f 	bl	34809164 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
348020e4:	e3e00003 	mvn	r0, #3
348020e8:	eb002d18 	bl	3480d550 <__show_boot_progress>
	case IMAGE_FORMAT_LEGACY:
		printf("## Booting kernel from Legacy Image at %08lx ...\n",
				img_addr);
		hdr = image_get_kernel(img_addr, images->verify);
		if (!hdr)
			return NULL;
348020ec:	e3a05000 	mov	r5, #0
348020f0:	ea00002f 	b	348021b4 <bootm_start.clone.17+0x248>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
348020f4:	e3a00005 	mov	r0, #5
348020f8:	eb002d14 	bl	3480d550 <__show_boot_progress>
		bootstage_mark(BOOTSTAGE_ID_CHECK_IMAGETYPE);

		/* get os_data and os_len */
		switch (image_get_type(hdr)) {
348020fc:	e5d4301e 	ldrb	r3, [r4, #30]
34802100:	e3530002 	cmp	r3, #2
34802104:	0a00000d 	beq	34802140 <bootm_start.clone.17+0x1d4>
34802108:	8a000001 	bhi	34802114 <bootm_start.clone.17+0x1a8>
3480210c:	e3530001 	cmp	r3, #1
34802110:	ea000002 	b	34802120 <bootm_start.clone.17+0x1b4>
34802114:	e3530004 	cmp	r3, #4
34802118:	0a000002 	beq	34802128 <bootm_start.clone.17+0x1bc>
3480211c:	e353000e 	cmp	r3, #14
34802120:	1a00000d 	bne	3480215c <bootm_start.clone.17+0x1f0>
34802124:	ea000005 	b	34802140 <bootm_start.clone.17+0x1d4>
		case IH_TYPE_KERNEL_NOLOAD:
			*os_data = image_get_data(hdr);
			*os_len = image_get_data_size(hdr);
			break;
		case IH_TYPE_MULTI:
			image_multi_getimg(hdr, 0, os_data, os_len);
34802128:	e59f21c8 	ldr	r2, [pc, #456]	; 348022f8 <bootm_start.clone.17+0x38c>
3480212c:	e1a00004 	mov	r0, r4
34802130:	e3a01000 	mov	r1, #0
34802134:	e2823004 	add	r3, r2, #4
34802138:	eb002a9e 	bl	3480cbb8 <image_multi_getimg>
3480213c:	ea00000b 	b	34802170 <bootm_start.clone.17+0x204>
			break;
		case IH_TYPE_STANDALONE:
			*os_data = image_get_data(hdr);
34802140:	e59fa188 	ldr	sl, [pc, #392]	; 348022d0 <bootm_start.clone.17+0x364>
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
34802144:	e2843040 	add	r3, r4, #64	; 0x40
	return (char *)hdr->ih_name;
}

static inline uint32_t image_get_data_size(const image_header_t *hdr)
{
	return image_get_size(hdr);
34802148:	e594000c 	ldr	r0, [r4, #12]
3480214c:	e58a3050 	str	r3, [sl, #80]	; 0x50
34802150:	ebffff29 	bl	34801dfc <image_get_size.clone.10>
			*os_len = image_get_data_size(hdr);
34802154:	e58a0054 	str	r0, [sl, #84]	; 0x54
34802158:	ea000004 	b	34802170 <bootm_start.clone.17+0x204>
			break;
		default:
			printf("Wrong Image Type for %s command\n",
3480215c:	e59f0198 	ldr	r0, [pc, #408]	; 348022fc <bootm_start.clone.17+0x390>
34802160:	e59a1000 	ldr	r1, [sl]
34802164:	eb001bfe 	bl	34809164 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802168:	e3e00004 	mvn	r0, #4
3480216c:	eaffffdd 	b	348020e8 <bootm_start.clone.17+0x17c>

		/*
		 * copy image header to allow for image overwrites during
		 * kernel decompression.
		 */
		memmove(&images->legacy_hdr_os_copy, hdr,
34802170:	e59fa158 	ldr	sl, [pc, #344]	; 348022d0 <bootm_start.clone.17+0x364>
34802174:	e1a01004 	mov	r1, r4
34802178:	e28a0004 	add	r0, sl, #4
3480217c:	e3a02040 	mov	r2, #64	; 0x40
34802180:	eb006790 	bl	3481bfc8 <memmove>
			sizeof(image_header_t));

		/* save pointer to image header */
		images->legacy_hdr_os = hdr;

		images->legacy_hdr_valid = 1;
34802184:	e3a03001 	mov	r3, #1
		 */
		memmove(&images->legacy_hdr_os_copy, hdr,
			sizeof(image_header_t));

		/* save pointer to image header */
		images->legacy_hdr_os = hdr;
34802188:	e58a4000 	str	r4, [sl]

		images->legacy_hdr_valid = 1;
3480218c:	e58a3044 	str	r3, [sl, #68]	; 0x44
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
34802190:	e3a00006 	mov	r0, #6
34802194:	eb002ced 	bl	3480d550 <__show_boot_progress>
34802198:	ea000005 	b	348021b4 <bootm_start.clone.17+0x248>
		images->fit_uname_os = fit_uname_kernel;
		images->fit_noffset_os = os_noffset;
		break;
#endif
	default:
		printf("Wrong Image Format for %s command\n", cmdtp->name);
3480219c:	e59a1000 	ldr	r1, [sl]
348021a0:	e59f0158 	ldr	r0, [pc, #344]	; 34802300 <bootm_start.clone.17+0x394>
348021a4:	eb001bee 	bl	34809164 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
348021a8:	e3e0006b 	mvn	r0, #107	; 0x6b
348021ac:	eb002ce7 	bl	3480d550 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_FIT_KERNEL_INFO);
		return NULL;
348021b0:	e1a05009 	mov	r5, r9
	bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, "bootm_start");

	/* get kernel image header, start address and length */
	os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,
			&images, &images.os.image_start, &images.os.image_len);
	if (images.os.image_len == 0) {
348021b4:	e59f4114 	ldr	r4, [pc, #276]	; 348022d0 <bootm_start.clone.17+0x364>
348021b8:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348021bc:	e3530000 	cmp	r3, #0
		puts("ERROR: can't get kernel image!\n");
348021c0:	059f013c 	ldreq	r0, [pc, #316]	; 34802304 <bootm_start.clone.17+0x398>
	bootstage_mark_name(BOOTSTAGE_ID_BOOTM_START, "bootm_start");

	/* get kernel image header, start address and length */
	os_hdr = boot_get_kernel(cmdtp, flag, argc, argv,
			&images, &images.os.image_start, &images.os.image_len);
	if (images.os.image_len == 0) {
348021c4:	0a000017 	beq	34802228 <bootm_start.clone.17+0x2bc>
		puts("ERROR: can't get kernel image!\n");
		return 1;
	}

	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
348021c8:	e1a00005 	mov	r0, r5
348021cc:	eb002b8e 	bl	3480d00c <genimg_get_format>
348021d0:	e3500001 	cmp	r0, #1
348021d4:	e1a0b000 	mov	fp, r0
			return 1;
		}
		break;
#endif
	default:
		puts("ERROR: unknown image format type!\n");
348021d8:	159f0128 	ldrne	r0, [pc, #296]	; 34802308 <bootm_start.clone.17+0x39c>
		puts("ERROR: can't get kernel image!\n");
		return 1;
	}

	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
348021dc:	1a000011 	bne	34802228 <bootm_start.clone.17+0x2bc>
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
348021e0:	e5d5a01e 	ldrb	sl, [r5, #30]
	}

	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
	case IMAGE_FORMAT_LEGACY:
		images.os.type = image_get_type(os_hdr);
348021e4:	e5c4a05d 	strb	sl, [r4, #93]	; 0x5d
		images.os.comp = image_get_comp(os_hdr);
348021e8:	e5d5301f 	ldrb	r3, [r5, #31]
348021ec:	e5c4305c 	strb	r3, [r4, #92]	; 0x5c
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
348021f0:	e5d5901c 	ldrb	r9, [r5, #28]
	/* get image parameters */
	switch (genimg_get_format(os_hdr)) {
	case IMAGE_FORMAT_LEGACY:
		images.os.type = image_get_type(os_hdr);
		images.os.comp = image_get_comp(os_hdr);
		images.os.os = image_get_os(os_hdr);
348021f4:	e5c4905e 	strb	r9, [r4, #94]	; 0x5e
	return ((ulong)hdr + image_get_header_size());
}

static inline uint32_t image_get_image_size(const image_header_t *hdr)
{
	return (image_get_size(hdr) + image_get_header_size());
348021f8:	e595000c 	ldr	r0, [r5, #12]
348021fc:	ebfffefe 	bl	34801dfc <image_get_size.clone.10>
34802200:	e2853040 	add	r3, r5, #64	; 0x40
}
static inline ulong image_get_image_end(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_image_size(hdr));
34802204:	e0833000 	add	r3, r3, r0

		images.os.end = image_get_image_end(os_hdr);
34802208:	e584304c 	str	r3, [r4, #76]	; 0x4c
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
image_get_hdr_l(load)		/* image_get_load */
3480220c:	e5950010 	ldr	r0, [r5, #16]
34802210:	ebfffe3f 	bl	34801b14 <__fswab32>
		puts("ERROR: unknown image format type!\n");
		return 1;
	}

	/* find kernel entry point */
	if (images.legacy_hdr_valid) {
34802214:	e5943044 	ldr	r3, [r4, #68]	; 0x44
		images.os.type = image_get_type(os_hdr);
		images.os.comp = image_get_comp(os_hdr);
		images.os.os = image_get_os(os_hdr);

		images.os.end = image_get_image_end(os_hdr);
		images.os.load = image_get_load(os_hdr);
34802218:	e5840058 	str	r0, [r4, #88]	; 0x58
		puts("ERROR: unknown image format type!\n");
		return 1;
	}

	/* find kernel entry point */
	if (images.legacy_hdr_valid) {
3480221c:	e3530000 	cmp	r3, #0
34802220:	1a000003 	bne	34802234 <bootm_start.clone.17+0x2c8>
34802224:	ea000008 	b	3480224c <bootm_start.clone.17+0x2e0>
			return 1;
		}
		break;
#endif
	default:
		puts("ERROR: unknown image format type!\n");
34802228:	eb001bc3 	bl	3480913c <puts>
		return 1;
3480222c:	e3a00001 	mov	r0, #1
34802230:	ea000025 	b	348022cc <bootm_start.clone.17+0x360>
image_get_hdr_l(ep)		/* image_get_ep */
34802234:	e5940018 	ldr	r0, [r4, #24]
34802238:	ebfffe35 	bl	34801b14 <__fswab32>
	} else {
		puts("Could not find kernel entry point!\n");
		return 1;
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
3480223c:	e35a000e 	cmp	sl, #14
		return 1;
	}

	/* find kernel entry point */
	if (images.legacy_hdr_valid) {
		images.ep = image_get_ep(&images.legacy_hdr_os_copy);
34802240:	e5840060 	str	r0, [r4, #96]	; 0x60
	} else {
		puts("Could not find kernel entry point!\n");
		return 1;
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
34802244:	1a000008 	bne	3480226c <bootm_start.clone.17+0x300>
34802248:	ea000003 	b	3480225c <bootm_start.clone.17+0x2f0>
			puts("Can't get entry point property!\n");
			return 1;
		}
#endif
	} else {
		puts("Could not find kernel entry point!\n");
3480224c:	e59f00b8 	ldr	r0, [pc, #184]	; 3480230c <bootm_start.clone.17+0x3a0>
34802250:	eb001bb9 	bl	3480913c <puts>
		return 1;
34802254:	e1a0000b 	mov	r0, fp
34802258:	ea00001b 	b	348022cc <bootm_start.clone.17+0x360>
	}

	if (images.os.type == IH_TYPE_KERNEL_NOLOAD) {
		images.os.load = images.os.image_start;
3480225c:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34802260:	e5843058 	str	r3, [r4, #88]	; 0x58
		images.ep += images.os.load;
34802264:	e0803003 	add	r3, r0, r3
34802268:	e5843060 	str	r3, [r4, #96]	; 0x60
	}

	if (((images.os.type == IH_TYPE_KERNEL) ||
3480226c:	e35a0002 	cmp	sl, #2
34802270:	135a000e 	cmpne	sl, #14
34802274:	0a000001 	beq	34802280 <bootm_start.clone.17+0x314>
	     (images.os.type == IH_TYPE_KERNEL_NOLOAD) ||
34802278:	e35a0004 	cmp	sl, #4
3480227c:	1a00000d 	bne	348022b8 <bootm_start.clone.17+0x34c>
	     (images.os.type == IH_TYPE_MULTI)) &&
34802280:	e3590005 	cmp	r9, #5
34802284:	1a00000b 	bne	348022b8 <bootm_start.clone.17+0x34c>
	    (images.os.os == IH_OS_LINUX)) {
		/* find ramdisk */
		ret = boot_get_ramdisk(argc, argv, &images, IH_INITRD_ARCH,
34802288:	e59f3080 	ldr	r3, [pc, #128]	; 34802310 <bootm_start.clone.17+0x3a4>
3480228c:	e1a00007 	mov	r0, r7
34802290:	e58d3000 	str	r3, [sp]
34802294:	e2833004 	add	r3, r3, #4
34802298:	e58d3004 	str	r3, [sp, #4]
3480229c:	e1a01006 	mov	r1, r6
348022a0:	e59f2028 	ldr	r2, [pc, #40]	; 348022d0 <bootm_start.clone.17+0x364>
348022a4:	e3a03002 	mov	r3, #2
348022a8:	eb002b60 	bl	3480d030 <boot_get_ramdisk>
				&images.rd_start, &images.rd_end);
		if (ret) {
348022ac:	e3500000 	cmp	r0, #0
			puts("Ramdisk image is corrupt or invalid\n");
348022b0:	159f005c 	ldrne	r0, [pc, #92]	; 34802314 <bootm_start.clone.17+0x3a8>
	     (images.os.type == IH_TYPE_MULTI)) &&
	    (images.os.os == IH_OS_LINUX)) {
		/* find ramdisk */
		ret = boot_get_ramdisk(argc, argv, &images, IH_INITRD_ARCH,
				&images.rd_start, &images.rd_end);
		if (ret) {
348022b4:	1affffdb 	bne	34802228 <bootm_start.clone.17+0x2bc>

		set_working_fdt_addr(images.ft_addr);
#endif
	}

	images.os.start = (ulong)os_hdr;
348022b8:	e59f3010 	ldr	r3, [pc, #16]	; 348022d0 <bootm_start.clone.17+0x364>
	images.state = BOOTM_STATE_START;
348022bc:	e3a02001 	mov	r2, #1

		set_working_fdt_addr(images.ft_addr);
#endif
	}

	images.os.start = (ulong)os_hdr;
348022c0:	e5835048 	str	r5, [r3, #72]	; 0x48
	images.state = BOOTM_STATE_START;
348022c4:	e5832088 	str	r2, [r3, #136]	; 0x88

	return 0;
348022c8:	e3a00000 	mov	r0, #0
}
348022cc:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
348022d0:	34829908 	.word	0x34829908
348022d4:	34822f2d 	.word	0x34822f2d
348022d8:	348284b4 	.word	0x348284b4
348022dc:	34822f34 	.word	0x34822f34
348022e0:	34822e0d 	.word	0x34822e0d
348022e4:	34822e22 	.word	0x34822e22
348022e8:	34822e37 	.word	0x34822e37
348022ec:	34822e55 	.word	0x34822e55
348022f0:	34822e63 	.word	0x34822e63
348022f4:	34822f66 	.word	0x34822f66
348022f8:	34829958 	.word	0x34829958
348022fc:	34822f85 	.word	0x34822f85
34802300:	34822fa6 	.word	0x34822fa6
34802304:	34822fc9 	.word	0x34822fc9
34802308:	34822fe9 	.word	0x34822fe9
3480230c:	3482300c 	.word	0x3482300c
34802310:	3482996c 	.word	0x3482996c
34802314:	34823030 	.word	0x34823030

34802318 <__arch_preboot_os>:

/* Allow for arch specific config before we boot */
void __arch_preboot_os(void)
{
	/* please define platform specific arch_preboot_os() */
}
34802318:	e12fff1e 	bx	lr

3480231c <do_bootm_subcommand>:
	U_BOOT_CMD_MKENT(go, 0, 1, (void *)BOOTM_STATE_OS_GO, "", ""),
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
3480231c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int ret = 0;
	long state;
	cmd_tbl_t *c;
	boot_os_fn *boot_fn;

	c = find_cmd_tbl(argv[1], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
34802320:	e59f1218 	ldr	r1, [pc, #536]	; 34802540 <do_bootm_subcommand+0x224>
	U_BOOT_CMD_MKENT(go, 0, 1, (void *)BOOTM_STATE_OS_GO, "", ""),
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
34802324:	e24dd030 	sub	sp, sp, #48	; 0x30
34802328:	e1a04000 	mov	r4, r0
3480232c:	e1a05002 	mov	r5, r2
	int ret = 0;
	long state;
	cmd_tbl_t *c;
	boot_os_fn *boot_fn;

	c = find_cmd_tbl(argv[1], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
34802330:	e5930004 	ldr	r0, [r3, #4]
34802334:	e3a02007 	mov	r2, #7
	U_BOOT_CMD_MKENT(go, 0, 1, (void *)BOOTM_STATE_OS_GO, "", ""),
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
34802338:	e1a07003 	mov	r7, r3
	int ret = 0;
	long state;
	cmd_tbl_t *c;
	boot_os_fn *boot_fn;

	c = find_cmd_tbl(argv[1], &cmd_bootm_sub[0], ARRAY_SIZE(cmd_bootm_sub));
3480233c:	e2836004 	add	r6, r3, #4
34802340:	eb0019ff 	bl	34808b44 <find_cmd_tbl>

	if (c) {
34802344:	e3500000 	cmp	r0, #0
34802348:	0a000076 	beq	34802528 <do_bootm_subcommand+0x20c>
		state = (long)c->cmd;
3480234c:	e590a00c 	ldr	sl, [r0, #12]

		/* treat start special since it resets the state machine */
		if (state == BOOTM_STATE_START) {
34802350:	e35a0001 	cmp	sl, #1
34802354:	1a000005 	bne	34802370 <do_bootm_subcommand+0x54>
			argc--;
			argv++;
			return bootm_start(cmdtp, flag, argc, argv);
34802358:	e2451001 	sub	r1, r5, #1
3480235c:	e1a00004 	mov	r0, r4
34802360:	e1a02006 	mov	r2, r6
34802364:	ebffff00 	bl	34801f6c <bootm_start.clone.17>
34802368:	e1a05000 	mov	r5, r0
3480236c:	ea000070 	b	34802534 <do_bootm_subcommand+0x218>
	} else {
		/* Unrecognized command */
		return CMD_RET_USAGE;
	}

	if (images.state >= state) {
34802370:	e59f41cc 	ldr	r4, [pc, #460]	; 34802544 <do_bootm_subcommand+0x228>
34802374:	e5943088 	ldr	r3, [r4, #136]	; 0x88
34802378:	e153000a 	cmp	r3, sl
3480237c:	ba000002 	blt	3480238c <do_bootm_subcommand+0x70>
		printf("Trying to execute a command out of order\n");
34802380:	e59f01c0 	ldr	r0, [pc, #448]	; 34802548 <do_bootm_subcommand+0x22c>
34802384:	eb001b76 	bl	34809164 <printf>
34802388:	ea000066 	b	34802528 <do_bootm_subcommand+0x20c>
		return CMD_RET_USAGE;
	}

	images.state |= state;
3480238c:	e18a3003 	orr	r3, sl, r3
34802390:	e5843088 	str	r3, [r4, #136]	; 0x88
	boot_fn = boot_os[images.os.os];
34802394:	e5d4205e 	ldrb	r2, [r4, #94]	; 0x5e
34802398:	e59f31ac 	ldr	r3, [pc, #428]	; 3480254c <do_bootm_subcommand+0x230>

	switch (state) {
3480239c:	e35a0010 	cmp	sl, #16
		printf("Trying to execute a command out of order\n");
		return CMD_RET_USAGE;
	}

	images.state |= state;
	boot_fn = boot_os[images.os.os];
348023a0:	e7936102 	ldr	r6, [r3, r2, lsl #2]

	switch (state) {
348023a4:	0a00003b 	beq	34802498 <do_bootm_subcommand+0x17c>
348023a8:	ca000004 	bgt	348023c0 <do_bootm_subcommand+0xa4>
348023ac:	e35a0002 	cmp	sl, #2
348023b0:	0a000009 	beq	348023dc <do_bootm_subcommand+0xc0>
348023b4:	e35a0004 	cmp	sl, #4
348023b8:	1a00005c 	bne	34802530 <do_bootm_subcommand+0x214>
348023bc:	ea00001b 	b	34802430 <do_bootm_subcommand+0x114>
348023c0:	e35a0040 	cmp	sl, #64	; 0x40
348023c4:	0a000045 	beq	348024e0 <do_bootm_subcommand+0x1c4>
348023c8:	e35a0080 	cmp	sl, #128	; 0x80
348023cc:	0a00004d 	beq	34802508 <do_bootm_subcommand+0x1ec>
348023d0:	e35a0020 	cmp	sl, #32
348023d4:	1a000055 	bne	34802530 <do_bootm_subcommand+0x214>
348023d8:	ea000037 	b	348024bc <do_bootm_subcommand+0x1a0>
		ulong load_end;
		case BOOTM_STATE_START:
			/* should never occur */
			break;
		case BOOTM_STATE_LOADOS:
			ret = bootm_load_os(images.os, &load_end, 0);
348023dc:	e5943058 	ldr	r3, [r4, #88]	; 0x58
348023e0:	e58d3000 	str	r3, [sp]
348023e4:	e5d4305c 	ldrb	r3, [r4, #92]	; 0x5c
348023e8:	e58d3004 	str	r3, [sp, #4]
348023ec:	e5d4305d 	ldrb	r3, [r4, #93]	; 0x5d
348023f0:	e58d3008 	str	r3, [sp, #8]
348023f4:	e28d302c 	add	r3, sp, #44	; 0x2c
348023f8:	e58d300c 	str	r3, [sp, #12]
348023fc:	e3a03000 	mov	r3, #0
34802400:	e58d3010 	str	r3, [sp, #16]
34802404:	e2840048 	add	r0, r4, #72	; 0x48
34802408:	e890000f 	ldm	r0, {r0, r1, r2, r3}
3480240c:	ebfffe7b 	bl	34801e00 <bootm_load_os.clone.18>
			if (ret)
34802410:	e2505000 	subs	r5, r0, #0
34802414:	1a000046 	bne	34802534 <do_bootm_subcommand+0x218>
				return ret;

			lmb_reserve(&images.lmb, images.os.load,
					(load_end - images.os.load));
34802418:	e5941058 	ldr	r1, [r4, #88]	; 0x58
		case BOOTM_STATE_LOADOS:
			ret = bootm_load_os(images.os, &load_end, 0);
			if (ret)
				return ret;

			lmb_reserve(&images.lmb, images.os.load,
3480241c:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
34802420:	e284008c 	add	r0, r4, #140	; 0x8c
34802424:	e0612002 	rsb	r2, r1, r2
34802428:	eb0064bc 	bl	3481b720 <lmb_reserve>
					(load_end - images.os.load));
			break;
3480242c:	ea000040 	b	34802534 <do_bootm_subcommand+0x218>
#ifdef CONFIG_SYS_BOOT_RAMDISK_HIGH
		case BOOTM_STATE_RAMDISK:
		{
			ulong rd_len = images.rd_end - images.rd_start;
34802430:	e5941064 	ldr	r1, [r4, #100]	; 0x64
34802434:	e5942068 	ldr	r2, [r4, #104]	; 0x68
			char str[17];

			ret = boot_ramdisk_high(&images.lmb, images.rd_start,
34802438:	e2843074 	add	r3, r4, #116	; 0x74
3480243c:	e58d3000 	str	r3, [sp]
34802440:	e284008c 	add	r0, r4, #140	; 0x8c
34802444:	e0612002 	rsb	r2, r1, r2
34802448:	e2843070 	add	r3, r4, #112	; 0x70
3480244c:	eb002b83 	bl	3480d260 <boot_ramdisk_high>
				rd_len, &images.initrd_start, &images.initrd_end);
			if (ret)
34802450:	e2505000 	subs	r5, r0, #0
34802454:	1a000036 	bne	34802534 <do_bootm_subcommand+0x218>
				return ret;

			sprintf(str, "%lx", images.initrd_start);
34802458:	e28d6018 	add	r6, sp, #24
3480245c:	e5942070 	ldr	r2, [r4, #112]	; 0x70
34802460:	e1a00006 	mov	r0, r6
34802464:	e59f10e4 	ldr	r1, [pc, #228]	; 34802550 <do_bootm_subcommand+0x234>
34802468:	eb006a2e 	bl	3481cd28 <sprintf>
			setenv("initrd_start", str);
3480246c:	e1a01006 	mov	r1, r6
34802470:	e59f00dc 	ldr	r0, [pc, #220]	; 34802554 <do_bootm_subcommand+0x238>
34802474:	eb001344 	bl	3480718c <setenv>
			sprintf(str, "%lx", images.initrd_end);
34802478:	e1a00006 	mov	r0, r6
3480247c:	e59f10cc 	ldr	r1, [pc, #204]	; 34802550 <do_bootm_subcommand+0x234>
34802480:	e5942074 	ldr	r2, [r4, #116]	; 0x74
34802484:	eb006a27 	bl	3481cd28 <sprintf>
			setenv("initrd_end", str);
34802488:	e1a01006 	mov	r1, r6
3480248c:	e59f00c4 	ldr	r0, [pc, #196]	; 34802558 <do_bootm_subcommand+0x23c>
34802490:	eb00133d 	bl	3480718c <setenv>
		}
			break;
34802494:	ea000026 	b	34802534 <do_bootm_subcommand+0x218>
				&images.ft_addr, &images.ft_len);
			break;
		}
#endif
		case BOOTM_STATE_OS_CMDLINE:
			ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, &images);
34802498:	e1a01005 	mov	r1, r5
3480249c:	e1a0000a 	mov	r0, sl
348024a0:	e1a02007 	mov	r2, r7
348024a4:	e1a03004 	mov	r3, r4
348024a8:	e12fff36 	blx	r6
			if (ret)
348024ac:	e2505000 	subs	r5, r0, #0
				printf("cmdline subcommand not supported\n");
348024b0:	159f00a4 	ldrne	r0, [pc, #164]	; 3480255c <do_bootm_subcommand+0x240>
			break;
		}
#endif
		case BOOTM_STATE_OS_CMDLINE:
			ret = boot_fn(BOOTM_STATE_OS_CMDLINE, argc, argv, &images);
			if (ret)
348024b4:	0a00001e 	beq	34802534 <do_bootm_subcommand+0x218>
348024b8:	ea000010 	b	34802500 <do_bootm_subcommand+0x1e4>
				printf("cmdline subcommand not supported\n");
			break;
		case BOOTM_STATE_OS_BD_T:
			ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, &images);
348024bc:	e1a01005 	mov	r1, r5
348024c0:	e1a0000a 	mov	r0, sl
348024c4:	e1a02007 	mov	r2, r7
348024c8:	e1a03004 	mov	r3, r4
348024cc:	e12fff36 	blx	r6
			if (ret)
348024d0:	e2505000 	subs	r5, r0, #0
				printf("bdt subcommand not supported\n");
348024d4:	159f0084 	ldrne	r0, [pc, #132]	; 34802560 <do_bootm_subcommand+0x244>
			if (ret)
				printf("cmdline subcommand not supported\n");
			break;
		case BOOTM_STATE_OS_BD_T:
			ret = boot_fn(BOOTM_STATE_OS_BD_T, argc, argv, &images);
			if (ret)
348024d8:	0a000015 	beq	34802534 <do_bootm_subcommand+0x218>
348024dc:	ea000007 	b	34802500 <do_bootm_subcommand+0x1e4>
				printf("bdt subcommand not supported\n");
			break;
		case BOOTM_STATE_OS_PREP:
			ret = boot_fn(BOOTM_STATE_OS_PREP, argc, argv, &images);
348024e0:	e1a01005 	mov	r1, r5
348024e4:	e1a0000a 	mov	r0, sl
348024e8:	e1a02007 	mov	r2, r7
348024ec:	e1a03004 	mov	r3, r4
348024f0:	e12fff36 	blx	r6
			if (ret)
348024f4:	e2505000 	subs	r5, r0, #0
348024f8:	0a00000d 	beq	34802534 <do_bootm_subcommand+0x218>
				printf("prep subcommand not supported\n");
348024fc:	e59f0060 	ldr	r0, [pc, #96]	; 34802564 <do_bootm_subcommand+0x248>
34802500:	eb001b17 	bl	34809164 <printf>
34802504:	ea00000a 	b	34802534 <do_bootm_subcommand+0x218>
			break;
		case BOOTM_STATE_OS_GO:
			disable_interrupts();
34802508:	ebfffc16 	bl	34801568 <disable_interrupts>
			 * Stop the ethernet stack if NetConsole could have
			 * left it up
			 */
			eth_halt();
#endif
			arch_preboot_os();
3480250c:	ebffff81 	bl	34802318 <__arch_preboot_os>
			boot_fn(BOOTM_STATE_OS_GO, argc, argv, &images);
34802510:	e1a0000a 	mov	r0, sl
34802514:	e1a01005 	mov	r1, r5
34802518:	e1a02007 	mov	r2, r7
3480251c:	e1a03004 	mov	r3, r4
34802520:	e12fff36 	blx	r6
34802524:	ea000001 	b	34802530 <do_bootm_subcommand+0x214>
			argv++;
			return bootm_start(cmdtp, flag, argc, argv);
		}
	} else {
		/* Unrecognized command */
		return CMD_RET_USAGE;
34802528:	e3e05000 	mvn	r5, #0
3480252c:	ea000000 	b	34802534 <do_bootm_subcommand+0x218>
};

int do_bootm_subcommand(cmd_tbl_t *cmdtp, int flag, int argc,
			char * const argv[])
{
	int ret = 0;
34802530:	e3a05000 	mov	r5, #0
			boot_fn(BOOTM_STATE_OS_GO, argc, argv, &images);
			break;
	}

	return ret;
}
34802534:	e1a00005 	mov	r0, r5
34802538:	e28dd030 	add	sp, sp, #48	; 0x30
3480253c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34802540:	34828324 	.word	0x34828324
34802544:	34829908 	.word	0x34829908
34802548:	34823055 	.word	0x34823055
3480254c:	348200e8 	.word	0x348200e8
34802550:	3482307f 	.word	0x3482307f
34802554:	34823083 	.word	0x34823083
34802558:	34823090 	.word	0x34823090
3480255c:	3482309b 	.word	0x3482309b
34802560:	348230bd 	.word	0x348230bd
34802564:	348230db 	.word	0x348230db

34802568 <do_bootm>:
/*******************************************************************/
/* bootm - boot application image from image in memory */
/*******************************************************************/

int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802568:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
		relocated = 1;
	}
#endif

	/* determine if we have a sub command */
	if (argc > 1) {
3480256c:	e3520001 	cmp	r2, #1
/*******************************************************************/
/* bootm - boot application image from image in memory */
/*******************************************************************/

int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802570:	e24dd040 	sub	sp, sp, #64	; 0x40
34802574:	e1a05003 	mov	r5, r3
	ulong		iflag;
	ulong		load_end = 0;
34802578:	e3a03000 	mov	r3, #0
/*******************************************************************/
/* bootm - boot application image from image in memory */
/*******************************************************************/

int do_bootm(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480257c:	e1a07000 	mov	r7, r0
34802580:	e1a09001 	mov	r9, r1
34802584:	e1a06002 	mov	r6, r2
	ulong		iflag;
	ulong		load_end = 0;
34802588:	e58d303c 	str	r3, [sp, #60]	; 0x3c
		relocated = 1;
	}
#endif

	/* determine if we have a sub command */
	if (argc > 1) {
3480258c:	da000010 	ble	348025d4 <do_bootm+0x6c>
		char *endp;

		simple_strtoul(argv[1], &endp, 16);
34802590:	e5950004 	ldr	r0, [r5, #4]
34802594:	e28d1038 	add	r1, sp, #56	; 0x38
34802598:	e3a02010 	mov	r2, #16
3480259c:	eb00693b 	bl	3481ca90 <simple_strtoul>
		 * If endp is ':' or '#' assume a FIT identifier so pass
		 * along for normal processing.
		 *
		 * Right now we assume the first arg should never be '-'
		 */
		if ((*endp != 0) && (*endp != ':') && (*endp != '#'))
348025a0:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
348025a4:	e5d33000 	ldrb	r3, [r3]
348025a8:	e353003a 	cmp	r3, #58	; 0x3a
348025ac:	13530000 	cmpne	r3, #0
348025b0:	0a000007 	beq	348025d4 <do_bootm+0x6c>
348025b4:	e3530023 	cmp	r3, #35	; 0x23
348025b8:	0a000005 	beq	348025d4 <do_bootm+0x6c>
			return do_bootm_subcommand(cmdtp, flag, argc, argv);
348025bc:	e1a00007 	mov	r0, r7
348025c0:	e1a01009 	mov	r1, r9
348025c4:	e1a02006 	mov	r2, r6
348025c8:	e1a03005 	mov	r3, r5
348025cc:	ebffff52 	bl	3480231c <do_bootm_subcommand>
348025d0:	ea00007f 	b	348027d4 <do_bootm+0x26c>
	}

	if (bootm_start(cmdtp, flag, argc, argv))
348025d4:	e1a00007 	mov	r0, r7
348025d8:	e1a01006 	mov	r1, r6
348025dc:	e1a02005 	mov	r2, r5
348025e0:	ebfffe61 	bl	34801f6c <bootm_start.clone.17>
348025e4:	e3500000 	cmp	r0, #0
348025e8:	1a000078 	bne	348027d0 <do_bootm+0x268>
	/*
	 * We have reached the point of no return: we are going to
	 * overwrite all exception vector code, so we cannot easily
	 * recover from any failures any more...
	 */
	iflag = disable_interrupts();
348025ec:	ebfffbdd 	bl	34801568 <disable_interrupts>
	 *   r3: ptr to board info data
	 */
	(*entry_point)(gd->bd);

	return 1;
}
348025f0:	e59f41e4 	ldr	r4, [pc, #484]	; 348027dc <do_bootm+0x274>
	/*
	 * We have reached the point of no return: we are going to
	 * overwrite all exception vector code, so we cannot easily
	 * recover from any failures any more...
	 */
	iflag = disable_interrupts();
348025f4:	e1a0b000 	mov	fp, r0
	 * details see the OpenHCI specification.
	 */
	usb_stop();
#endif

	ret = bootm_load_os(images.os, &load_end, 1);
348025f8:	e5943058 	ldr	r3, [r4, #88]	; 0x58
348025fc:	e58d3000 	str	r3, [sp]
34802600:	e5d4305c 	ldrb	r3, [r4, #92]	; 0x5c
34802604:	e58d3004 	str	r3, [sp, #4]
34802608:	e5d4305d 	ldrb	r3, [r4, #93]	; 0x5d
3480260c:	e58d3008 	str	r3, [sp, #8]
34802610:	e28d303c 	add	r3, sp, #60	; 0x3c
34802614:	e58d300c 	str	r3, [sp, #12]
34802618:	e3a03001 	mov	r3, #1
3480261c:	e58d3010 	str	r3, [sp, #16]
34802620:	e2840048 	add	r0, r4, #72	; 0x48
34802624:	e890000f 	ldm	r0, {r0, r1, r2, r3}
34802628:	ebfffdf4 	bl	34801e00 <bootm_load_os.clone.18>

	if (ret < 0) {
3480262c:	e3500000 	cmp	r0, #0
34802630:	aa00001d 	bge	348026ac <do_bootm+0x144>
		if (ret == BOOTM_ERR_RESET)
34802634:	e3700001 	cmn	r0, #1
34802638:	0a00000e 	beq	34802678 <do_bootm+0x110>
			do_reset(cmdtp, flag, argc, argv);
		if (ret == BOOTM_ERR_OVERLAP) {
3480263c:	e3700002 	cmn	r0, #2
34802640:	1a000012 	bne	34802690 <do_bootm+0x128>
			if (images.legacy_hdr_valid) {
34802644:	e5943044 	ldr	r3, [r4, #68]	; 0x44
34802648:	e3530000 	cmp	r3, #0
3480264c:	0a000005 	beq	34802668 <do_bootm+0x100>
				image_header_t *hdr;
				hdr = &images.legacy_hdr_os_copy;
				if (image_get_type(hdr) == IH_TYPE_MULTI)
34802650:	e5d43022 	ldrb	r3, [r4, #34]	; 0x22
34802654:	e3530004 	cmp	r3, #4
34802658:	1a000013 	bne	348026ac <do_bootm+0x144>
					puts("WARNING: legacy format multi "
3480265c:	e59f017c 	ldr	r0, [pc, #380]	; 348027e0 <do_bootm+0x278>
34802660:	eb001ab5 	bl	3480913c <puts>
34802664:	ea000010 	b	348026ac <do_bootm+0x144>
						"component image "
						"overwritten\n");
			} else {
				puts("ERROR: new format image overwritten - "
34802668:	e59f0174 	ldr	r0, [pc, #372]	; 348027e4 <do_bootm+0x27c>
3480266c:	eb001ab2 	bl	3480913c <puts>
34802670:	e3e00070 	mvn	r0, #112	; 0x70
34802674:	eb002bb5 	bl	3480d550 <__show_boot_progress>
					"must RESET the board to recover\n");
				bootstage_error(BOOTSTAGE_ID_OVERWRITTEN);
				do_reset(cmdtp, flag, argc, argv);
34802678:	e1a00007 	mov	r0, r7
3480267c:	e1a01009 	mov	r1, r9
34802680:	e1a02006 	mov	r2, r6
34802684:	e1a03005 	mov	r3, r5
34802688:	ebfffc4b 	bl	348017bc <do_reset>
3480268c:	ea000006 	b	348026ac <do_bootm+0x144>
			}
		}
		if (ret == BOOTM_ERR_UNIMPLEMENTED) {
34802690:	e3700003 	cmn	r0, #3
34802694:	1a000004 	bne	348026ac <do_bootm+0x144>
			if (iflag)
34802698:	e35b0000 	cmp	fp, #0
3480269c:	0a000000 	beq	348026a4 <do_bootm+0x13c>
				enable_interrupts();
348026a0:	ebfffbaf 	bl	34801564 <enable_interrupts>
348026a4:	e3e00006 	mvn	r0, #6
348026a8:	ea000039 	b	34802794 <do_bootm+0x22c>
			bootstage_error(BOOTSTAGE_ID_DECOMP_UNIMPL);
			return 1;
		}
	}

	lmb_reserve(&images.lmb, images.os.load, (load_end - images.os.load));
348026ac:	e59fa128 	ldr	sl, [pc, #296]	; 348027dc <do_bootm+0x274>
348026b0:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
348026b4:	e59a1058 	ldr	r1, [sl, #88]	; 0x58
348026b8:	e28a008c 	add	r0, sl, #140	; 0x8c
348026bc:	e0612002 	rsb	r2, r1, r2
348026c0:	eb006416 	bl	3481b720 <lmb_reserve>

	if (images.os.type == IH_TYPE_STANDALONE) {
348026c4:	e5da305d 	ldrb	r3, [sl, #93]	; 0x5d
348026c8:	e3530001 	cmp	r3, #1
348026cc:	1a00001e 	bne	3480274c <do_bootm+0x1e4>
		if (iflag)
348026d0:	e35b0000 	cmp	fp, #0
348026d4:	0a000000 	beq	348026dc <do_bootm+0x174>
			enable_interrupts();
348026d8:	ebfffba1 	bl	34801564 <enable_interrupts>
{
	char  *s;
	int   (*appl)(int, char * const []);

	/* Don't start if "autostart" is set to "no" */
	if (((s = getenv("autostart")) != NULL) && (strcmp(s, "no") == 0)) {
348026dc:	e59f0104 	ldr	r0, [pc, #260]	; 348027e8 <do_bootm+0x280>
348026e0:	eb0013b1 	bl	348075ac <getenv>
348026e4:	e3500000 	cmp	r0, #0
348026e8:	0a00000e 	beq	34802728 <do_bootm+0x1c0>
348026ec:	e59f10f8 	ldr	r1, [pc, #248]	; 348027ec <do_bootm+0x284>
348026f0:	eb00651f 	bl	3481bb74 <strcmp>
348026f4:	e2507000 	subs	r7, r0, #0
348026f8:	1a00000a 	bne	34802728 <do_bootm+0x1c0>
		char buf[32];
		sprintf(buf, "%lX", images.os.image_len);
348026fc:	e59f30d8 	ldr	r3, [pc, #216]	; 348027dc <do_bootm+0x274>
34802700:	e28d4018 	add	r4, sp, #24
34802704:	e59f10e4 	ldr	r1, [pc, #228]	; 348027f0 <do_bootm+0x288>
34802708:	e5932054 	ldr	r2, [r3, #84]	; 0x54
3480270c:	e1a00004 	mov	r0, r4
34802710:	eb006984 	bl	3481cd28 <sprintf>
		setenv("filesize", buf);
34802714:	e59f00d8 	ldr	r0, [pc, #216]	; 348027f4 <do_bootm+0x28c>
34802718:	e1a01004 	mov	r1, r4
3480271c:	eb00129a 	bl	3480718c <setenv>
	if (images.os.type == IH_TYPE_STANDALONE) {
		if (iflag)
			enable_interrupts();
		/* This may return when 'autostart' is 'no' */
		bootm_start_standalone(iflag, argc, argv);
		return 0;
34802720:	e1a00007 	mov	r0, r7
34802724:	ea00002a 	b	348027d4 <do_bootm+0x26c>
		char buf[32];
		sprintf(buf, "%lX", images.os.image_len);
		setenv("filesize", buf);
		return 0;
	}
	appl = (int (*)(int, char * const []))(ulong)ntohl(images.ep);
34802728:	e59f30ac 	ldr	r3, [pc, #172]	; 348027dc <do_bootm+0x274>
3480272c:	e5930060 	ldr	r0, [r3, #96]	; 0x60
34802730:	ebfffcf7 	bl	34801b14 <__fswab32>
	(*appl)(argc-1, &argv[1]);
34802734:	e2851004 	add	r1, r5, #4
		char buf[32];
		sprintf(buf, "%lX", images.os.image_len);
		setenv("filesize", buf);
		return 0;
	}
	appl = (int (*)(int, char * const []))(ulong)ntohl(images.ep);
34802738:	e1a03000 	mov	r3, r0
	(*appl)(argc-1, &argv[1]);
3480273c:	e2460001 	sub	r0, r6, #1
34802740:	e12fff33 	blx	r3
	if (images.os.type == IH_TYPE_STANDALONE) {
		if (iflag)
			enable_interrupts();
		/* This may return when 'autostart' is 'no' */
		bootm_start_standalone(iflag, argc, argv);
		return 0;
34802744:	e3a00000 	mov	r0, #0
34802748:	ea000021 	b	348027d4 <do_bootm+0x26c>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480274c:	e3a00008 	mov	r0, #8
34802750:	eb002b7e 	bl	3480d550 <__show_boot_progress>
#ifdef CONFIG_SILENT_CONSOLE
	if (images.os.os == IH_OS_LINUX)
		fixup_silent_linux();
#endif

	boot_fn = boot_os[images.os.os];
34802754:	e5da205e 	ldrb	r2, [sl, #94]	; 0x5e
34802758:	e59f3098 	ldr	r3, [pc, #152]	; 348027f8 <do_bootm+0x290>
3480275c:	e7934102 	ldr	r4, [r3, r2, lsl #2]

	if (boot_fn == NULL) {
34802760:	e3540000 	cmp	r4, #0
34802764:	1a00000c 	bne	3480279c <do_bootm+0x234>
		if (iflag)
34802768:	e35b0000 	cmp	fp, #0
3480276c:	0a000000 	beq	34802774 <do_bootm+0x20c>
			enable_interrupts();
34802770:	ebfffb7b 	bl	34801564 <enable_interrupts>
		printf("ERROR: booting os '%s' (%d) is not supported\n",
34802774:	e59f4060 	ldr	r4, [pc, #96]	; 348027dc <do_bootm+0x274>
34802778:	e5d4005e 	ldrb	r0, [r4, #94]	; 0x5e
3480277c:	eb002981 	bl	3480cd88 <genimg_get_os_name>
34802780:	e5d4205e 	ldrb	r2, [r4, #94]	; 0x5e
34802784:	e1a01000 	mov	r1, r0
34802788:	e59f006c 	ldr	r0, [pc, #108]	; 348027fc <do_bootm+0x294>
3480278c:	eb001a74 	bl	34809164 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
34802790:	e3e00007 	mvn	r0, #7
34802794:	eb002b6d 	bl	3480d550 <__show_boot_progress>
34802798:	ea00000c 	b	348027d0 <do_bootm+0x268>
			genimg_get_os_name(images.os.os), images.os.os);
		bootstage_error(BOOTSTAGE_ID_CHECK_BOOT_OS);
		return 1;
	}

	arch_preboot_os();
3480279c:	ebfffedd 	bl	34802318 <__arch_preboot_os>

	boot_fn(0, argc, argv, &images);
348027a0:	e1a01006 	mov	r1, r6
348027a4:	e1a02005 	mov	r2, r5
348027a8:	e1a0300a 	mov	r3, sl
348027ac:	e3a00000 	mov	r0, #0
348027b0:	e12fff34 	blx	r4
348027b4:	e3e00008 	mvn	r0, #8
348027b8:	eb002b64 	bl	3480d550 <__show_boot_progress>

	bootstage_error(BOOTSTAGE_ID_BOOT_OS_RETURNED);
#ifdef DEBUG
	puts("\n## Control returned to monitor - resetting...\n");
#endif
	do_reset(cmdtp, flag, argc, argv);
348027bc:	e1a00007 	mov	r0, r7
348027c0:	e1a01009 	mov	r1, r9
348027c4:	e1a02006 	mov	r2, r6
348027c8:	e1a03005 	mov	r3, r5
348027cc:	ebfffbfa 	bl	348017bc <do_reset>
		if ((*endp != 0) && (*endp != ':') && (*endp != '#'))
			return do_bootm_subcommand(cmdtp, flag, argc, argv);
	}

	if (bootm_start(cmdtp, flag, argc, argv))
		return 1;
348027d0:	e3a00001 	mov	r0, #1
	puts("\n## Control returned to monitor - resetting...\n");
#endif
	do_reset(cmdtp, flag, argc, argv);

	return 1;
}
348027d4:	e28dd040 	add	sp, sp, #64	; 0x40
348027d8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348027dc:	34829908 	.word	0x34829908
348027e0:	348230fa 	.word	0x348230fa
348027e4:	34823134 	.word	0x34823134
348027e8:	3482317b 	.word	0x3482317b
348027ec:	34823185 	.word	0x34823185
348027f0:	34823188 	.word	0x34823188
348027f4:	3482318c 	.word	0x3482318c
348027f8:	348200e8 	.word	0x348200e8
348027fc:	34823195 	.word	0x34823195

34802800 <bootm_maybe_autostart>:

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
34802800:	e92d4073 	push	{r0, r1, r4, r5, r6, lr}
34802804:	e1a05000 	mov	r5, r0
	const char *ep = getenv("autostart");
34802808:	e59f0054 	ldr	r0, [pc, #84]	; 34802864 <bootm_maybe_autostart+0x64>

	return 1;
}

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
3480280c:	e1a06001 	mov	r6, r1
	const char *ep = getenv("autostart");
34802810:	eb001365 	bl	348075ac <getenv>

	if (ep && !strcmp(ep, "yes")) {
34802814:	e2503000 	subs	r3, r0, #0
		local_args[1] = NULL;
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
		return do_bootm(cmdtp, 0, 1, local_args);
	}

	return 0;
34802818:	01a00003 	moveq	r0, r3

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
	const char *ep = getenv("autostart");

	if (ep && !strcmp(ep, "yes")) {
3480281c:	0a00000f 	beq	34802860 <bootm_maybe_autostart+0x60>
34802820:	e59f1040 	ldr	r1, [pc, #64]	; 34802868 <bootm_maybe_autostart+0x68>
34802824:	eb0064d2 	bl	3481bb74 <strcmp>
34802828:	e2504000 	subs	r4, r0, #0
		local_args[1] = NULL;
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
		return do_bootm(cmdtp, 0, 1, local_args);
	}

	return 0;
3480282c:	13a00000 	movne	r0, #0

int bootm_maybe_autostart(cmd_tbl_t *cmdtp, const char *cmd)
{
	const char *ep = getenv("autostart");

	if (ep && !strcmp(ep, "yes")) {
34802830:	1a00000a 	bne	34802860 <bootm_maybe_autostart+0x60>
		char *local_args[2];
		local_args[0] = (char *)cmd;
		local_args[1] = NULL;
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
34802834:	e59f3030 	ldr	r3, [pc, #48]	; 3480286c <bootm_maybe_autostart+0x6c>
34802838:	e59f0030 	ldr	r0, [pc, #48]	; 34802870 <bootm_maybe_autostart+0x70>
3480283c:	e5931000 	ldr	r1, [r3]
{
	const char *ep = getenv("autostart");

	if (ep && !strcmp(ep, "yes")) {
		char *local_args[2];
		local_args[0] = (char *)cmd;
34802840:	e58d6000 	str	r6, [sp]
		local_args[1] = NULL;
34802844:	e58d4004 	str	r4, [sp, #4]
		printf("Automatic boot of image at addr 0x%08lX ...\n", load_addr);
34802848:	eb001a45 	bl	34809164 <printf>
		return do_bootm(cmdtp, 0, 1, local_args);
3480284c:	e1a00005 	mov	r0, r5
34802850:	e1a01004 	mov	r1, r4
34802854:	e3a02001 	mov	r2, #1
34802858:	e1a0300d 	mov	r3, sp
3480285c:	ebffff41 	bl	34802568 <do_bootm>
	}

	return 0;
}
34802860:	e8bd807c 	pop	{r2, r3, r4, r5, r6, pc}
34802864:	3482317b 	.word	0x3482317b
34802868:	348231c3 	.word	0x348231c3
3480286c:	348284b4 	.word	0x348284b4
34802870:	348231c7 	.word	0x348231c7

34802874 <parse_argv>:
	}
	return 0;
}

static int parse_argv(const char *s)
{
34802874:	e92d4010 	push	{r4, lr}
	if (strcmp(s, "flush") == 0)
34802878:	e59f1044 	ldr	r1, [pc, #68]	; 348028c4 <parse_argv+0x50>
	}
	return 0;
}

static int parse_argv(const char *s)
{
3480287c:	e1a04000 	mov	r4, r0
	if (strcmp(s, "flush") == 0)
34802880:	eb0064bb 	bl	3481bb74 <strcmp>
34802884:	e3500000 	cmp	r0, #0
		return 2;
34802888:	03a00002 	moveq	r0, #2
	return 0;
}

static int parse_argv(const char *s)
{
	if (strcmp(s, "flush") == 0)
3480288c:	08bd8010 	popeq	{r4, pc}
		return 2;
	else if (strcmp(s, "on") == 0)
34802890:	e1a00004 	mov	r0, r4
34802894:	e59f102c 	ldr	r1, [pc, #44]	; 348028c8 <parse_argv+0x54>
34802898:	eb0064b5 	bl	3481bb74 <strcmp>
3480289c:	e3500000 	cmp	r0, #0
348028a0:	0a000005 	beq	348028bc <parse_argv+0x48>
		return 1;
	else if (strcmp(s, "off") == 0)
348028a4:	e1a00004 	mov	r0, r4
348028a8:	e59f101c 	ldr	r1, [pc, #28]	; 348028cc <parse_argv+0x58>
348028ac:	eb0064b0 	bl	3481bb74 <strcmp>
348028b0:	e3500000 	cmp	r0, #0
		return 0;
348028b4:	13e00000 	mvnne	r0, #0
348028b8:	e8bd8010 	pop	{r4, pc}
static int parse_argv(const char *s)
{
	if (strcmp(s, "flush") == 0)
		return 2;
	else if (strcmp(s, "on") == 0)
		return 1;
348028bc:	e3a00001 	mov	r0, #1
	else if (strcmp(s, "off") == 0)
		return 0;

	return -1;
}
348028c0:	e8bd8010 	pop	{r4, pc}
348028c4:	34823579 	.word	0x34823579
348028c8:	3482828b 	.word	0x3482828b
348028cc:	34822c18 	.word	0x34822c18
static int parse_argv(const char *);

void __weak invalidate_icache_all(void)
{
	/* please define arch specific invalidate_icache_all */
	puts("No arch specific invalidate_icache_all available!\n");
348028d0:	e59f0000 	ldr	r0, [pc, #0]	; 348028d8 <parse_argv+0x64>
348028d4:	ea001a18 	b	3480913c <puts>
348028d8:	3482357f 	.word	0x3482357f

348028dc <do_icache>:
}

int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
348028dc:	e3520001 	cmp	r2, #1
	/* please define arch specific invalidate_icache_all */
	puts("No arch specific invalidate_icache_all available!\n");
}

int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348028e0:	e92d4010 	push	{r4, lr}
	switch (argc) {
348028e4:	0a000012 	beq	34802934 <do_icache+0x58>
348028e8:	e3520002 	cmp	r2, #2
	case 1:			/* get status */
		printf("Instruction Cache is %s\n",
			icache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
348028ec:	13e00000 	mvnne	r0, #0
	puts("No arch specific invalidate_icache_all available!\n");
}

int do_icache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
348028f0:	18bd8010 	popne	{r4, pc}
	case 2:			/* on / off	*/
		switch (parse_argv(argv[1])) {
348028f4:	e5930004 	ldr	r0, [r3, #4]
348028f8:	ebffffdd 	bl	34802874 <parse_argv>
348028fc:	e3500001 	cmp	r0, #1
34802900:	e1a04000 	mov	r4, r0
34802904:	0a000006 	beq	34802924 <do_icache+0x48>
34802908:	e3500002 	cmp	r0, #2
3480290c:	0a000006 	beq	3480292c <do_icache+0x50>
34802910:	e3500000 	cmp	r0, #0
34802914:	1a00000f 	bne	34802958 <do_icache+0x7c>
		case 0:
			icache_disable();
34802918:	ebfffc0a 	bl	34801948 <icache_disable>
			icache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
	}
	return 0;
3480291c:	e1a00004 	mov	r0, r4
	switch (argc) {
	case 2:			/* on / off	*/
		switch (parse_argv(argv[1])) {
		case 0:
			icache_disable();
			break;
34802920:	e8bd8010 	pop	{r4, pc}
		case 1:
			icache_enable();
34802924:	ebfffc05 	bl	34801940 <icache_enable>
34802928:	ea000008 	b	34802950 <do_icache+0x74>
			break;
		case 2:
			invalidate_icache_all();
3480292c:	ebfff771 	bl	348006f8 <invalidate_icache_all>
34802930:	ea000006 	b	34802950 <do_icache+0x74>
			break;
		}
		break;
	case 1:			/* get status */
		printf("Instruction Cache is %s\n",
			icache_status() ? "ON" : "OFF");
34802934:	ebfffc05 	bl	34801950 <icache_status>
			invalidate_icache_all();
			break;
		}
		break;
	case 1:			/* get status */
		printf("Instruction Cache is %s\n",
34802938:	e59f3020 	ldr	r3, [pc, #32]	; 34802960 <do_icache+0x84>
3480293c:	e3500000 	cmp	r0, #0
34802940:	e59f101c 	ldr	r1, [pc, #28]	; 34802964 <do_icache+0x88>
34802944:	e59f001c 	ldr	r0, [pc, #28]	; 34802968 <do_icache+0x8c>
34802948:	11a01003 	movne	r1, r3
3480294c:	eb001a04 	bl	34809164 <printf>
			icache_status() ? "ON" : "OFF");
		return 0;
34802950:	e3a00000 	mov	r0, #0
34802954:	e8bd8010 	pop	{r4, pc}
	default:
		return CMD_RET_USAGE;
	}
	return 0;
34802958:	e3a00000 	mov	r0, #0
}
3480295c:	e8bd8010 	pop	{r4, pc}
34802960:	348262aa 	.word	0x348262aa
34802964:	348235b2 	.word	0x348235b2
34802968:	348235b6 	.word	0x348235b6

void __weak flush_dcache_all(void)
{
	puts("No arch specific flush_dcache_all available!\n");
3480296c:	e59f0000 	ldr	r0, [pc, #0]	; 34802974 <do_icache+0x98>
34802970:	ea0019f1 	b	3480913c <puts>
34802974:	348235cf 	.word	0x348235cf

34802978 <do_dcache>:
	/* please define arch specific flush_dcache_all */
}

int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
34802978:	e3520001 	cmp	r2, #1
	puts("No arch specific flush_dcache_all available!\n");
	/* please define arch specific flush_dcache_all */
}

int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480297c:	e92d4010 	push	{r4, lr}
	switch (argc) {
34802980:	0a000012 	beq	348029d0 <do_dcache+0x58>
34802984:	e3520002 	cmp	r2, #2
	case 1:			/* get status */
		printf("Data (writethrough) Cache is %s\n",
			dcache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
34802988:	13e00000 	mvnne	r0, #0
	/* please define arch specific flush_dcache_all */
}

int do_dcache(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	switch (argc) {
3480298c:	18bd8010 	popne	{r4, pc}
	case 2:			/* on / off */
		switch (parse_argv(argv[1])) {
34802990:	e5930004 	ldr	r0, [r3, #4]
34802994:	ebffffb6 	bl	34802874 <parse_argv>
34802998:	e3500001 	cmp	r0, #1
3480299c:	e1a04000 	mov	r4, r0
348029a0:	0a000006 	beq	348029c0 <do_dcache+0x48>
348029a4:	e3500002 	cmp	r0, #2
348029a8:	0a000006 	beq	348029c8 <do_dcache+0x50>
348029ac:	e3500000 	cmp	r0, #0
348029b0:	1a00000f 	bne	348029f4 <do_dcache+0x7c>
		case 0:
			dcache_disable();
348029b4:	ebfffbea 	bl	34801964 <dcache_disable>
			dcache_status() ? "ON" : "OFF");
		return 0;
	default:
		return CMD_RET_USAGE;
	}
	return 0;
348029b8:	e1a00004 	mov	r0, r4
	switch (argc) {
	case 2:			/* on / off */
		switch (parse_argv(argv[1])) {
		case 0:
			dcache_disable();
			break;
348029bc:	e8bd8010 	pop	{r4, pc}
		case 1:
			dcache_enable();
348029c0:	ebfffbe5 	bl	3480195c <dcache_enable>
348029c4:	ea000008 	b	348029ec <do_dcache+0x74>
			break;
		case 2:
			flush_dcache_all();
348029c8:	ebfff727 	bl	3480066c <flush_dcache_all>
348029cc:	ea000006 	b	348029ec <do_dcache+0x74>
			break;
		}
		break;
	case 1:			/* get status */
		printf("Data (writethrough) Cache is %s\n",
			dcache_status() ? "ON" : "OFF");
348029d0:	ebfffbe5 	bl	3480196c <dcache_status>
			flush_dcache_all();
			break;
		}
		break;
	case 1:			/* get status */
		printf("Data (writethrough) Cache is %s\n",
348029d4:	e59f3020 	ldr	r3, [pc, #32]	; 348029fc <do_dcache+0x84>
348029d8:	e3500000 	cmp	r0, #0
348029dc:	e59f101c 	ldr	r1, [pc, #28]	; 34802a00 <do_dcache+0x88>
348029e0:	e59f001c 	ldr	r0, [pc, #28]	; 34802a04 <do_dcache+0x8c>
348029e4:	11a01003 	movne	r1, r3
348029e8:	eb0019dd 	bl	34809164 <printf>
			dcache_status() ? "ON" : "OFF");
		return 0;
348029ec:	e3a00000 	mov	r0, #0
348029f0:	e8bd8010 	pop	{r4, pc}
	default:
		return CMD_RET_USAGE;
	}
	return 0;
348029f4:	e3a00000 	mov	r0, #0
}
348029f8:	e8bd8010 	pop	{r4, pc}
348029fc:	348262aa 	.word	0x348262aa
34802a00:	348235b2 	.word	0x348235b2
34802a04:	348235fd 	.word	0x348235fd

34802a08 <do_coninfo>:
#include <command.h>
#include <stdio_dev.h>

extern void _do_coninfo (void);
int do_coninfo (cmd_tbl_t * cmd, int flag, int argc, char * const argv[])
{
34802a08:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
	int l;
	struct list_head *list = stdio_get_list();
34802a0c:	eb002f36 	bl	3480e6ec <stdio_get_list>
34802a10:	e1a05000 	mov	r5, r0
	struct list_head *pos;
	struct stdio_dev *dev;

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");
34802a14:	e59f0090 	ldr	r0, [pc, #144]	; 34802aac <do_coninfo+0xa4>
34802a18:	eb0019c7 	bl	3480913c <puts>
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
34802a1c:	e59f708c 	ldr	r7, [pc, #140]	; 34802ab0 <do_coninfo+0xa8>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
34802a20:	e5954000 	ldr	r4, [r5]
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
				printf ("%s ", stdio_names[l]);
34802a24:	e59fa088 	ldr	sl, [pc, #136]	; 34802ab4 <do_coninfo+0xac>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
34802a28:	ea00001b 	b	34802a9c <do_coninfo+0x94>
		dev = list_entry(pos, struct stdio_dev, list);

		printf ("%-8s %08x %c%c%c ",
			dev->name,
			dev->flags,
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
34802a2c:	e5142034 	ldr	r2, [r4, #-52]	; 0x34
	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
		dev = list_entry(pos, struct stdio_dev, list);
34802a30:	e2446034 	sub	r6, r4, #52	; 0x34

		printf ("%-8s %08x %c%c%c ",
34802a34:	e3120001 	tst	r2, #1
34802a38:	03a0102e 	moveq	r1, #46	; 0x2e
34802a3c:	13a01049 	movne	r1, #73	; 0x49
34802a40:	e3120002 	tst	r2, #2
34802a44:	03a0302e 	moveq	r3, #46	; 0x2e
34802a48:	13a0304f 	movne	r3, #79	; 0x4f
34802a4c:	e3520000 	cmp	r2, #0
34802a50:	e88d000a 	stm	sp, {r1, r3}
34802a54:	e59f005c 	ldr	r0, [pc, #92]	; 34802ab8 <do_coninfo+0xb0>
34802a58:	e2861008 	add	r1, r6, #8
34802a5c:	a3a0302e 	movge	r3, #46	; 0x2e
34802a60:	b3a03053 	movlt	r3, #83	; 0x53
34802a64:	eb0019be 	bl	34809164 <printf>
34802a68:	e3a09000 	mov	r9, #0
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
			if (stdio_devices[l] == dev) {
34802a6c:	e7993007 	ldr	r3, [r9, r7]
34802a70:	e1530006 	cmp	r3, r6
34802a74:	1a000002 	bne	34802a84 <do_coninfo+0x7c>
				printf ("%s ", stdio_names[l]);
34802a78:	e59f003c 	ldr	r0, [pc, #60]	; 34802abc <do_coninfo+0xb4>
34802a7c:	e799100a 	ldr	r1, [r9, sl]
34802a80:	eb0019b7 	bl	34809164 <printf>
34802a84:	e2899004 	add	r9, r9, #4
			dev->flags,
			(dev->flags & DEV_FLAGS_SYSTEM) ? 'S' : '.',
			(dev->flags & DEV_FLAGS_INPUT) ? 'I' : '.',
			(dev->flags & DEV_FLAGS_OUTPUT) ? 'O' : '.');

		for (l = 0; l < MAX_FILES; l++) {
34802a88:	e359000c 	cmp	r9, #12
34802a8c:	1afffff6 	bne	34802a6c <do_coninfo+0x64>
			if (stdio_devices[l] == dev) {
				printf ("%s ", stdio_names[l]);
			}
		}
		putc ('\n');
34802a90:	e3a0000a 	mov	r0, #10
34802a94:	eb00199e 	bl	34809114 <putc>

	/* Scan for valid output and input devices */

	puts ("List of available devices:\n");

	list_for_each(pos, list) {
34802a98:	e5944000 	ldr	r4, [r4]
34802a9c:	e1540005 	cmp	r4, r5
34802aa0:	1affffe1 	bne	34802a2c <do_coninfo+0x24>
			}
		}
		putc ('\n');
	}
	return 0;
}
34802aa4:	e3a00000 	mov	r0, #0
34802aa8:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
34802aac:	348236fb 	.word	0x348236fb
34802ab0:	3482b5c0 	.word	0x3482b5c0
34802ab4:	34828a40 	.word	0x34828a40
34802ab8:	34823717 	.word	0x34823717
34802abc:	34825f27 	.word	0x34825f27

34802ac0 <do_echo>:

#include <common.h>
#include <command.h>

int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802ac0:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int i;
	int putnl = 1;
34802ac4:	e3a07001 	mov	r7, #1

#include <common.h>
#include <command.h>

int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802ac8:	e1a04002 	mov	r4, r2
34802acc:	e1a0a003 	mov	sl, r3
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
34802ad0:	e1a06007 	mov	r6, r7
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
34802ad4:	e3a0b000 	mov	fp, #0
				puts(prenls);
				*nls = '\\';
34802ad8:	e3a0905c 	mov	r9, #92	; 0x5c
int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
34802adc:	ea00001e 	b	34802b5c <do_echo+0x9c>
		char *p = argv[i];
		char *nls; /* new-line suppression */

		if (i > 1)
34802ae0:	e3560001 	cmp	r6, #1
{
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
		char *p = argv[i];
34802ae4:	e5ba5004 	ldr	r5, [sl, #4]!
		char *nls; /* new-line suppression */

		if (i > 1)
34802ae8:	da000001 	ble	34802af4 <do_echo+0x34>
			putc(' ');
34802aec:	e3a00020 	mov	r0, #32
34802af0:	eb001987 	bl	34809114 <putc>

		nls = strstr(p, "\\c");
34802af4:	e1a00005 	mov	r0, r5
34802af8:	e59f107c 	ldr	r1, [pc, #124]	; 34802b7c <do_echo+0xbc>
34802afc:	eb00655f 	bl	3481c080 <strstr>
		if (nls) {
34802b00:	e2503000 	subs	r3, r0, #0
34802b04:	0a000011 	beq	34802b50 <do_echo+0x90>
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
34802b08:	e5c3b000 	strb	fp, [r3]
				puts(prenls);
34802b0c:	e1a00005 	mov	r0, r5
34802b10:	e58d3004 	str	r3, [sp, #4]
34802b14:	eb001988 	bl	3480913c <puts>
				*nls = '\\';
34802b18:	e59d3004 	ldr	r3, [sp, #4]
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
34802b1c:	e59f1058 	ldr	r1, [pc, #88]	; 34802b7c <do_echo+0xbc>
			 * say \c more than once
			 */
			while (nls) {
				*nls = '\0';
				puts(prenls);
				*nls = '\\';
34802b20:	e1a05003 	mov	r5, r3
34802b24:	e4c59002 	strb	r9, [r5], #2
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
34802b28:	e1a00005 	mov	r0, r5
34802b2c:	eb006553 	bl	3481c080 <strstr>
			putnl = 0;
			/*
			 * be paranoid and guess that someone might
			 * say \c more than once
			 */
			while (nls) {
34802b30:	e2503000 	subs	r3, r0, #0
34802b34:	1afffff3 	bne	34802b08 <do_echo+0x48>
				puts(prenls);
				*nls = '\\';
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
			}
			puts(prenls);
34802b38:	e1a00005 	mov	r0, r5
34802b3c:	e58d3004 	str	r3, [sp, #4]
34802b40:	eb00197d 	bl	3480913c <puts>

		nls = strstr(p, "\\c");
		if (nls) {
			char *prenls = p;

			putnl = 0;
34802b44:	e59d3004 	ldr	r3, [sp, #4]
34802b48:	e1a07003 	mov	r7, r3
34802b4c:	ea000001 	b	34802b58 <do_echo+0x98>
				prenls = nls + 2;
				nls = strstr(prenls, "\\c");
			}
			puts(prenls);
		} else {
			puts(p);
34802b50:	e1a00005 	mov	r0, r5
34802b54:	eb001978 	bl	3480913c <puts>
int do_echo(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int i;
	int putnl = 1;

	for (i = 1; i < argc; i++) {
34802b58:	e2866001 	add	r6, r6, #1
34802b5c:	e1560004 	cmp	r6, r4
34802b60:	baffffde 	blt	34802ae0 <do_echo+0x20>
		} else {
			puts(p);
		}
	}

	if (putnl)
34802b64:	e3570000 	cmp	r7, #0
34802b68:	0a000001 	beq	34802b74 <do_echo+0xb4>
		putc('\n');
34802b6c:	e3a0000a 	mov	r0, #10
34802b70:	eb001967 	bl	34809114 <putc>

	return 0;
}
34802b74:	e3a00000 	mov	r0, #0
34802b78:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34802b7c:	34823757 	.word	0x34823757

34802b80 <do_exit>:
int do_exit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int r;

	r = 0;
	if (argc > 1)
34802b80:	e3520001 	cmp	r2, #1

#include <common.h>
#include <command.h>

int do_exit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34802b84:	e92d4008 	push	{r3, lr}
	int r;

	r = 0;
34802b88:	d3a03000 	movle	r3, #0
	if (argc > 1)
34802b8c:	da000004 	ble	34802ba4 <do_exit+0x24>
		r = simple_strtoul(argv[1], NULL, 10);
34802b90:	e5930004 	ldr	r0, [r3, #4]
34802b94:	e3a01000 	mov	r1, #0
34802b98:	e3a0200a 	mov	r2, #10
34802b9c:	eb0067bb 	bl	3481ca90 <simple_strtoul>
34802ba0:	e1a03000 	mov	r3, r0

	return -r - 2;
}
34802ba4:	e3e00001 	mvn	r0, #1
34802ba8:	e0630000 	rsb	r0, r3, r0
34802bac:	e8bd8008 	pop	{r3, pc}

34802bb0 <do_help>:

#include <common.h>
#include <command.h>

int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34802bb0:	e92d4007 	push	{r0, r1, r2, lr}
34802bb4:	e1a0c001 	mov	ip, r1
34802bb8:	e1a0e000 	mov	lr, r0
	return _do_help(&__u_boot_cmd_start,
			&__u_boot_cmd_end - &__u_boot_cmd_start,
34802bbc:	e59f1028 	ldr	r1, [pc, #40]	; 34802bec <do_help+0x3c>
#include <common.h>
#include <command.h>

int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	return _do_help(&__u_boot_cmd_start,
34802bc0:	e59f0028 	ldr	r0, [pc, #40]	; 34802bf0 <do_help+0x40>
34802bc4:	e58d3004 	str	r3, [sp, #4]
			&__u_boot_cmd_end - &__u_boot_cmd_start,
34802bc8:	e0601001 	rsb	r1, r0, r1
#include <common.h>
#include <command.h>

int do_help(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	return _do_help(&__u_boot_cmd_start,
34802bcc:	e59f3020 	ldr	r3, [pc, #32]	; 34802bf4 <do_help+0x44>
34802bd0:	e1a011c1 	asr	r1, r1, #3
34802bd4:	e58d2000 	str	r2, [sp]
34802bd8:	e0010193 	mul	r1, r3, r1
34802bdc:	e1a0200e 	mov	r2, lr
34802be0:	e1a0300c 	mov	r3, ip
34802be4:	eb00181e 	bl	34808c64 <_do_help>
			&__u_boot_cmd_end - &__u_boot_cmd_start,
			cmdtp, flag, argc, argv);
}
34802be8:	e8bd800e 	pop	{r1, r2, r3, pc}
34802bec:	34829900 	.word	0x34829900
34802bf0:	34829498 	.word	0x34829498
34802bf4:	aaaaaaab 	.word	0xaaaaaaab

34802bf8 <evalstr>:
}

static char * evalstr(char *s)
{
	/* if the parameter starts with a * then assume a string pointer else its a literal */
	if (s[0] == '*') {
34802bf8:	e5d02000 	ldrb	r2, [r0]
34802bfc:	e352002a 	cmp	r2, #42	; 0x2a
34802c00:	112fff1e 	bxne	lr
		return (char *)simple_strtoul(&s[1], NULL, 16);
34802c04:	e2800001 	add	r0, r0, #1
34802c08:	e3a01000 	mov	r1, #0
34802c0c:	e3a02010 	mov	r2, #16
34802c10:	ea00679e 	b	3481ca90 <simple_strtoul>

34802c14 <evalexp>:
	{ "-le", LE },
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
34802c14:	e92d4010 	push	{r4, lr}
	long l = 0;
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
34802c18:	e5d02000 	ldrb	r2, [r0]
	{ "-le", LE },
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
34802c1c:	e1a04001 	mov	r4, r1
	long l = 0;
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
34802c20:	e352002a 	cmp	r2, #42	; 0x2a
34802c24:	1a00000d 	bne	34802c60 <evalexp+0x4c>
		p = (long *)simple_strtoul(&s[1], NULL, 16);
34802c28:	e2800001 	add	r0, r0, #1
34802c2c:	e3a01000 	mov	r1, #0
34802c30:	e3a02010 	mov	r2, #16
34802c34:	eb006795 	bl	3481ca90 <simple_strtoul>
		switch (w) {
34802c38:	e3540002 	cmp	r4, #2
		case 1: return((long)(*(unsigned char *)p));
		case 2: return((long)(*(unsigned short *)p));
34802c3c:	01d000b0 	ldrheq	r0, [r0]
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
		switch (w) {
34802c40:	08bd8010 	popeq	{r4, pc}
34802c44:	e3540004 	cmp	r4, #4
		case 1: return((long)(*(unsigned char *)p));
		case 2: return((long)(*(unsigned short *)p));
		case 4: return(*p);
34802c48:	05900000 	ldreq	r0, [r0]
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
		switch (w) {
34802c4c:	08bd8010 	popeq	{r4, pc}
34802c50:	e3540001 	cmp	r4, #1
		case 1: return((long)(*(unsigned char *)p));
34802c54:	05d00000 	ldrbeq	r0, [r0]
	long *p;

	/* if the parameter starts with a * then assume is a pointer to the value we want */
	if (s[0] == '*') {
		p = (long *)simple_strtoul(&s[1], NULL, 16);
		switch (w) {
34802c58:	1a000004 	bne	34802c70 <evalexp+0x5c>
34802c5c:	e8bd8010 	pop	{r4, pc}
		case 1: return((long)(*(unsigned char *)p));
		case 2: return((long)(*(unsigned short *)p));
		case 4: return(*p);
		}
	} else {
		l = simple_strtoul(s, NULL, 16);
34802c60:	e3a01000 	mov	r1, #0
34802c64:	e3a02010 	mov	r2, #16
34802c68:	eb006788 	bl	3481ca90 <simple_strtoul>
34802c6c:	ea000000 	b	34802c74 <evalexp+0x60>
	{ "<=" , LE },
};

static long evalexp(char *s, int w)
{
	long l = 0;
34802c70:	e3a00000 	mov	r0, #0
		}
	} else {
		l = simple_strtoul(s, NULL, 16);
	}

	return (l & ((1 << (w * 8)) - 1));
34802c74:	e1a04184 	lsl	r4, r4, #3
34802c78:	e3e03000 	mvn	r3, #0
34802c7c:	e1c00413 	bic	r0, r0, r3, lsl r4
}
34802c80:	e8bd8010 	pop	{r4, pc}

34802c84 <binary_test>:
	}
	return (0);
}

int binary_test (char *op, char *arg1, char *arg2, int w)
{
34802c84:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34802c88:	e1a09000 	mov	r9, r0
34802c8c:	e1a05001 	mov	r5, r1
34802c90:	e1a04002 	mov	r4, r2
34802c94:	e1a07003 	mov	r7, r3
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);
34802c98:	eb0063e9 	bl	3481bc44 <strlen>
	case GE: return (l >= r);
	}
	return (0);
}

int binary_test (char *op, char *arg1, char *arg2, int w)
34802c9c:	e59fb190 	ldr	fp, [pc, #400]	; 34802e34 <binary_test+0x1b0>
{
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);
34802ca0:	e1a0a000 	mov	sl, r0

	for (optp = (op_tbl_t *)&op_table, i = 0;
34802ca4:	e59f618c 	ldr	r6, [pc, #396]	; 34802e38 <binary_test+0x1b4>
34802ca8:	ea000058 	b	34802e10 <binary_test+0x18c>
	     i < ARRAY_SIZE(op_table);
	     optp++, i++) {

		if ((strncmp (op, optp->op, len) == 0) && (len == strlen (optp->op))) {
34802cac:	e1a00009 	mov	r0, r9
34802cb0:	e5961000 	ldr	r1, [r6]
34802cb4:	e1a0200a 	mov	r2, sl
34802cb8:	eb0063b9 	bl	3481bba4 <strncmp>
34802cbc:	e3500000 	cmp	r0, #0
34802cc0:	1a000051 	bne	34802e0c <binary_test+0x188>
34802cc4:	e5960000 	ldr	r0, [r6]
34802cc8:	eb0063dd 	bl	3481bc44 <strlen>
34802ccc:	e15a0000 	cmp	sl, r0
34802cd0:	1a00004d 	bne	34802e0c <binary_test+0x188>
			if (w == 0) {
34802cd4:	e3570000 	cmp	r7, #0
34802cd8:	e5966004 	ldr	r6, [r6, #4]
34802cdc:	1a000023 	bne	34802d70 <binary_test+0xec>
static int stringcomp(char *s, char *t, int op)
{
	int p;
	char *l, *r;

	l = evalstr(s);
34802ce0:	e1a00005 	mov	r0, r5
34802ce4:	ebffffc3 	bl	34802bf8 <evalstr>
34802ce8:	e1a05000 	mov	r5, r0
	r = evalstr(t);
34802cec:	e1a00004 	mov	r0, r4
34802cf0:	ebffffc0 	bl	34802bf8 <evalstr>
34802cf4:	e1a01000 	mov	r1, r0

	p = strcmp(l, r);
34802cf8:	e1a00005 	mov	r0, r5
34802cfc:	eb00639c 	bl	3481bb74 <strcmp>
	switch (op) {
34802d00:	e3560005 	cmp	r6, #5
34802d04:	979ff106 	ldrls	pc, [pc, r6, lsl #2]
34802d08:	ea000045 	b	34802e24 <binary_test+0x1a0>
34802d0c:	34802d24 	.word	0x34802d24
34802d10:	34802d30 	.word	0x34802d30
34802d14:	34802d3c 	.word	0x34802d3c
34802d18:	34802d44 	.word	0x34802d44
34802d1c:	34802d54 	.word	0x34802d54
34802d20:	34802d64 	.word	0x34802d64
	case EQ: return (p == 0);
34802d24:	e2700001 	rsbs	r0, r0, #1
34802d28:	33a00000 	movcc	r0, #0
34802d2c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case NE: return (p != 0);
34802d30:	e2500000 	subs	r0, r0, #0
34802d34:	13a00001 	movne	r0, #1
34802d38:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (p < 0);
34802d3c:	e1a00fa0 	lsr	r0, r0, #31
34802d40:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GT: return (p > 0);
34802d44:	e3500000 	cmp	r0, #0
34802d48:	d3a00000 	movle	r0, #0
34802d4c:	c3a00001 	movgt	r0, #1
34802d50:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LE: return (p <= 0);
34802d54:	e3500000 	cmp	r0, #0
34802d58:	c3a00000 	movgt	r0, #0
34802d5c:	d3a00001 	movle	r0, #1
34802d60:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GE: return (p >= 0);
34802d64:	e1e00000 	mvn	r0, r0
34802d68:	e1a00fa0 	lsr	r0, r0, #31
34802d6c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

static int arithcomp (char *s, char *t, int op, int w)
{
	long l, r;

	l = evalexp (s, w);
34802d70:	e1a00005 	mov	r0, r5
34802d74:	e1a01007 	mov	r1, r7
34802d78:	ebffffa5 	bl	34802c14 <evalexp>
	r = evalexp (t, w);
34802d7c:	e1a01007 	mov	r1, r7

static int arithcomp (char *s, char *t, int op, int w)
{
	long l, r;

	l = evalexp (s, w);
34802d80:	e1a05000 	mov	r5, r0
	r = evalexp (t, w);
34802d84:	e1a00004 	mov	r0, r4
34802d88:	ebffffa1 	bl	34802c14 <evalexp>

	switch (op) {
34802d8c:	e3560005 	cmp	r6, #5
34802d90:	979ff106 	ldrls	pc, [pc, r6, lsl #2]
34802d94:	ea000024 	b	34802e2c <binary_test+0x1a8>
34802d98:	34802db0 	.word	0x34802db0
34802d9c:	34802dc0 	.word	0x34802dc0
34802da0:	34802dcc 	.word	0x34802dcc
34802da4:	34802ddc 	.word	0x34802ddc
34802da8:	34802dec 	.word	0x34802dec
34802dac:	34802dfc 	.word	0x34802dfc
	case EQ: return (l == r);
34802db0:	e1550000 	cmp	r5, r0
34802db4:	13a00000 	movne	r0, #0
34802db8:	03a00001 	moveq	r0, #1
34802dbc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case NE: return (l != r);
34802dc0:	e0550000 	subs	r0, r5, r0
34802dc4:	13a00001 	movne	r0, #1
34802dc8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (l < r);
34802dcc:	e1550000 	cmp	r5, r0
34802dd0:	a3a00000 	movge	r0, #0
34802dd4:	b3a00001 	movlt	r0, #1
34802dd8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GT: return (l > r);
34802ddc:	e1550000 	cmp	r5, r0
34802de0:	d3a00000 	movle	r0, #0
34802de4:	c3a00001 	movgt	r0, #1
34802de8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LE: return (l <= r);
34802dec:	e1550000 	cmp	r5, r0
34802df0:	c3a00000 	movgt	r0, #0
34802df4:	d3a00001 	movle	r0, #1
34802df8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case GE: return (l >= r);
34802dfc:	e1550000 	cmp	r5, r0
34802e00:	b3a00000 	movlt	r0, #0
34802e04:	a3a00001 	movge	r0, #1
34802e08:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

	len = strlen(op);

	for (optp = (op_tbl_t *)&op_table, i = 0;
	     i < ARRAY_SIZE(op_table);
	     optp++, i++) {
34802e0c:	e2866008 	add	r6, r6, #8
	int len, i;
	const op_tbl_t *optp;

	len = strlen(op);

	for (optp = (op_tbl_t *)&op_table, i = 0;
34802e10:	e156000b 	cmp	r6, fp
34802e14:	1affffa4 	bne	34802cac <binary_test+0x28>
				return (arithcomp (arg1, arg2, optp->opcode, w));
			}
		}
	}

	printf("Unknown operator '%s'\n", op);
34802e18:	e59f001c 	ldr	r0, [pc, #28]	; 34802e3c <binary_test+0x1b8>
34802e1c:	e1a01009 	mov	r1, r9
34802e20:	eb0018cf 	bl	34809164 <printf>
	case LT: return (p < 0);
	case GT: return (p > 0);
	case LE: return (p <= 0);
	case GE: return (p >= 0);
	}
	return (0);
34802e24:	e3a00000 	mov	r0, #0
34802e28:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	case LT: return (l < r);
	case GT: return (l > r);
	case LE: return (l <= r);
	case GE: return (l >= r);
	}
	return (0);
34802e2c:	e3a00000 	mov	r0, #0
		}
	}

	printf("Unknown operator '%s'\n", op);
	return 0;	/* op code not found */
}
34802e30:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34802e34:	3482019c 	.word	0x3482019c
34802e38:	34820134 	.word	0x34820134
34802e3c:	34823855 	.word	0x34823855

34802e40 <do_itest>:
int do_itest ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[] )
{
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
34802e40:	e3520004 	cmp	r2, #4
	return 0;	/* op code not found */
}

/* command line interface to the shell test */
int do_itest ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[] )
{
34802e44:	e92d4010 	push	{r4, lr}
34802e48:	e1a04003 	mov	r4, r3
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
34802e4c:	1a00001e 	bne	34802ecc <do_itest+0x8c>

	/* Check for a data width specification.
	 * Defaults to long (4) if no specification.
	 * Uses -2 as 'width' for .s (string) so as not to upset existing code
	 */
	switch (w = cmd_get_data_size(argv[0], 4)) {
34802e50:	e5930000 	ldr	r0, [r3]
34802e54:	e1a01002 	mov	r1, r2
34802e58:	eb0017e3 	bl	34808dec <cmd_get_data_size>
34802e5c:	e2802002 	add	r2, r0, #2
34802e60:	e1a03000 	mov	r3, r0
34802e64:	e3520006 	cmp	r2, #6
34802e68:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
34802e6c:	ea000010 	b	34802eb4 <do_itest+0x74>
34802e70:	34802e9c 	.word	0x34802e9c
34802e74:	34802eb4 	.word	0x34802eb4
34802e78:	34802eb4 	.word	0x34802eb4
34802e7c:	34802e8c 	.word	0x34802e8c
34802e80:	34802e8c 	.word	0x34802e8c
34802e84:	34802eb4 	.word	0x34802eb4
34802e88:	34802e8c 	.word	0x34802e8c
	case 1:
	case 2:
	case 4:
		value = binary_test (argv[2], argv[1], argv[3], w);
34802e8c:	e5940008 	ldr	r0, [r4, #8]
34802e90:	e5941004 	ldr	r1, [r4, #4]
34802e94:	e594200c 	ldr	r2, [r4, #12]
34802e98:	ea000003 	b	34802eac <do_itest+0x6c>
		break;
	case -2:
		value = binary_test (argv[2], argv[1], argv[3], 0);
34802e9c:	e5940008 	ldr	r0, [r4, #8]
34802ea0:	e5941004 	ldr	r1, [r4, #4]
34802ea4:	e594200c 	ldr	r2, [r4, #12]
34802ea8:	e3a03000 	mov	r3, #0
34802eac:	ebffff74 	bl	34802c84 <binary_test>
		break;
34802eb0:	ea000002 	b	34802ec0 <do_itest+0x80>
	case -1:
	default:
		puts("Invalid data width specifier\n");
34802eb4:	e59f0018 	ldr	r0, [pc, #24]	; 34802ed4 <do_itest+0x94>
34802eb8:	eb00189f 	bl	3480913c <puts>
		value = 0;
34802ebc:	e3a00000 	mov	r0, #0
		break;
	}

	return !value;
34802ec0:	e2700001 	rsbs	r0, r0, #1
34802ec4:	33a00000 	movcc	r0, #0
34802ec8:	e8bd8010 	pop	{r4, pc}
{
	int	value, w;

	/* Validate arguments */
	if ((argc != 4))
		return CMD_RET_USAGE;
34802ecc:	e3e00000 	mvn	r0, #0
		value = 0;
		break;
	}

	return !value;
}
34802ed0:	e8bd8010 	pop	{r4, pc}
34802ed4:	3482386c 	.word	0x3482386c

34802ed8 <bin_data_init>:
static char *os_data_addr, *os_data_addr_saved;
static char *bin_start_address;

static void bin_data_init (void)
{
	os_data_state = 0;
34802ed8:	e59f3010 	ldr	r3, [pc, #16]	; 34802ef0 <bin_data_init+0x18>
34802edc:	e3a02000 	mov	r2, #0
34802ee0:	e5832000 	str	r2, [r3]
	os_data_addr = bin_start_address;
34802ee4:	e5932008 	ldr	r2, [r3, #8]
34802ee8:	e5832004 	str	r2, [r3, #4]
}
34802eec:	e12fff1e 	bx	lr
34802ef0:	34829a34 	.word	0x34829a34

34802ef4 <bin_data_char>:
	os_data_addr = os_data_addr_saved;
}

static void bin_data_char (char new_char)
{
	switch (os_data_state) {
34802ef4:	e59f3014 	ldr	r3, [pc, #20]	; 34802f10 <bin_data_char+0x1c>
34802ef8:	e5932000 	ldr	r2, [r3]
34802efc:	e3520000 	cmp	r2, #0
	case 0:					/* data */
		*os_data_addr++ = new_char;
34802f00:	05932004 	ldreq	r2, [r3, #4]
34802f04:	04c20001 	strbeq	r0, [r2], #1
34802f08:	05832004 	streq	r2, [r3, #4]
34802f0c:	e12fff1e 	bx	lr
34802f10:	34829a34 	.word	0x34829a34

34802f14 <load_serial_ymodem>:
	if (tstc())
		return (getc());
	return -1;
}
static ulong load_serial_ymodem (ulong offset)
{
34802f14:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34802f18:	e24dde43 	sub	sp, sp, #1072	; 0x430
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
34802f1c:	e28dae42 	add	sl, sp, #1056	; 0x420
34802f20:	e28aa00c 	add	sl, sl, #12
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
34802f24:	e3a03002 	mov	r3, #2
	if (tstc())
		return (getc());
	return -1;
}
static ulong load_serial_ymodem (ulong offset)
{
34802f28:	e1a06000 	mov	r6, r0
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
34802f2c:	e1a0100a 	mov	r1, sl
34802f30:	e28d0e42 	add	r0, sp, #1056	; 0x420
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
34802f34:	e58d3424 	str	r3, [sp, #1060]	; 0x424
	res = xyzModem_stream_open (&info, &err);
34802f38:	eb002f57 	bl	3480ec9c <xyzModem_stream_open>
	if (!res) {
34802f3c:	e2505000 	subs	r5, r0, #0
34802f40:	01a04005 	moveq	r4, r5

		while ((res =
			xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
34802f44:	01a0700d 	moveq	r7, sp
	ulong addr = 0;

	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
	if (!res) {
34802f48:	0a000005 	beq	34802f64 <load_serial_ymodem+0x50>
34802f4c:	ea00000b 	b	34802f80 <load_serial_ymodem+0x6c>

		while ((res =
			xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
			store_addr = addr + offset;
34802f50:	e0850006 	add	r0, r5, r6
					return (~0);
				}
			} else
#endif
			{
				memcpy ((char *) (store_addr), ymodemBuf,
34802f54:	e1a0100d 	mov	r1, sp
	if (!res) {

		while ((res =
			xyzModem_stream_read (ymodemBuf, 1024, &err)) > 0) {
			store_addr = addr + offset;
			size += res;
34802f58:	e0844002 	add	r4, r4, r2
			addr += res;
34802f5c:	e0855002 	add	r5, r5, r2
					return (~0);
				}
			} else
#endif
			{
				memcpy ((char *) (store_addr), ymodemBuf,
34802f60:	eb0063fb 	bl	3481bf54 <memcpy>
	size = 0;
	info.mode = xyzModem_ymodem;
	res = xyzModem_stream_open (&info, &err);
	if (!res) {

		while ((res =
34802f64:	e1a0200a 	mov	r2, sl
34802f68:	e1a0000d 	mov	r0, sp
34802f6c:	e3a01b01 	mov	r1, #1024	; 0x400
34802f70:	eb002f9b 	bl	3480ede4 <xyzModem_stream_read>
34802f74:	e2502000 	subs	r2, r0, #0
34802f78:	cafffff4 	bgt	34802f50 <load_serial_ymodem+0x3c>
34802f7c:	ea000005 	b	34802f98 <load_serial_ymodem+0x84>
					res);
			}

		}
	} else {
		printf ("%s\n", xyzModem_error (err));
34802f80:	e59d042c 	ldr	r0, [sp, #1068]	; 0x42c
34802f84:	eb003063 	bl	3480f118 <xyzModem_error>
34802f88:	e1a01000 	mov	r1, r0
34802f8c:	e59f0064 	ldr	r0, [pc, #100]	; 34802ff8 <load_serial_ymodem+0xe4>
34802f90:	eb001873 	bl	34809164 <printf>
	connection_info_t info;
	char ymodemBuf[1024];
	ulong store_addr = ~0;
	ulong addr = 0;

	size = 0;
34802f94:	e3a04000 	mov	r4, #0
		}
	} else {
		printf ("%s\n", xyzModem_error (err));
	}

	xyzModem_stream_close (&err);
34802f98:	e28d0e42 	add	r0, sp, #1056	; 0x420
34802f9c:	e280000c 	add	r0, r0, #12
34802fa0:	eb003023 	bl	3480f034 <xyzModem_stream_close>
	xyzModem_stream_terminate (false, &getcxmodem);
34802fa4:	e3a00000 	mov	r0, #0
34802fa8:	e59f104c 	ldr	r1, [pc, #76]	; 34802ffc <load_serial_ymodem+0xe8>
34802fac:	eb003034 	bl	3480f084 <xyzModem_stream_terminate>


	flush_cache (offset, size);
34802fb0:	e1a00006 	mov	r0, r6
34802fb4:	e1a01004 	mov	r1, r4
34802fb8:	ebfff5cc 	bl	348006f0 <flush_cache>

	printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
	sprintf (buf, "%X", size);
34802fbc:	e28d5b01 	add	r5, sp, #1024	; 0x400
	xyzModem_stream_terminate (false, &getcxmodem);


	flush_cache (offset, size);

	printf ("## Total Size      = 0x%08x = %d Bytes\n", size, size);
34802fc0:	e1a01004 	mov	r1, r4
34802fc4:	e1a02004 	mov	r2, r4
34802fc8:	e59f0030 	ldr	r0, [pc, #48]	; 34803000 <load_serial_ymodem+0xec>
34802fcc:	eb001864 	bl	34809164 <printf>
	sprintf (buf, "%X", size);
34802fd0:	e1a02004 	mov	r2, r4
34802fd4:	e1a00005 	mov	r0, r5
34802fd8:	e59f1024 	ldr	r1, [pc, #36]	; 34803004 <load_serial_ymodem+0xf0>
34802fdc:	eb006751 	bl	3481cd28 <sprintf>
	setenv ("filesize", buf);
34802fe0:	e1a01005 	mov	r1, r5
34802fe4:	e59f001c 	ldr	r0, [pc, #28]	; 34803008 <load_serial_ymodem+0xf4>
34802fe8:	eb001067 	bl	3480718c <setenv>

	return offset;
}
34802fec:	e1a00006 	mov	r0, r6
34802ff0:	e28dde43 	add	sp, sp, #1072	; 0x430
34802ff4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34802ff8:	34825ea6 	.word	0x34825ea6
34802ffc:	3480300c 	.word	0x3480300c
34803000:	34823908 	.word	0x34823908
34803004:	34823930 	.word	0x34823930
34803008:	3482318c 	.word	0x3482318c

3480300c <getcxmodem>:
		}
	}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
}

static int getcxmodem(void) {
3480300c:	e92d4010 	push	{r4, lr}
	if (tstc())
34803010:	eb001836 	bl	348090f0 <tstc>
34803014:	e3500000 	cmp	r0, #0
34803018:	0a000001 	beq	34803024 <getcxmodem+0x18>
		return (getc());
	return -1;
}
3480301c:	e8bd4010 	pop	{r4, lr}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
}

static int getcxmodem(void) {
	if (tstc())
		return (getc());
34803020:	ea001829 	b	348090cc <getc>
	return -1;
}
34803024:	e3e00000 	mvn	r0, #0
34803028:	e8bd8010 	pop	{r4, pc}

3480302c <load_serial>:
	return rcode;
}

static ulong
load_serial (long offset)
{
3480302c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	ulong	size;				/* number of bytes transferred	*/
	char	buf[32];
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;
34803030:	e3a05000 	mov	r5, #0
	return rcode;
}

static ulong
load_serial (long offset)
{
34803034:	e24ddd0d 	sub	sp, sp, #832	; 0x340
34803038:	e58d000c 	str	r0, [sp, #12]
	ulong	addr;				/* load address from S-Record	*/
	ulong	size;				/* number of bytes transferred	*/
	char	buf[32];
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
3480303c:	e1a07005 	mov	r7, r5
	int	type;				/* return code for record type	*/
	ulong	addr;				/* load address from S-Record	*/
	ulong	size;				/* number of bytes transferred	*/
	char	buf[32];
	ulong	store_addr;
	ulong	start_addr = ~0;
34803040:	e3e04000 	mvn	r4, #0
#endif
	return rcode;
}

static ulong
load_serial (long offset)
34803044:	e28d9f85 	add	r9, sp, #532	; 0x214

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
		c = getc();		/* read character		*/
		if (do_echo)
34803048:	e59f61dc 	ldr	r6, [pc, #476]	; 3480322c <load_serial+0x200>
		}
	    }
	}

	/* line too long - truncate */
	*p = '\0';
3480304c:	e1a0b005 	mov	fp, r5
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803050:	ea000044 	b	34803168 <load_serial+0x13c>
		type = srec_decode (record, &binlen, &addr, binbuf);
34803054:	e28d0010 	add	r0, sp, #16
34803058:	e28d1fcf 	add	r1, sp, #828	; 0x33c
3480305c:	e28d2fce 	add	r2, sp, #824	; 0x338
34803060:	e28d3f86 	add	r3, sp, #536	; 0x218
34803064:	eb002c77 	bl	3480e248 <srec_decode>

		if (type < 0) {
34803068:	e3500000 	cmp	r0, #0
3480306c:	ba00006b 	blt	34803220 <load_serial+0x1f4>
			return (~0);		/* Invalid S-Record		*/
		}

		switch (type) {
34803070:	e2400001 	sub	r0, r0, #1
34803074:	e3500008 	cmp	r0, #8
34803078:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
3480307c:	ea00002e 	b	3480313c <load_serial+0x110>
34803080:	348030a4 	.word	0x348030a4
34803084:	348030a4 	.word	0x348030a4
34803088:	348030a4 	.word	0x348030a4
3480308c:	3480313c 	.word	0x3480313c
34803090:	3480313c 	.word	0x3480313c
34803094:	3480313c 	.word	0x3480313c
34803098:	348030e0 	.word	0x348030e0
3480309c:	348030e0 	.word	0x348030e0
348030a0:	348030e0 	.word	0x348030e0
		case SREC_DATA2:
		case SREC_DATA3:
		case SREC_DATA4:
		    store_addr = addr + offset;
348030a4:	e59d200c 	ldr	r2, [sp, #12]
348030a8:	e59da338 	ldr	sl, [sp, #824]	; 0x338
				return (~0);
			}
		    } else
#endif
		    {
			memcpy ((char *)(store_addr), binbuf, binlen);
348030ac:	e28d1f86 	add	r1, sp, #536	; 0x218

		switch (type) {
		case SREC_DATA2:
		case SREC_DATA3:
		case SREC_DATA4:
		    store_addr = addr + offset;
348030b0:	e082a00a 	add	sl, r2, sl
				return (~0);
			}
		    } else
#endif
		    {
			memcpy ((char *)(store_addr), binbuf, binlen);
348030b4:	e1a0000a 	mov	r0, sl
348030b8:	e59d233c 	ldr	r2, [sp, #828]	; 0x33c
348030bc:	eb0063a4 	bl	3481bf54 <memcpy>
		    }
		    if ((store_addr) < start_addr)
			start_addr = store_addr;
		    if ((store_addr + binlen - 1) > end_addr)
348030c0:	e59d333c 	ldr	r3, [sp, #828]	; 0x33c
				return (~0);
			}
		    } else
#endif
		    {
			memcpy ((char *)(store_addr), binbuf, binlen);
348030c4:	e154000a 	cmp	r4, sl
348030c8:	21a0400a 	movcs	r4, sl
		    }
		    if ((store_addr) < start_addr)
			start_addr = store_addr;
		    if ((store_addr + binlen - 1) > end_addr)
348030cc:	e2433001 	sub	r3, r3, #1
348030d0:	e083a00a 	add	sl, r3, sl
348030d4:	e157000a 	cmp	r7, sl
348030d8:	31a0700a 	movcc	r7, sl
348030dc:	ea000016 	b	3480313c <load_serial+0x110>
		    break;
		case SREC_END2:
		case SREC_END3:
		case SREC_END4:
		    udelay (10000);
		    size = end_addr - start_addr + 1;
348030e0:	e2875001 	add	r5, r7, #1
348030e4:	e0645005 	rsb	r5, r4, r5
			end_addr = store_addr + binlen - 1;
		    break;
		case SREC_END2:
		case SREC_END3:
		case SREC_END4:
		    udelay (10000);
348030e8:	e3020710 	movw	r0, #10000	; 0x2710
348030ec:	eb006423 	bl	3481c180 <udelay>
		    size = end_addr - start_addr + 1;
		    printf ("\n"
348030f0:	e1a03005 	mov	r3, r5
348030f4:	e1a01004 	mov	r1, r4
348030f8:	e1a02007 	mov	r2, r7
348030fc:	e59f012c 	ldr	r0, [pc, #300]	; 34803230 <load_serial+0x204>
34803100:	e58d5000 	str	r5, [sp]
34803104:	eb001816 	bl	34809164 <printf>
			    "## First Load Addr = 0x%08lX\n"
			    "## Last  Load Addr = 0x%08lX\n"
			    "## Total Size      = 0x%08lX = %ld Bytes\n",
			    start_addr, end_addr, size, size
		    );
		    flush_cache (start_addr, size);
34803108:	e1a00004 	mov	r0, r4
3480310c:	e1a01005 	mov	r1, r5
		    sprintf(buf, "%lX", size);
34803110:	e28d4fc6 	add	r4, sp, #792	; 0x318
			    "## First Load Addr = 0x%08lX\n"
			    "## Last  Load Addr = 0x%08lX\n"
			    "## Total Size      = 0x%08lX = %ld Bytes\n",
			    start_addr, end_addr, size, size
		    );
		    flush_cache (start_addr, size);
34803114:	ebfff575 	bl	348006f0 <flush_cache>
		    sprintf(buf, "%lX", size);
34803118:	e59f1114 	ldr	r1, [pc, #276]	; 34803234 <load_serial+0x208>
3480311c:	e1a02005 	mov	r2, r5
34803120:	e1a00004 	mov	r0, r4
34803124:	eb0066ff 	bl	3481cd28 <sprintf>
		    setenv("filesize", buf);
34803128:	e59f0108 	ldr	r0, [pc, #264]	; 34803238 <load_serial+0x20c>
3480312c:	e1a01004 	mov	r1, r4
34803130:	eb001015 	bl	3480718c <setenv>
		    return (addr);
34803134:	e59d0338 	ldr	r0, [sp, #824]	; 0x338
34803138:	ea000039 	b	34803224 <load_serial+0x1f8>
		case SREC_START:
		    break;
		default:
		    break;
		}
		if (!do_echo) {	/* print a '.' every 100 lines */
3480313c:	e5963000 	ldr	r3, [r6]
34803140:	e3530000 	cmp	r3, #0
34803144:	1a000007 	bne	34803168 <load_serial+0x13c>
			if ((++line_count % 100) == 0)
34803148:	e2855001 	add	r5, r5, #1
3480314c:	e1a00005 	mov	r0, r5
34803150:	e3a01064 	mov	r1, #100	; 0x64
34803154:	eb00739c 	bl	3481ffcc <__aeabi_idivmod>
34803158:	e3510000 	cmp	r1, #0
3480315c:	1a000001 	bne	34803168 <load_serial+0x13c>
				putc ('.');
34803160:	e3a0002e 	mov	r0, #46	; 0x2e
34803164:	eb0017ea 	bl	34809114 <putc>
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803168:	e28d3010 	add	r3, sp, #16
3480316c:	e58d5008 	str	r5, [sp, #8]
34803170:	e1a05004 	mov	r5, r4
34803174:	e1a04003 	mov	r4, r3
	char c;

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
		c = getc();		/* read character		*/
34803178:	eb0017d3 	bl	348090cc <getc>
		if (do_echo)
3480317c:	e5963000 	ldr	r3, [r6]
	char c;

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
		c = getc();		/* read character		*/
34803180:	e6efa070 	uxtb	sl, r0
		if (do_echo)
34803184:	e3530000 	cmp	r3, #0
34803188:	0a000001 	beq	34803194 <load_serial+0x168>
			putc (c);	/* ... and echo it		*/
3480318c:	e1a0000a 	mov	r0, sl
34803190:	eb0017df 	bl	34809114 <putc>

		switch (c) {
34803194:	e35a0003 	cmp	sl, #3
34803198:	0a000020 	beq	34803220 <load_serial+0x1f4>
3480319c:	8a000002 	bhi	348031ac <load_serial+0x180>
348031a0:	e35a0000 	cmp	sl, #0
348031a4:	0a00001d 	beq	34803220 <load_serial+0x1f4>
348031a8:	ea00000a 	b	348031d8 <load_serial+0x1ac>
348031ac:	e35a000a 	cmp	sl, #10
348031b0:	0a000001 	beq	348031bc <load_serial+0x190>
348031b4:	e35a000d 	cmp	sl, #13
348031b8:	1a000006 	bne	348031d8 <load_serial+0x1ac>
348031bc:	e1a03004 	mov	r3, r4
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
348031c0:	e28d2010 	add	r2, sp, #16
348031c4:	e1a04005 	mov	r4, r5
348031c8:	e59d5008 	ldr	r5, [sp, #8]
			putc (c);	/* ... and echo it		*/

		switch (c) {
		case '\r':
		case '\n':
			*p = '\0';
348031cc:	e5c3b000 	strb	fp, [r3]
			return (p - buf);
348031d0:	e0623003 	rsb	r3, r2, r3
348031d4:	ea00000f 	b	34803218 <load_serial+0x1ec>
		case '\0':
		case 0x03:			/* ^C - Control C		*/
			return (-1);
		default:
			*p = c;
348031d8:	e4c4a001 	strb	sl, [r4], #1
		}

	    /* Check for the console hangup (if any different from serial) */
	    if (gd->jt[XF_getc] != getc) {
348031dc:	e5983054 	ldr	r3, [r8, #84]	; 0x54
348031e0:	e59f2054 	ldr	r2, [pc, #84]	; 3480323c <load_serial+0x210>
348031e4:	e5933004 	ldr	r3, [r3, #4]
348031e8:	e1530002 	cmp	r3, r2
348031ec:	0a000002 	beq	348031fc <load_serial+0x1d0>
		if (ctrlc()) {
348031f0:	eb001800 	bl	348091f8 <ctrlc>
348031f4:	e3500000 	cmp	r0, #0
348031f8:	1a000008 	bne	34803220 <load_serial+0x1f4>
	char *p;
	char c;

	--len;	/* always leave room for terminating '\0' byte */

	for (p=buf; p < buf+len; ++p) {
348031fc:	e1540009 	cmp	r4, r9
34803200:	1affffdc 	bne	34803178 <load_serial+0x14c>
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803204:	e28d3010 	add	r3, sp, #16
34803208:	e1a04005 	mov	r4, r5
	    }
	}

	/* line too long - truncate */
	*p = '\0';
	return (p - buf);
3480320c:	e0633009 	rsb	r3, r3, r9
34803210:	e59d5008 	ldr	r5, [sp, #8]
		}
	    }
	}

	/* line too long - truncate */
	*p = '\0';
34803214:	e5c9b000 	strb	fp, [r9]
	ulong	store_addr;
	ulong	start_addr = ~0;
	ulong	end_addr   =  0;
	int	line_count =  0;

	while (read_record(record, SREC_MAXRECLEN + 1) >= 0) {
34803218:	e3530000 	cmp	r3, #0
3480321c:	aaffff8c 	bge	34803054 <load_serial+0x28>
			if ((++line_count % 100) == 0)
				putc ('.');
		}
	}

	return (~0);			/* Download aborted		*/
34803220:	e3e00000 	mvn	r0, #0
}
34803224:	e28ddd0d 	add	sp, sp, #832	; 0x340
34803228:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480322c:	348283cc 	.word	0x348283cc
34803230:	34823933 	.word	0x34823933
34803234:	34823188 	.word	0x34823188
34803238:	3482318c 	.word	0x3482318c
3480323c:	348090cc 	.word	0x348090cc

34803240 <do_load_serial>:

/* -------------------------------------------------------------------- */

#if defined(CONFIG_CMD_LOADS)
int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803240:	e92d4038 	push	{r3, r4, r5, lr}
	int load_baudrate, current_baudrate;

	load_baudrate = current_baudrate = gd->baudrate;
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
34803244:	e59f00b8 	ldr	r0, [pc, #184]	; 34803304 <do_load_serial+0xc4>

/* -------------------------------------------------------------------- */

#if defined(CONFIG_CMD_LOADS)
int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803248:	e1a04002 	mov	r4, r2
3480324c:	e1a05003 	mov	r5, r3
	int load_baudrate, current_baudrate;

	load_baudrate = current_baudrate = gd->baudrate;
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
34803250:	eb0010d5 	bl	348075ac <getenv>
34803254:	e3500000 	cmp	r0, #0
34803258:	0a000003 	beq	3480326c <do_load_serial+0x2c>
3480325c:	e5d03000 	ldrb	r3, [r0]
34803260:	e3530031 	cmp	r3, #49	; 0x31
		do_echo = 1;
34803264:	03a02001 	moveq	r2, #1
	int load_baudrate, current_baudrate;

	load_baudrate = current_baudrate = gd->baudrate;
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
34803268:	0a000000 	beq	34803270 <do_load_serial+0x30>
		do_echo = 1;
	} else {
		do_echo = 0;
3480326c:	e3a02000 	mov	r2, #0
34803270:	e59f3090 	ldr	r3, [pc, #144]	; 34803308 <do_load_serial+0xc8>
			if (getc() == '\r')
				break;
		}
	}
#else	/* ! CONFIG_SYS_LOADS_BAUD_CHANGE */
	if (argc == 2) {
34803274:	e3540002 	cmp	r4, #2
#endif

	if (((env_echo = getenv("loads_echo")) != NULL) && (*env_echo == '1')) {
		do_echo = 1;
	} else {
		do_echo = 0;
34803278:	e5832000 	str	r2, [r3]
/* -------------------------------------------------------------------- */

#if defined(CONFIG_CMD_LOADS)
int do_load_serial (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	long offset = 0;
3480327c:	13a04000 	movne	r4, #0
			if (getc() == '\r')
				break;
		}
	}
#else	/* ! CONFIG_SYS_LOADS_BAUD_CHANGE */
	if (argc == 2) {
34803280:	1a000004 	bne	34803298 <do_load_serial+0x58>
		offset = simple_strtol(argv[1], NULL, 16);
34803284:	e5950004 	ldr	r0, [r5, #4]
34803288:	e3a01000 	mov	r1, #0
3480328c:	e3a02010 	mov	r2, #16
34803290:	eb006647 	bl	3481cbb4 <simple_strtol>
34803294:	e1a04000 	mov	r4, r0
	}
#endif	/* CONFIG_SYS_LOADS_BAUD_CHANGE */

	printf ("## Ready for S-Record download ...\n");
34803298:	e59f006c 	ldr	r0, [pc, #108]	; 3480330c <do_load_serial+0xcc>
3480329c:	eb0017b0 	bl	34809164 <printf>

	addr = load_serial (offset);
348032a0:	e1a00004 	mov	r0, r4
348032a4:	ebffff60 	bl	3480302c <load_serial>
348032a8:	e3a04064 	mov	r4, #100	; 0x64
348032ac:	e1a05000 	mov	r5, r0
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
		if (tstc()) {
348032b0:	eb00178e 	bl	348090f0 <tstc>
348032b4:	e3500000 	cmp	r0, #0
348032b8:	0a000000 	beq	348032c0 <do_load_serial+0x80>
			(void) getc();
348032bc:	eb001782 	bl	348090cc <getc>
		}
		udelay(1000);
348032c0:	e3a00ffa 	mov	r0, #1000	; 0x3e8
348032c4:	eb0063ad 	bl	3481c180 <udelay>
	/*
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
348032c8:	e2544001 	subs	r4, r4, #1
348032cc:	1afffff7 	bne	348032b0 <do_load_serial+0x70>
			(void) getc();
		}
		udelay(1000);
	}

	if (addr == ~0) {
348032d0:	e3750001 	cmn	r5, #1
348032d4:	1a000003 	bne	348032e8 <do_load_serial+0xa8>
		printf ("## S-Record download aborted\n");
348032d8:	e59f0030 	ldr	r0, [pc, #48]	; 34803310 <do_load_serial+0xd0>
348032dc:	eb0017a0 	bl	34809164 <printf>
		rcode = 1;
348032e0:	e3a00001 	mov	r0, #1
348032e4:	e8bd8038 	pop	{r3, r4, r5, pc}
	} else {
		printf ("## Start Addr      = 0x%08lX\n", addr);
348032e8:	e1a01005 	mov	r1, r5
348032ec:	e59f0020 	ldr	r0, [pc, #32]	; 34803314 <do_load_serial+0xd4>
348032f0:	eb00179b 	bl	34809164 <printf>
		load_addr = addr;
348032f4:	e59f301c 	ldr	r3, [pc, #28]	; 34803318 <do_load_serial+0xd8>
{
	long offset = 0;
	ulong addr;
	int i;
	char *env_echo;
	int rcode = 0;
348032f8:	e1a00004 	mov	r0, r4
	if (addr == ~0) {
		printf ("## S-Record download aborted\n");
		rcode = 1;
	} else {
		printf ("## Start Addr      = 0x%08lX\n", addr);
		load_addr = addr;
348032fc:	e5835000 	str	r5, [r3]
				break;
		}
	}
#endif
	return rcode;
}
34803300:	e8bd8038 	pop	{r3, r4, r5, pc}
34803304:	34823998 	.word	0x34823998
34803308:	348283cc 	.word	0x348283cc
3480330c:	348239a3 	.word	0x348239a3
34803310:	348239c7 	.word	0x348239c7
34803314:	348239e5 	.word	0x348239e5
34803318:	348284b4 	.word	0x348284b4

3480331c <send_pad>:

	return offset;
}

void send_pad (void)
{
3480331c:	e92d4038 	push	{r3, r4, r5, lr}
34803320:	e59f501c 	ldr	r5, [pc, #28]	; 34803344 <send_pad+0x28>
34803324:	e595400c 	ldr	r4, [r5, #12]
	int count = his_pad_count;

	while (count-- > 0)
34803328:	ea000002 	b	34803338 <send_pad+0x1c>
		putc (his_pad_char);
3480332c:	e5d50010 	ldrb	r0, [r5, #16]
34803330:	eb001777 	bl	34809114 <putc>
34803334:	e2444001 	sub	r4, r4, #1

void send_pad (void)
{
	int count = his_pad_count;

	while (count-- > 0)
34803338:	e3540000 	cmp	r4, #0
3480333c:	cafffffa 	bgt	3480332c <send_pad+0x10>
		putc (his_pad_char);
}
34803340:	e8bd8038 	pop	{r3, r4, r5, pc}
34803344:	34829a34 	.word	0x34829a34

34803348 <ktrans>:

/* converts escaped kermit char to binary char */
char ktrans (char in)
{
	if ((in & 0x60) == 0x40) {
34803348:	e2003060 	and	r3, r0, #96	; 0x60
3480334c:	e3530040 	cmp	r3, #64	; 0x40
		return (char) (in & ~0x40);
34803350:	020000bf 	andeq	r0, r0, #191	; 0xbf
}

/* converts escaped kermit char to binary char */
char ktrans (char in)
{
	if ((in & 0x60) == 0x40) {
34803354:	012fff1e 	bxeq	lr
		return (char) (in & ~0x40);
	} else if ((in & 0x7f) == 0x3f) {
34803358:	e200307f 	and	r3, r0, #127	; 0x7f
3480335c:	e353003f 	cmp	r3, #63	; 0x3f
		return (char) (in | 0x40);
34803360:	03800040 	orreq	r0, r0, #64	; 0x40
	} else
		return in;
}
34803364:	e12fff1e 	bx	lr

34803368 <chk1>:

int chk1 (char *buffer)
{
	int total = 0;
34803368:	e3a03000 	mov	r3, #0

	while (*buffer) {
3480336c:	ea000000 	b	34803374 <chk1+0xc>
		total += *buffer++;
34803370:	e0833002 	add	r3, r3, r2

int chk1 (char *buffer)
{
	int total = 0;

	while (*buffer) {
34803374:	e4d02001 	ldrb	r2, [r0], #1
34803378:	e3520000 	cmp	r2, #0
3480337c:	1afffffb 	bne	34803370 <chk1+0x8>
		total += *buffer++;
	}
	return (int) ((total + ((total >> 6) & 0x03)) & 0x3f);
34803380:	e7e12353 	ubfx	r2, r3, #6, #2
34803384:	e0823003 	add	r3, r2, r3
}
34803388:	e203003f 	and	r0, r3, #63	; 0x3f
3480338c:	e12fff1e 	bx	lr

34803390 <s1_sendpacket>:

void s1_sendpacket (char *packet)
{
34803390:	e92d4010 	push	{r4, lr}
34803394:	e1a04000 	mov	r4, r0
	send_pad ();
34803398:	ebffffdf 	bl	3480331c <send_pad>
	while (*packet) {
3480339c:	ea000000 	b	348033a4 <s1_sendpacket+0x14>
		putc (*packet++);
348033a0:	eb00175b 	bl	34809114 <putc>
}

void s1_sendpacket (char *packet)
{
	send_pad ();
	while (*packet) {
348033a4:	e4d40001 	ldrb	r0, [r4], #1
348033a8:	e3500000 	cmp	r0, #0
348033ac:	1afffffb 	bne	348033a0 <s1_sendpacket+0x10>
		putc (*packet++);
	}
}
348033b0:	e8bd8010 	pop	{r4, pc}

348033b4 <send_ack>:

static char a_b[24];
void send_ack (int n)
{
348033b4:	e92d4070 	push	{r4, r5, r6, lr}
	a_b[0] = START_CHAR;
348033b8:	e59f404c 	ldr	r4, [pc, #76]	; 3480340c <send_ack+0x58>
348033bc:	e3a03001 	mov	r3, #1
348033c0:	e5c43014 	strb	r3, [r4, #20]
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
348033c4:	e2800020 	add	r0, r0, #32

static char a_b[24];
void send_ack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
348033c8:	e2833022 	add	r3, r3, #34	; 0x22
348033cc:	e5c43015 	strb	r3, [r4, #21]
	a_b[2] = tochar (n);
348033d0:	e5c40016 	strb	r0, [r4, #22]
	a_b[3] = ACK_TYPE;
348033d4:	e2833036 	add	r3, r3, #54	; 0x36
	a_b[4] = '\0';
348033d8:	e3a05000 	mov	r5, #0
	a_b[4] = tochar (chk1 (&a_b[1]));
348033dc:	e2840015 	add	r0, r4, #21
void send_ack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
348033e0:	e5c43017 	strb	r3, [r4, #23]
	a_b[4] = '\0';
348033e4:	e5c45018 	strb	r5, [r4, #24]
	a_b[4] = tochar (chk1 (&a_b[1]));
348033e8:	ebffffde 	bl	34803368 <chk1>
348033ec:	e2800020 	add	r0, r0, #32
348033f0:	e5c40018 	strb	r0, [r4, #24]
	a_b[5] = his_eol;
348033f4:	e5d4302c 	ldrb	r3, [r4, #44]	; 0x2c
	a_b[6] = '\0';
	s1_sendpacket (a_b);
348033f8:	e59f0010 	ldr	r0, [pc, #16]	; 34803410 <send_ack+0x5c>
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
348033fc:	e5c43019 	strb	r3, [r4, #25]
	a_b[6] = '\0';
34803400:	e5c4501a 	strb	r5, [r4, #26]
	s1_sendpacket (a_b);
}
34803404:	e8bd4070 	pop	{r4, r5, r6, lr}
	a_b[3] = ACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
	a_b[6] = '\0';
	s1_sendpacket (a_b);
34803408:	eaffffe0 	b	34803390 <s1_sendpacket>
3480340c:	34829a34 	.word	0x34829a34
34803410:	34829a48 	.word	0x34829a48

34803414 <send_nack>:
}

void send_nack (int n)
{
34803414:	e92d4070 	push	{r4, r5, r6, lr}
	a_b[0] = START_CHAR;
34803418:	e59f404c 	ldr	r4, [pc, #76]	; 3480346c <send_nack+0x58>
3480341c:	e3a03001 	mov	r3, #1
34803420:	e5c43014 	strb	r3, [r4, #20]
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
34803424:	e2800020 	add	r0, r0, #32
}

void send_nack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
34803428:	e2833022 	add	r3, r3, #34	; 0x22
3480342c:	e5c43015 	strb	r3, [r4, #21]
	a_b[2] = tochar (n);
34803430:	e5c40016 	strb	r0, [r4, #22]
	a_b[3] = NACK_TYPE;
34803434:	e283302b 	add	r3, r3, #43	; 0x2b
	a_b[4] = '\0';
34803438:	e3a05000 	mov	r5, #0
	a_b[4] = tochar (chk1 (&a_b[1]));
3480343c:	e2840015 	add	r0, r4, #21
void send_nack (int n)
{
	a_b[0] = START_CHAR;
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = NACK_TYPE;
34803440:	e5c43017 	strb	r3, [r4, #23]
	a_b[4] = '\0';
34803444:	e5c45018 	strb	r5, [r4, #24]
	a_b[4] = tochar (chk1 (&a_b[1]));
34803448:	ebffffc6 	bl	34803368 <chk1>
3480344c:	e2800020 	add	r0, r0, #32
34803450:	e5c40018 	strb	r0, [r4, #24]
	a_b[5] = his_eol;
34803454:	e5d4302c 	ldrb	r3, [r4, #44]	; 0x2c
	a_b[6] = '\0';
	s1_sendpacket (a_b);
34803458:	e59f0010 	ldr	r0, [pc, #16]	; 34803470 <send_nack+0x5c>
	a_b[1] = tochar (3);
	a_b[2] = tochar (n);
	a_b[3] = NACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
3480345c:	e5c43019 	strb	r3, [r4, #25]
	a_b[6] = '\0';
34803460:	e5c4501a 	strb	r5, [r4, #26]
	s1_sendpacket (a_b);
}
34803464:	e8bd4070 	pop	{r4, r5, r6, lr}
	a_b[3] = NACK_TYPE;
	a_b[4] = '\0';
	a_b[4] = tochar (chk1 (&a_b[1]));
	a_b[5] = his_eol;
	a_b[6] = '\0';
	s1_sendpacket (a_b);
34803468:	eaffffc8 	b	34803390 <s1_sendpacket>
3480346c:	34829a34 	.word	0x34829a34
34803470:	34829a48 	.word	0x34829a48

34803474 <k_data_init>:


/* k_data_* simply handles the kermit escape translations */
static int k_data_escape, k_data_escape_saved;
void k_data_init (void)
{
34803474:	e92d4008 	push	{r3, lr}
	k_data_escape = 0;
34803478:	e59f3010 	ldr	r3, [pc, #16]	; 34803490 <k_data_init+0x1c>
3480347c:	e3a02000 	mov	r2, #0
34803480:	e5832030 	str	r2, [r3, #48]	; 0x30
	os_data_init ();
34803484:	e5933034 	ldr	r3, [r3, #52]	; 0x34
34803488:	e12fff33 	blx	r3
}
3480348c:	e8bd8008 	pop	{r3, pc}
34803490:	34829a34 	.word	0x34829a34

34803494 <k_data_save>:

void k_data_save (void)
{
	k_data_escape_saved = k_data_escape;
34803494:	e59f3018 	ldr	r3, [pc, #24]	; 348034b4 <k_data_save+0x20>
34803498:	e5932030 	ldr	r2, [r3, #48]	; 0x30
3480349c:	e5832038 	str	r2, [r3, #56]	; 0x38
	os_data_addr = bin_start_address;
}

static void os_data_save (void)
{
	os_data_state_saved = os_data_state;
348034a0:	e5932000 	ldr	r2, [r3]
348034a4:	e583203c 	str	r2, [r3, #60]	; 0x3c
	os_data_addr_saved = os_data_addr;
348034a8:	e5932004 	ldr	r2, [r3, #4]
348034ac:	e5832040 	str	r2, [r3, #64]	; 0x40

void k_data_save (void)
{
	k_data_escape_saved = k_data_escape;
	os_data_save ();
}
348034b0:	e12fff1e 	bx	lr
348034b4:	34829a34 	.word	0x34829a34

348034b8 <k_data_restore>:

void k_data_restore (void)
{
	k_data_escape = k_data_escape_saved;
348034b8:	e59f3018 	ldr	r3, [pc, #24]	; 348034d8 <k_data_restore+0x20>
348034bc:	e5932038 	ldr	r2, [r3, #56]	; 0x38
348034c0:	e5832030 	str	r2, [r3, #48]	; 0x30
	os_data_addr_saved = os_data_addr;
}

static void os_data_restore (void)
{
	os_data_state = os_data_state_saved;
348034c4:	e593203c 	ldr	r2, [r3, #60]	; 0x3c
348034c8:	e5832000 	str	r2, [r3]
	os_data_addr = os_data_addr_saved;
348034cc:	e5932040 	ldr	r2, [r3, #64]	; 0x40
348034d0:	e5832004 	str	r2, [r3, #4]

void k_data_restore (void)
{
	k_data_escape = k_data_escape_saved;
	os_data_restore ();
}
348034d4:	e12fff1e 	bx	lr
348034d8:	34829a34 	.word	0x34829a34

348034dc <k_data_char>:

void k_data_char (char new_char)
{
348034dc:	e92d4010 	push	{r4, lr}
	if (k_data_escape) {
348034e0:	e59f4040 	ldr	r4, [pc, #64]	; 34803528 <k_data_char+0x4c>
348034e4:	e5942030 	ldr	r2, [r4, #48]	; 0x30
348034e8:	e3520000 	cmp	r2, #0
348034ec:	0a000004 	beq	34803504 <k_data_char+0x28>
		/* last char was escape - translate this character */
		os_data_char (ktrans (new_char));
348034f0:	ebffff94 	bl	34803348 <ktrans>
348034f4:	e5943044 	ldr	r3, [r4, #68]	; 0x44
348034f8:	e12fff33 	blx	r3
		k_data_escape = 0;
348034fc:	e3a03000 	mov	r3, #0
34803500:	ea000003 	b	34803514 <k_data_char+0x38>
	} else {
		if (new_char == his_quote) {
34803504:	e5d42048 	ldrb	r2, [r4, #72]	; 0x48
34803508:	e1520000 	cmp	r2, r0
3480350c:	1a000002 	bne	3480351c <k_data_char+0x40>
			/* this char is escape - remember */
			k_data_escape = 1;
34803510:	e3a03001 	mov	r3, #1
34803514:	e5843030 	str	r3, [r4, #48]	; 0x30
34803518:	e8bd8010 	pop	{r4, pc}
		} else {
			/* otherwise send this char as-is */
			os_data_char (new_char);
3480351c:	e5943044 	ldr	r3, [r4, #68]	; 0x44
34803520:	e12fff33 	blx	r3
34803524:	e8bd8010 	pop	{r4, pc}
34803528:	34829a34 	.word	0x34829a34

3480352c <handle_send_packet>:
{
	int length = 3;
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
3480352c:	e59f31b8 	ldr	r3, [pc, #440]	; 348036ec <handle_send_packet+0x1c0>
34803530:	e3a0200d 	mov	r2, #13
char *send_ptr;

/* handle_send_packet interprits the protocol info and builds and
   sends an appropriate ack for what we can do */
void handle_send_packet (int n)
{
34803534:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	int length = 3;
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
34803538:	e5c3202c 	strb	r2, [r3, #44]	; 0x2c
	his_pad_count = 0;
3480353c:	e3a02000 	mov	r2, #0
	his_pad_char = '\0';
	his_quote = K_ESCAPE;

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
34803540:	e593104c 	ldr	r1, [r3, #76]	; 0x4c
	int length = 3;
	int bytes;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
34803544:	e583200c 	str	r2, [r3, #12]
	his_pad_char = '\0';
34803548:	e5c32010 	strb	r2, [r3, #16]
	his_quote = K_ESCAPE;
3480354c:	e2822023 	add	r2, r2, #35	; 0x23
34803550:	e5c32048 	strb	r2, [r3, #72]	; 0x48

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
34803554:	e2832063 	add	r2, r3, #99	; 0x63
34803558:	e1510002 	cmp	r1, r2
		--send_ptr;
3480355c:	02832062 	addeq	r2, r3, #98	; 0x62
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
34803560:	e59f4184 	ldr	r4, [pc, #388]	; 348036ec <handle_send_packet+0x1c0>
	his_pad_char = '\0';
	his_quote = K_ESCAPE;

	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
		--send_ptr;
34803564:	0583204c 	streq	r2, [r3, #76]	; 0x4c
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
34803568:	e594504c 	ldr	r5, [r4, #76]	; 0x4c
3480356c:	e2843050 	add	r3, r4, #80	; 0x50
34803570:	e0635005 	rsb	r5, r3, r5
	do {
		if (bytes-- <= 0)
34803574:	e3550000 	cmp	r5, #0
char *send_ptr;

/* handle_send_packet interprits the protocol info and builds and
   sends an appropriate ack for what we can do */
void handle_send_packet (int n)
{
34803578:	e1a07000 	mov	r7, r0
	int length = 3;
3480357c:	d3a06003 	movle	r6, #3
	/* ignore last character if it filled the buffer */
	if (send_ptr == &send_parms[SEND_DATA_SIZE - 1])
		--send_ptr;
	bytes = send_ptr - send_parms;	/* how many bytes we'll process */
	do {
		if (bytes-- <= 0)
34803580:	da000040 	ble	34803688 <handle_send_packet+0x15c>
			break;
		/* handle MAXL - max length */
		/* ignore what he says - most I'll take (here) is 94 */
		a_b[++length] = tochar (94);
34803584:	e3a0307e 	mov	r3, #126	; 0x7e
		if (bytes-- <= 0)
34803588:	e2555001 	subs	r5, r5, #1
	do {
		if (bytes-- <= 0)
			break;
		/* handle MAXL - max length */
		/* ignore what he says - most I'll take (here) is 94 */
		a_b[++length] = tochar (94);
3480358c:	e5c43018 	strb	r3, [r4, #24]
34803590:	03a06004 	moveq	r6, #4
		if (bytes-- <= 0)
34803594:	0a00003b 	beq	34803688 <handle_send_packet+0x15c>
			break;
		/* handle TIME - time you should wait for my packets */
		/* ignore what he says - don't wait for my ack longer than 1 second */
		a_b[++length] = tochar (1);
34803598:	e3a03021 	mov	r3, #33	; 0x21
		if (bytes-- <= 0)
3480359c:	e2555001 	subs	r5, r5, #1
		a_b[++length] = tochar (94);
		if (bytes-- <= 0)
			break;
		/* handle TIME - time you should wait for my packets */
		/* ignore what he says - don't wait for my ack longer than 1 second */
		a_b[++length] = tochar (1);
348035a0:	e5c43019 	strb	r3, [r4, #25]
348035a4:	03a06005 	moveq	r6, #5
		if (bytes-- <= 0)
348035a8:	0a000036 	beq	34803688 <handle_send_packet+0x15c>
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar (send_parms[2]);
348035ac:	e5d43052 	ldrb	r3, [r4, #82]	; 0x52
		a_b[++length] = tochar (0);
		if (bytes-- <= 0)
348035b0:	e2555001 	subs	r5, r5, #1
		a_b[++length] = tochar (1);
		if (bytes-- <= 0)
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar (send_parms[2]);
348035b4:	e2433020 	sub	r3, r3, #32
348035b8:	e20330ff 	and	r3, r3, #255	; 0xff
348035bc:	e584300c 	str	r3, [r4, #12]
		a_b[++length] = tochar (0);
348035c0:	e3a03020 	mov	r3, #32
348035c4:	e5c4301a 	strb	r3, [r4, #26]
348035c8:	03a06006 	moveq	r6, #6
		if (bytes-- <= 0)
348035cc:	0a00002d 	beq	34803688 <handle_send_packet+0x15c>
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans (send_parms[3]);
348035d0:	e5d40053 	ldrb	r0, [r4, #83]	; 0x53
348035d4:	ebffff5b 	bl	34803348 <ktrans>
			break;
		/* handle NPAD - number of pad chars I need */
		/* remember what he says - I need none */
		his_pad_count = untochar (send_parms[2]);
		a_b[++length] = tochar (0);
		if (bytes-- <= 0)
348035d8:	e2455001 	sub	r5, r5, #1
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans (send_parms[3]);
		a_b[++length] = 0x40;	/* He should ignore this */
348035dc:	e3a03040 	mov	r3, #64	; 0x40
		if (bytes-- <= 0)
348035e0:	e3550000 	cmp	r5, #0
		a_b[++length] = tochar (0);
		if (bytes-- <= 0)
			break;
		/* handle PADC - pad chars I need */
		/* remember what he says - I need none */
		his_pad_char = ktrans (send_parms[3]);
348035e4:	e5c40010 	strb	r0, [r4, #16]
		a_b[++length] = 0x40;	/* He should ignore this */
348035e8:	e5c4301b 	strb	r3, [r4, #27]
348035ec:	03a06007 	moveq	r6, #7
		if (bytes-- <= 0)
348035f0:	0a000024 	beq	34803688 <handle_send_packet+0x15c>
			break;
		/* handle EOL - end of line he needs */
		/* remember what he says - I need CR */
		his_eol = untochar (send_parms[4]);
348035f4:	e5d43054 	ldrb	r3, [r4, #84]	; 0x54
		a_b[++length] = tochar (END_CHAR);
		if (bytes-- <= 0)
348035f8:	e2555001 	subs	r5, r5, #1
		a_b[++length] = 0x40;	/* He should ignore this */
		if (bytes-- <= 0)
			break;
		/* handle EOL - end of line he needs */
		/* remember what he says - I need CR */
		his_eol = untochar (send_parms[4]);
348035fc:	e2433020 	sub	r3, r3, #32
34803600:	e5c4302c 	strb	r3, [r4, #44]	; 0x2c
		a_b[++length] = tochar (END_CHAR);
34803604:	e3a0302d 	mov	r3, #45	; 0x2d
34803608:	e5c4301c 	strb	r3, [r4, #28]
3480360c:	03a06008 	moveq	r6, #8
		if (bytes-- <= 0)
34803610:	0a00001c 	beq	34803688 <handle_send_packet+0x15c>
			break;
		/* handle QCTL - quote control char he'll use */
		/* remember what he says - I'll use '#' */
		his_quote = send_parms[5];
34803614:	e5d43055 	ldrb	r3, [r4, #85]	; 0x55
		a_b[++length] = '#';
		if (bytes-- <= 0)
34803618:	e2555001 	subs	r5, r5, #1
		a_b[++length] = tochar (END_CHAR);
		if (bytes-- <= 0)
			break;
		/* handle QCTL - quote control char he'll use */
		/* remember what he says - I'll use '#' */
		his_quote = send_parms[5];
3480361c:	e5c43048 	strb	r3, [r4, #72]	; 0x48
		a_b[++length] = '#';
34803620:	e3a03023 	mov	r3, #35	; 0x23
34803624:	e5c4301d 	strb	r3, [r4, #29]
34803628:	03a06009 	moveq	r6, #9
		if (bytes-- <= 0)
3480362c:	0a000015 	beq	34803688 <handle_send_packet+0x15c>
			break;
		/* handle QBIN - 8-th bit prefixing */
		/* ignore what he says - I refuse */
		a_b[++length] = 'N';
34803630:	e283302b 	add	r3, r3, #43	; 0x2b
		if (bytes-- <= 0)
34803634:	e2555001 	subs	r5, r5, #1
		a_b[++length] = '#';
		if (bytes-- <= 0)
			break;
		/* handle QBIN - 8-th bit prefixing */
		/* ignore what he says - I refuse */
		a_b[++length] = 'N';
34803638:	e5c4301e 	strb	r3, [r4, #30]
3480363c:	03a0600a 	moveq	r6, #10
		if (bytes-- <= 0)
34803640:	0a000010 	beq	34803688 <handle_send_packet+0x15c>
			break;
		/* handle CHKT - the clock check type */
		/* ignore what he says - I do type 1 (for now) */
		a_b[++length] = '1';
34803644:	e3a02031 	mov	r2, #49	; 0x31
		if (bytes-- <= 0)
34803648:	e2555001 	subs	r5, r5, #1
		a_b[++length] = 'N';
		if (bytes-- <= 0)
			break;
		/* handle CHKT - the clock check type */
		/* ignore what he says - I do type 1 (for now) */
		a_b[++length] = '1';
3480364c:	e5c4201f 	strb	r2, [r4, #31]
34803650:	03a0600b 	moveq	r6, #11
		if (bytes-- <= 0)
34803654:	0a00000b 	beq	34803688 <handle_send_packet+0x15c>
			break;
		/* handle REPT - the repeat prefix */
		/* ignore what he says - I refuse (for now) */
		a_b[++length] = 'N';
		if (bytes-- <= 0)
34803658:	e3550001 	cmp	r5, #1
		a_b[++length] = '1';
		if (bytes-- <= 0)
			break;
		/* handle REPT - the repeat prefix */
		/* ignore what he says - I refuse (for now) */
		a_b[++length] = 'N';
3480365c:	e5c43020 	strb	r3, [r4, #32]
34803660:	03a0600c 	moveq	r6, #12
		if (bytes-- <= 0)
34803664:	0a000007 	beq	34803688 <handle_send_packet+0x15c>
			break;
		/* handle CAPAS - the capabilities mask */
		/* ignore what he says - I only do long packets - I don't do windows */
		a_b[++length] = tochar (2);	/* only long packets */
34803668:	e3a02022 	mov	r2, #34	; 0x22
3480366c:	e5c42021 	strb	r2, [r4, #33]	; 0x21
		a_b[++length] = tochar (0);	/* no windows */
34803670:	e3a02020 	mov	r2, #32
34803674:	e5c42022 	strb	r2, [r4, #34]	; 0x22
		a_b[++length] = tochar (94);	/* large packet msb */
34803678:	e282205e 	add	r2, r2, #94	; 0x5e
3480367c:	e5c42023 	strb	r2, [r4, #35]	; 0x23
		a_b[++length] = tochar (94);	/* large packet lsb */
34803680:	e5c42024 	strb	r2, [r4, #36]	; 0x24
34803684:	e3a06010 	mov	r6, #16
	} while (0);

	a_b[0] = START_CHAR;
34803688:	e59f405c 	ldr	r4, [pc, #92]	; 348036ec <handle_send_packet+0x1c0>
3480368c:	e3a03001 	mov	r3, #1
34803690:	e5c43014 	strb	r3, [r4, #20]
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
34803694:	e2877020 	add	r7, r7, #32
		a_b[++length] = tochar (94);	/* large packet msb */
		a_b[++length] = tochar (94);	/* large packet lsb */
	} while (0);

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
34803698:	e2863020 	add	r3, r6, #32
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
3480369c:	e2866001 	add	r6, r6, #1
		a_b[++length] = tochar (94);	/* large packet msb */
		a_b[++length] = tochar (94);	/* large packet lsb */
	} while (0);

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
348036a0:	e5c43015 	strb	r3, [r4, #21]
	a_b[2] = tochar (n);
348036a4:	e5c47016 	strb	r7, [r4, #22]
	a_b[3] = ACK_TYPE;
348036a8:	e3a03059 	mov	r3, #89	; 0x59
	a_b[++length] = '\0';
348036ac:	e0847006 	add	r7, r4, r6
348036b0:	e3a05000 	mov	r5, #0
	} while (0);

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
348036b4:	e5c43017 	strb	r3, [r4, #23]
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
348036b8:	e2840015 	add	r0, r4, #21

	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
348036bc:	e5c75014 	strb	r5, [r7, #20]
	a_b[length] = tochar (chk1 (&a_b[1]));
348036c0:	ebffff28 	bl	34803368 <chk1>
	a_b[++length] = his_eol;
348036c4:	e2866001 	add	r6, r6, #1
	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
348036c8:	e2800020 	add	r0, r0, #32
	a_b[++length] = his_eol;
348036cc:	e5d4302c 	ldrb	r3, [r4, #44]	; 0x2c
	a_b[0] = START_CHAR;
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
348036d0:	e5c70014 	strb	r0, [r7, #20]
	a_b[++length] = his_eol;
348036d4:	e0846006 	add	r6, r4, r6
	a_b[++length] = '\0';
	s1_sendpacket (a_b);
348036d8:	e2840014 	add	r0, r4, #20
	a_b[1] = tochar (length);
	a_b[2] = tochar (n);
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
	a_b[++length] = his_eol;
348036dc:	e5c63014 	strb	r3, [r6, #20]
	a_b[++length] = '\0';
348036e0:	e5c65015 	strb	r5, [r6, #21]
	s1_sendpacket (a_b);
}
348036e4:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
	a_b[3] = ACK_TYPE;
	a_b[++length] = '\0';
	a_b[length] = tochar (chk1 (&a_b[1]));
	a_b[++length] = his_eol;
	a_b[++length] = '\0';
	s1_sendpacket (a_b);
348036e8:	eaffff28 	b	34803390 <s1_sendpacket>
348036ec:	34829a34 	.word	0x34829a34

348036f0 <do_load_serial_bin>:
int  his_pad_count;  /* number of pad chars he needs */
char his_pad_char;   /* pad chars he needs */
char his_quote;      /* quote chars he'll use */

int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348036f0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}

	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
	offset = CONFIG_SYS_LOAD_ADDR;

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
348036f4:	e59f0404 	ldr	r0, [pc, #1028]	; 34803b00 <do_load_serial_bin+0x410>
int  his_pad_count;  /* number of pad chars he needs */
char his_pad_char;   /* pad chars he needs */
char his_quote;      /* quote chars he'll use */

int do_load_serial_bin (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348036f8:	e24dd028 	sub	sp, sp, #40	; 0x28
348036fc:	e1a05002 	mov	r5, r2
34803700:	e1a06003 	mov	r6, r3

	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
	offset = CONFIG_SYS_LOAD_ADDR;

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
34803704:	eb000fa8 	bl	348075ac <getenv>
34803708:	e3500000 	cmp	r0, #0
	int load_baudrate, current_baudrate;
	int rcode = 0;
	char *s;

	/* pre-set offset from CONFIG_SYS_LOAD_ADDR */
	offset = CONFIG_SYS_LOAD_ADDR;
3480370c:	03a0430d 	moveq	r4, #872415232	; 0x34000000

	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
34803710:	0a000003 	beq	34803724 <do_load_serial_bin+0x34>
		offset = simple_strtoul(s, NULL, 16);
34803714:	e3a01000 	mov	r1, #0
34803718:	e3a02010 	mov	r2, #16
3480371c:	eb0064db 	bl	3481ca90 <simple_strtoul>
34803720:	e1a04000 	mov	r4, r0
	}

	load_baudrate = current_baudrate = gd->baudrate;

	if (argc >= 2) {
34803724:	e3550001 	cmp	r5, #1
	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
		offset = simple_strtoul(s, NULL, 16);
	}

	load_baudrate = current_baudrate = gd->baudrate;
34803728:	e5987008 	ldr	r7, [r8, #8]

	if (argc >= 2) {
3480372c:	da0000eb 	ble	34803ae0 <do_load_serial_bin+0x3f0>
		offset = simple_strtoul(argv[1], NULL, 16);
34803730:	e5960004 	ldr	r0, [r6, #4]
34803734:	e3a01000 	mov	r1, #0
34803738:	e3a02010 	mov	r2, #16
3480373c:	eb0064d3 	bl	3481ca90 <simple_strtoul>
	}
	if (argc == 3) {
34803740:	e3550003 	cmp	r5, #3
	}

	load_baudrate = current_baudrate = gd->baudrate;

	if (argc >= 2) {
		offset = simple_strtoul(argv[1], NULL, 16);
34803744:	e1a04000 	mov	r4, r0
	}
	if (argc == 3) {
34803748:	1a0000e4 	bne	34803ae0 <do_load_serial_bin+0x3f0>
		load_baudrate = (int)simple_strtoul(argv[2], NULL, 10);
3480374c:	e5960008 	ldr	r0, [r6, #8]
34803750:	e3a01000 	mov	r1, #0
34803754:	e3a0200a 	mov	r2, #10
34803758:	eb0064cc 	bl	3481ca90 <simple_strtoul>

		/* default to current baudrate */
		if (load_baudrate == 0)
3480375c:	e2505000 	subs	r5, r0, #0
34803760:	0a0000de 	beq	34803ae0 <do_load_serial_bin+0x3f0>
			load_baudrate = current_baudrate;
	}

	if (load_baudrate != current_baudrate) {
34803764:	e1550007 	cmp	r5, r7
34803768:	0a00000b 	beq	3480379c <do_load_serial_bin+0xac>
		printf ("## Switch baudrate to %d bps and press ENTER ...\n",
3480376c:	e1a01005 	mov	r1, r5
34803770:	e59f038c 	ldr	r0, [pc, #908]	; 34803b04 <do_load_serial_bin+0x414>
34803774:	eb00167a 	bl	34809164 <printf>
			load_baudrate);
		udelay(50000);
34803778:	e30c0350 	movw	r0, #50000	; 0xc350
3480377c:	eb00627f 	bl	3481c180 <udelay>
		gd->baudrate = load_baudrate;
34803780:	e5885008 	str	r5, [r8, #8]
		serial_setbrg ();
34803784:	eb002bbb 	bl	3480e678 <serial_setbrg>
		udelay(50000);
34803788:	e30c0350 	movw	r0, #50000	; 0xc350
3480378c:	eb00627b 	bl	3481c180 <udelay>
		for (;;) {
			if (getc() == '\r')
34803790:	eb00164d 	bl	348090cc <getc>
34803794:	e350000d 	cmp	r0, #13
34803798:	1afffffc 	bne	34803790 <do_load_serial_bin+0xa0>
				break;
		}
	}

	if (strcmp(argv[0],"loady")==0) {
3480379c:	e5960000 	ldr	r0, [r6]
348037a0:	e59f1360 	ldr	r1, [pc, #864]	; 34803b08 <do_load_serial_bin+0x418>
348037a4:	eb0060f2 	bl	3481bb74 <strcmp>
348037a8:	e2509000 	subs	r9, r0, #0
348037ac:	1a000006 	bne	348037cc <do_load_serial_bin+0xdc>
		printf ("## Ready for binary (ymodem) download "
348037b0:	e1a01004 	mov	r1, r4
348037b4:	e1a02005 	mov	r2, r5
348037b8:	e59f034c 	ldr	r0, [pc, #844]	; 34803b0c <do_load_serial_bin+0x41c>
348037bc:	eb001668 	bl	34809164 <printf>
			"to 0x%08lX at %d bps...\n",
			offset,
			load_baudrate);

		addr = load_serial_ymodem (offset);
348037c0:	e1a00004 	mov	r0, r4
348037c4:	ebfffdd2 	bl	34802f14 <load_serial_ymodem>
348037c8:	ea0000b3 	b	34803a9c <do_load_serial_bin+0x3ac>

	} else {

		printf ("## Ready for binary (kermit) download "
348037cc:	e1a02005 	mov	r2, r5
348037d0:	e1a01004 	mov	r1, r4
348037d4:	e59f0334 	ldr	r0, [pc, #820]	; 34803b10 <do_load_serial_bin+0x420>
348037d8:	eb001661 	bl	34809164 <printf>
	}
}

static void set_kerm_bin_mode (unsigned long *addr)
{
	bin_start_address = (char *) addr;
348037dc:	e59fa330 	ldr	sl, [pc, #816]	; 34803b14 <do_load_serial_bin+0x424>
	os_data_init = bin_data_init;
348037e0:	e59f3330 	ldr	r3, [pc, #816]	; 34803b18 <do_load_serial_bin+0x428>
	int n, last_n;
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
348037e4:	e3a06000 	mov	r6, #0
}

static void set_kerm_bin_mode (unsigned long *addr)
{
	bin_start_address = (char *) addr;
	os_data_init = bin_data_init;
348037e8:	e58a3034 	str	r3, [sl, #52]	; 0x34
	os_data_char = bin_data_char;
348037ec:	e59f3328 	ldr	r3, [pc, #808]	; 34803b1c <do_load_serial_bin+0x42c>
	}
}

static void set_kerm_bin_mode (unsigned long *addr)
{
	bin_start_address = (char *) addr;
348037f0:	e58a4008 	str	r4, [sl, #8]
	os_data_init = bin_data_init;
	os_data_char = bin_data_char;
348037f4:	e58a3044 	str	r3, [sl, #68]	; 0x44
	int length;
	int n, last_n;
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
348037f8:	e3a0300d 	mov	r3, #13
348037fc:	e5ca302c 	strb	r3, [sl, #44]	; 0x2c
	his_pad_count = 0;
	his_pad_char = '\0';
	his_quote = K_ESCAPE;
34803800:	e2833016 	add	r3, r3, #22
34803804:	e5ca3048 	strb	r3, [sl, #72]	; 0x48
	int n, last_n;
	int len_lo, len_hi;

	/* initialize some protocol parameters */
	his_eol = END_CHAR;		/* default end of line character */
	his_pad_count = 0;
34803808:	e58a600c 	str	r6, [sl, #12]
	his_pad_char = '\0';
3480380c:	e5ca6010 	strb	r6, [sl, #16]
	his_quote = K_ESCAPE;

	/* initialize the k_recv and k_data state machine */
	done = 0;
	k_state = 0;
	k_data_init ();
34803810:	ebffff17 	bl	34803474 <k_data_init>
	k_state_saved = k_state;
	k_data_save ();
34803814:	ebffff1e 	bl	34803494 <k_data_save>
	n = 0;				/* just to get rid of a warning */
	last_n = -1;
34803818:	e3e09000 	mvn	r9, #0
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
			length = len_hi * 95 + len_lo;
3480381c:	e58d5004 	str	r5, [sp, #4]
34803820:	e1a05004 	mov	r5, r4
	 */

	/* enter main loop */
	while (!done) {
		/* set the send packet pointer to begining of send packet parms */
		send_ptr = send_parms;
34803824:	e59f12f4 	ldr	r1, [pc, #756]	; 34803b20 <do_load_serial_bin+0x430>
34803828:	e58a104c 	str	r1, [sl, #76]	; 0x4c
#endif

		/* get a packet */
		/* wait for the starting character or ^C */
		for (;;) {
			switch (getc ()) {
3480382c:	eb001626 	bl	348090cc <getc>
34803830:	e3500001 	cmp	r0, #1
34803834:	0a000002 	beq	34803844 <do_load_serial_bin+0x154>
34803838:	e3500003 	cmp	r0, #3
3480383c:	1afffffa 	bne	3480382c <do_load_serial_bin+0x13c>
34803840:	ea00006e 	b	34803a00 <do_load_serial_bin+0x310>
			}
		}
START:
		/* get length of packet */
		sum = 0;
		new_char = getc ();
34803844:	eb001620 	bl	348090cc <getc>
		if ((new_char & 0xE0) == 0)
34803848:	e6ef4070 	uxtb	r4, r0
3480384c:	e31400e0 	tst	r4, #224	; 0xe0
34803850:	0a000057 	beq	348039b4 <do_load_serial_bin+0x2c4>
			goto packet_error;
		sum += new_char & 0xff;
		length = untochar (new_char);
		/* get sequence number */
		new_char = getc ();
34803854:	eb00161c 	bl	348090cc <getc>
		if ((new_char & 0xE0) == 0)
34803858:	e6efb070 	uxtb	fp, r0
3480385c:	e31b00e0 	tst	fp, #224	; 0xe0
34803860:	0a000053 	beq	348039b4 <do_load_serial_bin+0x2c4>
			goto packet_error;
		sum += new_char & 0xff;
		n = untochar (new_char);
34803864:	e24b6020 	sub	r6, fp, #32
34803868:	e20660ff 	and	r6, r6, #255	; 0xff
		 * received.  Handling an invalid sequence number adds another layer
		 * of complexity that may not be needed - yet!  At this time, I'm hoping
		 * that I don't need to buffer the incoming data packets and can write
		 * the data into memory in real time.
		 */
		if (n == last_n) {
3480386c:	e1560009 	cmp	r6, r9
34803870:	1a000001 	bne	3480387c <do_load_serial_bin+0x18c>
			/* same sequence number, restore the previous state */
			k_state = k_state_saved;
			k_data_restore ();
34803874:	ebffff0f 	bl	348034b8 <k_data_restore>
34803878:	ea000000 	b	34803880 <do_load_serial_bin+0x190>
		} else {
			/* new sequence number, checkpoint the download */
			last_n = n;
			k_state_saved = k_state;
			k_data_save ();
3480387c:	ebffff04 	bl	34803494 <k_data_save>
		}
		/* END NEW CODE */

		/* get packet type */
		new_char = getc ();
34803880:	eb001611 	bl	348090cc <getc>
34803884:	e6ef9070 	uxtb	r9, r0
		if ((new_char & 0xE0) == 0)
34803888:	e31900e0 	tst	r9, #224	; 0xe0
3480388c:	0a000047 	beq	348039b0 <do_load_serial_bin+0x2c0>
		length = untochar (new_char);
		/* get sequence number */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
34803890:	e08bb004 	add	fp, fp, r4
		sum = 0;
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		length = untochar (new_char);
34803894:	e2444020 	sub	r4, r4, #32
34803898:	e20440ff 	and	r4, r4, #255	; 0xff
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		k_state = new_char;
		--length;
3480389c:	e2444002 	sub	r4, r4, #2
		/* check for extended length */
		if (length == -2) {
348038a0:	e3740002 	cmn	r4, #2

		/* get packet type */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
348038a4:	e08bb009 	add	fp, fp, r9
		k_state = new_char;
		--length;
		/* check for extended length */
		if (length == -2) {
348038a8:	1a000030 	bne	34803970 <do_load_serial_bin+0x280>
			/* (length byte was 0, decremented twice) */
			/* get the two length bytes */
			new_char = getc ();
348038ac:	eb001606 	bl	348090cc <getc>
			if ((new_char & 0xE0) == 0)
348038b0:	e6ef4070 	uxtb	r4, r0
348038b4:	e31400e0 	tst	r4, #224	; 0xe0
348038b8:	0a00003c 	beq	348039b0 <do_load_serial_bin+0x2c0>
				goto packet_error;
			sum += new_char & 0xff;
			len_hi = untochar (new_char);
			new_char = getc ();
348038bc:	eb001602 	bl	348090cc <getc>
			if ((new_char & 0xE0) == 0)
348038c0:	e6ef3070 	uxtb	r3, r0
348038c4:	e31300e0 	tst	r3, #224	; 0xe0
348038c8:	0a000038 	beq	348039b0 <do_load_serial_bin+0x2c0>
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
			length = len_hi * 95 + len_lo;
			/* check header checksum */
			new_char = getc ();
348038cc:	e58d3000 	str	r3, [sp]
348038d0:	eb0015fd 	bl	348090cc <getc>
348038d4:	e6ef0070 	uxtb	r0, r0
			if ((new_char & 0xE0) == 0)
348038d8:	e31000e0 	tst	r0, #224	; 0xe0
348038dc:	e59d3000 	ldr	r3, [sp]
348038e0:	0a000032 	beq	348039b0 <do_load_serial_bin+0x2c0>
			/* (length byte was 0, decremented twice) */
			/* get the two length bytes */
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
348038e4:	e084b00b 	add	fp, r4, fp
			len_hi = untochar (new_char);
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
348038e8:	e08bb003 	add	fp, fp, r3
			length = len_hi * 95 + len_lo;
			/* check header checksum */
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
348038ec:	e7e1235b 	ubfx	r2, fp, #6, #2
348038f0:	e082200b 	add	r2, r2, fp
348038f4:	e202203f 	and	r2, r2, #63	; 0x3f
348038f8:	e2822020 	add	r2, r2, #32
348038fc:	e1500002 	cmp	r0, r2
34803900:	1a00002a 	bne	348039b0 <do_load_serial_bin+0x2c0>
			/* get the two length bytes */
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_hi = untochar (new_char);
34803904:	e2444020 	sub	r4, r4, #32
34803908:	e20440ff 	and	r4, r4, #255	; 0xff
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
			length = len_hi * 95 + len_lo;
3480390c:	e3a0205f 	mov	r2, #95	; 0x5f
34803910:	e0040492 	mul	r4, r2, r4
			len_hi = untochar (new_char);
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
			len_lo = untochar (new_char);
34803914:	e2433020 	sub	r3, r3, #32
			length = len_hi * 95 + len_lo;
34803918:	e6e44073 	uxtab	r4, r4, r3
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
				goto packet_error;
			sum += new_char & 0xff;
3480391c:	e080b00b 	add	fp, r0, fp
34803920:	ea000012 	b	34803970 <do_load_serial_bin+0x280>
/* --length; */ /* new length includes only data and block check to come */
		}
		/* bring in rest of packet */
		while (length > 1) {
			new_char = getc ();
34803924:	eb0015e8 	bl	348090cc <getc>
34803928:	e6ef0070 	uxtb	r0, r0
			if ((new_char & 0xE0) == 0)
3480392c:	e31000e0 	tst	r0, #224	; 0xe0
34803930:	0a00001e 	beq	348039b0 <do_load_serial_bin+0x2c0>
				goto packet_error;
			sum += new_char & 0xff;
			--length;
			if (k_state == DATA_TYPE) {
34803934:	e3590044 	cmp	r9, #68	; 0x44
		/* bring in rest of packet */
		while (length > 1) {
			new_char = getc ();
			if ((new_char & 0xE0) == 0)
				goto packet_error;
			sum += new_char & 0xff;
34803938:	e08bb000 	add	fp, fp, r0
			--length;
3480393c:	e2444001 	sub	r4, r4, #1
			if (k_state == DATA_TYPE) {
34803940:	1a000001 	bne	3480394c <do_load_serial_bin+0x25c>
				/* pass on the data if this is a data packet */
				k_data_char (new_char);
34803944:	ebfffee4 	bl	348034dc <k_data_char>
34803948:	ea000008 	b	34803970 <do_load_serial_bin+0x280>
			} else if (k_state == SEND_TYPE) {
3480394c:	e3590053 	cmp	r9, #83	; 0x53
34803950:	1a000006 	bne	34803970 <do_load_serial_bin+0x280>
				/* save send pack in buffer as is */
				*send_ptr++ = new_char;
34803954:	e59a204c 	ldr	r2, [sl, #76]	; 0x4c
				/* if too much data, back off the pointer */
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
34803958:	e59f11c4 	ldr	r1, [pc, #452]	; 34803b24 <do_load_serial_bin+0x434>
			if (k_state == DATA_TYPE) {
				/* pass on the data if this is a data packet */
				k_data_char (new_char);
			} else if (k_state == SEND_TYPE) {
				/* save send pack in buffer as is */
				*send_ptr++ = new_char;
3480395c:	e1a03002 	mov	r3, r2
34803960:	e4c30001 	strb	r0, [r3], #1
				/* if too much data, back off the pointer */
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
34803964:	e1530001 	cmp	r3, r1
					--send_ptr;
34803968:	21a03002 	movcs	r3, r2
3480396c:	e58a304c 	str	r3, [sl, #76]	; 0x4c
				goto packet_error;
			sum += new_char & 0xff;
/* --length; */ /* new length includes only data and block check to come */
		}
		/* bring in rest of packet */
		while (length > 1) {
34803970:	e3540001 	cmp	r4, #1
34803974:	caffffea 	bgt	34803924 <do_load_serial_bin+0x234>
				if (send_ptr >= &send_parms[SEND_DATA_SIZE])
					--send_ptr;
			}
		}
		/* get and validate checksum character */
		new_char = getc ();
34803978:	eb0015d3 	bl	348090cc <getc>
3480397c:	e6ef0070 	uxtb	r0, r0
		if ((new_char & 0xE0) == 0)
34803980:	e31000e0 	tst	r0, #224	; 0xe0
34803984:	0a000009 	beq	348039b0 <do_load_serial_bin+0x2c0>
			goto packet_error;
		if (new_char != tochar ((sum + ((sum >> 6) & 0x03)) & 0x3f))
34803988:	e7e1335b 	ubfx	r3, fp, #6, #2
3480398c:	e083b00b 	add	fp, r3, fp
34803990:	e20bb03f 	and	fp, fp, #63	; 0x3f
34803994:	e28bb020 	add	fp, fp, #32
34803998:	e150000b 	cmp	r0, fp
3480399c:	1a000003 	bne	348039b0 <do_load_serial_bin+0x2c0>
			goto packet_error;
		/* get END_CHAR */
		new_char = getc ();
348039a0:	eb0015c9 	bl	348090cc <getc>
		if (new_char != END_CHAR) {
348039a4:	e6ef0070 	uxtb	r0, r0
348039a8:	e350000d 	cmp	r0, #13
348039ac:	0a000006 	beq	348039cc <do_load_serial_bin+0x2dc>
		/* get sequence number */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		n = untochar (new_char);
348039b0:	e1a09006 	mov	r9, r6
		new_char = getc ();
		if (new_char != END_CHAR) {
		  packet_error:
			/* restore state machines */
			k_state = k_state_saved;
			k_data_restore ();
348039b4:	ebfffebf 	bl	348034b8 <k_data_restore>
			/* send a negative acknowledge packet in */
			send_nack (n);
348039b8:	e1a00006 	mov	r0, r6
348039bc:	ebfffe94 	bl	34803414 <send_nack>
348039c0:	e1a03006 	mov	r3, r6
348039c4:	e1a06009 	mov	r6, r9
348039c8:	ea000009 	b	348039f4 <do_load_serial_bin+0x304>
		} else if (k_state == SEND_TYPE) {
348039cc:	e3590053 	cmp	r9, #83	; 0x53
348039d0:	1a000002 	bne	348039e0 <do_load_serial_bin+0x2f0>
			/* crack the protocol parms, build an appropriate ack packet */
			handle_send_packet (n);
348039d4:	e1a00006 	mov	r0, r6
348039d8:	ebfffed3 	bl	3480352c <handle_send_packet>
348039dc:	ea000003 	b	348039f0 <do_load_serial_bin+0x300>
		} else {
			/* send simple acknowledge packet in */
			send_ack (n);
348039e0:	e1a00006 	mov	r0, r6
348039e4:	ebfffe72 	bl	348033b4 <send_ack>
			/* quit if end of transmission */
			if (k_state == BREAK_TYPE)
348039e8:	e3590042 	cmp	r9, #66	; 0x42
348039ec:	0a00003d 	beq	34803ae8 <do_load_serial_bin+0x3f8>
		/* get sequence number */
		new_char = getc ();
		if ((new_char & 0xE0) == 0)
			goto packet_error;
		sum += new_char & 0xff;
		n = untochar (new_char);
348039f0:	e1a03006 	mov	r3, r6
	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
		offset = simple_strtoul(s, NULL, 16);
	}

	load_baudrate = current_baudrate = gd->baudrate;
348039f4:	e1a09006 	mov	r9, r6
348039f8:	e1a06003 	mov	r6, r3
348039fc:	eaffff88 	b	34803824 <do_load_serial_bin+0x134>
34803a00:	e1a04005 	mov	r4, r5
34803a04:	e59d5004 	ldr	r5, [sp, #4]
		for (;;) {
			switch (getc ()) {
			case START_CHAR:	/* start packet */
				goto START;
			case ETX_CHAR:		/* ^C waiting for packet */
				return (0);
34803a08:	e3a06000 	mov	r6, #0
34803a0c:	e3a09064 	mov	r9, #100	; 0x64
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
		if (tstc()) {
34803a10:	eb0015b6 	bl	348090f0 <tstc>
34803a14:	e3500000 	cmp	r0, #0
34803a18:	0a000000 	beq	34803a20 <do_load_serial_bin+0x330>
			(void) getc();
34803a1c:	eb0015aa 	bl	348090cc <getc>
		}
		udelay(1000);
34803a20:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34803a24:	eb0061d5 	bl	3481c180 <udelay>
	/*
	 * Gather any trailing characters (for instance, the ^D which
	 * is sent by 'cu' after sending a file), and give the
	 * box some time (100 * 1 ms)
	 */
	for (i=0; i<100; ++i) {
34803a28:	e2599001 	subs	r9, r9, #1
34803a2c:	1afffff7 	bne	34803a10 <do_load_serial_bin+0x320>
			(void) getc();
		}
		udelay(1000);
	}

	flush_cache (offset, size);
34803a30:	e1a01006 	mov	r1, r6
34803a34:	e1a00004 	mov	r0, r4
34803a38:	ebfff32c 	bl	348006f0 <flush_cache>

	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
	sprintf(buf, "%X", size);
34803a3c:	e28da008 	add	sl, sp, #8
		udelay(1000);
	}

	flush_cache (offset, size);

	printf("## Total Size      = 0x%08x = %d Bytes\n", size, size);
34803a40:	e1a01006 	mov	r1, r6
34803a44:	e1a02006 	mov	r2, r6
34803a48:	e59f00d8 	ldr	r0, [pc, #216]	; 34803b28 <do_load_serial_bin+0x438>
34803a4c:	eb0015c4 	bl	34809164 <printf>
	sprintf(buf, "%X", size);
34803a50:	e1a02006 	mov	r2, r6
34803a54:	e59f10d0 	ldr	r1, [pc, #208]	; 34803b2c <do_load_serial_bin+0x43c>
34803a58:	e1a0000a 	mov	r0, sl
34803a5c:	eb0064b1 	bl	3481cd28 <sprintf>
	setenv("filesize", buf);
34803a60:	e59f00c8 	ldr	r0, [pc, #200]	; 34803b30 <do_load_serial_bin+0x440>
34803a64:	e1a0100a 	mov	r1, sl
34803a68:	eb000dc7 	bl	3480718c <setenv>
			"to 0x%08lX at %d bps...\n",
			offset,
			load_baudrate);
		addr = load_serial_bin (offset);

		if (addr == ~0) {
34803a6c:	e3740001 	cmn	r4, #1
34803a70:	e59f60bc 	ldr	r6, [pc, #188]	; 34803b34 <do_load_serial_bin+0x444>
34803a74:	1a000004 	bne	34803a8c <do_load_serial_bin+0x39c>
			load_addr = 0;
34803a78:	e5869000 	str	r9, [r6]
			printf ("## Binary (kermit) download aborted\n");
34803a7c:	e59f00b4 	ldr	r0, [pc, #180]	; 34803b38 <do_load_serial_bin+0x448>
34803a80:	eb0015b7 	bl	34809164 <printf>
			rcode = 1;
34803a84:	e3a09001 	mov	r9, #1
34803a88:	ea000003 	b	34803a9c <do_load_serial_bin+0x3ac>
		} else {
			printf ("## Start Addr      = 0x%08lX\n", addr);
34803a8c:	e59f00a8 	ldr	r0, [pc, #168]	; 34803b3c <do_load_serial_bin+0x44c>
34803a90:	e1a01004 	mov	r1, r4
34803a94:	eb0015b2 	bl	34809164 <printf>
			load_addr = addr;
34803a98:	e5864000 	str	r4, [r6]
		}
	}
	if (load_baudrate != current_baudrate) {
34803a9c:	e1550007 	cmp	r5, r7
34803aa0:	0a00000b 	beq	34803ad4 <do_load_serial_bin+0x3e4>
		printf ("## Switch baudrate to %d bps and press ESC ...\n",
34803aa4:	e1a01007 	mov	r1, r7
34803aa8:	e59f0090 	ldr	r0, [pc, #144]	; 34803b40 <do_load_serial_bin+0x450>
34803aac:	eb0015ac 	bl	34809164 <printf>
			current_baudrate);
		udelay (50000);
34803ab0:	e30c0350 	movw	r0, #50000	; 0xc350
34803ab4:	eb0061b1 	bl	3481c180 <udelay>
		gd->baudrate = current_baudrate;
34803ab8:	e5887008 	str	r7, [r8, #8]
		serial_setbrg ();
34803abc:	eb002aed 	bl	3480e678 <serial_setbrg>
		udelay (50000);
34803ac0:	e30c0350 	movw	r0, #50000	; 0xc350
34803ac4:	eb0061ad 	bl	3481c180 <udelay>
		for (;;) {
			if (getc() == 0x1B) /* ESC */
34803ac8:	eb00157f 	bl	348090cc <getc>
34803acc:	e350001b 	cmp	r0, #27
34803ad0:	1afffffc 	bne	34803ac8 <do_load_serial_bin+0x3d8>
				break;
		}
	}

	return rcode;
}
34803ad4:	e1a00009 	mov	r0, r9
34803ad8:	e28dd028 	add	sp, sp, #40	; 0x28
34803adc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	/* pre-set offset from $loadaddr */
	if ((s = getenv("loadaddr")) != NULL) {
		offset = simple_strtoul(s, NULL, 16);
	}

	load_baudrate = current_baudrate = gd->baudrate;
34803ae0:	e1a05007 	mov	r5, r7
34803ae4:	eaffff2c 	b	3480379c <do_load_serial_bin+0xac>
			/* quit if end of transmission */
			if (k_state == BREAK_TYPE)
				done = 1;
		}
	}
	return ((ulong) os_data_addr - (ulong) bin_start_address);
34803ae8:	e59f3024 	ldr	r3, [pc, #36]	; 34803b14 <do_load_serial_bin+0x424>
34803aec:	e1a04005 	mov	r4, r5
34803af0:	e9930044 	ldmib	r3, {r2, r6}
34803af4:	e0426006 	sub	r6, r2, r6
34803af8:	e59d5004 	ldr	r5, [sp, #4]
34803afc:	eaffffc2 	b	34803a0c <do_load_serial_bin+0x31c>
34803b00:	34822884 	.word	0x34822884
34803b04:	34823a03 	.word	0x34823a03
34803b08:	34823a35 	.word	0x34823a35
34803b0c:	34823a3b 	.word	0x34823a3b
34803b10:	34823a7a 	.word	0x34823a7a
34803b14:	34829a34 	.word	0x34829a34
34803b18:	34802ed8 	.word	0x34802ed8
34803b1c:	34802ef4 	.word	0x34802ef4
34803b20:	34829a84 	.word	0x34829a84
34803b24:	34829a98 	.word	0x34829a98
34803b28:	34823908 	.word	0x34823908
34803b2c:	34823930 	.word	0x34823930
34803b30:	3482318c 	.word	0x3482318c
34803b34:	348284b4 	.word	0x348284b4
34803b38:	34823ab9 	.word	0x34823ab9
34803b3c:	348239e5 	.word	0x348239e5
34803b40:	34823ade 	.word	0x34823ade

34803b44 <do_mem_crc>:
{
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
34803b44:	e3520002 	cmp	r2, #2
#ifdef CONFIG_CMD_CRC32

#ifndef CONFIG_CRC32_VERIFY

int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803b48:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
		return CMD_RET_USAGE;
34803b4c:	d3e00000 	mvnle	r0, #0
#ifdef CONFIG_CMD_CRC32

#ifndef CONFIG_CRC32_VERIFY

int do_mem_crc (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803b50:	e1a07002 	mov	r7, r2
34803b54:	e1a04003 	mov	r4, r3
	ulong addr, length;
	ulong crc;
	ulong *ptr;

	if (argc < 3)
34803b58:	d8bd84f0 	pople	{r4, r5, r6, r7, sl, pc}
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
34803b5c:	e5930004 	ldr	r0, [r3, #4]
34803b60:	e3a01000 	mov	r1, #0
34803b64:	e3a02010 	mov	r2, #16
34803b68:	eb0063c8 	bl	3481ca90 <simple_strtoul>
	addr += base_address;
34803b6c:	e59f3074 	ldr	r3, [pc, #116]	; 34803be8 <do_mem_crc+0xa4>

	length = simple_strtoul (argv[2], NULL, 16);
34803b70:	e3a01000 	mov	r1, #0

	if (argc < 3)
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;
34803b74:	e5935000 	ldr	r5, [r3]

	length = simple_strtoul (argv[2], NULL, 16);
34803b78:	e3a02010 	mov	r2, #16

	if (argc < 3)
		return CMD_RET_USAGE;

	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;
34803b7c:	e0805005 	add	r5, r0, r5

	length = simple_strtoul (argv[2], NULL, 16);
34803b80:	e5940008 	ldr	r0, [r4, #8]
34803b84:	eb0063c1 	bl	3481ca90 <simple_strtoul>
34803b88:	e1a06000 	mov	r6, r0

	crc = crc32_wd (0, (const uchar *) addr, length, CHUNKSZ_CRC32);
34803b8c:	e1a01005 	mov	r1, r5
34803b90:	e1a02006 	mov	r2, r6
34803b94:	e3a03801 	mov	r3, #65536	; 0x10000
34803b98:	e3a00000 	mov	r0, #0
34803b9c:	eb00596f 	bl	3481a160 <crc32_wd>

	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
			addr, addr + length - 1, crc);
34803ba0:	e2462001 	sub	r2, r6, #1
	addr = simple_strtoul (argv[1], NULL, 16);
	addr += base_address;

	length = simple_strtoul (argv[2], NULL, 16);

	crc = crc32_wd (0, (const uchar *) addr, length, CHUNKSZ_CRC32);
34803ba4:	e1a0a000 	mov	sl, r0

	printf ("CRC32 for %08lx ... %08lx ==> %08lx\n",
34803ba8:	e1a01005 	mov	r1, r5
34803bac:	e59f0038 	ldr	r0, [pc, #56]	; 34803bec <do_mem_crc+0xa8>
34803bb0:	e0822005 	add	r2, r2, r5
34803bb4:	e1a0300a 	mov	r3, sl
34803bb8:	eb001569 	bl	34809164 <printf>
			addr, addr + length - 1, crc);

	if (argc > 3) {
34803bbc:	e3570003 	cmp	r7, #3
34803bc0:	0a000006 	beq	34803be0 <do_mem_crc+0x9c>
		ptr = (ulong *) simple_strtoul (argv[3], NULL, 16);
34803bc4:	e594000c 	ldr	r0, [r4, #12]
34803bc8:	e3a01000 	mov	r1, #0
34803bcc:	e3a02010 	mov	r2, #16
34803bd0:	eb0063ae 	bl	3481ca90 <simple_strtoul>
		*ptr = crc;
34803bd4:	e580a000 	str	sl, [r0]
	}

	return 0;
34803bd8:	e3a00000 	mov	r0, #0
34803bdc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34803be0:	e3a00000 	mov	r0, #0
}
34803be4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34803be8:	34829a98 	.word	0x34829a98
34803bec:	34823c41 	.word	0x34823c41

34803bf0 <do_mem_base>:
	return 0;
}

int do_mem_base (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	if (argc > 1) {
34803bf0:	e3520001 	cmp	r2, #1
	}
	return 0;
}

int do_mem_base (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803bf4:	e92d4008 	push	{r3, lr}
	if (argc > 1) {
34803bf8:	da000005 	ble	34803c14 <do_mem_base+0x24>
		/* Set new base address.
		*/
		base_address = simple_strtoul(argv[1], NULL, 16);
34803bfc:	e5930004 	ldr	r0, [r3, #4]
34803c00:	e3a01000 	mov	r1, #0
34803c04:	e3a02010 	mov	r2, #16
34803c08:	eb0063a0 	bl	3481ca90 <simple_strtoul>
34803c0c:	e59f3018 	ldr	r3, [pc, #24]	; 34803c2c <do_mem_base+0x3c>
34803c10:	e5830000 	str	r0, [r3]
	}
	/* Print the current base address.
	*/
	printf("Base Address: 0x%08lx\n", base_address);
34803c14:	e59f3010 	ldr	r3, [pc, #16]	; 34803c2c <do_mem_base+0x3c>
34803c18:	e59f0010 	ldr	r0, [pc, #16]	; 34803c30 <do_mem_base+0x40>
34803c1c:	e5931000 	ldr	r1, [r3]
34803c20:	eb00154f 	bl	34809164 <printf>
	return 0;
}
34803c24:	e3a00000 	mov	r0, #0
34803c28:	e8bd8008 	pop	{r3, pc}
34803c2c:	34829a98 	.word	0x34829a98
34803c30:	34823c66 	.word	0x34823c66

34803c34 <do_mem_mtest>:
#else
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
34803c34:	e3520001 	cmp	r2, #1
 * Perform a memory test. A more complete alternative test can be
 * configured using CONFIG_SYS_ALT_MEMTEST. The complete test loops until
 * interrupted by ctrl-c or by a failure of one of the sub-tests.
 */
int do_mem_mtest (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803c38:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
34803c3c:	e1a05002 	mov	r5, r2
34803c40:	e1a06003 	mov	r6, r3
#else
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
34803c44:	da000056 	ble	34803da4 <do_mem_mtest+0x170>
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
34803c48:	e5930004 	ldr	r0, [r3, #4]
34803c4c:	e3a01000 	mov	r1, #0
34803c50:	e3a02010 	mov	r2, #16
34803c54:	eb00638d 	bl	3481ca90 <simple_strtoul>
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
34803c58:	e3550002 	cmp	r5, #2
	ulong	incr;
	ulong	pattern;
#endif

	if (argc > 1)
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
34803c5c:	e58d0000 	str	r0, [sp]
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
34803c60:	0a000051 	beq	34803dac <do_mem_mtest+0x178>
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
34803c64:	e5960008 	ldr	r0, [r6, #8]
34803c68:	e3a01000 	mov	r1, #0
34803c6c:	e3a02010 	mov	r2, #16
34803c70:	eb006386 	bl	3481ca90 <simple_strtoul>
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
34803c74:	e3550003 	cmp	r5, #3
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;

	if (argc > 2)
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
34803c78:	e58d0004 	str	r0, [sp, #4]
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
34803c7c:	0a00004c 	beq	34803db4 <do_mem_mtest+0x180>
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
34803c80:	e596000c 	ldr	r0, [r6, #12]
34803c84:	e3a01000 	mov	r1, #0
34803c88:	e3a02010 	mov	r2, #16
34803c8c:	eb00637f 	bl	3481ca90 <simple_strtoul>
	else
		pattern = 0;

	if (argc > 4)
34803c90:	e3550004 	cmp	r5, #4
		end = (ulong *)simple_strtoul(argv[2], NULL, 16);
	else
		end = (ulong *)(CONFIG_SYS_MEMTEST_END);

	if (argc > 3)
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
34803c94:	e1a04000 	mov	r4, r0
		pattern = 0;

	if (argc > 4)
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
	else
		iteration_limit = 0;
34803c98:	03a0b000 	moveq	fp, #0
	if (argc > 3)
		pattern = (ulong)simple_strtoul(argv[3], NULL, 16);
	else
		pattern = 0;

	if (argc > 4)
34803c9c:	0a000004 	beq	34803cb4 <do_mem_mtest+0x80>
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
34803ca0:	e5960010 	ldr	r0, [r6, #16]
34803ca4:	e3a01000 	mov	r1, #0
34803ca8:	e3a02010 	mov	r2, #16
34803cac:	eb006377 	bl	3481ca90 <simple_strtoul>
34803cb0:	e1a0b000 	mov	fp, r0
		    start[offset] = 0;
		}
	}

#else /* The original, quickie test */
	incr = 1;
34803cb4:	e3a05001 	mov	r5, #1
{
	vu_long	*addr, *start, *end;
	ulong	val;
	ulong	readback;
	ulong	errs = 0;
	int iterations = 1;
34803cb8:	e1a0a005 	mov	sl, r5
int do_mem_mtest (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	vu_long	*addr, *start, *end;
	ulong	val;
	ulong	readback;
	ulong	errs = 0;
34803cbc:	e3a09000 	mov	r9, #0
	}

#else /* The original, quickie test */
	incr = 1;
	for (;;) {
		if (ctrlc()) {
34803cc0:	eb00154c 	bl	348091f8 <ctrlc>
34803cc4:	e3500000 	cmp	r0, #0
34803cc8:	1a000025 	bne	34803d64 <do_mem_mtest+0x130>
			putc ('\n');
			return 1;
		}

		if (iteration_limit && iterations > iteration_limit) {
34803ccc:	e35b0000 	cmp	fp, #0
34803cd0:	115a000b 	cmpne	sl, fp
34803cd4:	da000006 	ble	34803cf4 <do_mem_mtest+0xc0>
			printf("Tested %d iteration(s) with %lu errors.\n",
34803cd8:	e59f00e0 	ldr	r0, [pc, #224]	; 34803dc0 <do_mem_mtest+0x18c>
34803cdc:	e24a1001 	sub	r1, sl, #1
34803ce0:	e1a02009 	mov	r2, r9
34803ce4:	eb00151e 	bl	34809164 <printf>
				iterations-1, errs);
			return errs != 0;
34803ce8:	e2590000 	subs	r0, r9, #0
34803cec:	13a00001 	movne	r0, #1
34803cf0:	ea00002a 	b	34803da0 <do_mem_mtest+0x16c>
		}
		++iterations;

		printf ("\rPattern %08lX  Writing..."
34803cf4:	e59f20c8 	ldr	r2, [pc, #200]	; 34803dc4 <do_mem_mtest+0x190>
34803cf8:	e59f00c8 	ldr	r0, [pc, #200]	; 34803dc8 <do_mem_mtest+0x194>
34803cfc:	e1a01004 	mov	r1, r4
34803d00:	eb001517 	bl	34809164 <printf>
			"%12s"
			"\b\b\b\b\b\b\b\b\b\b",
			pattern, "");

		for (addr=start,val=pattern; addr<end; addr++) {
34803d04:	e1a02004 	mov	r2, r4
34803d08:	e59d3000 	ldr	r3, [sp]
34803d0c:	ea000001 	b	34803d18 <do_mem_mtest+0xe4>
			WATCHDOG_RESET();
			*addr = val;
34803d10:	e4832004 	str	r2, [r3], #4
			val  += incr;
34803d14:	e0822005 	add	r2, r2, r5
		printf ("\rPattern %08lX  Writing..."
			"%12s"
			"\b\b\b\b\b\b\b\b\b\b",
			pattern, "");

		for (addr=start,val=pattern; addr<end; addr++) {
34803d18:	e59d1004 	ldr	r1, [sp, #4]
34803d1c:	e1530001 	cmp	r3, r1
34803d20:	3afffffa 	bcc	34803d10 <do_mem_mtest+0xdc>
			WATCHDOG_RESET();
			*addr = val;
			val  += incr;
		}

		puts ("Reading...");
34803d24:	e59f00a0 	ldr	r0, [pc, #160]	; 34803dcc <do_mem_mtest+0x198>
34803d28:	eb001503 	bl	3480913c <puts>

		for (addr=start,val=pattern; addr<end; addr++) {
34803d2c:	e1a07004 	mov	r7, r4
34803d30:	e59d6000 	ldr	r6, [sp]
34803d34:	ea000010 	b	34803d7c <do_mem_mtest+0x148>
			WATCHDOG_RESET();
			readback = *addr;
34803d38:	e5962000 	ldr	r2, [r6]
			if (readback != val) {
34803d3c:	e1520007 	cmp	r2, r7
34803d40:	0a00000b 	beq	34803d74 <do_mem_mtest+0x140>
				printf ("\nMem error @ 0x%08X: "
34803d44:	e1a01006 	mov	r1, r6
34803d48:	e1a03007 	mov	r3, r7
34803d4c:	e59f007c 	ldr	r0, [pc, #124]	; 34803dd0 <do_mem_mtest+0x19c>
34803d50:	eb001503 	bl	34809164 <printf>
					"found %08lX, expected %08lX\n",
					(uint)(uintptr_t)addr, readback, val);
				errs++;
				if (ctrlc()) {
34803d54:	eb001527 	bl	348091f8 <ctrlc>
34803d58:	e3500000 	cmp	r0, #0
			readback = *addr;
			if (readback != val) {
				printf ("\nMem error @ 0x%08X: "
					"found %08lX, expected %08lX\n",
					(uint)(uintptr_t)addr, readback, val);
				errs++;
34803d5c:	02899001 	addeq	r9, r9, #1
34803d60:	0a000003 	beq	34803d74 <do_mem_mtest+0x140>
				if (ctrlc()) {
					putc ('\n');
34803d64:	e3a0000a 	mov	r0, #10
34803d68:	eb0014e9 	bl	34809114 <putc>
					return 1;
34803d6c:	e3a00001 	mov	r0, #1
34803d70:	ea00000a 	b	34803da0 <do_mem_mtest+0x16c>
				}
			}
			val += incr;
34803d74:	e0877005 	add	r7, r7, r5
			val  += incr;
		}

		puts ("Reading...");

		for (addr=start,val=pattern; addr<end; addr++) {
34803d78:	e2866004 	add	r6, r6, #4
34803d7c:	e59d3004 	ldr	r3, [sp, #4]
34803d80:	e1560003 	cmp	r6, r3
34803d84:	3affffeb 	bcc	34803d38 <do_mem_mtest+0x104>
		 * Flip the pattern each time to make lots of zeros and
		 * then, the next time, lots of ones.  We decrement
		 * the "negative" patterns and increment the "positive"
		 * patterns to preserve this feature.
		 */
		if(pattern & 0x80000000) {
34803d88:	e3540000 	cmp	r4, #0
			pattern = -pattern;	/* complement & increment */
34803d8c:	b2644000 	rsblt	r4, r4, #0
		}
		else {
			pattern = ~pattern;
34803d90:	a1e04004 	mvnge	r4, r4
		if (iteration_limit && iterations > iteration_limit) {
			printf("Tested %d iteration(s) with %lu errors.\n",
				iterations-1, errs);
			return errs != 0;
		}
		++iterations;
34803d94:	e28aa001 	add	sl, sl, #1
			pattern = -pattern;	/* complement & increment */
		}
		else {
			pattern = ~pattern;
		}
		incr = -incr;
34803d98:	e2655000 	rsb	r5, r5, #0
	}
34803d9c:	eaffffc7 	b	34803cc0 <do_mem_mtest+0x8c>
#endif
	return 0;	/* not reached */
}
34803da0:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
#endif

	if (argc > 1)
		start = (ulong *)simple_strtoul(argv[1], NULL, 16);
	else
		start = (ulong *)CONFIG_SYS_MEMTEST_START;
34803da4:	e3a01203 	mov	r1, #805306368	; 0x30000000
34803da8:	e58d1000 	str	r1, [sp]
34803dac:	e3a03435 	mov	r3, #889192448	; 0x35000000
34803db0:	e58d3004 	str	r3, [sp, #4]
		pattern = 0;

	if (argc > 4)
		iteration_limit = (ulong)simple_strtoul(argv[4], NULL, 16);
	else
		iteration_limit = 0;
34803db4:	e3a04000 	mov	r4, #0
34803db8:	e1a0b004 	mov	fp, r4
34803dbc:	eaffffbc 	b	34803cb4 <do_mem_mtest+0x80>
34803dc0:	34823c7d 	.word	0x34823c7d
34803dc4:	34823cce 	.word	0x34823cce
34803dc8:	34823ca6 	.word	0x34823ca6
34803dcc:	34823ccf 	.word	0x34823ccf
34803dd0:	34823cda 	.word	0x34823cda

34803dd4 <do_mem_loop>:
	int	size;
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
34803dd4:	e3520002 	cmp	r2, #2
	printf("Base Address: 0x%08lx\n", base_address);
	return 0;
}

int do_mem_loop (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803dd8:	e92d4070 	push	{r4, r5, r6, lr}
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
		return CMD_RET_USAGE;
34803ddc:	d3e00000 	mvnle	r0, #0
	printf("Base Address: 0x%08lx\n", base_address);
	return 0;
}

int do_mem_loop (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803de0:	e1a06003 	mov	r6, r3
	int	size;
	volatile uint	*longp;
	volatile ushort *shortp;
	volatile u_char	*cp;

	if (argc < 3)
34803de4:	d8bd8070 	pople	{r4, r5, r6, pc}
		return CMD_RET_USAGE;

	/* Check for a size spefication.
	 * Defaults to long if no or incorrect specification.
	 */
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34803de8:	e5930000 	ldr	r0, [r3]
34803dec:	e3a01004 	mov	r1, #4
34803df0:	eb0013fd 	bl	34808dec <cmd_get_data_size>
34803df4:	e2505000 	subs	r5, r0, #0
34803df8:	ba000030 	blt	34803ec0 <do_mem_loop+0xec>
		return 1;

	/* Address is always specified.
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
34803dfc:	e3a01000 	mov	r1, #0
34803e00:	e3a02010 	mov	r2, #16
34803e04:	e5960004 	ldr	r0, [r6, #4]
34803e08:	eb006320 	bl	3481ca90 <simple_strtoul>

	/* Length is the number of objects, not number of bytes.
	*/
	length = simple_strtoul(argv[2], NULL, 16);
34803e0c:	e3a01000 	mov	r1, #0
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	/* Address is always specified.
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
34803e10:	e1a04000 	mov	r4, r0

	/* Length is the number of objects, not number of bytes.
	*/
	length = simple_strtoul(argv[2], NULL, 16);
34803e14:	e3a02010 	mov	r2, #16
34803e18:	e5960008 	ldr	r0, [r6, #8]
34803e1c:	eb00631b 	bl	3481ca90 <simple_strtoul>

	/* We want to optimize the loops to run as fast as possible.
	 * If we have only one object, just run infinite loops.
	 */
	if (length == 1) {
34803e20:	e3500001 	cmp	r0, #1
34803e24:	1a000009 	bne	34803e50 <do_mem_loop+0x7c>
		if (size == 4) {
34803e28:	e3550004 	cmp	r5, #4
34803e2c:	1a000001 	bne	34803e38 <do_mem_loop+0x64>
			longp = (uint *)addr;
			for (;;)
				i = *longp;
34803e30:	e5943000 	ldr	r3, [r4]
34803e34:	eafffffd 	b	34803e30 <do_mem_loop+0x5c>
		}
		if (size == 2) {
34803e38:	e3550002 	cmp	r5, #2
34803e3c:	1a000001 	bne	34803e48 <do_mem_loop+0x74>
			shortp = (ushort *)addr;
			for (;;)
				i = *shortp;
34803e40:	e1d430b0 	ldrh	r3, [r4]
34803e44:	eafffffd 	b	34803e40 <do_mem_loop+0x6c>
		}
		cp = (u_char *)addr;
		for (;;)
			i = *cp;
34803e48:	e5d43000 	ldrb	r3, [r4]
34803e4c:	eafffffd 	b	34803e48 <do_mem_loop+0x74>
	}

	if (size == 4) {
34803e50:	e3550004 	cmp	r5, #4
34803e54:	1a000007 	bne	34803e78 <do_mem_loop+0xa4>
		for (;;) {
			longp = (uint *)addr;
34803e58:	e1a02004 	mov	r2, r4
			i = length;
			while (i-- > 0)
34803e5c:	e1a03000 	mov	r3, r0
34803e60:	ea000001 	b	34803e6c <do_mem_loop+0x98>
				*longp++;
34803e64:	e4921004 	ldr	r1, [r2], #4
34803e68:	e2433001 	sub	r3, r3, #1

	if (size == 4) {
		for (;;) {
			longp = (uint *)addr;
			i = length;
			while (i-- > 0)
34803e6c:	e3530000 	cmp	r3, #0
34803e70:	0afffff8 	beq	34803e58 <do_mem_loop+0x84>
34803e74:	eafffffa 	b	34803e64 <do_mem_loop+0x90>
				*longp++;
		}
	}
	if (size == 2) {
34803e78:	e3550002 	cmp	r5, #2
34803e7c:	1a000007 	bne	34803ea0 <do_mem_loop+0xcc>
		for (;;) {
			shortp = (ushort *)addr;
34803e80:	e1a02004 	mov	r2, r4
			i = length;
			while (i-- > 0)
34803e84:	e1a03000 	mov	r3, r0
34803e88:	ea000001 	b	34803e94 <do_mem_loop+0xc0>
				*shortp++;
34803e8c:	e0d210b2 	ldrh	r1, [r2], #2
34803e90:	e2433001 	sub	r3, r3, #1
	}
	if (size == 2) {
		for (;;) {
			shortp = (ushort *)addr;
			i = length;
			while (i-- > 0)
34803e94:	e3530000 	cmp	r3, #0
34803e98:	0afffff8 	beq	34803e80 <do_mem_loop+0xac>
34803e9c:	eafffffa 	b	34803e8c <do_mem_loop+0xb8>
				*shortp++;
		}
	}
	for (;;) {
		cp = (u_char *)addr;
34803ea0:	e1a02004 	mov	r2, r4
		i = length;
		while (i-- > 0)
34803ea4:	e1a03000 	mov	r3, r0
34803ea8:	ea000001 	b	34803eb4 <do_mem_loop+0xe0>
			*cp++;
34803eac:	e4d21001 	ldrb	r1, [r2], #1
34803eb0:	e2433001 	sub	r3, r3, #1
		}
	}
	for (;;) {
		cp = (u_char *)addr;
		i = length;
		while (i-- > 0)
34803eb4:	e3530000 	cmp	r3, #0
34803eb8:	0afffff8 	beq	34803ea0 <do_mem_loop+0xcc>
34803ebc:	eafffffa 	b	34803eac <do_mem_loop+0xd8>

	/* Check for a size spefication.
	 * Defaults to long if no or incorrect specification.
	 */
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
34803ec0:	e3a00001 	mov	r0, #1
		cp = (u_char *)addr;
		i = length;
		while (i-- > 0)
			*cp++;
	}
}
34803ec4:	e8bd8070 	pop	{r4, r5, r6, pc}

34803ec8 <do_mem_cp>:
int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, dest, count;
	int	size;

	if (argc != 4)
34803ec8:	e3520004 	cmp	r2, #4
	printf("Total of %ld %s(s) were the same\n", ngood, type);
	return rcode;
}

int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803ecc:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	ulong	addr, dest, count;
	int	size;

	if (argc != 4)
		return CMD_RET_USAGE;
34803ed0:	13e00000 	mvnne	r0, #0
	printf("Total of %ld %s(s) were the same\n", ngood, type);
	return rcode;
}

int do_mem_cp ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803ed4:	e1a05003 	mov	r5, r3
	ulong	addr, dest, count;
	int	size;

	if (argc != 4)
34803ed8:	18bd86f8 	popne	{r3, r4, r5, r6, r7, r9, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34803edc:	e5930000 	ldr	r0, [r3]
34803ee0:	e1a01002 	mov	r1, r2
34803ee4:	eb0013c0 	bl	34808dec <cmd_get_data_size>
34803ee8:	e2504000 	subs	r4, r0, #0
34803eec:	ba000026 	blt	34803f8c <do_mem_cp+0xc4>
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
34803ef0:	e3a01000 	mov	r1, #0
34803ef4:	e3a02010 	mov	r2, #16
34803ef8:	e5950004 	ldr	r0, [r5, #4]
34803efc:	eb0062e3 	bl	3481ca90 <simple_strtoul>
	addr += base_address;
34803f00:	e59f608c 	ldr	r6, [pc, #140]	; 34803f94 <do_mem_cp+0xcc>
	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
34803f04:	e1a0a000 	mov	sl, r0
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
34803f08:	e3a01000 	mov	r1, #0
34803f0c:	e3a02010 	mov	r2, #16
34803f10:	e5950008 	ldr	r0, [r5, #8]
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
34803f14:	e5967000 	ldr	r7, [r6]

	dest = simple_strtoul(argv[2], NULL, 16);
34803f18:	eb0062dc 	bl	3481ca90 <simple_strtoul>
	dest += base_address;

	count = simple_strtoul(argv[3], NULL, 16);
34803f1c:	e3a01000 	mov	r1, #0
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
34803f20:	e1a09000 	mov	r9, r0
	dest += base_address;

	count = simple_strtoul(argv[3], NULL, 16);
34803f24:	e3a02010 	mov	r2, #16
34803f28:	e595000c 	ldr	r0, [r5, #12]

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	dest = simple_strtoul(argv[2], NULL, 16);
	dest += base_address;
34803f2c:	e5966000 	ldr	r6, [r6]

	count = simple_strtoul(argv[3], NULL, 16);
34803f30:	eb0062d6 	bl	3481ca90 <simple_strtoul>

	if (count == 0) {
34803f34:	e3500000 	cmp	r0, #0
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;

	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
34803f38:	108a7007 	addne	r7, sl, r7

	dest = simple_strtoul(argv[2], NULL, 16);
	dest += base_address;
34803f3c:	10896006 	addne	r6, r9, r6

	count = simple_strtoul(argv[3], NULL, 16);

	if (count == 0) {
34803f40:	1a000003 	bne	34803f54 <do_mem_cp+0x8c>
		puts ("Zero length ???\n");
34803f44:	e59f004c 	ldr	r0, [pc, #76]	; 34803f98 <do_mem_cp+0xd0>
34803f48:	eb00147b 	bl	3480913c <puts>
		return 1;
34803f4c:	e3a00001 	mov	r0, #1
34803f50:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		return 0;
	}
#endif

	while (count-- > 0) {
		if (size == 4)
34803f54:	e3540004 	cmp	r4, #4
			*((ulong  *)dest) = *((ulong  *)addr);
34803f58:	05973000 	ldreq	r3, [r7]
34803f5c:	05863000 	streq	r3, [r6]
		return 0;
	}
#endif

	while (count-- > 0) {
		if (size == 4)
34803f60:	0a000004 	beq	34803f78 <do_mem_cp+0xb0>
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
34803f64:	e3540002 	cmp	r4, #2
			*((ushort *)dest) = *((ushort *)addr);
34803f68:	01d730b0 	ldrheq	r3, [r7]
		else
			*((u_char *)dest) = *((u_char *)addr);
34803f6c:	15d73000 	ldrbne	r3, [r7]

	while (count-- > 0) {
		if (size == 4)
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
			*((ushort *)dest) = *((ushort *)addr);
34803f70:	01c630b0 	strheq	r3, [r6]
		else
			*((u_char *)dest) = *((u_char *)addr);
34803f74:	15c63000 	strbne	r3, [r6]
		memcpy((void *)dest, (void *)addr, count * size);
		return 0;
	}
#endif

	while (count-- > 0) {
34803f78:	e2500001 	subs	r0, r0, #1
			*((ulong  *)dest) = *((ulong  *)addr);
		else if (size == 2)
			*((ushort *)dest) = *((ushort *)addr);
		else
			*((u_char *)dest) = *((u_char *)addr);
		addr += size;
34803f7c:	e0877004 	add	r7, r7, r4
34803f80:	e0866004 	add	r6, r6, r4
		memcpy((void *)dest, (void *)addr, count * size);
		return 0;
	}
#endif

	while (count-- > 0) {
34803f84:	1afffff2 	bne	34803f54 <do_mem_cp+0x8c>
34803f88:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
34803f8c:	e3a00001 	mov	r0, #1
		/* reset watchdog from time to time */
		if ((count % (64 << 10)) == 0)
			WATCHDOG_RESET();
	}
	return 0;
}
34803f90:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
34803f94:	34829a98 	.word	0x34829a98
34803f98:	34823d0c 	.word	0x34823d0c

34803f9c <do_mem_cmp>:
	return 0;
}
#endif /* CONFIG_MX_CYCLIC */

int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803f9c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
	const char *type;

	if (argc != 4)
34803fa0:	e3520004 	cmp	r2, #4
	return 0;
}
#endif /* CONFIG_MX_CYCLIC */

int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34803fa4:	e24dd018 	sub	sp, sp, #24
34803fa8:	e1a05003 	mov	r5, r3
	int	size;
	int     rcode = 0;
	const char *type;

	if (argc != 4)
		return CMD_RET_USAGE;
34803fac:	13e06000 	mvnne	r6, #0
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
	const char *type;

	if (argc != 4)
34803fb0:	1a00003f 	bne	348040b4 <do_mem_cmp+0x118>
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34803fb4:	e5930000 	ldr	r0, [r3]
34803fb8:	e1a01002 	mov	r1, r2
34803fbc:	eb00138a 	bl	34808dec <cmd_get_data_size>
34803fc0:	e2506000 	subs	r6, r0, #0
		return 1;
34803fc4:	b3a06001 	movlt	r6, #1
	if (argc != 4)
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34803fc8:	ba000039 	blt	348040b4 <do_mem_cmp+0x118>
		return 1;
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";
34803fcc:	e3560004 	cmp	r6, #4
34803fd0:	059f40e8 	ldreq	r4, [pc, #232]	; 348040c0 <do_mem_cmp+0x124>
34803fd4:	0a000003 	beq	34803fe8 <do_mem_cmp+0x4c>
34803fd8:	e59f30e4 	ldr	r3, [pc, #228]	; 348040c4 <do_mem_cmp+0x128>
34803fdc:	e3560002 	cmp	r6, #2
34803fe0:	e59f40e0 	ldr	r4, [pc, #224]	; 348040c8 <do_mem_cmp+0x12c>
34803fe4:	01a04003 	moveq	r4, r3

	addr1 = simple_strtoul(argv[1], NULL, 16);
34803fe8:	e5950004 	ldr	r0, [r5, #4]
34803fec:	e3a01000 	mov	r1, #0
34803ff0:	e3a02010 	mov	r2, #16
34803ff4:	eb0062a5 	bl	3481ca90 <simple_strtoul>
	addr1 += base_address;
34803ff8:	e59fa0cc 	ldr	sl, [pc, #204]	; 348040cc <do_mem_cmp+0x130>

	addr2 = simple_strtoul(argv[2], NULL, 16);
34803ffc:	e3a01000 	mov	r1, #0
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;
34804000:	e59a7000 	ldr	r7, [sl]

	addr2 = simple_strtoul(argv[2], NULL, 16);
34804004:	e3a02010 	mov	r2, #16
	if ((size = cmd_get_data_size(argv[0], 4)) < 0)
		return 1;
	type = size == 4 ? "word" : size == 2 ? "halfword" : "byte";

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;
34804008:	e0807007 	add	r7, r0, r7

	addr2 = simple_strtoul(argv[2], NULL, 16);
3480400c:	e5950008 	ldr	r0, [r5, #8]
34804010:	eb00629e 	bl	3481ca90 <simple_strtoul>
	addr2 += base_address;
34804014:	e59aa000 	ldr	sl, [sl]

	count = simple_strtoul(argv[3], NULL, 16);
34804018:	e3a01000 	mov	r1, #0

	addr1 = simple_strtoul(argv[1], NULL, 16);
	addr1 += base_address;

	addr2 = simple_strtoul(argv[2], NULL, 16);
	addr2 += base_address;
3480401c:	e080a00a 	add	sl, r0, sl

	count = simple_strtoul(argv[3], NULL, 16);
34804020:	e3a02010 	mov	r2, #16
34804024:	e595000c 	ldr	r0, [r5, #12]
34804028:	eb006298 	bl	3481ca90 <simple_strtoul>
		puts ("Comparison with L1 instruction memory not supported.\n\r");
		return 0;
	}
#endif

	for (ngood = 0; ngood < count; ++ngood) {
3480402c:	e3a05000 	mov	r5, #0
34804030:	ea000018 	b	34804098 <do_mem_cmp+0xfc>
		ulong word1, word2;
		if (size == 4) {
34804034:	e3560004 	cmp	r6, #4
			word1 = *(ulong *)addr1;
34804038:	05972000 	ldreq	r2, [r7]
			word2 = *(ulong *)addr2;
3480403c:	059a3000 	ldreq	r3, [sl]
	}
#endif

	for (ngood = 0; ngood < count; ++ngood) {
		ulong word1, word2;
		if (size == 4) {
34804040:	0a000004 	beq	34804058 <do_mem_cmp+0xbc>
			word1 = *(ulong *)addr1;
			word2 = *(ulong *)addr2;
		} else if (size == 2) {
34804044:	e3560002 	cmp	r6, #2
			word1 = *(ushort *)addr1;
34804048:	01d720b0 	ldrheq	r2, [r7]
			word2 = *(ushort *)addr2;
3480404c:	01da30b0 	ldrheq	r3, [sl]
		} else {
			word1 = *(u_char *)addr1;
34804050:	15d72000 	ldrbne	r2, [r7]
			word2 = *(u_char *)addr2;
34804054:	15da3000 	ldrbne	r3, [sl]
		}
		if (word1 != word2) {
34804058:	e1520003 	cmp	r2, r3
3480405c:	0a00000a 	beq	3480408c <do_mem_cmp+0xf0>
			printf("%s at 0x%08lx (%#0*lx) != %s at 0x%08lx (%#0*lx)\n",
34804060:	e58d2000 	str	r2, [sp]
34804064:	e58d3010 	str	r3, [sp, #16]
34804068:	e59f0060 	ldr	r0, [pc, #96]	; 348040d0 <do_mem_cmp+0x134>
3480406c:	e1a03006 	mov	r3, r6
34804070:	e1a01004 	mov	r1, r4
34804074:	e1a02007 	mov	r2, r7
34804078:	e58d600c 	str	r6, [sp, #12]
3480407c:	e98d0410 	stmib	sp, {r4, sl}
				type, addr1, size, word1,
				type, addr2, size, word2);
			rcode = 1;
34804080:	e3a06001 	mov	r6, #1
		} else {
			word1 = *(u_char *)addr1;
			word2 = *(u_char *)addr2;
		}
		if (word1 != word2) {
			printf("%s at 0x%08lx (%#0*lx) != %s at 0x%08lx (%#0*lx)\n",
34804084:	eb001436 	bl	34809164 <printf>
				type, addr1, size, word1,
				type, addr2, size, word2);
			rcode = 1;
			break;
34804088:	ea000005 	b	348040a4 <do_mem_cmp+0x108>
		}

		addr1 += size;
3480408c:	e0877006 	add	r7, r7, r6
34804090:	e08aa006 	add	sl, sl, r6
		puts ("Comparison with L1 instruction memory not supported.\n\r");
		return 0;
	}
#endif

	for (ngood = 0; ngood < count; ++ngood) {
34804094:	e2855001 	add	r5, r5, #1
34804098:	e1550000 	cmp	r5, r0
3480409c:	3affffe4 	bcc	34804034 <do_mem_cmp+0x98>

int do_mem_cmp (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr1, addr2, count, ngood;
	int	size;
	int     rcode = 0;
348040a0:	e3a06000 	mov	r6, #0
		/* reset watchdog from time to time */
		if ((ngood % (64 << 10)) == 0)
			WATCHDOG_RESET();
	}

	printf("Total of %ld %s(s) were the same\n", ngood, type);
348040a4:	e59f0028 	ldr	r0, [pc, #40]	; 348040d4 <do_mem_cmp+0x138>
348040a8:	e1a01005 	mov	r1, r5
348040ac:	e1a02004 	mov	r2, r4
348040b0:	eb00142b 	bl	34809164 <printf>
	return rcode;
}
348040b4:	e1a00006 	mov	r0, r6
348040b8:	e28dd018 	add	sp, sp, #24
348040bc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
348040c0:	34823d26 	.word	0x34823d26
348040c4:	34823d22 	.word	0x34823d22
348040c8:	34823d1d 	.word	0x34823d1d
348040cc:	34829a98 	.word	0x34829a98
348040d0:	34823d2b 	.word	0x34823d2b
348040d4:	34823d5d 	.word	0x34823d5d

348040d8 <do_mem_mw>:
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
}

int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348040d8:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
348040dc:	e1a06003 	mov	r6, r3
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
348040e0:	e2423003 	sub	r3, r2, #3
348040e4:	e3530001 	cmp	r3, #1
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
}

int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348040e8:	e1a04002 	mov	r4, r2
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
		return CMD_RET_USAGE;
348040ec:	83e00000 	mvnhi	r0, #0
int do_mem_mw ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	ulong	addr, writeval, count;
	int	size;

	if ((argc < 3) || (argc > 4))
348040f0:	88bd84f0 	pophi	{r4, r5, r6, r7, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 1)
348040f4:	e5960000 	ldr	r0, [r6]
348040f8:	e3a01004 	mov	r1, #4
348040fc:	eb00133a 	bl	34808dec <cmd_get_data_size>
34804100:	e2507000 	subs	r7, r0, #0
34804104:	da00001e 	ble	34804184 <do_mem_mw+0xac>
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
34804108:	e3a01000 	mov	r1, #0
3480410c:	e3a02010 	mov	r2, #16
34804110:	e5960004 	ldr	r0, [r6, #4]
34804114:	eb00625d 	bl	3481ca90 <simple_strtoul>
	addr += base_address;
34804118:	e59f306c 	ldr	r3, [pc, #108]	; 3480418c <do_mem_mw+0xb4>

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
3480411c:	e3a01000 	mov	r1, #0
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
34804120:	e5935000 	ldr	r5, [r3]

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
34804124:	e3a02010 	mov	r2, #16
		return 1;

	/* Address is specified since argc > 1
	*/
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;
34804128:	e0805005 	add	r5, r0, r5

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
3480412c:	e5960008 	ldr	r0, [r6, #8]
34804130:	eb006256 	bl	3481ca90 <simple_strtoul>

	/* Count ? */
	if (argc == 4) {
34804134:	e3540004 	cmp	r4, #4
	addr = simple_strtoul(argv[1], NULL, 16);
	addr += base_address;

	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);
34804138:	e1a0a000 	mov	sl, r0

	/* Count ? */
	if (argc == 4) {
		count = simple_strtoul(argv[3], NULL, 16);
	} else {
		count = 1;
3480413c:	13a00001 	movne	r0, #1
	/* Get the value to write.
	*/
	writeval = simple_strtoul(argv[2], NULL, 16);

	/* Count ? */
	if (argc == 4) {
34804140:	1a00000c 	bne	34804178 <do_mem_mw+0xa0>
		count = simple_strtoul(argv[3], NULL, 16);
34804144:	e596000c 	ldr	r0, [r6, #12]
34804148:	e3a01000 	mov	r1, #0
3480414c:	e3a02010 	mov	r2, #16
34804150:	eb00624e 	bl	3481ca90 <simple_strtoul>
34804154:	ea000007 	b	34804178 <do_mem_mw+0xa0>
	} else {
		count = 1;
	}

	while (count-- > 0) {
		if (size == 4)
34804158:	e3570004 	cmp	r7, #4
			*((ulong  *)addr) = (ulong )writeval;
3480415c:	0585a000 	streq	sl, [r5]
	} else {
		count = 1;
	}

	while (count-- > 0) {
		if (size == 4)
34804160:	0a000002 	beq	34804170 <do_mem_mw+0x98>
			*((ulong  *)addr) = (ulong )writeval;
		else if (size == 2)
34804164:	e3570002 	cmp	r7, #2
			*((ushort *)addr) = (ushort)writeval;
34804168:	01c5a0b0 	strheq	sl, [r5]
		else
			*((u_char *)addr) = (u_char)writeval;
3480416c:	15c5a000 	strbne	sl, [r5]
34804170:	e0855007 	add	r5, r5, r7
34804174:	e2400001 	sub	r0, r0, #1
		count = simple_strtoul(argv[3], NULL, 16);
	} else {
		count = 1;
	}

	while (count-- > 0) {
34804178:	e3500000 	cmp	r0, #0
3480417c:	1afffff5 	bne	34804158 <do_mem_mw+0x80>
34804180:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
		return CMD_RET_USAGE;

	/* Check for size specification.
	*/
	if ((size = cmd_get_data_size(argv[0], 4)) < 1)
		return 1;
34804184:	e3a00001 	mov	r0, #1
		else
			*((u_char *)addr) = (u_char)writeval;
		addr += size;
	}
	return 0;
}
34804188:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3480418c:	34829a98 	.word	0x34829a98

34804190 <do_mem_md>:
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
int do_mem_md ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804190:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int rc = 0;

	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
34804194:	e59fa0b8 	ldr	sl, [pc, #184]	; 34804254 <do_mem_md+0xc4>
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
int do_mem_md ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34804198:	e1a07003 	mov	r7, r3
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
	size = dp_last_size;
	length = dp_last_length;
3480419c:	e59f30b4 	ldr	r3, [pc, #180]	; 34804258 <do_mem_md+0xc8>

	if (argc < 2)
348041a0:	e3520001 	cmp	r2, #1
 * Syntax:
 *	md{.b, .w, .l} {addr} {len}
 */
#define DISP_LINE_LEN	16
int do_mem_md ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348041a4:	e1a0b002 	mov	fp, r2
	int rc = 0;

	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = dp_last_addr;
348041a8:	e59a6004 	ldr	r6, [sl, #4]
	size = dp_last_size;
348041ac:	e59a4008 	ldr	r4, [sl, #8]
	length = dp_last_length;
348041b0:	e5935000 	ldr	r5, [r3]

	if (argc < 2)
		return CMD_RET_USAGE;
348041b4:	d3e00000 	mvnle	r0, #0
	 */
	addr = dp_last_addr;
	size = dp_last_size;
	length = dp_last_length;

	if (argc < 2)
348041b8:	da000024 	ble	34804250 <do_mem_md+0xc0>
		return CMD_RET_USAGE;

	if ((flag & CMD_FLAG_REPEAT) == 0) {
348041bc:	e2119001 	ands	r9, r1, #1
348041c0:	1a000012 	bne	34804210 <do_mem_md+0x80>
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
348041c4:	e5970000 	ldr	r0, [r7]
348041c8:	e3a01004 	mov	r1, #4
348041cc:	eb001306 	bl	34808dec <cmd_get_data_size>
348041d0:	e2504000 	subs	r4, r0, #0
			return 1;
348041d4:	b3a00001 	movlt	r0, #1

	if ((flag & CMD_FLAG_REPEAT) == 0) {
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
348041d8:	ba00001c 	blt	34804250 <do_mem_md+0xc0>
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
348041dc:	e5970004 	ldr	r0, [r7, #4]
348041e0:	e1a01009 	mov	r1, r9
348041e4:	e3a02010 	mov	r2, #16
348041e8:	eb006228 	bl	3481ca90 <simple_strtoul>
		addr += base_address;
348041ec:	e59a6000 	ldr	r6, [sl]

		/* If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 */
		if (argc > 2)
348041f0:	e35b0002 	cmp	fp, #2
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
		addr += base_address;
348041f4:	e0806006 	add	r6, r0, r6

		/* If another parameter, it is the length to display.
		 * Length is the number of objects, not number of bytes.
		 */
		if (argc > 2)
348041f8:	0a000004 	beq	34804210 <do_mem_md+0x80>
			length = simple_strtoul(argv[2], NULL, 16);
348041fc:	e5970008 	ldr	r0, [r7, #8]
34804200:	e1a01009 	mov	r1, r9
34804204:	e3a02010 	mov	r2, #16
34804208:	eb006220 	bl	3481ca90 <simple_strtoul>
3480420c:	e1a05000 	mov	r5, r0
	} else
# endif

	{
		/* Print the lines. */
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
34804210:	e1a01004 	mov	r1, r4
34804214:	e3a00010 	mov	r0, #16
34804218:	eb006ee3 	bl	3481fdac <__divsi3>
3480421c:	e1a01006 	mov	r1, r6
34804220:	e58d0000 	str	r0, [sp]
34804224:	e1a00006 	mov	r0, r6
		addr += size*length;
34804228:	e0266495 	mla	r6, r5, r4, r6
	} else
# endif

	{
		/* Print the lines. */
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
3480422c:	e1a02004 	mov	r2, r4
34804230:	e1a03005 	mov	r3, r5
34804234:	eb005827 	bl	3481a2d8 <print_buffer>
		addr += size*length;
	}
#endif

	dp_last_addr = addr;
34804238:	e59f3014 	ldr	r3, [pc, #20]	; 34804254 <do_mem_md+0xc4>
	dp_last_length = length;
3480423c:	e59f2014 	ldr	r2, [pc, #20]	; 34804258 <do_mem_md+0xc8>
		print_buffer(addr, (void*)addr, size, length, DISP_LINE_LEN/size);
		addr += size*length;
	}
#endif

	dp_last_addr = addr;
34804240:	e5836004 	str	r6, [r3, #4]
	dp_last_length = length;
34804244:	e5825000 	str	r5, [r2]
	dp_last_size = size;
34804248:	e5834008 	str	r4, [r3, #8]
	return (rc);
3480424c:	e3a00000 	mov	r0, #0
}
34804250:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34804254:	34829a98 	.word	0x34829a98
34804258:	348283d0 	.word	0x348283d0

3480425c <mod_mem.clone.0>:
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
{
	ulong	addr, i;
	int	nbytes, size;

	if (argc != 2)
3480425c:	e3520002 	cmp	r2, #2
 * Syntax:
 *	mm{.b, .w, .l} {addr}
 *	nm{.b, .w, .l} {addr}
 */
static int
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
34804260:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
34804264:	e1a04000 	mov	r4, r0
34804268:	e1a0a003 	mov	sl, r3
{
	ulong	addr, i;
	int	nbytes, size;

	if (argc != 2)
		return CMD_RET_USAGE;
3480426c:	13e00000 	mvnne	r0, #0
mod_mem(cmd_tbl_t *cmdtp, int incrflag, int flag, int argc, char * const argv[])
{
	ulong	addr, i;
	int	nbytes, size;

	if (argc != 2)
34804270:	1a000040 	bne	34804378 <mod_mem.clone.0+0x11c>
	reset_cmd_timeout();	/* got a good command to get here */
#endif
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = mm_last_addr;
34804274:	e59f7114 	ldr	r7, [pc, #276]	; 34804390 <mod_mem.clone.0+0x134>
	size = mm_last_size;

	if ((flag & CMD_FLAG_REPEAT) == 0) {
34804278:	e2119001 	ands	r9, r1, #1
	reset_cmd_timeout();	/* got a good command to get here */
#endif
	/* We use the last specified parameters, unless new ones are
	 * entered.
	 */
	addr = mm_last_addr;
3480427c:	e597500c 	ldr	r5, [r7, #12]
	size = mm_last_size;
34804280:	e5976010 	ldr	r6, [r7, #16]

	if ((flag & CMD_FLAG_REPEAT) == 0) {
34804284:	1a00000b 	bne	348042b8 <mod_mem.clone.0+0x5c>
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
34804288:	e5930000 	ldr	r0, [r3]
3480428c:	e3a01004 	mov	r1, #4
34804290:	eb0012d5 	bl	34808dec <cmd_get_data_size>
34804294:	e2506000 	subs	r6, r0, #0
			return 1;
34804298:	b3a00001 	movlt	r0, #1

	if ((flag & CMD_FLAG_REPEAT) == 0) {
		/* New command specified.  Check for a size specification.
		 * Defaults to long if no or incorrect specification.
		 */
		if ((size = cmd_get_data_size(argv[0], 4)) < 0)
3480429c:	ba000035 	blt	34804378 <mod_mem.clone.0+0x11c>
			return 1;

		/* Address is specified since argc > 1
		*/
		addr = simple_strtoul(argv[1], NULL, 16);
348042a0:	e59a0004 	ldr	r0, [sl, #4]
348042a4:	e1a01009 	mov	r1, r9
348042a8:	e3a02010 	mov	r2, #16
348042ac:	eb0061f7 	bl	3481ca90 <simple_strtoul>
		addr += base_address;
348042b0:	e5975000 	ldr	r5, [r7]
348042b4:	e0805005 	add	r5, r0, r5
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
348042b8:	e59f70d4 	ldr	r7, [pc, #212]	; 34804394 <mod_mem.clone.0+0x138>
		if (nbytes == 0 || (nbytes == 1 && console_buffer[0] == '-')) {
			/* <CR> pressed as only input, don't modify current
			 * location and move to next. "-" pressed will go back.
			 */
			if (incrflag)
				addr += nbytes ? -size : size;
348042bc:	e266a000 	rsb	sl, r6, #0
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
348042c0:	e28d9004 	add	r9, sp, #4

	/* Print the address, followed by value.  Then accept input for
	 * the next value.  A non-converted value exits.
	 */
	do {
		printf("%08lx:", addr);
348042c4:	e1a01005 	mov	r1, r5
348042c8:	e59f00c8 	ldr	r0, [pc, #200]	; 34804398 <mod_mem.clone.0+0x13c>
348042cc:	eb0013a4 	bl	34809164 <printf>
		if (size == 4)
348042d0:	e3560004 	cmp	r6, #4
			printf(" %08x", *((uint   *)addr));
348042d4:	059f00c0 	ldreq	r0, [pc, #192]	; 3480439c <mod_mem.clone.0+0x140>
348042d8:	05951000 	ldreq	r1, [r5]
	/* Print the address, followed by value.  Then accept input for
	 * the next value.  A non-converted value exits.
	 */
	do {
		printf("%08lx:", addr);
		if (size == 4)
348042dc:	0a000004 	beq	348042f4 <mod_mem.clone.0+0x98>
			printf(" %08x", *((uint   *)addr));
		else if (size == 2)
348042e0:	e3560002 	cmp	r6, #2
			printf(" %04x", *((ushort *)addr));
348042e4:	059f00b4 	ldreq	r0, [pc, #180]	; 348043a0 <mod_mem.clone.0+0x144>
348042e8:	01d510b0 	ldrheq	r1, [r5]
		else
			printf(" %02x", *((u_char *)addr));
348042ec:	159f00b0 	ldrne	r0, [pc, #176]	; 348043a4 <mod_mem.clone.0+0x148>
348042f0:	15d51000 	ldrbne	r1, [r5]
348042f4:	eb00139a 	bl	34809164 <printf>

		nbytes = readline (" ? ");
348042f8:	e59f00a8 	ldr	r0, [pc, #168]	; 348043a8 <mod_mem.clone.0+0x14c>
348042fc:	eb0026d1 	bl	3480de48 <readline>
		if (nbytes == 0 || (nbytes == 1 && console_buffer[0] == '-')) {
34804300:	e3500000 	cmp	r0, #0
34804304:	0a000004 	beq	3480431c <mod_mem.clone.0+0xc0>
34804308:	e3500001 	cmp	r0, #1
3480430c:	1a000009 	bne	34804338 <mod_mem.clone.0+0xdc>
34804310:	e5d73000 	ldrb	r3, [r7]
34804314:	e353002d 	cmp	r3, #45	; 0x2d
34804318:	1a000006 	bne	34804338 <mod_mem.clone.0+0xdc>
			/* <CR> pressed as only input, don't modify current
			 * location and move to next. "-" pressed will go back.
			 */
			if (incrflag)
3480431c:	e3540000 	cmp	r4, #0
34804320:	0affffe7 	beq	348042c4 <mod_mem.clone.0+0x68>
				addr += nbytes ? -size : size;
34804324:	e3500000 	cmp	r0, #0
34804328:	01a03006 	moveq	r3, r6
3480432c:	11a0300a 	movne	r3, sl
34804330:	e0855003 	add	r5, r5, r3
34804334:	eaffffe2 	b	348042c4 <mod_mem.clone.0+0x68>
			break;	/* timed out, exit the command	*/
		}
#endif
		else {
			char *endp;
			i = simple_strtoul(console_buffer, &endp, 16);
34804338:	e59f0054 	ldr	r0, [pc, #84]	; 34804394 <mod_mem.clone.0+0x138>
3480433c:	e1a01009 	mov	r1, r9
34804340:	e3a02010 	mov	r2, #16
34804344:	eb0061d1 	bl	3481ca90 <simple_strtoul>
			nbytes = endp - console_buffer;
			if (nbytes) {
34804348:	e59d3004 	ldr	r3, [sp, #4]
3480434c:	e1530007 	cmp	r3, r7
34804350:	0a000009 	beq	3480437c <mod_mem.clone.0+0x120>
#ifdef CONFIG_BOOT_RETRY_TIME
				/* good enough to not time out
				 */
				reset_cmd_timeout();
#endif
				if (size == 4)
34804354:	e3560004 	cmp	r6, #4
					*((uint   *)addr) = i;
34804358:	05850000 	streq	r0, [r5]
#ifdef CONFIG_BOOT_RETRY_TIME
				/* good enough to not time out
				 */
				reset_cmd_timeout();
#endif
				if (size == 4)
3480435c:	0a000002 	beq	3480436c <mod_mem.clone.0+0x110>
					*((uint   *)addr) = i;
				else if (size == 2)
34804360:	e3560002 	cmp	r6, #2
					*((ushort *)addr) = i;
34804364:	01c500b0 	strheq	r0, [r5]
				else
					*((u_char *)addr) = i;
34804368:	15c50000 	strbne	r0, [r5]
				if (incrflag)
3480436c:	e3540000 	cmp	r4, #0
					addr += size;
34804370:	10855006 	addne	r5, r5, r6
34804374:	eaffffd2 	b	348042c4 <mod_mem.clone.0+0x68>
	} while (nbytes);

	mm_last_addr = addr;
	mm_last_size = size;
	return 0;
}
34804378:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
					addr += size;
			}
		}
	} while (nbytes);

	mm_last_addr = addr;
3480437c:	e59f300c 	ldr	r3, [pc, #12]	; 34804390 <mod_mem.clone.0+0x134>
	mm_last_size = size;
	return 0;
34804380:	e3a00000 	mov	r0, #0
					addr += size;
			}
		}
	} while (nbytes);

	mm_last_addr = addr;
34804384:	e583500c 	str	r5, [r3, #12]
	mm_last_size = size;
34804388:	e5836010 	str	r6, [r3, #16]
3480438c:	eafffff9 	b	34804378 <mod_mem.clone.0+0x11c>
34804390:	34829a98 	.word	0x34829a98
34804394:	3482b478 	.word	0x3482b478
34804398:	34823d7f 	.word	0x34823d7f
3480439c:	34827096 	.word	0x34827096
348043a0:	34823d86 	.word	0x34823d86
348043a4:	34823d8c 	.word	0x34823d8c
348043a8:	34823d92 	.word	0x34823d92

348043ac <do_mem_nm>:
{
	return mod_mem (cmdtp, 1, flag, argc, argv);
}
int do_mem_nm ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return mod_mem (cmdtp, 0, flag, argc, argv);
348043ac:	e3a00000 	mov	r0, #0
348043b0:	eaffffa9 	b	3480425c <mod_mem.clone.0>

348043b4 <do_mem_mm>:
	return (rc);
}

int do_mem_mm ( cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return mod_mem (cmdtp, 1, flag, argc, argv);
348043b4:	e3a00001 	mov	r0, #1
348043b8:	eaffffa7 	b	3480425c <mod_mem.clone.0>

348043bc <do_mmcops>:

int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	enum mmc_state state;

	if (argc < 2)
348043bc:	e3520001 	cmp	r2, #1
	"display MMC info",
	"- dislay info of the current MMC device"
);

int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348043c0:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
348043c4:	e1a07002 	mov	r7, r2
348043c8:	e1a04003 	mov	r4, r3
	enum mmc_state state;

	if (argc < 2)
348043cc:	da0000eb 	ble	34804780 <do_mmcops+0x3c4>
		return CMD_RET_USAGE;

	if (curr_device < 0) {
348043d0:	e59f53b4 	ldr	r5, [pc, #948]	; 3480478c <do_mmcops+0x3d0>
348043d4:	e5953000 	ldr	r3, [r5]
348043d8:	e3530000 	cmp	r3, #0
348043dc:	aa000005 	bge	348043f8 <do_mmcops+0x3c>
		if (get_mmc_num() > 0)
348043e0:	eb003808 	bl	34812408 <get_mmc_num>
348043e4:	e3500000 	cmp	r0, #0
			curr_device = 0;
348043e8:	c3a03000 	movgt	r3, #0
348043ec:	c5853000 	strgt	r3, [r5]
		else {
			puts("No MMC device available\n");
348043f0:	d59f0398 	ldrle	r0, [pc, #920]	; 34804790 <do_mmcops+0x3d4>

	if (argc < 2)
		return CMD_RET_USAGE;

	if (curr_device < 0) {
		if (get_mmc_num() > 0)
348043f4:	da000027 	ble	34804498 <do_mmcops+0xdc>
			puts("No MMC device available\n");
			return 1;
		}
	}

	if (strcmp(argv[1], "rescan") == 0) {
348043f8:	e5940004 	ldr	r0, [r4, #4]
348043fc:	e59f1390 	ldr	r1, [pc, #912]	; 34804794 <do_mmcops+0x3d8>
34804400:	eb005ddb 	bl	3481bb74 <strcmp>
34804404:	e2505000 	subs	r5, r0, #0
34804408:	1a000009 	bne	34804434 <do_mmcops+0x78>
		struct mmc *mmc = find_mmc_device(curr_device);
3480440c:	e59f4378 	ldr	r4, [pc, #888]	; 3480478c <do_mmcops+0x3d0>
34804410:	e5940000 	ldr	r0, [r4]
34804414:	eb0032bf 	bl	34810f18 <find_mmc_device>

		if (!mmc) {
34804418:	e2503000 	subs	r3, r0, #0
3480441c:	0a00000f 	beq	34804460 <do_mmcops+0xa4>
			printf("no mmc device at slot %x\n", curr_device);
			return 1;
		}

		mmc->has_init = 0;
34804420:	e5835034 	str	r5, [r3, #52]	; 0x34

		if (mmc_init(mmc))
34804424:	eb00379a 	bl	34812294 <mmc_init>
int do_mmcops(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	enum mmc_state state;

	if (argc < 2)
		return CMD_RET_USAGE;
34804428:	e2505000 	subs	r5, r0, #0
3480442c:	13a05001 	movne	r5, #1
34804430:	ea0000d3 	b	34804784 <do_mmcops+0x3c8>

		if (mmc_init(mmc))
			return 1;
		else
			return 0;
	} else if (strncmp(argv[1], "part", 4) == 0) {
34804434:	e5940004 	ldr	r0, [r4, #4]
34804438:	e59f1358 	ldr	r1, [pc, #856]	; 34804798 <do_mmcops+0x3dc>
3480443c:	e3a02004 	mov	r2, #4
34804440:	eb005dd7 	bl	3481bba4 <strncmp>
34804444:	e2505000 	subs	r5, r0, #0
34804448:	1a000014 	bne	348044a0 <do_mmcops+0xe4>
		block_dev_desc_t *mmc_dev;
		struct mmc *mmc = find_mmc_device(curr_device);
3480444c:	e59f4338 	ldr	r4, [pc, #824]	; 3480478c <do_mmcops+0x3d0>
34804450:	e5940000 	ldr	r0, [r4]
34804454:	eb0032af 	bl	34810f18 <find_mmc_device>

		if (!mmc) {
34804458:	e3500000 	cmp	r0, #0
3480445c:	1a000002 	bne	3480446c <do_mmcops+0xb0>
			printf("no mmc device at slot %x\n", curr_device);
34804460:	e59f0334 	ldr	r0, [pc, #820]	; 3480479c <do_mmcops+0x3e0>
34804464:	e5941000 	ldr	r1, [r4]
34804468:	ea000092 	b	348046b8 <do_mmcops+0x2fc>
			return 1;
		}
		mmc_init(mmc);
3480446c:	eb003788 	bl	34812294 <mmc_init>
		mmc_dev = mmc_get_dev(curr_device);
34804470:	e5940000 	ldr	r0, [r4]
34804474:	eb0037be 	bl	34812374 <mmc_get_dev>
		if (mmc_dev != NULL &&
34804478:	e2503000 	subs	r3, r0, #0
3480447c:	0a000004 	beq	34804494 <do_mmcops+0xd8>
34804480:	e5d3300b 	ldrb	r3, [r3, #11]
34804484:	e35300ff 	cmp	r3, #255	; 0xff
34804488:	0a000001 	beq	34804494 <do_mmcops+0xd8>
				mmc_dev->type != DEV_TYPE_UNKNOWN) {
			print_part(mmc_dev);
3480448c:	eb002bd0 	bl	3480f3d4 <print_part>
			return 0;
34804490:	ea0000bb 	b	34804784 <do_mmcops+0x3c8>
		}

		puts("get mmc type error!\n");
34804494:	e59f0304 	ldr	r0, [pc, #772]	; 348047a0 <do_mmcops+0x3e4>
34804498:	eb001327 	bl	3480913c <puts>
3480449c:	ea000086 	b	348046bc <do_mmcops+0x300>
		return 1;
	} else if (strcmp(argv[1], "list") == 0) {
348044a0:	e5940004 	ldr	r0, [r4, #4]
348044a4:	e59f12f8 	ldr	r1, [pc, #760]	; 348047a4 <do_mmcops+0x3e8>
348044a8:	eb005db1 	bl	3481bb74 <strcmp>
348044ac:	e2505000 	subs	r5, r0, #0
348044b0:	1a000002 	bne	348044c0 <do_mmcops+0x104>
		print_mmc_devices('\n');
348044b4:	e280000a 	add	r0, r0, #10
348044b8:	eb0037b9 	bl	348123a4 <print_mmc_devices>
		return 0;
348044bc:	ea0000b0 	b	34804784 <do_mmcops+0x3c8>
	} else if (strcmp(argv[1], "dev") == 0) {
348044c0:	e5940004 	ldr	r0, [r4, #4]
348044c4:	e59f12dc 	ldr	r1, [pc, #732]	; 348047a8 <do_mmcops+0x3ec>
348044c8:	eb005da9 	bl	3481bb74 <strcmp>
348044cc:	e2505000 	subs	r5, r0, #0
348044d0:	1a000048 	bne	348045f8 <do_mmcops+0x23c>
		int dev, part = -1;
		struct mmc *mmc;

		if (argc == 2)
348044d4:	e3570002 	cmp	r7, #2
			dev = curr_device;
348044d8:	059f32ac 	ldreq	r3, [pc, #684]	; 3480478c <do_mmcops+0x3d0>
348044dc:	05934000 	ldreq	r4, [r3]
		return 0;
	} else if (strcmp(argv[1], "dev") == 0) {
		int dev, part = -1;
		struct mmc *mmc;

		if (argc == 2)
348044e0:	0a000006 	beq	34804500 <do_mmcops+0x144>
			dev = curr_device;
		else if (argc == 3)
348044e4:	e3570003 	cmp	r7, #3
348044e8:	1a000006 	bne	34804508 <do_mmcops+0x14c>
			dev = simple_strtoul(argv[2], NULL, 10);
348044ec:	e5940008 	ldr	r0, [r4, #8]
348044f0:	e1a01005 	mov	r1, r5
348044f4:	e3a0200a 	mov	r2, #10
348044f8:	eb006164 	bl	3481ca90 <simple_strtoul>
348044fc:	e1a04000 	mov	r4, r0
		return 1;
	} else if (strcmp(argv[1], "list") == 0) {
		print_mmc_devices('\n');
		return 0;
	} else if (strcmp(argv[1], "dev") == 0) {
		int dev, part = -1;
34804500:	e3e07000 	mvn	r7, #0
34804504:	ea000010 	b	3480454c <do_mmcops+0x190>

		if (argc == 2)
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
34804508:	e3570004 	cmp	r7, #4
3480450c:	1a00009b 	bne	34804780 <do_mmcops+0x3c4>
			dev = (int)simple_strtoul(argv[2], NULL, 10);
34804510:	e1a01005 	mov	r1, r5
34804514:	e3a0200a 	mov	r2, #10
34804518:	e5940008 	ldr	r0, [r4, #8]
3480451c:	eb00615b 	bl	3481ca90 <simple_strtoul>
			part = (int)simple_strtoul(argv[3], NULL, 10);
34804520:	e1a01005 	mov	r1, r5
		if (argc == 2)
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
34804524:	e1a06000 	mov	r6, r0
			part = (int)simple_strtoul(argv[3], NULL, 10);
34804528:	e3a0200a 	mov	r2, #10
3480452c:	e594000c 	ldr	r0, [r4, #12]
34804530:	eb006156 	bl	3481ca90 <simple_strtoul>
			if (part > PART_ACCESS_MASK) {
34804534:	e3500007 	cmp	r0, #7
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
			part = (int)simple_strtoul(argv[3], NULL, 10);
34804538:	e1a07000 	mov	r7, r0
			if (part > PART_ACCESS_MASK) {
				printf("#part_num shouldn't be larger"
3480453c:	c3a01007 	movgt	r1, #7
34804540:	c59f0264 	ldrgt	r0, [pc, #612]	; 348047ac <do_mmcops+0x3f0>
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
			part = (int)simple_strtoul(argv[3], NULL, 10);
			if (part > PART_ACCESS_MASK) {
34804544:	ca00005b 	bgt	348046b8 <do_mmcops+0x2fc>
		if (argc == 2)
			dev = curr_device;
		else if (argc == 3)
			dev = simple_strtoul(argv[2], NULL, 10);
		else if (argc == 4) {
			dev = (int)simple_strtoul(argv[2], NULL, 10);
34804548:	e1a04006 	mov	r4, r6
				return 1;
			}
		} else
			return CMD_RET_USAGE;

		mmc = find_mmc_device(dev);
3480454c:	e1a00004 	mov	r0, r4
34804550:	eb003270 	bl	34810f18 <find_mmc_device>
		if (!mmc) {
34804554:	e2505000 	subs	r5, r0, #0
			printf("no mmc device at slot %x\n", dev);
34804558:	059f023c 	ldreq	r0, [pc, #572]	; 3480479c <do_mmcops+0x3e0>
3480455c:	01a01004 	moveq	r1, r4
			}
		} else
			return CMD_RET_USAGE;

		mmc = find_mmc_device(dev);
		if (!mmc) {
34804560:	0a000054 	beq	348046b8 <do_mmcops+0x2fc>
			printf("no mmc device at slot %x\n", dev);
			return 1;
		}

		mmc_init(mmc);
34804564:	eb00374a 	bl	34812294 <mmc_init>
		if (part != -1) {
34804568:	e3770001 	cmn	r7, #1
3480456c:	0a000012 	beq	348045bc <do_mmcops+0x200>
			int ret;
			if (mmc->part_config == MMCPART_NOAVAILABLE) {
34804570:	e5d53082 	ldrb	r3, [r5, #130]	; 0x82
34804574:	e35300ff 	cmp	r3, #255	; 0xff
34804578:	1a000002 	bne	34804588 <do_mmcops+0x1cc>
				printf("Card doesn't support part_switch\n");
3480457c:	e59f022c 	ldr	r0, [pc, #556]	; 348047b0 <do_mmcops+0x3f4>
34804580:	eb0012f7 	bl	34809164 <printf>
34804584:	ea00004c 	b	348046bc <do_mmcops+0x300>
				return 1;
			}

			if (part != mmc->part_num) {
34804588:	e5d53083 	ldrb	r3, [r5, #131]	; 0x83
3480458c:	e1570003 	cmp	r7, r3
34804590:	0a000009 	beq	348045bc <do_mmcops+0x200>
				ret = mmc_switch_part(dev, part);
34804594:	e1a01007 	mov	r1, r7
34804598:	e1a00004 	mov	r0, r4
3480459c:	eb003499 	bl	34811808 <mmc_switch_part>
				if (!ret)
348045a0:	e3500000 	cmp	r0, #0
					mmc->part_num = part;
348045a4:	05c57083 	strbeq	r7, [r5, #131]	; 0x83

				printf("switch to partions #%d, %s\n",
348045a8:	059f2204 	ldreq	r2, [pc, #516]	; 348047b4 <do_mmcops+0x3f8>
348045ac:	159f2204 	ldrne	r2, [pc, #516]	; 348047b8 <do_mmcops+0x3fc>
348045b0:	e59f0204 	ldr	r0, [pc, #516]	; 348047bc <do_mmcops+0x400>
348045b4:	e1a01007 	mov	r1, r7
348045b8:	eb0012e9 	bl	34809164 <printf>
						part, (!ret) ? "OK" : "ERROR");
			}
		}
		curr_device = dev;
348045bc:	e59f31c8 	ldr	r3, [pc, #456]	; 3480478c <do_mmcops+0x3d0>
348045c0:	e5834000 	str	r4, [r3]
		if (mmc->part_config == MMCPART_NOAVAILABLE)
348045c4:	e5d53082 	ldrb	r3, [r5, #130]	; 0x82
348045c8:	e35300ff 	cmp	r3, #255	; 0xff
348045cc:	1a000003 	bne	348045e0 <do_mmcops+0x224>
			printf("mmc%d is current device\n", curr_device);
348045d0:	e1a01004 	mov	r1, r4
348045d4:	e59f01e4 	ldr	r0, [pc, #484]	; 348047c0 <do_mmcops+0x404>
348045d8:	eb0012e1 	bl	34809164 <printf>
348045dc:	ea000003 	b	348045f0 <do_mmcops+0x234>
		else
			printf("mmc%d(part %d) is current device\n",
348045e0:	e59f01dc 	ldr	r0, [pc, #476]	; 348047c4 <do_mmcops+0x408>
348045e4:	e1a01004 	mov	r1, r4
348045e8:	e5d52083 	ldrb	r2, [r5, #131]	; 0x83
348045ec:	eb0012dc 	bl	34809164 <printf>
				curr_device, mmc->part_num);

		return 0;
348045f0:	e3a05000 	mov	r5, #0
348045f4:	ea000062 	b	34804784 <do_mmcops+0x3c8>
	}

	if (strcmp(argv[1], "read") == 0)
348045f8:	e5940004 	ldr	r0, [r4, #4]
348045fc:	e59f11c4 	ldr	r1, [pc, #452]	; 348047c8 <do_mmcops+0x40c>
34804600:	eb005d5b 	bl	3481bb74 <strcmp>
34804604:	e3500000 	cmp	r0, #0
		state = MMC_READ;
34804608:	03a06001 	moveq	r6, #1
				curr_device, mmc->part_num);

		return 0;
	}

	if (strcmp(argv[1], "read") == 0)
3480460c:	0a00000b 	beq	34804640 <do_mmcops+0x284>
		state = MMC_READ;
	else if (strcmp(argv[1], "write") == 0)
34804610:	e5940004 	ldr	r0, [r4, #4]
34804614:	e59f11b0 	ldr	r1, [pc, #432]	; 348047cc <do_mmcops+0x410>
34804618:	eb005d55 	bl	3481bb74 <strcmp>
3480461c:	e3500000 	cmp	r0, #0
		state = MMC_WRITE;
34804620:	03a06002 	moveq	r6, #2
		return 0;
	}

	if (strcmp(argv[1], "read") == 0)
		state = MMC_READ;
	else if (strcmp(argv[1], "write") == 0)
34804624:	0a000005 	beq	34804640 <do_mmcops+0x284>
		state = MMC_WRITE;
	else if (strcmp(argv[1], "erase") == 0)
34804628:	e5940004 	ldr	r0, [r4, #4]
3480462c:	e59f119c 	ldr	r1, [pc, #412]	; 348047d0 <do_mmcops+0x414>
34804630:	eb005d4f 	bl	3481bb74 <strcmp>
34804634:	e3500000 	cmp	r0, #0
		state = MMC_ERASE;
34804638:	03a06003 	moveq	r6, #3

	if (strcmp(argv[1], "read") == 0)
		state = MMC_READ;
	else if (strcmp(argv[1], "write") == 0)
		state = MMC_WRITE;
	else if (strcmp(argv[1], "erase") == 0)
3480463c:	1a00004f 	bne	34804780 <do_mmcops+0x3c4>
		state = MMC_ERASE;
	else
		state = MMC_INVALID;

	if (state != MMC_INVALID) {
		struct mmc *mmc = find_mmc_device(curr_device);
34804640:	e59f3144 	ldr	r3, [pc, #324]	; 3480478c <do_mmcops+0x3d0>
34804644:	e5930000 	ldr	r0, [r3]
34804648:	eb003232 	bl	34810f18 <find_mmc_device>
		int idx = 2;
		u32 blk, cnt, n;
		void *addr;

		if (state != MMC_ERASE) {
3480464c:	e3560003 	cmp	r6, #3
		state = MMC_ERASE;
	else
		state = MMC_INVALID;

	if (state != MMC_INVALID) {
		struct mmc *mmc = find_mmc_device(curr_device);
34804650:	e1a07000 	mov	r7, r0

		if (state != MMC_ERASE) {
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
			++idx;
		} else
			addr = 0;
34804654:	03a0b000 	moveq	fp, #0
	else
		state = MMC_INVALID;

	if (state != MMC_INVALID) {
		struct mmc *mmc = find_mmc_device(curr_device);
		int idx = 2;
34804658:	03a05002 	moveq	r5, #2
		u32 blk, cnt, n;
		void *addr;

		if (state != MMC_ERASE) {
3480465c:	0a000005 	beq	34804678 <do_mmcops+0x2bc>
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
34804660:	e5940008 	ldr	r0, [r4, #8]
34804664:	e3a01000 	mov	r1, #0
34804668:	e3a02010 	mov	r2, #16
3480466c:	eb006107 	bl	3481ca90 <simple_strtoul>
			++idx;
34804670:	e3a05003 	mov	r5, #3
		int idx = 2;
		u32 blk, cnt, n;
		void *addr;

		if (state != MMC_ERASE) {
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
34804674:	e1a0b000 	mov	fp, r0
			++idx;
		} else
			addr = 0;
		blk = simple_strtoul(argv[idx], NULL, 16);
34804678:	e7940105 	ldr	r0, [r4, r5, lsl #2]
3480467c:	e3a01000 	mov	r1, #0
34804680:	e3a02010 	mov	r2, #16
34804684:	eb006101 	bl	3481ca90 <simple_strtoul>
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
34804688:	e2855001 	add	r5, r5, #1
		if (state != MMC_ERASE) {
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
			++idx;
		} else
			addr = 0;
		blk = simple_strtoul(argv[idx], NULL, 16);
3480468c:	e1a09000 	mov	r9, r0
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
34804690:	e3a01000 	mov	r1, #0
34804694:	e7940105 	ldr	r0, [r4, r5, lsl #2]
34804698:	e3a02010 	mov	r2, #16
3480469c:	eb0060fb 	bl	3481ca90 <simple_strtoul>

		if (!mmc) {
348046a0:	e3570000 	cmp	r7, #0
			addr = (void *)simple_strtoul(argv[idx], NULL, 16);
			++idx;
		} else
			addr = 0;
		blk = simple_strtoul(argv[idx], NULL, 16);
		cnt = simple_strtoul(argv[idx + 1], NULL, 16);
348046a4:	e1a05000 	mov	r5, r0
348046a8:	e59fa0dc 	ldr	sl, [pc, #220]	; 3480478c <do_mmcops+0x3d0>

		if (!mmc) {
348046ac:	1a000004 	bne	348046c4 <do_mmcops+0x308>
			printf("no mmc device at slot %x\n", curr_device);
348046b0:	e59f00e4 	ldr	r0, [pc, #228]	; 3480479c <do_mmcops+0x3e0>
348046b4:	e59a1000 	ldr	r1, [sl]
348046b8:	eb0012a9 	bl	34809164 <printf>
			return 1;
348046bc:	e3a05001 	mov	r5, #1
348046c0:	ea00002f 	b	34804784 <do_mmcops+0x3c8>
		}

		printf("\nMMC %s: dev # %d, block # %d, count %d ... ",
348046c4:	e58d0000 	str	r0, [sp]
348046c8:	e5941004 	ldr	r1, [r4, #4]
348046cc:	e59a2000 	ldr	r2, [sl]
348046d0:	e1a03009 	mov	r3, r9
348046d4:	e59f00f8 	ldr	r0, [pc, #248]	; 348047d4 <do_mmcops+0x418>
348046d8:	eb0012a1 	bl	34809164 <printf>
				argv[1], curr_device, blk, cnt);

		mmc_init(mmc);
348046dc:	e1a00007 	mov	r0, r7
348046e0:	eb0036eb 	bl	34812294 <mmc_init>

		switch (state) {
348046e4:	e3560002 	cmp	r6, #2
348046e8:	0a00000c 	beq	34804720 <do_mmcops+0x364>
348046ec:	e3560003 	cmp	r6, #3
348046f0:	0a000011 	beq	3480473c <do_mmcops+0x380>
		case MMC_READ:
			n = mmc->block_dev.block_read(curr_device, blk,
348046f4:	e1a01009 	mov	r1, r9
348046f8:	e597c100 	ldr	ip, [r7, #256]	; 0x100
348046fc:	e59a0000 	ldr	r0, [sl]
34804700:	e1a02005 	mov	r2, r5
34804704:	e1a0300b 	mov	r3, fp
34804708:	e12fff3c 	blx	ip
						      cnt, addr);
			/* flush cache after read */
			flush_cache((ulong)addr, cnt * 512); /* FIXME */
3480470c:	e1a01485 	lsl	r1, r5, #9

		mmc_init(mmc);

		switch (state) {
		case MMC_READ:
			n = mmc->block_dev.block_read(curr_device, blk,
34804710:	e1a06000 	mov	r6, r0
						      cnt, addr);
			/* flush cache after read */
			flush_cache((ulong)addr, cnt * 512); /* FIXME */
34804714:	e1a0000b 	mov	r0, fp
34804718:	ebffeff4 	bl	348006f0 <flush_cache>
			break;
3480471c:	ea00000c 	b	34804754 <do_mmcops+0x398>
		case MMC_WRITE:
			n = mmc->block_dev.block_write(curr_device, blk,
34804720:	e597c104 	ldr	ip, [r7, #260]	; 0x104
34804724:	e59a0000 	ldr	r0, [sl]
34804728:	e1a01009 	mov	r1, r9
3480472c:	e1a02005 	mov	r2, r5
34804730:	e1a0300b 	mov	r3, fp
34804734:	e12fff3c 	blx	ip
34804738:	ea000004 	b	34804750 <do_mmcops+0x394>
						      cnt, addr);
			break;
		case MMC_ERASE:
			n = mmc->block_dev.block_erase(curr_device, blk, cnt);
3480473c:	e5973108 	ldr	r3, [r7, #264]	; 0x108
34804740:	e59a0000 	ldr	r0, [sl]
34804744:	e1a01009 	mov	r1, r9
34804748:	e1a02005 	mov	r2, r5
3480474c:	e12fff33 	blx	r3
34804750:	e1a06000 	mov	r6, r0
			break;
		default:
			BUG();
		}

		printf("%d blocks %s: %s\n",
34804754:	e59fc05c 	ldr	ip, [pc, #92]	; 348047b8 <do_mmcops+0x3fc>
34804758:	e1560005 	cmp	r6, r5
3480475c:	e59f3050 	ldr	r3, [pc, #80]	; 348047b4 <do_mmcops+0x3f8>
34804760:	e59f0070 	ldr	r0, [pc, #112]	; 348047d8 <do_mmcops+0x41c>
34804764:	11a0300c 	movne	r3, ip
34804768:	e1a01006 	mov	r1, r6
3480476c:	e5942004 	ldr	r2, [r4, #4]
34804770:	eb00127b 	bl	34809164 <printf>
				n, argv[1], (n == cnt) ? "OK" : "ERROR");
		return (n == cnt) ? 0 : 1;
34804774:	e0565005 	subs	r5, r6, r5
34804778:	13a05001 	movne	r5, #1
3480477c:	ea000000 	b	34804784 <do_mmcops+0x3c8>
	}

	return CMD_RET_USAGE;
34804780:	e3e05000 	mvn	r5, #0
}
34804784:	e1a00005 	mov	r0, r5
34804788:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3480478c:	348283d4 	.word	0x348283d4
34804790:	34824051 	.word	0x34824051
34804794:	3482406a 	.word	0x3482406a
34804798:	34824b07 	.word	0x34824b07
3480479c:	34824071 	.word	0x34824071
348047a0:	3482408b 	.word	0x3482408b
348047a4:	348240a0 	.word	0x348240a0
348047a8:	348240a5 	.word	0x348240a5
348047ac:	348240a9 	.word	0x348240a9
348047b0:	348240d0 	.word	0x348240d0
348047b4:	34824048 	.word	0x34824048
348047b8:	3482404b 	.word	0x3482404b
348047bc:	348240f2 	.word	0x348240f2
348047c0:	3482410e 	.word	0x3482410e
348047c4:	34824127 	.word	0x34824127
348047c8:	34824149 	.word	0x34824149
348047cc:	3482414e 	.word	0x3482414e
348047d0:	34824154 	.word	0x34824154
348047d4:	3482415a 	.word	0x3482415a
348047d8:	34824187 	.word	0x34824187

348047dc <do_mmcinfo>:

	printf("Bus Width: %d-bit\n", mmc->bus_width);
}

int do_mmcinfo (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348047dc:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
	struct mmc *mmc;

	if (curr_device < 0) {
348047e0:	e59f4128 	ldr	r4, [pc, #296]	; 34804910 <do_mmcinfo+0x134>
348047e4:	e5943000 	ldr	r3, [r4]
348047e8:	e3530000 	cmp	r3, #0
348047ec:	aa000007 	bge	34804810 <do_mmcinfo+0x34>
		if (get_mmc_num() > 0)
348047f0:	eb003704 	bl	34812408 <get_mmc_num>
348047f4:	e3500000 	cmp	r0, #0
			curr_device = 0;
348047f8:	c3a03000 	movgt	r3, #0
348047fc:	c5843000 	strgt	r3, [r4]
int do_mmcinfo (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	struct mmc *mmc;

	if (curr_device < 0) {
		if (get_mmc_num() > 0)
34804800:	ca000002 	bgt	34804810 <do_mmcinfo+0x34>
			curr_device = 0;
		else {
			puts("No MMC device available\n");
34804804:	e59f0108 	ldr	r0, [pc, #264]	; 34804914 <do_mmcinfo+0x138>
34804808:	eb00124b 	bl	3480913c <puts>
3480480c:	ea00003d 	b	34804908 <do_mmcinfo+0x12c>
			return 1;
		}
	}

	mmc = find_mmc_device(curr_device);
34804810:	e59f50f8 	ldr	r5, [pc, #248]	; 34804910 <do_mmcinfo+0x134>
34804814:	e5950000 	ldr	r0, [r5]
34804818:	eb0031be 	bl	34810f18 <find_mmc_device>

	if (mmc) {
3480481c:	e2504000 	subs	r4, r0, #0
34804820:	0a000035 	beq	348048fc <do_mmcinfo+0x120>
		mmc_init(mmc);
34804824:	eb00369a 	bl	34812294 <mmc_init>
	MMC_WRITE,
	MMC_ERASE,
};
static void print_mmcinfo(struct mmc *mmc)
{
	printf("Device: %s\n", mmc->name);
34804828:	e2841008 	add	r1, r4, #8
3480482c:	e59f00e4 	ldr	r0, [pc, #228]	; 34804918 <do_mmcinfo+0x13c>
34804830:	eb00124b 	bl	34809164 <printf>
	printf("Manufacturer ID: %x\n", mmc->cid[0] >> 24);
34804834:	e5d41073 	ldrb	r1, [r4, #115]	; 0x73
34804838:	e59f00dc 	ldr	r0, [pc, #220]	; 3480491c <do_mmcinfo+0x140>
3480483c:	eb001248 	bl	34809164 <printf>
	printf("OEM: %x\n", (mmc->cid[0] >> 8) & 0xffff);
34804840:	e5941070 	ldr	r1, [r4, #112]	; 0x70
34804844:	e59f00d4 	ldr	r0, [pc, #212]	; 34804920 <do_mmcinfo+0x144>
34804848:	e7ef1451 	ubfx	r1, r1, #8, #16
3480484c:	eb001244 	bl	34809164 <printf>
	printf("Name: %c%c%c%c%c \n", mmc->cid[0] & 0xff,
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
34804850:	e5943074 	ldr	r3, [r4, #116]	; 0x74
static void print_mmcinfo(struct mmc *mmc)
{
	printf("Device: %s\n", mmc->name);
	printf("Manufacturer ID: %x\n", mmc->cid[0] >> 24);
	printf("OEM: %x\n", (mmc->cid[0] >> 8) & 0xffff);
	printf("Name: %c%c%c%c%c \n", mmc->cid[0] & 0xff,
34804854:	e5d41070 	ldrb	r1, [r4, #112]	; 0x70
34804858:	e7e72453 	ubfx	r2, r3, #8, #8
3480485c:	e58d2000 	str	r2, [sp]
34804860:	e20320ff 	and	r2, r3, #255	; 0xff
34804864:	e58d2004 	str	r2, [sp, #4]
34804868:	e59f00b4 	ldr	r0, [pc, #180]	; 34804924 <do_mmcinfo+0x148>
3480486c:	e1a02c23 	lsr	r2, r3, #24
34804870:	e7e73853 	ubfx	r3, r3, #16, #8
34804874:	eb00123a 	bl	34809164 <printf>
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);

	printf("Tran Speed: %d\n", mmc->tran_speed);
34804878:	e5941084 	ldr	r1, [r4, #132]	; 0x84
3480487c:	e59f00a4 	ldr	r0, [pc, #164]	; 34804928 <do_mmcinfo+0x14c>
34804880:	eb001237 	bl	34809164 <printf>
	printf("Rd Block Len: %d\n", mmc->read_bl_len);
34804884:	e5941088 	ldr	r1, [r4, #136]	; 0x88
34804888:	e59f009c 	ldr	r0, [pc, #156]	; 3480492c <do_mmcinfo+0x150>
3480488c:	eb001234 	bl	34809164 <printf>

	printf("%s version %d.%d\n", IS_SD(mmc) ? "SD" : "MMC",
34804890:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34804894:	e59f2094 	ldr	r2, [pc, #148]	; 34804930 <do_mmcinfo+0x154>
34804898:	e59f1094 	ldr	r1, [pc, #148]	; 34804934 <do_mmcinfo+0x158>
3480489c:	e3130802 	tst	r3, #131072	; 0x20000
348048a0:	11a01002 	movne	r1, r2
348048a4:	e59f008c 	ldr	r0, [pc, #140]	; 34804938 <do_mmcinfo+0x15c>
348048a8:	e7e32253 	ubfx	r2, r3, #4, #4
348048ac:	e203300f 	and	r3, r3, #15
348048b0:	eb00122b 	bl	34809164 <printf>
			(mmc->version >> 4) & 0xf, mmc->version & 0xf);

	printf("High Capacity: %s\n", mmc->high_capacity ? "Yes" : "No");
348048b4:	e5941040 	ldr	r1, [r4, #64]	; 0x40
348048b8:	e59f307c 	ldr	r3, [pc, #124]	; 3480493c <do_mmcinfo+0x160>
348048bc:	e59f207c 	ldr	r2, [pc, #124]	; 34804940 <do_mmcinfo+0x164>
348048c0:	e3510000 	cmp	r1, #0
348048c4:	01a01002 	moveq	r1, r2
348048c8:	11a01003 	movne	r1, r3
348048cc:	e59f0070 	ldr	r0, [pc, #112]	; 34804944 <do_mmcinfo+0x168>
348048d0:	eb001223 	bl	34809164 <printf>
	puts("Capacity: ");
348048d4:	e59f006c 	ldr	r0, [pc, #108]	; 34804948 <do_mmcinfo+0x16c>
348048d8:	eb001217 	bl	3480913c <puts>
	print_size(mmc->capacity, "\n");
348048dc:	e1c409d8 	ldrd	r0, [r4, #152]	; 0x98
348048e0:	e59f2064 	ldr	r2, [pc, #100]	; 3480494c <do_mmcinfo+0x170>
348048e4:	eb005630 	bl	3481a1ac <print_size>

	printf("Bus Width: %d-bit\n", mmc->bus_width);
348048e8:	e59f0060 	ldr	r0, [pc, #96]	; 34804950 <do_mmcinfo+0x174>
348048ec:	e5941044 	ldr	r1, [r4, #68]	; 0x44
348048f0:	eb00121b 	bl	34809164 <printf>

	if (mmc) {
		mmc_init(mmc);

		print_mmcinfo(mmc);
		return 0;
348048f4:	e3a00000 	mov	r0, #0
348048f8:	ea000003 	b	3480490c <do_mmcinfo+0x130>
	} else {
		printf("no mmc device at slot %x\n", curr_device);
348048fc:	e59f0050 	ldr	r0, [pc, #80]	; 34804954 <do_mmcinfo+0x178>
34804900:	e5951000 	ldr	r1, [r5]
34804904:	eb001216 	bl	34809164 <printf>
		return 1;
34804908:	e3a00001 	mov	r0, #1
	}
}
3480490c:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}
34804910:	348283d4 	.word	0x348283d4
34804914:	34824051 	.word	0x34824051
34804918:	348241a4 	.word	0x348241a4
3480491c:	348241b0 	.word	0x348241b0
34804920:	348241c5 	.word	0x348241c5
34804924:	348241ce 	.word	0x348241ce
34804928:	348241e1 	.word	0x348241e1
3480492c:	348241f1 	.word	0x348241f1
34804930:	348268bf 	.word	0x348268bf
34804934:	34824199 	.word	0x34824199
34804938:	34824203 	.word	0x34824203
3480493c:	3482419d 	.word	0x3482419d
34804940:	348241a1 	.word	0x348241a1
34804944:	34824215 	.word	0x34824215
34804948:	34824228 	.word	0x34824228
3480494c:	34826214 	.word	0x34826214
34804950:	34824233 	.word	0x34824233
34804954:	34824071 	.word	0x34824071

34804958 <mtd_part_info>:
 * @param dev device that is to be searched for a partition
 * @param part_num requested partition number
 * @return pointer to the part_info, NULL otherwise
 */
static struct part_info* mtd_part_info(struct mtd_device *dev, unsigned int part_num)
{
34804958:	e92d4007 	push	{r0, r1, r2, lr}
	struct list_head *entry;
	struct part_info *part;
	int num;

	if (!dev)
3480495c:	e3500000 	cmp	r0, #0
34804960:	0a00001c 	beq	348049d8 <mtd_part_info+0x80>

	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
34804964:	e1d030bc 	ldrh	r3, [r0, #12]
34804968:	e1510003 	cmp	r1, r3
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
3480496c:	31a0c000 	movcc	ip, r0
34804970:	35bc3010 	ldrcc	r3, [ip, #16]!
				dev->id->num, dev->id->mtd_id);
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
34804974:	33a02000 	movcc	r2, #0

	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
34804978:	3a000013 	bcc	348049cc <mtd_part_info+0x74>
		printf("invalid partition number %d for device %s%d (%s)\n",
				part_num, MTD_DEV_TYPE(dev->id->type),
3480497c:	e5900008 	ldr	r0, [r0, #8]
34804980:	e5d03008 	ldrb	r3, [r0, #8]
	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
		printf("invalid partition number %d for device %s%d (%s)\n",
34804984:	e3530002 	cmp	r3, #2
34804988:	059f204c 	ldreq	r2, [pc, #76]	; 348049dc <mtd_part_info+0x84>
3480498c:	0a000003 	beq	348049a0 <mtd_part_info+0x48>
				part_num, MTD_DEV_TYPE(dev->id->type),
34804990:	e59fc048 	ldr	ip, [pc, #72]	; 348049e0 <mtd_part_info+0x88>
34804994:	e3530004 	cmp	r3, #4
34804998:	e59f2044 	ldr	r2, [pc, #68]	; 348049e4 <mtd_part_info+0x8c>
3480499c:	11a0200c 	movne	r2, ip
	debug("\n--- mtd_part_info: partition number %d for device %s%d (%s)\n",
			part_num, MTD_DEV_TYPE(dev->id->type),
			dev->id->num, dev->id->mtd_id);

	if (part_num >= dev->num_parts) {
		printf("invalid partition number %d for device %s%d (%s)\n",
348049a0:	e5d03009 	ldrb	r3, [r0, #9]
348049a4:	e5900010 	ldr	r0, [r0, #16]
348049a8:	e58d0000 	str	r0, [sp]
348049ac:	e59f0034 	ldr	r0, [pc, #52]	; 348049e8 <mtd_part_info+0x90>
348049b0:	eb0011eb 	bl	34809164 <printf>
348049b4:	ea000006 	b	348049d4 <mtd_part_info+0x7c>
	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
		part = list_entry(entry, struct part_info, link);

		if (part_num == num++) {
348049b8:	e1510002 	cmp	r1, r2
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
		part = list_entry(entry, struct part_info, link);
348049bc:	e1a00003 	mov	r0, r3

		if (part_num == num++) {
348049c0:	0a000004 	beq	348049d8 <mtd_part_info+0x80>
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
348049c4:	e5933000 	ldr	r3, [r3]
		part = list_entry(entry, struct part_info, link);

		if (part_num == num++) {
348049c8:	e2822001 	add	r2, r2, #1
		return NULL;
	}

	/* locate partition number, return it */
	num = 0;
	list_for_each(entry, &dev->parts) {
348049cc:	e153000c 	cmp	r3, ip
348049d0:	1afffff8 	bne	348049b8 <mtd_part_info+0x60>
		if (part_num == num++) {
			return part;
		}
	}

	return NULL;
348049d4:	e3a00000 	mov	r0, #0
}
348049d8:	e8bd800e 	pop	{r1, r2, r3, pc}
348049dc:	34824754 	.word	0x34824754
348049e0:	34824383 	.word	0x34824383
348049e4:	34824751 	.word	0x34824751
348049e8:	34824387 	.word	0x34824387

348049ec <index_partitions>:
 * This routine does global indexing of all partitions. Resulting index for
 * current partition is saved in 'mtddevnum'. Current partition name in
 * 'mtddevname'.
 */
static void index_partitions(void)
{
348049ec:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct list_head *dentry;
	struct mtd_device *dev;

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
348049f0:	e59f10a0 	ldr	r1, [pc, #160]	; 34804a98 <index_partitions+0xac>
348049f4:	e5914000 	ldr	r4, [r1]
348049f8:	e3540000 	cmp	r4, #0
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
348049fc:	15b13004 	ldrne	r3, [r1, #4]!
	struct mtd_device *dev;

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
		mtddevnum = 0;
34804a00:	13a02000 	movne	r2, #0
	struct list_head *dentry;
	struct mtd_device *dev;

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
34804a04:	1a000012 	bne	34804a54 <index_partitions+0x68>
34804a08:	ea00001b 	b	34804a7c <index_partitions+0x90>
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
34804a0c:	e1530004 	cmp	r3, r4
34804a10:	1a00000b 	bne	34804a44 <index_partitions+0x58>
				mtddevnum += current_mtd_partnum;
34804a14:	e59f307c 	ldr	r3, [pc, #124]	; 34804a98 <index_partitions+0xac>
				sprintf(buf, "%d", mtddevnum);
34804a18:	e1a0000d 	mov	r0, sp
	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
				mtddevnum += current_mtd_partnum;
34804a1c:	e5d3300c 	ldrb	r3, [r3, #12]
				sprintf(buf, "%d", mtddevnum);
34804a20:	e59f1074 	ldr	r1, [pc, #116]	; 34804a9c <index_partitions+0xb0>
	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
				mtddevnum += current_mtd_partnum;
34804a24:	e0822003 	add	r2, r2, r3
				sprintf(buf, "%d", mtddevnum);
34804a28:	e6ff2072 	uxth	r2, r2
34804a2c:	eb0060bd 	bl	3481cd28 <sprintf>
				setenv("mtddevnum", buf);
34804a30:	e1a0100d 	mov	r1, sp
34804a34:	e59f0064 	ldr	r0, [pc, #100]	; 34804aa0 <index_partitions+0xb4>
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
			dev = list_entry(dentry, struct mtd_device, link);
			if (dev == current_mtd_dev) {
				mtddevnum += current_mtd_partnum;
				sprintf(buf, "%d", mtddevnum);
34804a38:	e1a0400d 	mov	r4, sp
				setenv("mtddevnum", buf);
34804a3c:	eb0009d2 	bl	3480718c <setenv>
				break;
34804a40:	ea000005 	b	34804a5c <index_partitions+0x70>
			}
			mtddevnum += dev->num_parts;
34804a44:	e1d300bc 	ldrh	r0, [r3, #12]

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
34804a48:	e5933000 	ldr	r3, [r3]
				mtddevnum += current_mtd_partnum;
				sprintf(buf, "%d", mtddevnum);
				setenv("mtddevnum", buf);
				break;
			}
			mtddevnum += dev->num_parts;
34804a4c:	e0822000 	add	r2, r2, r0
34804a50:	e6ff2072 	uxth	r2, r2

	debug("--- index partitions ---\n");

	if (current_mtd_dev) {
		mtddevnum = 0;
		list_for_each(dentry, &devices) {
34804a54:	e1530001 	cmp	r3, r1
34804a58:	1affffeb 	bne	34804a0c <index_partitions+0x20>
				break;
			}
			mtddevnum += dev->num_parts;
		}

		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
34804a5c:	e59f3034 	ldr	r3, [pc, #52]	; 34804a98 <index_partitions+0xac>
34804a60:	e5d3100c 	ldrb	r1, [r3, #12]
34804a64:	e5930000 	ldr	r0, [r3]
34804a68:	ebffffba 	bl	34804958 <mtd_part_info>
34804a6c:	e1a03000 	mov	r3, r0
		setenv("mtddevname", part->name);
34804a70:	e5931008 	ldr	r1, [r3, #8]
34804a74:	e59f0028 	ldr	r0, [pc, #40]	; 34804aa4 <index_partitions+0xb8>
34804a78:	ea000004 	b	34804a90 <index_partitions+0xa4>

		debug("=> mtddevnum %d,\n=> mtddevname %s\n", mtddevnum, part->name);
	} else {
		setenv("mtddevnum", NULL);
34804a7c:	e1a01004 	mov	r1, r4
34804a80:	e59f0018 	ldr	r0, [pc, #24]	; 34804aa0 <index_partitions+0xb4>
34804a84:	eb0009c0 	bl	3480718c <setenv>
		setenv("mtddevname", NULL);
34804a88:	e59f0014 	ldr	r0, [pc, #20]	; 34804aa4 <index_partitions+0xb8>
34804a8c:	e1a01004 	mov	r1, r4
34804a90:	eb0009bd 	bl	3480718c <setenv>

		debug("=> mtddevnum NULL\n=> mtddevname NULL\n");
	}
}
34804a94:	e8bd801f 	pop	{r0, r1, r2, r3, r4, pc}
34804a98:	34829aac 	.word	0x34829aac
34804a9c:	34825a9f 	.word	0x34825a9f
34804aa0:	348243b9 	.word	0x348243b9
34804aa4:	348243c3 	.word	0x348243c3

34804aa8 <memsize_format>:
{
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
34804aa8:	e3c13103 	bic	r3, r1, #-1073741824	; 0xc0000000
 *
 * @param buf output buffer
 * @param size size to be converted to string
 */
static void memsize_format(char *buf, u32 size)
{
34804aac:	e1a02001 	mov	r2, r1
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
34804ab0:	e3530000 	cmp	r3, #0
		sprintf(buf, "%ug", size/SIZE_GB);
34804ab4:	059f1030 	ldreq	r1, [pc, #48]	; 34804aec <memsize_format+0x44>
34804ab8:	01a02f22 	lsreq	r2, r2, #30
{
#define SIZE_GB ((u32)1024*1024*1024)
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
34804abc:	0a000009 	beq	34804ae8 <memsize_format+0x40>
		sprintf(buf, "%ug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
34804ac0:	e3c234ff 	bic	r3, r2, #-16777216	; 0xff000000
34804ac4:	e3c3360f 	bic	r3, r3, #15728640	; 0xf00000
34804ac8:	e3530000 	cmp	r3, #0
		sprintf(buf, "%um", size/SIZE_MB);
34804acc:	059f101c 	ldreq	r1, [pc, #28]	; 34804af0 <memsize_format+0x48>
34804ad0:	01a02a22 	lsreq	r2, r2, #20
#define SIZE_MB ((u32)1024*1024)
#define SIZE_KB ((u32)1024)

	if ((size % SIZE_GB) == 0)
		sprintf(buf, "%ug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
34804ad4:	0a000003 	beq	34804ae8 <memsize_format+0x40>
		sprintf(buf, "%um", size/SIZE_MB);
	else if (size % SIZE_KB == 0)
34804ad8:	e1b03b02 	lsls	r3, r2, #22
		sprintf(buf, "%uk", size/SIZE_KB);
34804adc:	059f1010 	ldreq	r1, [pc, #16]	; 34804af4 <memsize_format+0x4c>
	else
		sprintf(buf, "%u", size);
34804ae0:	159f1010 	ldrne	r1, [pc, #16]	; 34804af8 <memsize_format+0x50>
	if ((size % SIZE_GB) == 0)
		sprintf(buf, "%ug", size/SIZE_GB);
	else if ((size % SIZE_MB) == 0)
		sprintf(buf, "%um", size/SIZE_MB);
	else if (size % SIZE_KB == 0)
		sprintf(buf, "%uk", size/SIZE_KB);
34804ae4:	01a02522 	lsreq	r2, r2, #10
	else
		sprintf(buf, "%u", size);
34804ae8:	ea00608e 	b	3481cd28 <sprintf>
34804aec:	348243ce 	.word	0x348243ce
34804af0:	348243d2 	.word	0x348243d2
34804af4:	348243d6 	.word	0x348243d6
34804af8:	348243da 	.word	0x348243da

34804afc <current_save>:

/**
 * Save current device and partition in environment variable 'partition'.
 */
static void current_save(void)
{
34804afc:	e92d4030 	push	{r4, r5, lr}
	char buf[16];

	debug("--- current_save ---\n");

	if (current_mtd_dev) {
34804b00:	e59f508c 	ldr	r5, [pc, #140]	; 34804b94 <current_save+0x98>

/**
 * Save current device and partition in environment variable 'partition'.
 */
static void current_save(void)
{
34804b04:	e24dd01c 	sub	sp, sp, #28
	char buf[16];

	debug("--- current_save ---\n");

	if (current_mtd_dev) {
34804b08:	e5954000 	ldr	r4, [r5]
34804b0c:	e3540000 	cmp	r4, #0
34804b10:	0a000018 	beq	34804b78 <current_save+0x7c>
		sprintf(buf, "%s%d,%d", MTD_DEV_TYPE(current_mtd_dev->id->type),
34804b14:	e5943008 	ldr	r3, [r4, #8]
34804b18:	e5d31008 	ldrb	r1, [r3, #8]
34804b1c:	e3510002 	cmp	r1, #2
34804b20:	059f2070 	ldreq	r2, [pc, #112]	; 34804b98 <current_save+0x9c>
34804b24:	0a000003 	beq	34804b38 <current_save+0x3c>
34804b28:	e59f006c 	ldr	r0, [pc, #108]	; 34804b9c <current_save+0xa0>
34804b2c:	e3510004 	cmp	r1, #4
34804b30:	e59f2068 	ldr	r2, [pc, #104]	; 34804ba0 <current_save+0xa4>
34804b34:	11a02000 	movne	r2, r0
34804b38:	e59f5054 	ldr	r5, [pc, #84]	; 34804b94 <current_save+0x98>
34804b3c:	e28d4008 	add	r4, sp, #8
34804b40:	e5d5100c 	ldrb	r1, [r5, #12]
34804b44:	e5d33009 	ldrb	r3, [r3, #9]
34804b48:	e1a00004 	mov	r0, r4
34804b4c:	e58d1000 	str	r1, [sp]
34804b50:	e59f104c 	ldr	r1, [pc, #76]	; 34804ba4 <current_save+0xa8>
34804b54:	eb006073 	bl	3481cd28 <sprintf>
					current_mtd_dev->id->num, current_mtd_partnum);

		setenv("partition", buf);
34804b58:	e1a01004 	mov	r1, r4
34804b5c:	e59f0044 	ldr	r0, [pc, #68]	; 34804ba8 <current_save+0xac>
34804b60:	eb000989 	bl	3480718c <setenv>
		strncpy(last_partition, buf, 16);
34804b64:	e2850010 	add	r0, r5, #16
34804b68:	e1a01004 	mov	r1, r4
34804b6c:	e3a02010 	mov	r2, #16
34804b70:	eb005bd5 	bl	3481bacc <strncpy>
34804b74:	ea000003 	b	34804b88 <current_save+0x8c>

		debug("=> partition %s\n", buf);
	} else {
		setenv("partition", NULL);
34804b78:	e59f0028 	ldr	r0, [pc, #40]	; 34804ba8 <current_save+0xac>
34804b7c:	e1a01004 	mov	r1, r4
34804b80:	eb000981 	bl	3480718c <setenv>
		last_partition[0] = '\0';
34804b84:	e5c54010 	strb	r4, [r5, #16]

		debug("=> partition NULL\n");
	}
	index_partitions();
34804b88:	ebffff97 	bl	348049ec <index_partitions>
}
34804b8c:	e28dd01c 	add	sp, sp, #28
34804b90:	e8bd8030 	pop	{r4, r5, pc}
34804b94:	34829aac 	.word	0x34829aac
34804b98:	34824754 	.word	0x34824754
34804b9c:	34824383 	.word	0x34824383
34804ba0:	34824751 	.word	0x34824751
34804ba4:	348243dd 	.word	0x348243dd
34804ba8:	34824b1a 	.word	0x34824b1a

34804bac <part_sort_add>:
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34804bac:	e5903010 	ldr	r3, [r0, #16]
 *
 * @param head list this partition is to be added to
 * @param new partition to be added
 */
static int part_sort_add(struct mtd_device *dev, struct part_info *part)
{
34804bb0:	e92d4070 	push	{r4, r5, r6, lr}
	struct part_info *new_pi, *curr_pi;

	/* link partition to parrent dev */
	part->dev = dev;

	if (list_empty(&dev->parts)) {
34804bb4:	e2806010 	add	r6, r0, #16
 *
 * @param head list this partition is to be added to
 * @param new partition to be added
 */
static int part_sort_add(struct mtd_device *dev, struct part_info *part)
{
34804bb8:	e1a05001 	mov	r5, r1
	struct part_info *new_pi, *curr_pi;

	/* link partition to parrent dev */
	part->dev = dev;

	if (list_empty(&dev->parts)) {
34804bbc:	e1530006 	cmp	r3, r6
 *
 * @param head list this partition is to be added to
 * @param new partition to be added
 */
static int part_sort_add(struct mtd_device *dev, struct part_info *part)
{
34804bc0:	e1a04000 	mov	r4, r0
	struct list_head *entry;
	struct part_info *new_pi, *curr_pi;

	/* link partition to parrent dev */
	part->dev = dev;
34804bc4:	e5850024 	str	r0, [r5, #36]	; 0x24

	if (list_empty(&dev->parts)) {
34804bc8:	1a000007 	bne	34804bec <part_sort_add+0x40>
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34804bcc:	e5831004 	str	r1, [r3, #4]
	new->next = next;
34804bd0:	e5813000 	str	r3, [r1]
	new->prev = prev;
34804bd4:	e5813004 	str	r3, [r1, #4]
		debug("part_sort_add: list empty\n");
		list_add(&part->link, &dev->parts);
		dev->num_parts++;
34804bd8:	e1d030bc 	ldrh	r3, [r0, #12]
	prev->next = new;
34804bdc:	e5841010 	str	r1, [r4, #16]
34804be0:	e2833001 	add	r3, r3, #1
34804be4:	e1c030bc 	strh	r3, [r0, #12]
34804be8:	ea000027 	b	34804c8c <part_sort_add+0xe0>

	new_pi = list_entry(&part->link, struct part_info, link);

	/* get current partition info if we are updating current device */
	curr_pi = NULL;
	if (dev == current_mtd_dev)
34804bec:	e59f30dc 	ldr	r3, [pc, #220]	; 34804cd0 <part_sort_add+0x124>
34804bf0:	e5932000 	ldr	r2, [r3]
34804bf4:	e1500002 	cmp	r0, r2
	}

	new_pi = list_entry(&part->link, struct part_info, link);

	/* get current partition info if we are updating current device */
	curr_pi = NULL;
34804bf8:	13a00000 	movne	r0, #0
	if (dev == current_mtd_dev)
34804bfc:	1a000001 	bne	34804c08 <part_sort_add+0x5c>
		curr_pi = mtd_part_info(current_mtd_dev, current_mtd_partnum);
34804c00:	e5d3100c 	ldrb	r1, [r3, #12]
34804c04:	ebffff53 	bl	34804958 <mtd_part_info>

	list_for_each(entry, &dev->parts) {
34804c08:	e5943010 	ldr	r3, [r4, #16]
34804c0c:	ea000022 	b	34804c9c <part_sort_add+0xf0>
		struct part_info *pi;

		pi = list_entry(entry, struct part_info, link);

		/* be compliant with kernel cmdline, allow only one partition at offset zero */
		if ((new_pi->offset == pi->offset) && (pi->offset == 0)) {
34804c10:	e5952014 	ldr	r2, [r5, #20]
34804c14:	e5931014 	ldr	r1, [r3, #20]
34804c18:	e1520001 	cmp	r2, r1
34804c1c:	1a000005 	bne	34804c38 <part_sort_add+0x8c>
34804c20:	e3520000 	cmp	r2, #0
34804c24:	1a000005 	bne	34804c40 <part_sort_add+0x94>
			printf("cannot add second partition at offset 0\n");
34804c28:	e59f00a4 	ldr	r0, [pc, #164]	; 34804cd4 <part_sort_add+0x128>
34804c2c:	eb00114c 	bl	34809164 <printf>
			return 1;
34804c30:	e3a00001 	mov	r0, #1
34804c34:	e8bd8070 	pop	{r4, r5, r6, pc}
		}

		if (new_pi->offset <= pi->offset) {
34804c38:	8a000016 	bhi	34804c98 <part_sort_add+0xec>
		struct part_info *pi;

		pi = list_entry(entry, struct part_info, link);

		/* be compliant with kernel cmdline, allow only one partition at offset zero */
		if ((new_pi->offset == pi->offset) && (pi->offset == 0)) {
34804c3c:	e1a02001 	mov	r2, r1
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34804c40:	e5931004 	ldr	r1, [r3, #4]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34804c44:	e5853000 	str	r3, [r5]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34804c48:	e5835004 	str	r5, [r3, #4]
			return 1;
		}

		if (new_pi->offset <= pi->offset) {
			list_add_tail(&part->link, entry);
			dev->num_parts++;
34804c4c:	e1d430bc 	ldrh	r3, [r4, #12]

			if (curr_pi && (pi->offset <= curr_pi->offset)) {
34804c50:	e3500000 	cmp	r0, #0
			return 1;
		}

		if (new_pi->offset <= pi->offset) {
			list_add_tail(&part->link, entry);
			dev->num_parts++;
34804c54:	e2833001 	add	r3, r3, #1
	new->next = next;
	new->prev = prev;
34804c58:	e5851004 	str	r1, [r5, #4]
	prev->next = new;
34804c5c:	e5815000 	str	r5, [r1]
34804c60:	e1c430bc 	strh	r3, [r4, #12]

			if (curr_pi && (pi->offset <= curr_pi->offset)) {
34804c64:	0a000008 	beq	34804c8c <part_sort_add+0xe0>
34804c68:	e5903014 	ldr	r3, [r0, #20]
34804c6c:	e1520003 	cmp	r2, r3
34804c70:	8a000005 	bhi	34804c8c <part_sort_add+0xe0>
				/* we are modyfing partitions for the current
				 * device, update current */
				current_mtd_partnum++;
34804c74:	e59f3054 	ldr	r3, [pc, #84]	; 34804cd0 <part_sort_add+0x124>
34804c78:	e5d3200c 	ldrb	r2, [r3, #12]
34804c7c:	e2822001 	add	r2, r2, #1
34804c80:	e5c3200c 	strb	r2, [r3, #12]
				current_save();
34804c84:	ebffff9c 	bl	34804afc <current_save>
34804c88:	ea000000 	b	34804c90 <part_sort_add+0xe4>
			} else {
				index_partitions();
34804c8c:	ebffff56 	bl	348049ec <index_partitions>
			}
			return 0;
34804c90:	e3a00000 	mov	r0, #0
34804c94:	e8bd8070 	pop	{r4, r5, r6, pc}
	/* get current partition info if we are updating current device */
	curr_pi = NULL;
	if (dev == current_mtd_dev)
		curr_pi = mtd_part_info(current_mtd_dev, current_mtd_partnum);

	list_for_each(entry, &dev->parts) {
34804c98:	e5933000 	ldr	r3, [r3]
34804c9c:	e1530006 	cmp	r3, r6
34804ca0:	1affffda 	bne	34804c10 <part_sort_add+0x64>
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34804ca4:	e5853000 	str	r3, [r5]
			return 0;
		}
	}

	list_add_tail(&part->link, &dev->parts);
	dev->num_parts++;
34804ca8:	e1d430bc 	ldrh	r3, [r4, #12]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34804cac:	e5942014 	ldr	r2, [r4, #20]
34804cb0:	e2833001 	add	r3, r3, #1
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34804cb4:	e5845014 	str	r5, [r4, #20]
	new->next = next;
	new->prev = prev;
	prev->next = new;
34804cb8:	e5825000 	str	r5, [r2]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
34804cbc:	e5852004 	str	r2, [r5, #4]
34804cc0:	e1c430bc 	strh	r3, [r4, #12]
	index_partitions();
34804cc4:	ebffff48 	bl	348049ec <index_partitions>
	return 0;
34804cc8:	e3a00000 	mov	r0, #0
}
34804ccc:	e8bd8070 	pop	{r4, r5, r6, pc}
34804cd0:	34829aac 	.word	0x34829aac
34804cd4:	348243e5 	.word	0x348243e5

34804cd8 <part_delall>:
 * Delete all partitions from parts head list, free memory.
 *
 * @param head list of partitions to delete
 */
static void part_delall(struct list_head *head)
{
34804cd8:	e92d4070 	push	{r4, r5, r6, lr}
34804cdc:	e1a06000 	mov	r6, r0
	struct list_head *entry, *n;
	struct part_info *part_tmp;

	/* clean tmp_list and free allocated memory */
	list_for_each_safe(entry, n, head) {
34804ce0:	e5900000 	ldr	r0, [r0]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34804ce4:	e3a05000 	mov	r5, #0
34804ce8:	e5904000 	ldr	r4, [r0]
34804cec:	ea000007 	b	34804d10 <part_delall+0x38>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34804cf0:	e890000c 	ldm	r0, {r2, r3}
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34804cf4:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34804cf8:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
34804cfc:	e5805004 	str	r5, [r0, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34804d00:	e5805000 	str	r5, [r0]
		part_tmp = list_entry(entry, struct part_info, link);

		list_del(entry);
		free(part_tmp);
34804d04:	eb001254 	bl	3480965c <free>
{
	struct list_head *entry, *n;
	struct part_info *part_tmp;

	/* clean tmp_list and free allocated memory */
	list_for_each_safe(entry, n, head) {
34804d08:	e1a00004 	mov	r0, r4
34804d0c:	e5944000 	ldr	r4, [r4]
34804d10:	e1500006 	cmp	r0, r6
34804d14:	1afffff5 	bne	34804cf0 <part_delall+0x18>
		part_tmp = list_entry(entry, struct part_info, link);

		list_del(entry);
		free(part_tmp);
	}
}
34804d18:	e8bd8070 	pop	{r4, r5, r6, pc}

34804d1c <device_del>:
 *
 * @param dev device to be deleted
 * @return 0 on success, 1 otherwise
 */
static int device_del(struct mtd_device *dev)
{
34804d1c:	e92d4038 	push	{r3, r4, r5, lr}
34804d20:	e1a04000 	mov	r4, r0
	part_delall(&dev->parts);
34804d24:	e2800010 	add	r0, r0, #16
34804d28:	ebffffea 	bl	34804cd8 <part_delall>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34804d2c:	e894000c 	ldm	r4, {r2, r3}
	entry->next = LIST_POISON1;
34804d30:	e3a05000 	mov	r5, #0
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34804d34:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34804d38:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
34804d3c:	e5845004 	str	r5, [r4, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34804d40:	e5845000 	str	r5, [r4]
	list_del(&dev->link);
	free(dev);
34804d44:	e1a00004 	mov	r0, r4
34804d48:	eb001243 	bl	3480965c <free>

	if (dev == current_mtd_dev) {
34804d4c:	e59f3034 	ldr	r3, [pc, #52]	; 34804d88 <device_del+0x6c>
34804d50:	e5932000 	ldr	r2, [r3]
34804d54:	e1540002 	cmp	r4, r2
34804d58:	1a000007 	bne	34804d7c <device_del+0x60>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34804d5c:	e1a02003 	mov	r2, r3
34804d60:	e5b21004 	ldr	r1, [r2, #4]!
		/* we just deleted current device */
		if (list_empty(&devices)) {
34804d64:	e1510002 	cmp	r1, r2
			current_mtd_dev = NULL;
34804d68:	05835000 	streq	r5, [r3]
		} else {
			/* reset first partition from first dev from the
			 * devices list as current */
			current_mtd_dev = list_entry(devices.next, struct mtd_device, link);
34804d6c:	15831000 	strne	r1, [r3]
			current_mtd_partnum = 0;
34804d70:	15c3500c 	strbne	r5, [r3, #12]
		}
		current_save();
34804d74:	ebffff60 	bl	34804afc <current_save>
		return 0;
34804d78:	ea000000 	b	34804d80 <device_del+0x64>
	}

	index_partitions();
34804d7c:	ebffff1a 	bl	348049ec <index_partitions>
	return 0;
}
34804d80:	e3a00000 	mov	r0, #0
34804d84:	e8bd8038 	pop	{r3, r4, r5, pc}
34804d88:	34829aac 	.word	0x34829aac

34804d8c <memsize_parse>:
 * @param ptr where parse begins
 * @param retptr output pointer to next char after parse completes (output)
 * @return resulting unsigned int
 */
static unsigned long memsize_parse (const char *const ptr, const char **retptr)
{
34804d8c:	e92d4010 	push	{r4, lr}
	unsigned long ret = simple_strtoul(ptr, (char **)retptr, 0);
34804d90:	e3a02000 	mov	r2, #0
 * @param ptr where parse begins
 * @param retptr output pointer to next char after parse completes (output)
 * @return resulting unsigned int
 */
static unsigned long memsize_parse (const char *const ptr, const char **retptr)
{
34804d94:	e1a04001 	mov	r4, r1
	unsigned long ret = simple_strtoul(ptr, (char **)retptr, 0);
34804d98:	eb005f3c 	bl	3481ca90 <simple_strtoul>

	switch (**retptr) {
34804d9c:	e5942000 	ldr	r2, [r4]
34804da0:	e5d23000 	ldrb	r3, [r2]
34804da4:	e353004d 	cmp	r3, #77	; 0x4d
34804da8:	0a00000c 	beq	34804de0 <memsize_parse+0x54>
34804dac:	8a000004 	bhi	34804dc4 <memsize_parse+0x38>
34804db0:	e3530047 	cmp	r3, #71	; 0x47
34804db4:	0a000008 	beq	34804ddc <memsize_parse+0x50>
34804db8:	e353004b 	cmp	r3, #75	; 0x4b
34804dbc:	18bd8010 	popne	{r4, pc}
34804dc0:	ea000007 	b	34804de4 <memsize_parse+0x58>
34804dc4:	e353006b 	cmp	r3, #107	; 0x6b
34804dc8:	0a000005 	beq	34804de4 <memsize_parse+0x58>
34804dcc:	e353006d 	cmp	r3, #109	; 0x6d
34804dd0:	0a000002 	beq	34804de0 <memsize_parse+0x54>
34804dd4:	e3530067 	cmp	r3, #103	; 0x67
34804dd8:	18bd8010 	popne	{r4, pc}
		case 'G':
		case 'g':
			ret <<= 10;
34804ddc:	e1a00500 	lsl	r0, r0, #10
		case 'M':
		case 'm':
			ret <<= 10;
34804de0:	e1a00500 	lsl	r0, r0, #10
		case 'K':
		case 'k':
			ret <<= 10;
			(*retptr)++;
34804de4:	e2822001 	add	r2, r2, #1
		case 'M':
		case 'm':
			ret <<= 10;
		case 'K':
		case 'k':
			ret <<= 10;
34804de8:	e1a00500 	lsl	r0, r0, #10
			(*retptr)++;
34804dec:	e5842000 	str	r2, [r4]
		default:
			break;
	}

	return ret;
}
34804df0:	e8bd8010 	pop	{r4, pc}

34804df4 <get_mtd_info>:
 * @param num mtd number
 * @param mtd a pointer to an mtd_info instance (output)
 * @return 0 if device is valid, 1 otherwise
 */
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
34804df4:	e92d4030 	push	{r4, r5, lr}
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
34804df8:	e3500002 	cmp	r0, #2
 * @param num mtd number
 * @param mtd a pointer to an mtd_info instance (output)
 * @return 0 if device is valid, 1 otherwise
 */
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
34804dfc:	e1a05002 	mov	r5, r2
34804e00:	e24dd014 	sub	sp, sp, #20
34804e04:	e1a03001 	mov	r3, r1
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
34804e08:	059f2050 	ldreq	r2, [pc, #80]	; 34804e60 <get_mtd_info+0x6c>
34804e0c:	0a000003 	beq	34804e20 <get_mtd_info+0x2c>
34804e10:	e59f104c 	ldr	r1, [pc, #76]	; 34804e64 <get_mtd_info+0x70>
34804e14:	e3500004 	cmp	r0, #4
34804e18:	e59f2048 	ldr	r2, [pc, #72]	; 34804e68 <get_mtd_info+0x74>
34804e1c:	11a02001 	movne	r2, r1
34804e20:	e59f1044 	ldr	r1, [pc, #68]	; 34804e6c <get_mtd_info+0x78>
34804e24:	e1a0000d 	mov	r0, sp
34804e28:	eb005fbe 	bl	3481cd28 <sprintf>
	*mtd = get_mtd_device_nm(mtd_dev);
34804e2c:	e1a0000d 	mov	r0, sp
34804e30:	eb003828 	bl	34812ed8 <get_mtd_device_nm>
	if (IS_ERR(*mtd)) {
34804e34:	e3700a01 	cmn	r0, #4096	; 0x1000
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
	*mtd = get_mtd_device_nm(mtd_dev);
34804e38:	e5850000 	str	r0, [r5]
 */
static int get_mtd_info(u8 type, u8 num, struct mtd_info **mtd)
{
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
34804e3c:	e1a0400d 	mov	r4, sp
	if (IS_ERR(*mtd)) {
		printf("Device %s not found!\n", mtd_dev);
		return 1;
	}

	return 0;
34804e40:	93a00000 	movls	r0, #0
{
	char mtd_dev[16];

	sprintf(mtd_dev, "%s%d", MTD_DEV_TYPE(type), num);
	*mtd = get_mtd_device_nm(mtd_dev);
	if (IS_ERR(*mtd)) {
34804e44:	9a000003 	bls	34804e58 <get_mtd_info+0x64>
		printf("Device %s not found!\n", mtd_dev);
34804e48:	e59f0020 	ldr	r0, [pc, #32]	; 34804e70 <get_mtd_info+0x7c>
34804e4c:	e1a0100d 	mov	r1, sp
34804e50:	eb0010c3 	bl	34809164 <printf>
		return 1;
34804e54:	e3a00001 	mov	r0, #1
	}

	return 0;
}
34804e58:	e28dd014 	add	sp, sp, #20
34804e5c:	e8bd8030 	pop	{r4, r5, pc}
34804e60:	34824754 	.word	0x34824754
34804e64:	34824383 	.word	0x34824383
34804e68:	34824751 	.word	0x34824751
34804e6c:	3482440e 	.word	0x3482440e
34804e70:	34824413 	.word	0x34824413

34804e74 <part_validate_eraseblock>:
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate_eraseblock(struct mtdids *id, struct part_info *part)
{
34804e74:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	struct mtd_info *mtd = NULL;
34804e78:	e3a03000 	mov	r3, #0
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate_eraseblock(struct mtdids *id, struct part_info *part)
{
34804e7c:	e1a05000 	mov	r5, r0
	struct mtd_info *mtd = NULL;
34804e80:	e28d2008 	add	r2, sp, #8
 * @param id of the parent device
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate_eraseblock(struct mtdids *id, struct part_info *part)
{
34804e84:	e1a04001 	mov	r4, r1
	struct mtd_info *mtd = NULL;
34804e88:	e5223004 	str	r3, [r2, #-4]!
	int i, j;
	ulong start;

	if (get_mtd_info(id->type, id->num, &mtd))
34804e8c:	e5d00008 	ldrb	r0, [r0, #8]
34804e90:	e5d51009 	ldrb	r1, [r5, #9]
34804e94:	ebffffd6 	bl	34804df4 <get_mtd_info>
34804e98:	e3500000 	cmp	r0, #0
34804e9c:	1a00001f 	bne	34804f20 <part_validate_eraseblock+0xac>
		return 1;

	part->sector_size = mtd->erasesize;
34804ea0:	e59d7004 	ldr	r7, [sp, #4]

	if (!mtd->numeraseregions) {
34804ea4:	e597c02c 	ldr	ip, [r7, #44]	; 0x2c
	ulong start;

	if (get_mtd_info(id->type, id->num, &mtd))
		return 1;

	part->sector_size = mtd->erasesize;
34804ea8:	e5976010 	ldr	r6, [r7, #16]

	if (!mtd->numeraseregions) {
34804eac:	e35c0000 	cmp	ip, #0
	ulong start;

	if (get_mtd_info(id->type, id->num, &mtd))
		return 1;

	part->sector_size = mtd->erasesize;
34804eb0:	e5846020 	str	r6, [r4, #32]

	if (!mtd->numeraseregions) {
34804eb4:	11a06000 	movne	r6, r0
34804eb8:	1a00002b 	bne	34804f6c <part_validate_eraseblock+0xf8>
		/*
		 * Only one eraseregion (NAND, OneNAND or uniform NOR),
		 * checking for alignment is easy here
		 */
		if ((unsigned long)part->offset % mtd->erasesize) {
34804ebc:	e5940014 	ldr	r0, [r4, #20]
34804ec0:	e1a01006 	mov	r1, r6
34804ec4:	eb006bb0 	bl	3481fd8c <__aeabi_uidivmod>
34804ec8:	e3510000 	cmp	r1, #0
34804ecc:	0a000009 	beq	34804ef8 <part_validate_eraseblock+0x84>
			printf("%s%d: partition (%s) start offset"
			       "alignment incorrect\n",
			       MTD_DEV_TYPE(id->type), id->num, part->name);
34804ed0:	e5d53008 	ldrb	r3, [r5, #8]
		/*
		 * Only one eraseregion (NAND, OneNAND or uniform NOR),
		 * checking for alignment is easy here
		 */
		if ((unsigned long)part->offset % mtd->erasesize) {
			printf("%s%d: partition (%s) start offset"
34804ed4:	e3530002 	cmp	r3, #2
34804ed8:	059f113c 	ldreq	r1, [pc, #316]	; 3480501c <part_validate_eraseblock+0x1a8>
34804edc:	0a000003 	beq	34804ef0 <part_validate_eraseblock+0x7c>
			       "alignment incorrect\n",
			       MTD_DEV_TYPE(id->type), id->num, part->name);
34804ee0:	e59f2138 	ldr	r2, [pc, #312]	; 34805020 <part_validate_eraseblock+0x1ac>
34804ee4:	e3530004 	cmp	r3, #4
34804ee8:	e59f1134 	ldr	r1, [pc, #308]	; 34805024 <part_validate_eraseblock+0x1b0>
34804eec:	01a01002 	moveq	r1, r2
		/*
		 * Only one eraseregion (NAND, OneNAND or uniform NOR),
		 * checking for alignment is easy here
		 */
		if ((unsigned long)part->offset % mtd->erasesize) {
			printf("%s%d: partition (%s) start offset"
34804ef0:	e59f0130 	ldr	r0, [pc, #304]	; 34805028 <part_validate_eraseblock+0x1b4>
34804ef4:	ea000006 	b	34804f14 <part_validate_eraseblock+0xa0>
			       "alignment incorrect\n",
			       MTD_DEV_TYPE(id->type), id->num, part->name);
			return 1;
		}

		if (part->size % mtd->erasesize) {
34804ef8:	e5940010 	ldr	r0, [r4, #16]
34804efc:	e1a01006 	mov	r1, r6
34804f00:	eb006ba1 	bl	3481fd8c <__aeabi_uidivmod>
34804f04:	e2510000 	subs	r0, r1, #0
34804f08:	1a000038 	bne	34804ff0 <part_validate_eraseblock+0x17c>
34804f0c:	ea000041 	b	34805018 <part_validate_eraseblock+0x1a4>
			printf("%s%d: partition (%s) size alignment incorrect\n",
34804f10:	e59f0114 	ldr	r0, [pc, #276]	; 3480502c <part_validate_eraseblock+0x1b8>
34804f14:	e5d52009 	ldrb	r2, [r5, #9]
34804f18:	e5943008 	ldr	r3, [r4, #8]
34804f1c:	eb001090 	bl	34809164 <printf>
			       MTD_DEV_TYPE(id->type), id->num, part->name);
			return 1;
34804f20:	e3a00001 	mov	r0, #1
34804f24:	ea00003b 	b	34805018 <part_validate_eraseblock+0x1a4>
		 * checking for alignment is more complex here
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
34804f28:	e5971030 	ldr	r1, [r7, #48]	; 0x30
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34804f2c:	e3a0a000 	mov	sl, #0
		 * checking for alignment is more complex here
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
34804f30:	e0819000 	add	r9, r1, r0
34804f34:	e7913000 	ldr	r3, [r1, r0]
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34804f38:	e599b00c 	ldr	fp, [r9, #12]
34804f3c:	ea000006 	b	34804f5c <part_validate_eraseblock+0xe8>
				if (part->offset == start)
34804f40:	e5942014 	ldr	r2, [r4, #20]
34804f44:	e1520003 	cmp	r2, r3
34804f48:	03a00000 	moveq	r0, #0
34804f4c:	0a000021 	beq	34804fd8 <part_validate_eraseblock+0x164>
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
34804f50:	e5992008 	ldr	r2, [r9, #8]
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34804f54:	e28aa001 	add	sl, sl, #1
				if (part->offset == start)
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
34804f58:	e0833002 	add	r3, r3, r2
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34804f5c:	e15a000b 	cmp	sl, fp
34804f60:	3afffff6 	bcc	34804f40 <part_validate_eraseblock+0xcc>
		 * Multiple eraseregions (non-uniform NOR),
		 * checking for alignment is more complex here
		 */

		/* Check start alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
34804f64:	e2866001 	add	r6, r6, #1
34804f68:	e2800018 	add	r0, r0, #24
34804f6c:	e156000c 	cmp	r6, ip
34804f70:	baffffec 	blt	34804f28 <part_validate_eraseblock+0xb4>
				start += mtd->eraseregions[i].erasesize;
			}
		}

		printf("%s%d: partition (%s) start offset alignment incorrect\n",
		       MTD_DEV_TYPE(id->type), id->num, part->name);
34804f74:	e5d53008 	ldrb	r3, [r5, #8]
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
			}
		}

		printf("%s%d: partition (%s) start offset alignment incorrect\n",
34804f78:	e3530002 	cmp	r3, #2
34804f7c:	059f1098 	ldreq	r1, [pc, #152]	; 3480501c <part_validate_eraseblock+0x1a8>
34804f80:	0a000003 	beq	34804f94 <part_validate_eraseblock+0x120>
		       MTD_DEV_TYPE(id->type), id->num, part->name);
34804f84:	e59f2094 	ldr	r2, [pc, #148]	; 34805020 <part_validate_eraseblock+0x1ac>
34804f88:	e3530004 	cmp	r3, #4
34804f8c:	e59f1090 	ldr	r1, [pc, #144]	; 34805024 <part_validate_eraseblock+0x1b0>
34804f90:	01a01002 	moveq	r1, r2
					goto start_ok;
				start += mtd->eraseregions[i].erasesize;
			}
		}

		printf("%s%d: partition (%s) start offset alignment incorrect\n",
34804f94:	e59f0094 	ldr	r0, [pc, #148]	; 34805030 <part_validate_eraseblock+0x1bc>
34804f98:	eaffffdd 	b	34804f14 <part_validate_eraseblock+0xa0>

	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
34804f9c:	e5913000 	ldr	r3, [r1]
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34804fa0:	e591700c 	ldr	r7, [r1, #12]
34804fa4:	e3a06000 	mov	r6, #0
34804fa8:	ea000006 	b	34804fc8 <part_validate_eraseblock+0x154>
				if ((part->offset + part->size) == start)
34804fac:	e594a010 	ldr	sl, [r4, #16]
34804fb0:	e082a00a 	add	sl, r2, sl
34804fb4:	e15a0003 	cmp	sl, r3
34804fb8:	0a000015 	beq	34805014 <part_validate_eraseblock+0x1a0>
					goto end_ok;
				start += mtd->eraseregions[i].erasesize;
34804fbc:	e591a008 	ldr	sl, [r1, #8]
	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34804fc0:	e2866001 	add	r6, r6, #1
				if ((part->offset + part->size) == start)
					goto end_ok;
				start += mtd->eraseregions[i].erasesize;
34804fc4:	e083300a 	add	r3, r3, sl
	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
			start = mtd->eraseregions[i].offset;
			for (j = 0; j < mtd->eraseregions[i].numblocks; j++) {
34804fc8:	e1560007 	cmp	r6, r7
34804fcc:	3afffff6 	bcc	34804fac <part_validate_eraseblock+0x138>
		return 1;

	start_ok:

		/* Check end/size alignment */
		for (i = 0; i < mtd->numeraseregions; i++) {
34804fd0:	e2800001 	add	r0, r0, #1
34804fd4:	e2811018 	add	r1, r1, #24
34804fd8:	e150000c 	cmp	r0, ip
34804fdc:	baffffee 	blt	34804f9c <part_validate_eraseblock+0x128>
					goto end_ok;
				start += mtd->eraseregions[i].erasesize;
			}
		}
		/* Check last sector alignment */
		if ((part->offset + part->size) == start)
34804fe0:	e5941010 	ldr	r1, [r4, #16]
34804fe4:	e0822001 	add	r2, r2, r1
34804fe8:	e1520003 	cmp	r2, r3
34804fec:	0a000008 	beq	34805014 <part_validate_eraseblock+0x1a0>
			goto end_ok;

		printf("%s%d: partition (%s) size alignment incorrect\n",
		       MTD_DEV_TYPE(id->type), id->num, part->name);
34804ff0:	e5d53008 	ldrb	r3, [r5, #8]
		}
		/* Check last sector alignment */
		if ((part->offset + part->size) == start)
			goto end_ok;

		printf("%s%d: partition (%s) size alignment incorrect\n",
34804ff4:	e3530002 	cmp	r3, #2
			       MTD_DEV_TYPE(id->type), id->num, part->name);
			return 1;
		}

		if (part->size % mtd->erasesize) {
			printf("%s%d: partition (%s) size alignment incorrect\n",
34804ff8:	059f101c 	ldreq	r1, [pc, #28]	; 3480501c <part_validate_eraseblock+0x1a8>
		}
		/* Check last sector alignment */
		if ((part->offset + part->size) == start)
			goto end_ok;

		printf("%s%d: partition (%s) size alignment incorrect\n",
34804ffc:	0affffc3 	beq	34804f10 <part_validate_eraseblock+0x9c>
		       MTD_DEV_TYPE(id->type), id->num, part->name);
34805000:	e59f2018 	ldr	r2, [pc, #24]	; 34805020 <part_validate_eraseblock+0x1ac>
34805004:	e3530004 	cmp	r3, #4
34805008:	e59f1014 	ldr	r1, [pc, #20]	; 34805024 <part_validate_eraseblock+0x1b0>
3480500c:	01a01002 	moveq	r1, r2
34805010:	eaffffbe 	b	34804f10 <part_validate_eraseblock+0x9c>
		return 1;

	end_ok:
		return 0;
34805014:	e3a00000 	mov	r0, #0
	}

	return 0;
}
34805018:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3480501c:	34824754 	.word	0x34824754
34805020:	34824751 	.word	0x34824751
34805024:	34824383 	.word	0x34824383
34805028:	34824429 	.word	0x34824429
3480502c:	3482445f 	.word	0x3482445f
34805030:	3482448e 	.word	0x3482448e

34805034 <device_delall.clone.2>:
 * Delete all mtd devices from a supplied devices list, free memory allocated for
 * each device and delete all device partitions.
 *
 * @return 0 on success, 1 otherwise
 */
static int device_delall(struct list_head *head)
34805034:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
{
	struct list_head *entry, *n;
	struct mtd_device *dev_tmp;

	/* clean devices list */
	list_for_each_safe(entry, n, head) {
34805038:	e59f6054 	ldr	r6, [pc, #84]	; 34805094 <device_delall.clone.2+0x60>
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
3480503c:	e3a07000 	mov	r7, #0
34805040:	e5b64004 	ldr	r4, [r6, #4]!
34805044:	e5945000 	ldr	r5, [r4]
34805048:	ea00000a 	b	34805078 <device_delall.clone.2+0x44>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
3480504c:	e894000c 	ldm	r4, {r2, r3}
		dev_tmp = list_entry(entry, struct mtd_device, link);
		list_del(entry);
		part_delall(&dev_tmp->parts);
34805050:	e2840010 	add	r0, r4, #16
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34805054:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34805058:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
3480505c:	e5847004 	str	r7, [r4, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34805060:	e5847000 	str	r7, [r4]
34805064:	ebffff1b 	bl	34804cd8 <part_delall>
		free(dev_tmp);
34805068:	e1a00004 	mov	r0, r4
3480506c:	eb00117a 	bl	3480965c <free>
{
	struct list_head *entry, *n;
	struct mtd_device *dev_tmp;

	/* clean devices list */
	list_for_each_safe(entry, n, head) {
34805070:	e1a04005 	mov	r4, r5
34805074:	e5955000 	ldr	r5, [r5]
34805078:	e1540006 	cmp	r4, r6
{
	last_parts[0] = '\0';
	current_mtd_dev = NULL;
	current_save();

	return device_delall(&devices);
3480507c:	e59f3010 	ldr	r3, [pc, #16]	; 34805094 <device_delall.clone.2+0x60>
{
	struct list_head *entry, *n;
	struct mtd_device *dev_tmp;

	/* clean devices list */
	list_for_each_safe(entry, n, head) {
34805080:	1afffff1 	bne	3480504c <device_delall.clone.2+0x18>
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34805084:	e5834004 	str	r4, [r3, #4]
	list->prev = list;
34805088:	e5834008 	str	r4, [r3, #8]
		free(dev_tmp);
	}
	INIT_LIST_HEAD(&devices);

	return 0;
}
3480508c:	e3a00000 	mov	r0, #0
34805090:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34805094:	34829aac 	.word	0x34829aac

34805098 <mtd_devices_init>:
 *
 * @return 0 on success, 1 otherwise
 */
static int mtd_devices_init(void)
{
	last_parts[0] = '\0';
34805098:	e59f3018 	ldr	r3, [pc, #24]	; 348050b8 <mtd_devices_init+0x20>
3480509c:	e3a02000 	mov	r2, #0
 * Initialize global device list.
 *
 * @return 0 on success, 1 otherwise
 */
static int mtd_devices_init(void)
{
348050a0:	e92d4010 	push	{r4, lr}
	last_parts[0] = '\0';
348050a4:	e5c32020 	strb	r2, [r3, #32]
	current_mtd_dev = NULL;
348050a8:	e5832000 	str	r2, [r3]
	current_save();
348050ac:	ebfffe92 	bl	34804afc <current_save>

	return device_delall(&devices);
}
348050b0:	e8bd4010 	pop	{r4, lr}
{
	last_parts[0] = '\0';
	current_mtd_dev = NULL;
	current_save();

	return device_delall(&devices);
348050b4:	eaffffde 	b	34805034 <device_delall.clone.2>
348050b8:	34829aac 	.word	0x34829aac

348050bc <generate_mtdparts_save.clone.1>:
 *
 * @param buf output buffer holding generated mtdparts string (output)
 * @param buflen buffer size
 * @return 0 on success, 1 otherwise
 */
static int generate_mtdparts_save(char *buf, u32 buflen)
348050bc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
348050c0:	e59f52a8 	ldr	r5, [pc, #680]	; 34805370 <generate_mtdparts_save.clone.1+0x2b4>
348050c4:	e24dd030 	sub	sp, sp, #48	; 0x30
	u32 size, offset, len, part_cnt;
	u32 maxlen = buflen - 1;

	debug("--- generate_mtdparts ---\n");

	if (list_empty(&devices)) {
348050c8:	e5952004 	ldr	r2, [r5, #4]
348050cc:	e2853004 	add	r3, r5, #4
348050d0:	e1520003 	cmp	r2, r3
		buf[0] = '\0';
348050d4:	03a04000 	moveq	r4, #0
348050d8:	05c54020 	strbeq	r4, [r5, #32]
	u32 size, offset, len, part_cnt;
	u32 maxlen = buflen - 1;

	debug("--- generate_mtdparts ---\n");

	if (list_empty(&devices)) {
348050dc:	0a000095 	beq	34805338 <generate_mtdparts_save.clone.1+0x27c>
		buf[0] = '\0';
		return 0;
	}

	sprintf(p, "mtdparts=");
348050e0:	e2850020 	add	r0, r5, #32
348050e4:	e59f1288 	ldr	r1, [pc, #648]	; 34805374 <generate_mtdparts_save.clone.1+0x2b8>
348050e8:	eb005f0e 	bl	3481cd28 <sprintf>
	struct mtd_device *dev;
	struct part_info *part, *prev_part;
	char *p = buf;
	char tmpbuf[32];
	u32 size, offset, len, part_cnt;
	u32 maxlen = buflen - 1;
348050ec:	e30041ff 	movw	r4, #511	; 0x1ff
	}

	sprintf(p, "mtdparts=");
	p += 9;

	list_for_each(dentry, &devices) {
348050f0:	e5957004 	ldr	r7, [r5, #4]
			size = part->size;
			offset = part->offset;
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
348050f4:	e28d9010 	add	r9, sp, #16
		buf[0] = '\0';
		return 0;
	}

	sprintf(p, "mtdparts=");
	p += 9;
348050f8:	e2855029 	add	r5, r5, #41	; 0x29
348050fc:	ea000083 	b	34805310 <generate_mtdparts_save.clone.1+0x254>

	list_for_each(dentry, &devices) {
		dev = list_entry(dentry, struct mtd_device, link);

		/* copy mtd_id */
		len = strlen(dev->id->mtd_id) + 1;
34805100:	e5973008 	ldr	r3, [r7, #8]
34805104:	e5930010 	ldr	r0, [r3, #16]
34805108:	eb005acd 	bl	3481bc44 <strlen>
3480510c:	e280a001 	add	sl, r0, #1
		if (len > maxlen)
34805110:	e15a0004 	cmp	sl, r4

	list_for_each(dentry, &devices) {
		dev = list_entry(dentry, struct mtd_device, link);

		/* copy mtd_id */
		len = strlen(dev->id->mtd_id) + 1;
34805114:	e1a06000 	mov	r6, r0
		if (len > maxlen)
34805118:	8a000082 	bhi	34805328 <generate_mtdparts_save.clone.1+0x26c>
			goto cleanup;
		memcpy(p, dev->id->mtd_id, len - 1);
3480511c:	e5973008 	ldr	r3, [r7, #8]
34805120:	e1a00005 	mov	r0, r5
34805124:	e5931010 	ldr	r1, [r3, #16]
34805128:	e1a02006 	mov	r2, r6
3480512c:	eb005b88 	bl	3481bf54 <memcpy>
		p += len - 1;
		*(p++) = ':';
34805130:	e3a0203a 	mov	r2, #58	; 0x3a
34805134:	e7c52006 	strb	r2, [r5, r6]
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
34805138:	e1a02007 	mov	r2, r7
		/* copy mtd_id */
		len = strlen(dev->id->mtd_id) + 1;
		if (len > maxlen)
			goto cleanup;
		memcpy(p, dev->id->mtd_id, len - 1);
		p += len - 1;
3480513c:	e0853006 	add	r3, r5, r6
		*(p++) = ':';
		maxlen -= len;
34805140:	e06a4004 	rsb	r4, sl, r4

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
34805144:	e5b2a010 	ldr	sl, [r2, #16]!
		len = strlen(dev->id->mtd_id) + 1;
		if (len > maxlen)
			goto cleanup;
		memcpy(p, dev->id->mtd_id, len - 1);
		p += len - 1;
		*(p++) = ':';
34805148:	e2835001 	add	r5, r3, #1
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
3480514c:	e3a03000 	mov	r3, #0
		list_for_each(pentry, &dev->parts) {
34805150:	e88d0088 	stm	sp, {r3, r7}
34805154:	e58d2004 	str	r2, [sp, #4]
		p += len - 1;
		*(p++) = ':';
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
34805158:	e1a0b003 	mov	fp, r3
3480515c:	ea00005e 	b	348052dc <generate_mtdparts_save.clone.1+0x220>
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
34805160:	e59a2014 	ldr	r2, [sl, #20]
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
34805164:	e1a00009 	mov	r0, r9
34805168:	e59a1010 	ldr	r1, [sl, #16]
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
3480516c:	e58d2008 	str	r2, [sp, #8]

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
34805170:	e58da00c 	str	sl, [sp, #12]
			size = part->size;
			offset = part->offset;
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
34805174:	ebfffe4b 	bl	34804aa8 <memsize_format>
			len = strlen(tmpbuf);
34805178:	e1a00009 	mov	r0, r9
3480517c:	eb005ab0 	bl	3481bc44 <strlen>
			if (len > maxlen)
34805180:	e1500004 	cmp	r0, r4
			offset = part->offset;
			part_cnt++;

			/* partition size */
			memsize_format(tmpbuf, size);
			len = strlen(tmpbuf);
34805184:	e1a06000 	mov	r6, r0
			if (len > maxlen)
34805188:	8a000066 	bhi	34805328 <generate_mtdparts_save.clone.1+0x26c>
				goto cleanup;
			memcpy(p, tmpbuf, len);
3480518c:	e1a00005 	mov	r0, r5
34805190:	e1a02006 	mov	r2, r6
34805194:	e1a01009 	mov	r1, r9
34805198:	eb005b6d 	bl	3481bf54 <memcpy>
			maxlen -= len;


			/* add offset only when there is a gap between
			 * partitions */
			if ((!prev_part && (offset != 0)) ||
3480519c:	e59d2008 	ldr	r2, [sp, #8]
348051a0:	e27b3001 	rsbs	r3, fp, #1
348051a4:	33a03000 	movcc	r3, #0
348051a8:	e3520000 	cmp	r2, #0
348051ac:	03a03000 	moveq	r3, #0
348051b0:	e3530000 	cmp	r3, #0
			memsize_format(tmpbuf, size);
			len = strlen(tmpbuf);
			if (len > maxlen)
				goto cleanup;
			memcpy(p, tmpbuf, len);
			p += len;
348051b4:	e0855006 	add	r5, r5, r6
			maxlen -= len;
348051b8:	e0664004 	rsb	r4, r6, r4


			/* add offset only when there is a gap between
			 * partitions */
			if ((!prev_part && (offset != 0)) ||
348051bc:	1a000007 	bne	348051e0 <generate_mtdparts_save.clone.1+0x124>
348051c0:	e35b0000 	cmp	fp, #0
348051c4:	0a000016 	beq	34805224 <generate_mtdparts_save.clone.1+0x168>
					(prev_part && ((prev_part->offset + prev_part->size) != part->offset))) {
348051c8:	e59b3014 	ldr	r3, [fp, #20]
348051cc:	e59b2010 	ldr	r2, [fp, #16]
348051d0:	e0822003 	add	r2, r2, r3
348051d4:	e59a3014 	ldr	r3, [sl, #20]
348051d8:	e1520003 	cmp	r2, r3
348051dc:	0a000010 	beq	34805224 <generate_mtdparts_save.clone.1+0x168>

				memsize_format(tmpbuf, offset);
348051e0:	e1a00009 	mov	r0, r9
348051e4:	e59d1008 	ldr	r1, [sp, #8]
348051e8:	ebfffe2e 	bl	34804aa8 <memsize_format>
				len = strlen(tmpbuf) + 1;
348051ec:	e1a00009 	mov	r0, r9
348051f0:	eb005a93 	bl	3481bc44 <strlen>
348051f4:	e280b001 	add	fp, r0, #1
				if (len > maxlen)
348051f8:	e15b0004 	cmp	fp, r4
			 * partitions */
			if ((!prev_part && (offset != 0)) ||
					(prev_part && ((prev_part->offset + prev_part->size) != part->offset))) {

				memsize_format(tmpbuf, offset);
				len = strlen(tmpbuf) + 1;
348051fc:	e1a06000 	mov	r6, r0
				if (len > maxlen)
34805200:	8a000048 	bhi	34805328 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;
				*(p++) = '@';
34805204:	e3a03040 	mov	r3, #64	; 0x40
34805208:	e4c53001 	strb	r3, [r5], #1
				memcpy(p, tmpbuf, len - 1);
3480520c:	e1a00005 	mov	r0, r5
34805210:	e1a01009 	mov	r1, r9
34805214:	e1a02006 	mov	r2, r6
34805218:	eb005b4d 	bl	3481bf54 <memcpy>
				p += len - 1;
3480521c:	e0855006 	add	r5, r5, r6
				maxlen -= len;
34805220:	e06b4004 	rsb	r4, fp, r4
			}

			/* copy name only if user supplied */
			if(!part->auto_name) {
34805224:	e5da300c 	ldrb	r3, [sl, #12]
34805228:	e3530000 	cmp	r3, #0
3480522c:	1a000010 	bne	34805274 <generate_mtdparts_save.clone.1+0x1b8>
				len = strlen(part->name) + 2;
34805230:	e59a0008 	ldr	r0, [sl, #8]
34805234:	eb005a82 	bl	3481bc44 <strlen>
34805238:	e280b002 	add	fp, r0, #2
				if (len > maxlen)
3480523c:	e15b0004 	cmp	fp, r4
				maxlen -= len;
			}

			/* copy name only if user supplied */
			if(!part->auto_name) {
				len = strlen(part->name) + 2;
34805240:	e1a06000 	mov	r6, r0
				if (len > maxlen)
34805244:	8a000037 	bhi	34805328 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;

				*(p++) = '(';
34805248:	e3a02028 	mov	r2, #40	; 0x28
3480524c:	e4c52001 	strb	r2, [r5], #1
				memcpy(p, part->name, len - 2);
34805250:	e1a00005 	mov	r0, r5
34805254:	e1a02006 	mov	r2, r6
34805258:	e59a1008 	ldr	r1, [sl, #8]
3480525c:	eb005b3c 	bl	3481bf54 <memcpy>
				p += len - 2;
34805260:	e0853006 	add	r3, r5, r6
				*(p++) = ')';
34805264:	e3a02029 	mov	r2, #41	; 0x29
34805268:	e7c52006 	strb	r2, [r5, r6]
				maxlen -= len;
3480526c:	e06b4004 	rsb	r4, fp, r4
					goto cleanup;

				*(p++) = '(';
				memcpy(p, part->name, len - 2);
				p += len - 2;
				*(p++) = ')';
34805270:	e2835001 	add	r5, r3, #1
				maxlen -= len;
			}

			/* ro mask flag */
			if (part->mask_flags && MTD_WRITEABLE_CMD) {
34805274:	e59a301c 	ldr	r3, [sl, #28]
34805278:	e3530000 	cmp	r3, #0
3480527c:	0a000008 	beq	348052a4 <generate_mtdparts_save.clone.1+0x1e8>
				len = 2;
				if (len > maxlen)
34805280:	e3540001 	cmp	r4, #1
34805284:	9a000027 	bls	34805328 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;
				*(p++) = 'r';
34805288:	e1a03005 	mov	r3, r5
3480528c:	e3a02072 	mov	r2, #114	; 0x72
34805290:	e4c32001 	strb	r2, [r3], #1
				*(p++) = 'o';
34805294:	e3a0206f 	mov	r2, #111	; 0x6f
34805298:	e5c52001 	strb	r2, [r5, #1]
				maxlen -= 2;
3480529c:	e2444002 	sub	r4, r4, #2
			if (part->mask_flags && MTD_WRITEABLE_CMD) {
				len = 2;
				if (len > maxlen)
					goto cleanup;
				*(p++) = 'r';
				*(p++) = 'o';
348052a0:	e2835001 	add	r5, r3, #1
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
			part = list_entry(pentry, struct part_info, link);
			size = part->size;
			offset = part->offset;
			part_cnt++;
348052a4:	e59d3000 	ldr	r3, [sp]
348052a8:	e2833001 	add	r3, r3, #1
348052ac:	e58d3000 	str	r3, [sp]
				maxlen -= 2;
			}

			/* print ',' separator if there are other partitions
			 * following */
			if (dev->num_parts > part_cnt) {
348052b0:	e59d2000 	ldr	r2, [sp]
348052b4:	e1d730bc 	ldrh	r3, [r7, #12]
348052b8:	e1530002 	cmp	r3, r2
348052bc:	9a000004 	bls	348052d4 <generate_mtdparts_save.clone.1+0x218>
				if (1 > maxlen)
348052c0:	e3540000 	cmp	r4, #0
348052c4:	0a000017 	beq	34805328 <generate_mtdparts_save.clone.1+0x26c>
					goto cleanup;
				*(p++) = ',';
348052c8:	e3a0302c 	mov	r3, #44	; 0x2c
348052cc:	e4c53001 	strb	r3, [r5], #1
				maxlen--;
348052d0:	e2444001 	sub	r4, r4, #1
		maxlen -= len;

		/* format partitions */
		prev_part = NULL;
		part_cnt = 0;
		list_for_each(pentry, &dev->parts) {
348052d4:	e59aa000 	ldr	sl, [sl]
348052d8:	e59db00c 	ldr	fp, [sp, #12]
348052dc:	e59d2004 	ldr	r2, [sp, #4]
348052e0:	e15a0002 	cmp	sl, r2
348052e4:	1affff9d 	bne	34805160 <generate_mtdparts_save.clone.1+0xa4>
				maxlen--;
			}
			prev_part = part;
		}
		/* print ';' separator if there are other devices following */
		if (dentry->next != &devices) {
348052e8:	e5972000 	ldr	r2, [r7]
348052ec:	e59f3084 	ldr	r3, [pc, #132]	; 34805378 <generate_mtdparts_save.clone.1+0x2bc>
348052f0:	e1520003 	cmp	r2, r3
348052f4:	0a000004 	beq	3480530c <generate_mtdparts_save.clone.1+0x250>
			if (1 > maxlen)
348052f8:	e3540000 	cmp	r4, #0
348052fc:	0a000009 	beq	34805328 <generate_mtdparts_save.clone.1+0x26c>
				goto cleanup;
			*(p++) = ';';
34805300:	e3a0303b 	mov	r3, #59	; 0x3b
34805304:	e4c53001 	strb	r3, [r5], #1
			maxlen--;
34805308:	e2444001 	sub	r4, r4, #1
	}

	sprintf(p, "mtdparts=");
	p += 9;

	list_for_each(dentry, &devices) {
3480530c:	e5977000 	ldr	r7, [r7]
34805310:	e59f3060 	ldr	r3, [pc, #96]	; 34805378 <generate_mtdparts_save.clone.1+0x2bc>
34805314:	e1570003 	cmp	r7, r3
34805318:	1affff78 	bne	34805100 <generate_mtdparts_save.clone.1+0x44>
		}
	}

	/* we still have at least one char left, as we decremented maxlen at
	 * the begining */
	*p = '\0';
3480531c:	e3a04000 	mov	r4, #0
34805320:	e5c54000 	strb	r4, [r5]
34805324:	ea000003 	b	34805338 <generate_mtdparts_save.clone.1+0x27c>

	return 0;

cleanup:
	last_parts[0] = '\0';
34805328:	e59f3040 	ldr	r3, [pc, #64]	; 34805370 <generate_mtdparts_save.clone.1+0x2b4>
3480532c:	e3a02000 	mov	r2, #0
34805330:	e5c32020 	strb	r2, [r3, #32]
	return 1;
34805334:	e3a04001 	mov	r4, #1
{
	int ret;

	ret = generate_mtdparts(buf, buflen);

	if ((buf[0] != '\0') && (ret == 0))
34805338:	e59f3030 	ldr	r3, [pc, #48]	; 34805370 <generate_mtdparts_save.clone.1+0x2b4>
3480533c:	e2242001 	eor	r2, r4, #1
34805340:	e5d31020 	ldrb	r1, [r3, #32]
34805344:	e3510000 	cmp	r1, #0
34805348:	03a01000 	moveq	r1, #0
3480534c:	12021001 	andne	r1, r2, #1
34805350:	e3510000 	cmp	r1, #0
		setenv("mtdparts", buf);
34805354:	159f0020 	ldrne	r0, [pc, #32]	; 3480537c <generate_mtdparts_save.clone.1+0x2c0>
34805358:	12831020 	addne	r1, r3, #32
	else
		setenv("mtdparts", NULL);
3480535c:	059f0018 	ldreq	r0, [pc, #24]	; 3480537c <generate_mtdparts_save.clone.1+0x2c0>
34805360:	eb000789 	bl	3480718c <setenv>

	return ret;
}
34805364:	e1a00004 	mov	r0, r4
34805368:	e28dd030 	add	sp, sp, #48	; 0x30
3480536c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34805370:	34829aac 	.word	0x34829aac
34805374:	348244c5 	.word	0x348244c5
34805378:	34829ab0 	.word	0x34829ab0
3480537c:	348244cf 	.word	0x348244cf

34805380 <mtd_device_validate>:
 * @param num mtd number
 * @param size a pointer to the size of the mtd device (output)
 * @return 0 if device is valid, 1 otherwise
 */
int mtd_device_validate(u8 type, u8 num, u32 *size)
{
34805380:	e92d4013 	push	{r0, r1, r4, lr}
	struct mtd_info *mtd = NULL;
34805384:	e3a03000 	mov	r3, #0
 * @param num mtd number
 * @param size a pointer to the size of the mtd device (output)
 * @return 0 if device is valid, 1 otherwise
 */
int mtd_device_validate(u8 type, u8 num, u32 *size)
{
34805388:	e1a04002 	mov	r4, r2
	struct mtd_info *mtd = NULL;
3480538c:	e28d2008 	add	r2, sp, #8
34805390:	e5223004 	str	r3, [r2, #-4]!

	if (get_mtd_info(type, num, &mtd))
34805394:	ebfffe96 	bl	34804df4 <get_mtd_info>
34805398:	e3500000 	cmp	r0, #0
		return 1;

	*size = mtd->size;
3480539c:	059d3004 	ldreq	r3, [sp, #4]
int mtd_device_validate(u8 type, u8 num, u32 *size)
{
	struct mtd_info *mtd = NULL;

	if (get_mtd_info(type, num, &mtd))
		return 1;
348053a0:	13a00001 	movne	r0, #1

	*size = mtd->size;
348053a4:	05933008 	ldreq	r3, [r3, #8]
348053a8:	05843000 	streq	r3, [r4]

	return 0;
}
348053ac:	e8bd801c 	pop	{r2, r3, r4, pc}

348053b0 <device_find>:
struct mtd_device *device_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
348053b0:	e59fc040 	ldr	ip, [pc, #64]	; 348053f8 <device_find+0x48>
 * @param type device type
 * @param num device number
 * @return NULL if requested device does not exist
 */
struct mtd_device *device_find(u8 type, u8 num)
{
348053b4:	e92d4030 	push	{r4, r5, lr}
348053b8:	e1a03000 	mov	r3, r0
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
348053bc:	e5bc2004 	ldr	r2, [ip, #4]!
348053c0:	ea000008 	b	348053e8 <device_find+0x38>
		dev_tmp = list_entry(entry, struct mtd_device, link);

		if ((dev_tmp->id->type == type) && (dev_tmp->id->num == num))
348053c4:	e5924008 	ldr	r4, [r2, #8]
{
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
		dev_tmp = list_entry(entry, struct mtd_device, link);
348053c8:	e1a00002 	mov	r0, r2

		if ((dev_tmp->id->type == type) && (dev_tmp->id->num == num))
348053cc:	e5d45008 	ldrb	r5, [r4, #8]
348053d0:	e1550003 	cmp	r5, r3
348053d4:	1a000002 	bne	348053e4 <device_find+0x34>
348053d8:	e5d44009 	ldrb	r4, [r4, #9]
348053dc:	e1540001 	cmp	r4, r1
348053e0:	08bd8030 	popeq	{r4, r5, pc}
struct mtd_device *device_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtd_device *dev_tmp;

	list_for_each(entry, &devices) {
348053e4:	e5922000 	ldr	r2, [r2]
348053e8:	e152000c 	cmp	r2, ip
348053ec:	1afffff4 	bne	348053c4 <device_find+0x14>

		if ((dev_tmp->id->type == type) && (dev_tmp->id->num == num))
			return dev_tmp;
	}

	return NULL;
348053f0:	e3a00000 	mov	r0, #0
}
348053f4:	e8bd8030 	pop	{r4, r5, pc}
348053f8:	34829aac 	.word	0x34829aac

348053fc <device_parse>:
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 */
static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_device **retdev)
{
348053fc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34805400:	e24dd028 	sub	sp, sp, #40	; 0x28
	struct mtdids *id;
	const char *mtd_id;
	unsigned int mtd_id_len;
	const char *p;
	const char *pend;
	LIST_HEAD(tmp_list);
34805404:	e28d301c 	add	r3, sp, #28
34805408:	e58d301c 	str	r3, [sp, #28]
3480540c:	e58d3020 	str	r3, [sp, #32]
	debug("===device_parse===\n");

	assert(retdev);
	*retdev = NULL;

	if (ret)
34805410:	e2517000 	subs	r7, r1, #0
	int err = 1;

	debug("===device_parse===\n");

	assert(retdev);
	*retdev = NULL;
34805414:	e3a03000 	mov	r3, #0
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 */
static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_device **retdev)
{
34805418:	e58d2010 	str	r2, [sp, #16]
	if (ret)
		*ret = NULL;

	/* fetch <mtd-id> */
	mtd_id = p = mtd_dev;
	if (!(p = strchr(mtd_id, ':'))) {
3480541c:	e3a0103a 	mov	r1, #58	; 0x3a
	int err = 1;

	debug("===device_parse===\n");

	assert(retdev);
	*retdev = NULL;
34805420:	e5823000 	str	r3, [r2]

	if (ret)
		*ret = NULL;
34805424:	15873000 	strne	r3, [r7]
 * @param ret output pointer to next char after parse completes (output)
 * @param retdev pointer to the allocated device (output)
 * @return 0 on success, 1 otherwise
 */
static int device_parse(const char *const mtd_dev, const char **ret, struct mtd_device **retdev)
{
34805428:	e1a04000 	mov	r4, r0
	if (ret)
		*ret = NULL;

	/* fetch <mtd-id> */
	mtd_id = p = mtd_dev;
	if (!(p = strchr(mtd_id, ':'))) {
3480542c:	eb0059ee 	bl	3481bbec <strchr>
34805430:	e2509000 	subs	r9, r0, #0
		printf("no <mtd-id> identifier\n");
34805434:	059f04cc 	ldreq	r0, [pc, #1228]	; 34805908 <device_parse+0x50c>
	if (ret)
		*ret = NULL;

	/* fetch <mtd-id> */
	mtd_id = p = mtd_dev;
	if (!(p = strchr(mtd_id, ':'))) {
34805438:	0a000109 	beq	34805864 <device_parse+0x468>
	struct mtdids *id;

	debug("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len);

	list_for_each(entry, &mtdids) {
3480543c:	e59fa4c8 	ldr	sl, [pc, #1224]	; 3480590c <device_parse+0x510>
	}
	mtd_id_len = p - mtd_id + 1;
	p++;

	/* verify if we have a valid device specified */
	if ((id = id_find_by_mtd_id(mtd_id, mtd_id_len - 1)) == NULL) {
34805440:	e0646009 	rsb	r6, r4, r9
	struct mtdids *id;

	debug("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len);

	list_for_each(entry, &mtdids) {
34805444:	e5ba5220 	ldr	r5, [sl, #544]!	; 0x220
34805448:	ea00000a 	b	34805478 <device_parse+0x7c>
		id = list_entry(entry, struct mtdids, link);

		debug("entry: '%s' (len = %d)\n",
				id->mtd_id, strlen(id->mtd_id));

		if (mtd_id_len != strlen(id->mtd_id))
3480544c:	e5950010 	ldr	r0, [r5, #16]
34805450:	eb0059fb 	bl	3481bc44 <strlen>
34805454:	e1560000 	cmp	r6, r0
34805458:	1a000005 	bne	34805474 <device_parse+0x78>
			continue;
		if (strncmp(id->mtd_id, mtd_id, mtd_id_len) == 0)
3480545c:	e5950010 	ldr	r0, [r5, #16]
34805460:	e1a01004 	mov	r1, r4
34805464:	e1a02006 	mov	r2, r6
34805468:	eb0059cd 	bl	3481bba4 <strncmp>
3480546c:	e3500000 	cmp	r0, #0
34805470:	0a000003 	beq	34805484 <device_parse+0x88>
	struct mtdids *id;

	debug("--- id_find_by_mtd_id: '%.*s' (len = %d)\n",
			mtd_id_len, mtd_id, mtd_id_len);

	list_for_each(entry, &mtdids) {
34805474:	e5955000 	ldr	r5, [r5]
34805478:	e155000a 	cmp	r5, sl
3480547c:	1afffff2 	bne	3480544c <device_parse+0x50>
34805480:	ea000006 	b	348054a0 <device_parse+0xa4>

	/* parse partitions */
	num_parts = 0;

	offset = 0;
	if ((dev = device_find(id->type, id->num)) != NULL) {
34805484:	e5d50008 	ldrb	r0, [r5, #8]
34805488:	e5d51009 	ldrb	r1, [r5, #9]
3480548c:	ebffffc7 	bl	348053b0 <device_find>
34805490:	e3500000 	cmp	r0, #0


	/* parse partitions */
	num_parts = 0;

	offset = 0;
34805494:	058d0008 	streq	r0, [sp, #8]
	if ((dev = device_find(id->type, id->num)) != NULL) {
34805498:	1a000005 	bne	348054b4 <device_parse+0xb8>
3480549c:	ea000009 	b	348054c8 <device_parse+0xcc>
	mtd_id_len = p - mtd_id + 1;
	p++;

	/* verify if we have a valid device specified */
	if ((id = id_find_by_mtd_id(mtd_id, mtd_id_len - 1)) == NULL) {
		printf("invalid mtd device '%.*s'\n", mtd_id_len - 1, mtd_id);
348054a0:	e1a01006 	mov	r1, r6
348054a4:	e1a02004 	mov	r2, r4
348054a8:	e59f0460 	ldr	r0, [pc, #1120]	; 34805910 <device_parse+0x514>
348054ac:	eb000f2c 	bl	34809164 <printf>
348054b0:	ea000111 	b	348058fc <device_parse+0x500>
	num_parts = 0;

	offset = 0;
	if ((dev = device_find(id->type, id->num)) != NULL) {
		/* if device already exists start at the end of the last partition */
		part = list_entry(dev->parts.prev, struct part_info, link);
348054b4:	e5903014 	ldr	r3, [r0, #20]
		offset = part->offset + part->size;
348054b8:	e5932010 	ldr	r2, [r3, #16]
348054bc:	e5933014 	ldr	r3, [r3, #20]
348054c0:	e0823003 	add	r3, r2, r3
348054c4:	e58d3008 	str	r3, [sp, #8]
	if (!(p = strchr(mtd_id, ':'))) {
		printf("no <mtd-id> identifier\n");
		return 1;
	}
	mtd_id_len = p - mtd_id + 1;
	p++;
348054c8:	e3a02000 	mov	r2, #0
348054cc:	e2896001 	add	r6, r9, #1
348054d0:	e3a00001 	mov	r0, #1
348054d4:	e58d2004 	str	r2, [sp, #4]
348054d8:	e58d7014 	str	r7, [sp, #20]
348054dc:	ea0000a9 	b	34805788 <device_parse+0x38c>
	const char *name;
	int name_len;
	unsigned int mask_flags;
	const char *p;

	p = partdef;
348054e0:	e58d6024 	str	r6, [sp, #36]	; 0x24
	*retpart = NULL;
	*ret = NULL;

	/* fetch the partition size */
	if (*p == '-') {
348054e4:	e5d63000 	ldrb	r3, [r6]
348054e8:	e353002d 	cmp	r3, #45	; 0x2d
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
		p++;
348054ec:	02866001 	addeq	r6, r6, #1
348054f0:	058d6024 	streq	r6, [sp, #36]	; 0x24

	/* fetch the partition size */
	if (*p == '-') {
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
348054f4:	03e09000 	mvneq	r9, #0
	p = partdef;
	*retpart = NULL;
	*ret = NULL;

	/* fetch the partition size */
	if (*p == '-') {
348054f8:	0a000008 	beq	34805520 <device_parse+0x124>
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
		p++;
	} else {
		size = memsize_parse(p, &p);
348054fc:	e1a00006 	mov	r0, r6
34805500:	e28d1024 	add	r1, sp, #36	; 0x24
34805504:	ebfffe20 	bl	34804d8c <memsize_parse>
		if (size < MIN_PART_SIZE) {
34805508:	e3003fff 	movw	r3, #4095	; 0xfff
3480550c:	e1500003 	cmp	r0, r3
		/* assign all remaining space to this partition */
		debug("'-': remaining size assigned\n");
		size = SIZE_REMAINING;
		p++;
	} else {
		size = memsize_parse(p, &p);
34805510:	e1a09000 	mov	r9, r0
		if (size < MIN_PART_SIZE) {
			printf("partition size too small (%lx)\n", size);
34805514:	959f03f8 	ldrls	r0, [pc, #1016]	; 34805914 <device_parse+0x518>
34805518:	91a01009 	movls	r1, r9
3480551c:	9a000039 	bls	34805608 <device_parse+0x20c>
		}
	}

	/* check for offset */
	offset = OFFSET_NOT_SPECIFIED;
	if (*p == '@') {
34805520:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
34805524:	e5d03000 	ldrb	r3, [r0]
34805528:	e3530040 	cmp	r3, #64	; 0x40
			return 1;
		}
	}

	/* check for offset */
	offset = OFFSET_NOT_SPECIFIED;
3480552c:	13e0b000 	mvnne	fp, #0
	if (*p == '@') {
34805530:	1a000004 	bne	34805548 <device_parse+0x14c>
		p++;
34805534:	e2800001 	add	r0, r0, #1
		offset = memsize_parse(p, &p);
34805538:	e28d1024 	add	r1, sp, #36	; 0x24
	}

	/* check for offset */
	offset = OFFSET_NOT_SPECIFIED;
	if (*p == '@') {
		p++;
3480553c:	e58d0024 	str	r0, [sp, #36]	; 0x24
		offset = memsize_parse(p, &p);
34805540:	ebfffe11 	bl	34804d8c <memsize_parse>
34805544:	e1a0b000 	mov	fp, r0
	}

	/* now look for the name */
	if (*p == '(') {
34805548:	e59d7024 	ldr	r7, [sp, #36]	; 0x24
3480554c:	e5d73000 	ldrb	r3, [r7]
34805550:	e3530028 	cmp	r3, #40	; 0x28
			return 1;
		}
		p++;
	} else {
		/* 0x00000000@0x00000000 */
		name_len = 22;
34805554:	13a0a016 	movne	sl, #22
		name = NULL;
34805558:	13a07000 	movne	r7, #0
		p++;
		offset = memsize_parse(p, &p);
	}

	/* now look for the name */
	if (*p == '(') {
3480555c:	1a00000f 	bne	348055a0 <device_parse+0x1a4>
		name = ++p;
34805560:	e2877001 	add	r7, r7, #1
		if ((p = strchr(name, ')')) == NULL) {
34805564:	e1a00007 	mov	r0, r7
34805568:	e3a01029 	mov	r1, #41	; 0x29
		offset = memsize_parse(p, &p);
	}

	/* now look for the name */
	if (*p == '(') {
		name = ++p;
3480556c:	e58d7024 	str	r7, [sp, #36]	; 0x24
		if ((p = strchr(name, ')')) == NULL) {
34805570:	eb00599d 	bl	3481bbec <strchr>
34805574:	e3500000 	cmp	r0, #0
34805578:	e58d0024 	str	r0, [sp, #36]	; 0x24
			printf("no closing ) found in partition name\n");
3480557c:	059f0394 	ldreq	r0, [pc, #916]	; 34805918 <device_parse+0x51c>
34805580:	0a00002a 	beq	34805630 <device_parse+0x234>
			return 1;
		}
		name_len = p - name + 1;
34805584:	e267a001 	rsb	sl, r7, #1
34805588:	e080a00a 	add	sl, r0, sl
		if ((name_len - 1) == 0) {
3480558c:	e35a0001 	cmp	sl, #1
			printf("empty partition name\n");
34805590:	059f0384 	ldreq	r0, [pc, #900]	; 3480591c <device_parse+0x520>
34805594:	0a000025 	beq	34805630 <device_parse+0x234>
			return 1;
		}
		p++;
34805598:	e2800001 	add	r0, r0, #1
3480559c:	e58d0024 	str	r0, [sp, #36]	; 0x24
		name = NULL;
	}

	/* test for options */
	mask_flags = 0;
	if (strncmp(p, "ro", 2) == 0) {
348055a0:	e3a02002 	mov	r2, #2
348055a4:	e59f1374 	ldr	r1, [pc, #884]	; 34805920 <device_parse+0x524>
348055a8:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
348055ac:	eb00597c 	bl	3481bba4 <strncmp>
348055b0:	e3500000 	cmp	r0, #0
		mask_flags |= MTD_WRITEABLE_CMD;
		p += 2;
348055b4:	059d3024 	ldreq	r3, [sp, #36]	; 0x24
	}

	/* test for options */
	mask_flags = 0;
	if (strncmp(p, "ro", 2) == 0) {
		mask_flags |= MTD_WRITEABLE_CMD;
348055b8:	03a02001 	moveq	r2, #1
		p += 2;
348055bc:	02833002 	addeq	r3, r3, #2
348055c0:	058d3024 	streq	r3, [sp, #36]	; 0x24
		name_len = 22;
		name = NULL;
	}

	/* test for options */
	mask_flags = 0;
348055c4:	13a03000 	movne	r3, #0
		mask_flags |= MTD_WRITEABLE_CMD;
		p += 2;
	}

	/* check for next partition definition */
	if (*p == ',') {
348055c8:	e59d6024 	ldr	r6, [sp, #36]	; 0x24
	}

	/* test for options */
	mask_flags = 0;
	if (strncmp(p, "ro", 2) == 0) {
		mask_flags |= MTD_WRITEABLE_CMD;
348055cc:	058d200c 	streq	r2, [sp, #12]
		name_len = 22;
		name = NULL;
	}

	/* test for options */
	mask_flags = 0;
348055d0:	158d300c 	strne	r3, [sp, #12]
		mask_flags |= MTD_WRITEABLE_CMD;
		p += 2;
	}

	/* check for next partition definition */
	if (*p == ',') {
348055d4:	e5d61000 	ldrb	r1, [r6]
348055d8:	e351002c 	cmp	r1, #44	; 0x2c
348055dc:	1a000005 	bne	348055f8 <device_parse+0x1fc>
		if (size == SIZE_REMAINING) {
348055e0:	e3790001 	cmn	r9, #1
			*ret = NULL;
			printf("no partitions allowed after a fill-up partition\n");
348055e4:	059f0338 	ldreq	r0, [pc, #824]	; 34805924 <device_parse+0x528>
348055e8:	0a000010 	beq	34805630 <device_parse+0x234>
			return 1;
		}
		*ret = ++p;
348055ec:	e2866001 	add	r6, r6, #1
348055f0:	e58d6024 	str	r6, [sp, #36]	; 0x24
348055f4:	ea000005 	b	34805610 <device_parse+0x214>
	} else if ((*p == ';') || (*p == '\0')) {
348055f8:	e351003b 	cmp	r1, #59	; 0x3b
348055fc:	13510000 	cmpne	r1, #0
34805600:	0a000002 	beq	34805610 <device_parse+0x214>
		*ret = p;
	} else {
		printf("unexpected character '%c' at the end of partition\n", *p);
34805604:	e59f031c 	ldr	r0, [pc, #796]	; 34805928 <device_parse+0x52c>
34805608:	eb000ed5 	bl	34809164 <printf>
3480560c:	ea000067 	b	348057b0 <device_parse+0x3b4>
		*ret = NULL;
		return 1;
	}

	/*  allocate memory */
	part = (struct part_info *)malloc(sizeof(struct part_info) + name_len);
34805610:	e28a2028 	add	r2, sl, #40	; 0x28
34805614:	e1a00002 	mov	r0, r2
34805618:	e58d2000 	str	r2, [sp]
3480561c:	eb001097 	bl	34809880 <malloc>
	if (!part) {
34805620:	e2504000 	subs	r4, r0, #0
34805624:	e59d2000 	ldr	r2, [sp]
34805628:	1a000002 	bne	34805638 <device_parse+0x23c>
		printf("out of memory\n");
3480562c:	e59f02f8 	ldr	r0, [pc, #760]	; 3480592c <device_parse+0x530>
34805630:	eb000ecb 	bl	34809164 <printf>
34805634:	ea00005d 	b	348057b0 <device_parse+0x3b4>
		return 1;
	}
	memset(part, 0, sizeof(struct part_info) + name_len);
34805638:	e3a01000 	mov	r1, #0
3480563c:	eb005a20 	bl	3481bec4 <memset>
	part->size = size;
	part->offset = offset;
	part->mask_flags = mask_flags;
34805640:	e59d200c 	ldr	r2, [sp, #12]
	part->name = (char *)(part + 1);
34805644:	e2840028 	add	r0, r4, #40	; 0x28

	if (name) {
34805648:	e3570000 	cmp	r7, #0
	if (!part) {
		printf("out of memory\n");
		return 1;
	}
	memset(part, 0, sizeof(struct part_info) + name_len);
	part->size = size;
3480564c:	e5849010 	str	r9, [r4, #16]
	part->offset = offset;
34805650:	e584b014 	str	fp, [r4, #20]
	part->mask_flags = mask_flags;
34805654:	e584201c 	str	r2, [r4, #28]
	part->name = (char *)(part + 1);
34805658:	e5840008 	str	r0, [r4, #8]

	if (name) {
3480565c:	0a000005 	beq	34805678 <device_parse+0x27c>
		/* copy user provided name */
		strncpy(part->name, name, name_len - 1);
34805660:	e1a01007 	mov	r1, r7
34805664:	e24a2001 	sub	r2, sl, #1
34805668:	eb005917 	bl	3481bacc <strncpy>
		part->auto_name = 0;
3480566c:	e3a03000 	mov	r3, #0
34805670:	e5c4300c 	strb	r3, [r4, #12]
34805674:	ea000005 	b	34805690 <device_parse+0x294>
	} else {
		/* auto generated name in form of size@offset */
		sprintf(part->name, "0x%08lx@0x%08lx", size, offset);
34805678:	e1a02009 	mov	r2, r9
3480567c:	e59f12ac 	ldr	r1, [pc, #684]	; 34805930 <device_parse+0x534>
34805680:	e1a0300b 	mov	r3, fp
34805684:	eb005da7 	bl	3481cd28 <sprintf>
		part->auto_name = 1;
34805688:	e3a02001 	mov	r2, #1
3480568c:	e5c4200c 	strb	r2, [r4, #12]
	}

	part->name[name_len - 1] = '\0';
34805690:	e5943008 	ldr	r3, [r4, #8]
34805694:	e083a00a 	add	sl, r3, sl
34805698:	e3a03000 	mov	r3, #0
3480569c:	e54a3001 	strb	r3, [sl, #-1]
		err = 1;
		if ((part_parse(p, &p, &part) != 0) || (!part))
			break;

		/* calculate offset when not specified */
		if (part->offset == OFFSET_NOT_SPECIFIED)
348056a0:	e5947014 	ldr	r7, [r4, #20]
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
348056a4:	e5943010 	ldr	r3, [r4, #16]
		err = 1;
		if ((part_parse(p, &p, &part) != 0) || (!part))
			break;

		/* calculate offset when not specified */
		if (part->offset == OFFSET_NOT_SPECIFIED)
348056a8:	e3770001 	cmn	r7, #1
			part->offset = offset;
348056ac:	059d2008 	ldreq	r2, [sp, #8]
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
348056b0:	e5844000 	str	r4, [r4]
348056b4:	05842014 	streq	r2, [r4, #20]
348056b8:	01a07002 	moveq	r7, r2
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
348056bc:	e3730001 	cmn	r3, #1
		part->size = id->size - part->offset;
348056c0:	0595200c 	ldreq	r2, [r5, #12]
348056c4:	05943014 	ldreq	r3, [r4, #20]
	list->prev = list;
348056c8:	e5844004 	str	r4, [r4, #4]
348056cc:	00633002 	rsbeq	r3, r3, r2
348056d0:	05843010 	streq	r3, [r4, #16]

	if (part->offset > id->size) {
348056d4:	e5942014 	ldr	r2, [r4, #20]
348056d8:	e595300c 	ldr	r3, [r5, #12]
348056dc:	e1520003 	cmp	r2, r3
		printf("%s: offset %08x beyond flash size %08x\n",
348056e0:	859f024c 	ldrhi	r0, [pc, #588]	; 34805934 <device_parse+0x538>
348056e4:	85951010 	ldrhi	r1, [r5, #16]
348056e8:	8a00000e 	bhi	34805728 <device_parse+0x32c>
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
348056ec:	e5941010 	ldr	r1, [r4, #16]
348056f0:	e0821001 	add	r1, r2, r1
348056f4:	e1510002 	cmp	r1, r2
348056f8:	8a00000c 	bhi	34805730 <device_parse+0x334>
		printf("%s%d: partition (%s) size too big\n",
				MTD_DEV_TYPE(id->type), id->num, part->name);
348056fc:	e5d53008 	ldrb	r3, [r5, #8]
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
34805700:	e3530002 	cmp	r3, #2
34805704:	059f122c 	ldreq	r1, [pc, #556]	; 34805938 <device_parse+0x53c>
34805708:	0a000003 	beq	3480571c <device_parse+0x320>
				MTD_DEV_TYPE(id->type), id->num, part->name);
3480570c:	e59f2228 	ldr	r2, [pc, #552]	; 3480593c <device_parse+0x540>
34805710:	e3530004 	cmp	r3, #4
34805714:	e59f1224 	ldr	r1, [pc, #548]	; 34805940 <device_parse+0x544>
34805718:	01a01002 	moveq	r1, r2
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
3480571c:	e59f0220 	ldr	r0, [pc, #544]	; 34805944 <device_parse+0x548>
34805720:	e5d52009 	ldrb	r2, [r5, #9]
34805724:	e5943008 	ldr	r3, [r4, #8]
34805728:	eb000e8d 	bl	34809164 <printf>
3480572c:	ea00001f 	b	348057b0 <device_parse+0x3b4>
				MTD_DEV_TYPE(id->type), id->num, part->name);
		return 1;
	}

	if (part->offset + part->size > id->size) {
34805730:	e1510003 	cmp	r1, r3
		printf("%s: partitioning exceeds flash size\n", id->mtd_id);
34805734:	859f020c 	ldrhi	r0, [pc, #524]	; 34805948 <device_parse+0x54c>
34805738:	85951010 	ldrhi	r1, [r5, #16]
3480573c:	8affffb1 	bhi	34805608 <device_parse+0x20c>

	/*
	 * Now we need to check if the partition starts and ends on
	 * sector (eraseblock) regions
	 */
	return part_validate_eraseblock(id, part);
34805740:	e1a00005 	mov	r0, r5
34805744:	e1a01004 	mov	r1, r4
34805748:	ebfffdc9 	bl	34804e74 <part_validate_eraseblock>
			part->offset = offset;
		else
			offset = part->offset;

		/* verify alignment and size */
		if (part_validate(id, part) != 0)
3480574c:	e3500000 	cmp	r0, #0
34805750:	1a000016 	bne	348057b0 <device_parse+0x3b4>
			break;

		offset += part->size;
34805754:	e5943010 	ldr	r3, [r4, #16]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34805758:	e28d201c 	add	r2, sp, #28
3480575c:	e0873003 	add	r3, r7, r3
34805760:	e5842000 	str	r2, [r4]
34805764:	e58d3008 	str	r3, [sp, #8]

		/* partition is ok, add it to the list */
		list_add_tail(&part->link, &tmp_list);
		num_parts++;
34805768:	e59d2004 	ldr	r2, [sp, #4]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
3480576c:	e59d3020 	ldr	r3, [sp, #32]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34805770:	e58d4020 	str	r4, [sp, #32]
	new->next = next;
	new->prev = prev;
	prev->next = new;
34805774:	e5834000 	str	r4, [r3]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
34805778:	e5843004 	str	r3, [r4, #4]
3480577c:	e2823001 	add	r3, r2, #1
34805780:	e6ff3073 	uxth	r3, r3
34805784:	e58d3004 	str	r3, [sp, #4]
		/* if device already exists start at the end of the last partition */
		part = list_entry(dev->parts.prev, struct part_info, link);
		offset = part->offset + part->size;
	}

	while (p && (*p != '\0') && (*p != ';')) {
34805788:	e3560000 	cmp	r6, #0
3480578c:	0a000004 	beq	348057a4 <device_parse+0x3a8>
34805790:	e5d63000 	ldrb	r3, [r6]
34805794:	e3530000 	cmp	r3, #0
34805798:	0a000001 	beq	348057a4 <device_parse+0x3a8>
3480579c:	e353003b 	cmp	r3, #59	; 0x3b
348057a0:	1affff4e 	bne	348054e0 <device_parse+0xe4>
		/* partition is ok, add it to the list */
		list_add_tail(&part->link, &tmp_list);
		num_parts++;
		err = 0;
	}
	if (err == 1) {
348057a4:	e3500001 	cmp	r0, #1
348057a8:	e59d7014 	ldr	r7, [sp, #20]
348057ac:	1a000002 	bne	348057bc <device_parse+0x3c0>
		part_delall(&tmp_list);
348057b0:	e28d001c 	add	r0, sp, #28
348057b4:	ebfffd47 	bl	34804cd8 <part_delall>
348057b8:	ea00004f 	b	348058fc <device_parse+0x500>
		return 1;
	}

	if (num_parts == 0) {
348057bc:	e59d3004 	ldr	r3, [sp, #4]
348057c0:	e3530000 	cmp	r3, #0
348057c4:	1a00000c 	bne	348057fc <device_parse+0x400>
		printf("no partitions for device %s%d (%s)\n",
				MTD_DEV_TYPE(id->type), id->num, id->mtd_id);
348057c8:	e5d53008 	ldrb	r3, [r5, #8]
		part_delall(&tmp_list);
		return 1;
	}

	if (num_parts == 0) {
		printf("no partitions for device %s%d (%s)\n",
348057cc:	e3530002 	cmp	r3, #2
348057d0:	059f1160 	ldreq	r1, [pc, #352]	; 34805938 <device_parse+0x53c>
348057d4:	0a000003 	beq	348057e8 <device_parse+0x3ec>
				MTD_DEV_TYPE(id->type), id->num, id->mtd_id);
348057d8:	e59f215c 	ldr	r2, [pc, #348]	; 3480593c <device_parse+0x540>
348057dc:	e3530004 	cmp	r3, #4
348057e0:	e59f1158 	ldr	r1, [pc, #344]	; 34805940 <device_parse+0x544>
348057e4:	01a01002 	moveq	r1, r2
		part_delall(&tmp_list);
		return 1;
	}

	if (num_parts == 0) {
		printf("no partitions for device %s%d (%s)\n",
348057e8:	e5d52009 	ldrb	r2, [r5, #9]
348057ec:	e5953010 	ldr	r3, [r5, #16]
348057f0:	e59f0154 	ldr	r0, [pc, #340]	; 3480594c <device_parse+0x550>
348057f4:	eb000e5a 	bl	34809164 <printf>
348057f8:	ea00003f 	b	348058fc <device_parse+0x500>
	}

	debug("\ntotal partitions: %d\n", num_parts);

	/* check for next device presence */
	if (p) {
348057fc:	e3560000 	cmp	r6, #0
34805800:	0a000012 	beq	34805850 <device_parse+0x454>
		if (*p == ';') {
34805804:	e5d61000 	ldrb	r1, [r6]
34805808:	e351003b 	cmp	r1, #59	; 0x3b
3480580c:	1a000003 	bne	34805820 <device_parse+0x424>
			if (ret)
34805810:	e3570000 	cmp	r7, #0
				*ret = ++p;
34805814:	12866001 	addne	r6, r6, #1
	debug("\ntotal partitions: %d\n", num_parts);

	/* check for next device presence */
	if (p) {
		if (*p == ';') {
			if (ret)
34805818:	1a000004 	bne	34805830 <device_parse+0x434>
3480581c:	ea00000b 	b	34805850 <device_parse+0x454>
				*ret = ++p;
		} else if (*p == '\0') {
34805820:	e3510000 	cmp	r1, #0
34805824:	1a000003 	bne	34805838 <device_parse+0x43c>
			if (ret)
34805828:	e3570000 	cmp	r7, #0
3480582c:	0a000007 	beq	34805850 <device_parse+0x454>
				*ret = p;
34805830:	e5876000 	str	r6, [r7]
34805834:	ea000005 	b	34805850 <device_parse+0x454>
		} else {
			printf("unexpected character '%c' at the end of device\n", *p);
34805838:	e59f0110 	ldr	r0, [pc, #272]	; 34805950 <device_parse+0x554>
3480583c:	eb000e48 	bl	34809164 <printf>
			if (ret)
34805840:	e3570000 	cmp	r7, #0
				*ret = NULL;
34805844:	13a03000 	movne	r3, #0
34805848:	15873000 	strne	r3, [r7]
3480584c:	ea00002a 	b	348058fc <device_parse+0x500>
			return 1;
		}
	}

	/* allocate memory for mtd_device structure */
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
34805850:	e3a00018 	mov	r0, #24
34805854:	eb001009 	bl	34809880 <malloc>
34805858:	e2504000 	subs	r4, r0, #0
3480585c:	1a000002 	bne	3480586c <device_parse+0x470>
		printf("out of memory\n");
34805860:	e59f00c4 	ldr	r0, [pc, #196]	; 3480592c <device_parse+0x530>
34805864:	eb000e3e 	bl	34809164 <printf>
34805868:	ea000023 	b	348058fc <device_parse+0x500>
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
3480586c:	e3a01000 	mov	r1, #0
34805870:	e3a02018 	mov	r2, #24
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
34805874:	e28d6028 	add	r6, sp, #40	; 0x28
	/* allocate memory for mtd_device structure */
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
		printf("out of memory\n");
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
34805878:	eb005991 	bl	3481bec4 <memset>
	dev->id = id;
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
3480587c:	e2843010 	add	r3, r4, #16
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
34805880:	e536100c 	ldr	r1, [r6, #-12]!
		printf("out of memory\n");
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
	dev->id = id;
	dev->num_parts = 0; /* part_sort_add increments num_parts */
34805884:	e3a02000 	mov	r2, #0
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34805888:	e5843010 	str	r3, [r4, #16]
3480588c:	e5844000 	str	r4, [r4]
	if ((dev = (struct mtd_device *)malloc(sizeof(struct mtd_device))) == NULL) {
		printf("out of memory\n");
		return 1;
	}
	memset(dev, 0, sizeof(struct mtd_device));
	dev->id = id;
34805890:	e5845008 	str	r5, [r4, #8]
	dev->num_parts = 0; /* part_sort_add increments num_parts */
34805894:	e1c420bc 	strh	r2, [r4, #12]
	list->prev = list;
34805898:	e5843014 	str	r3, [r4, #20]
3480589c:	e5844004 	str	r4, [r4, #4]
	INIT_LIST_HEAD(&dev->parts);
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
348058a0:	e5915000 	ldr	r5, [r1]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348058a4:	e3a07000 	mov	r7, #0
348058a8:	ea00000d 	b	348058e4 <device_parse+0x4e8>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
348058ac:	e891000c 	ldm	r1, {r2, r3}
		part = list_entry(entry, struct part_info, link);
		list_del(entry);
		if (part_sort_add(dev, part) != 0) {
348058b0:	e1a00004 	mov	r0, r4
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
348058b4:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
348058b8:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
348058bc:	e5817004 	str	r7, [r1, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
348058c0:	e5817000 	str	r7, [r1]
348058c4:	ebfffcb8 	bl	34804bac <part_sort_add>
348058c8:	e3500000 	cmp	r0, #0
348058cc:	0a000002 	beq	348058dc <device_parse+0x4e0>
			device_del(dev);
348058d0:	e1a00004 	mov	r0, r4
348058d4:	ebfffd10 	bl	34804d1c <device_del>
348058d8:	ea000007 	b	348058fc <device_parse+0x500>
	dev->num_parts = 0; /* part_sort_add increments num_parts */
	INIT_LIST_HEAD(&dev->parts);
	INIT_LIST_HEAD(&dev->link);

	/* move partitions from tmp_list to dev->parts */
	list_for_each_safe(entry, n, &tmp_list) {
348058dc:	e1a01005 	mov	r1, r5
348058e0:	e5955000 	ldr	r5, [r5]
348058e4:	e1510006 	cmp	r1, r6
348058e8:	1affffef 	bne	348058ac <device_parse+0x4b0>
			device_del(dev);
			return 1;
		}
	}

	*retdev = dev;
348058ec:	e59d3010 	ldr	r3, [sp, #16]

	debug("===\n\n");
	return 0;
348058f0:	e3a00000 	mov	r0, #0
			device_del(dev);
			return 1;
		}
	}

	*retdev = dev;
348058f4:	e5834000 	str	r4, [r3]

	debug("===\n\n");
	return 0;
348058f8:	ea000000 	b	34805900 <device_parse+0x504>
				*ret = p;
		} else {
			printf("unexpected character '%c' at the end of device\n", *p);
			if (ret)
				*ret = NULL;
			return 1;
348058fc:	e3a00001 	mov	r0, #1

	*retdev = dev;

	debug("===\n\n");
	return 0;
}
34805900:	e28dd028 	add	sp, sp, #40	; 0x28
34805904:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34805908:	348247e7 	.word	0x348247e7
3480590c:	34829aac 	.word	0x34829aac
34805910:	348244d8 	.word	0x348244d8
34805914:	348244f3 	.word	0x348244f3
34805918:	34824513 	.word	0x34824513
3480591c:	34824539 	.word	0x34824539
34805920:	3482454f 	.word	0x3482454f
34805924:	34824552 	.word	0x34824552
34805928:	34824583 	.word	0x34824583
3480592c:	348245b6 	.word	0x348245b6
34805930:	348245c5 	.word	0x348245c5
34805934:	348245d5 	.word	0x348245d5
34805938:	34824754 	.word	0x34824754
3480593c:	34824751 	.word	0x34824751
34805940:	34824383 	.word	0x34824383
34805944:	348245fd 	.word	0x348245fd
34805948:	34824620 	.word	0x34824620
3480594c:	34824645 	.word	0x34824645
34805950:	34824669 	.word	0x34824669

34805954 <mtd_id_parse>:
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
34805954:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34805958:	e1a07003 	mov	r7, r3
	const char *p = id;

	*dev_type = 0;
3480595c:	e3a03000 	mov	r3, #0
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
	const char *p = id;
34805960:	e58d0004 	str	r0, [sp, #4]
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
34805964:	e1a05001 	mov	r5, r1
	const char *p = id;

	*dev_type = 0;
34805968:	e5c23000 	strb	r3, [r2]
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
3480596c:	e1a04002 	mov	r4, r2
	const char *p = id;

	*dev_type = 0;
	if (strncmp(p, "nand", 4) == 0) {
34805970:	e59f10d4 	ldr	r1, [pc, #212]	; 34805a4c <mtd_id_parse+0xf8>
34805974:	e3a02004 	mov	r2, #4
 * @param dev_type parsed device type (output)
 * @param dev_num parsed device number (output)
 * @return 0 on success, 1 otherwise
 */
int mtd_id_parse(const char *id, const char **ret_id, u8 *dev_type, u8 *dev_num)
{
34805978:	e1a06000 	mov	r6, r0
	const char *p = id;

	*dev_type = 0;
	if (strncmp(p, "nand", 4) == 0) {
3480597c:	eb005888 	bl	3481bba4 <strncmp>
34805980:	e3500000 	cmp	r0, #0
		*dev_type = MTD_DEV_TYPE_NAND;
34805984:	03a03002 	moveq	r3, #2
34805988:	05c43000 	strbeq	r3, [r4]
		p += 4;
3480598c:	059d3004 	ldreq	r3, [sp, #4]
34805990:	02833004 	addeq	r3, r3, #4
34805994:	0a000013 	beq	348059e8 <mtd_id_parse+0x94>
	} else if (strncmp(p, "nor", 3) == 0) {
34805998:	e59d0004 	ldr	r0, [sp, #4]
3480599c:	e59f10ac 	ldr	r1, [pc, #172]	; 34805a50 <mtd_id_parse+0xfc>
348059a0:	e3a02003 	mov	r2, #3
348059a4:	eb00587e 	bl	3481bba4 <strncmp>
348059a8:	e3500000 	cmp	r0, #0
		*dev_type = MTD_DEV_TYPE_NOR;
348059ac:	03a03001 	moveq	r3, #1
348059b0:	05c43000 	strbeq	r3, [r4]
		p += 3;
348059b4:	059d3004 	ldreq	r3, [sp, #4]
348059b8:	02833003 	addeq	r3, r3, #3
348059bc:	0a000009 	beq	348059e8 <mtd_id_parse+0x94>
	} else if (strncmp(p, "onenand", 7) == 0) {
348059c0:	e59d0004 	ldr	r0, [sp, #4]
348059c4:	e59f1088 	ldr	r1, [pc, #136]	; 34805a54 <mtd_id_parse+0x100>
348059c8:	e3a02007 	mov	r2, #7
348059cc:	eb005874 	bl	3481bba4 <strncmp>
348059d0:	e3500000 	cmp	r0, #0
348059d4:	1a00000b 	bne	34805a08 <mtd_id_parse+0xb4>
		*dev_type = MTD_DEV_TYPE_ONENAND;
348059d8:	e3a03004 	mov	r3, #4
348059dc:	e5c43000 	strb	r3, [r4]
		p += 7;
348059e0:	e59d3004 	ldr	r3, [sp, #4]
348059e4:	e2833007 	add	r3, r3, #7
348059e8:	e58d3004 	str	r3, [sp, #4]
	} else {
		printf("incorrect device type in %s\n", id);
		return 1;
	}

	if (!isdigit(*p)) {
348059ec:	e59d0004 	ldr	r0, [sp, #4]
348059f0:	e59f2060 	ldr	r2, [pc, #96]	; 34805a58 <mtd_id_parse+0x104>
348059f4:	e5d03000 	ldrb	r3, [r0]
348059f8:	e7d23003 	ldrb	r3, [r2, r3]
348059fc:	e3130004 	tst	r3, #4
34805a00:	1a000007 	bne	34805a24 <mtd_id_parse+0xd0>
34805a04:	ea000001 	b	34805a10 <mtd_id_parse+0xbc>
		p += 3;
	} else if (strncmp(p, "onenand", 7) == 0) {
		*dev_type = MTD_DEV_TYPE_ONENAND;
		p += 7;
	} else {
		printf("incorrect device type in %s\n", id);
34805a08:	e59f004c 	ldr	r0, [pc, #76]	; 34805a5c <mtd_id_parse+0x108>
34805a0c:	ea000000 	b	34805a14 <mtd_id_parse+0xc0>
		return 1;
	}

	if (!isdigit(*p)) {
		printf("incorrect device number in %s\n", id);
34805a10:	e59f0048 	ldr	r0, [pc, #72]	; 34805a60 <mtd_id_parse+0x10c>
34805a14:	e1a01006 	mov	r1, r6
34805a18:	eb000dd1 	bl	34809164 <printf>
		return 1;
34805a1c:	e3a00001 	mov	r0, #1
34805a20:	ea000008 	b	34805a48 <mtd_id_parse+0xf4>
	}

	*dev_num = simple_strtoul(p, (char **)&p, 0);
34805a24:	e28d1004 	add	r1, sp, #4
34805a28:	e3a02000 	mov	r2, #0
34805a2c:	eb005c17 	bl	3481ca90 <simple_strtoul>
	if (ret_id)
34805a30:	e3550000 	cmp	r5, #0
		*ret_id = p;
34805a34:	159d3004 	ldrne	r3, [sp, #4]
	if (!isdigit(*p)) {
		printf("incorrect device number in %s\n", id);
		return 1;
	}

	*dev_num = simple_strtoul(p, (char **)&p, 0);
34805a38:	e5c70000 	strb	r0, [r7]
	if (ret_id)
		*ret_id = p;
34805a3c:	15853000 	strne	r3, [r5]
	return 0;
34805a40:	13a00000 	movne	r0, #0
34805a44:	01a00005 	moveq	r0, r5
}
34805a48:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
34805a4c:	34824754 	.word	0x34824754
34805a50:	34824383 	.word	0x34824383
34805a54:	34824751 	.word	0x34824751
34805a58:	34821cd4 	.word	0x34821cd4
34805a5c:	34824699 	.word	0x34824699
34805a60:	348246b6 	.word	0x348246b6

34805a64 <find_dev_and_part>:
 * @param part pointer to requested partition (output)
 * @return 0 on success, 1 otherwise
 */
int find_dev_and_part(const char *id, struct mtd_device **dev,
		u8 *part_num, struct part_info **part)
{
34805a64:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
34805a68:	e59fb18c 	ldr	fp, [pc, #396]	; 34805bfc <find_dev_and_part+0x198>
 * @param part pointer to requested partition (output)
 * @return 0 on success, 1 otherwise
 */
int find_dev_and_part(const char *id, struct mtd_device **dev,
		u8 *part_num, struct part_info **part)
{
34805a6c:	e1a0a003 	mov	sl, r3
34805a70:	e1a07000 	mov	r7, r0
34805a74:	e1a05001 	mov	r5, r1
34805a78:	e1a04002 	mov	r4, r2
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
34805a7c:	e5bb6004 	ldr	r6, [fp, #4]!
		*part_num = 0;
34805a80:	e3a03000 	mov	r3, #0
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
34805a84:	ea000014 	b	34805adc <find_dev_and_part+0x78>
		*part_num = 0;
34805a88:	e5c43000 	strb	r3, [r4]
		*dev = list_entry(dentry, struct mtd_device, link);
		list_for_each(pentry, &(*dev)->parts) {
34805a8c:	e5969010 	ldr	r9, [r6, #16]

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
		*part_num = 0;
		*dev = list_entry(dentry, struct mtd_device, link);
34805a90:	e5856000 	str	r6, [r5]
		list_for_each(pentry, &(*dev)->parts) {
34805a94:	ea00000b 	b	34805ac8 <find_dev_and_part+0x64>
			*part = list_entry(pentry, struct part_info, link);
			if (strcmp((*part)->name, id) == 0)
34805a98:	e5990008 	ldr	r0, [r9, #8]

	list_for_each(dentry, &devices) {
		*part_num = 0;
		*dev = list_entry(dentry, struct mtd_device, link);
		list_for_each(pentry, &(*dev)->parts) {
			*part = list_entry(pentry, struct part_info, link);
34805a9c:	e58a9000 	str	r9, [sl]
			if (strcmp((*part)->name, id) == 0)
34805aa0:	e1a01007 	mov	r1, r7
34805aa4:	e58d3004 	str	r3, [sp, #4]
34805aa8:	eb005831 	bl	3481bb74 <strcmp>
34805aac:	e3500000 	cmp	r0, #0
34805ab0:	e59d3004 	ldr	r3, [sp, #4]
34805ab4:	0a00004e 	beq	34805bf4 <find_dev_and_part+0x190>
				return 0;
			(*part_num)++;
34805ab8:	e5d42000 	ldrb	r2, [r4]
34805abc:	e2822001 	add	r2, r2, #1
34805ac0:	e5c42000 	strb	r2, [r4]
	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
		*part_num = 0;
		*dev = list_entry(dentry, struct mtd_device, link);
		list_for_each(pentry, &(*dev)->parts) {
34805ac4:	e5999000 	ldr	r9, [r9]
34805ac8:	e5952000 	ldr	r2, [r5]
34805acc:	e2822010 	add	r2, r2, #16
34805ad0:	e1590002 	cmp	r9, r2
34805ad4:	1affffef 	bne	34805a98 <find_dev_and_part+0x34>
	u8 type, dnum, pnum;
	const char *p;

	debug("--- find_dev_and_part ---\nid = %s\n", id);

	list_for_each(dentry, &devices) {
34805ad8:	e5966000 	ldr	r6, [r6]
34805adc:	e156000b 	cmp	r6, fp
34805ae0:	1affffe8 	bne	34805a88 <find_dev_and_part+0x24>
				return 0;
			(*part_num)++;
		}
	}

	p = id;
34805ae4:	e28d6010 	add	r6, sp, #16
34805ae8:	e5267008 	str	r7, [r6, #-8]!
	*dev = NULL;
34805aec:	e3a03000 	mov	r3, #0
34805af0:	e5853000 	str	r3, [r5]
	*part = NULL;
	*part_num = 0;

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
34805af4:	e28d200f 	add	r2, sp, #15
		}
	}

	p = id;
	*dev = NULL;
	*part = NULL;
34805af8:	e58a3000 	str	r3, [sl]
	*part_num = 0;

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
34805afc:	e1a00007 	mov	r0, r7
	}

	p = id;
	*dev = NULL;
	*part = NULL;
	*part_num = 0;
34805b00:	e5c43000 	strb	r3, [r4]

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
34805b04:	e1a01006 	mov	r1, r6
34805b08:	e28d300e 	add	r3, sp, #14
34805b0c:	ebffff90 	bl	34805954 <mtd_id_parse>
34805b10:	e2502000 	subs	r2, r0, #0
34805b14:	1a000035 	bne	34805bf0 <find_dev_and_part+0x18c>
		return 1;

	if ((*p++ != ',') || (*p == '\0')) {
34805b18:	e59d3008 	ldr	r3, [sp, #8]
34805b1c:	e1a00003 	mov	r0, r3
34805b20:	e4d01001 	ldrb	r1, [r0], #1
34805b24:	e351002c 	cmp	r1, #44	; 0x2c
34805b28:	e58d0008 	str	r0, [sp, #8]
34805b2c:	1a000002 	bne	34805b3c <find_dev_and_part+0xd8>
34805b30:	e5d33001 	ldrb	r3, [r3, #1]
34805b34:	e3530000 	cmp	r3, #0
34805b38:	1a000002 	bne	34805b48 <find_dev_and_part+0xe4>
		printf("no partition number specified\n");
34805b3c:	e59f00bc 	ldr	r0, [pc, #188]	; 34805c00 <find_dev_and_part+0x19c>
34805b40:	eb000d87 	bl	34809164 <printf>
34805b44:	ea000029 	b	34805bf0 <find_dev_and_part+0x18c>
		return 1;
	}
	pnum = simple_strtoul(p, (char **)&p, 0);
34805b48:	e1a01006 	mov	r1, r6
34805b4c:	eb005bcf 	bl	3481ca90 <simple_strtoul>
	if (*p != '\0') {
34805b50:	e59d3008 	ldr	r3, [sp, #8]

	if ((*p++ != ',') || (*p == '\0')) {
		printf("no partition number specified\n");
		return 1;
	}
	pnum = simple_strtoul(p, (char **)&p, 0);
34805b54:	e1a0b000 	mov	fp, r0
	if (*p != '\0') {
34805b58:	e5d36000 	ldrb	r6, [r3]
34805b5c:	e3560000 	cmp	r6, #0
34805b60:	0a000003 	beq	34805b74 <find_dev_and_part+0x110>
		printf("unexpected trailing character '%c'\n", *p);
34805b64:	e1a01006 	mov	r1, r6
34805b68:	e59f0094 	ldr	r0, [pc, #148]	; 34805c04 <find_dev_and_part+0x1a0>
34805b6c:	eb000d7c 	bl	34809164 <printf>
34805b70:	ea00001e 	b	34805bf0 <find_dev_and_part+0x18c>
		return 1;
	}

	if ((*dev = device_find(type, dnum)) == NULL) {
34805b74:	e5dd700f 	ldrb	r7, [sp, #15]
34805b78:	e5dd900e 	ldrb	r9, [sp, #14]
34805b7c:	e1a00007 	mov	r0, r7
34805b80:	e1a01009 	mov	r1, r9
34805b84:	ebfffe09 	bl	348053b0 <device_find>
34805b88:	e3500000 	cmp	r0, #0
34805b8c:	e5850000 	str	r0, [r5]
34805b90:	1a00000a 	bne	34805bc0 <find_dev_and_part+0x15c>
		printf("no such device %s%d\n", MTD_DEV_TYPE(type), dnum);
34805b94:	e3570002 	cmp	r7, #2
34805b98:	059f1068 	ldreq	r1, [pc, #104]	; 34805c08 <find_dev_and_part+0x1a4>
34805b9c:	0a000003 	beq	34805bb0 <find_dev_and_part+0x14c>
34805ba0:	e59f3064 	ldr	r3, [pc, #100]	; 34805c0c <find_dev_and_part+0x1a8>
34805ba4:	e3570004 	cmp	r7, #4
34805ba8:	e59f1060 	ldr	r1, [pc, #96]	; 34805c10 <find_dev_and_part+0x1ac>
34805bac:	01a01003 	moveq	r1, r3
34805bb0:	e1a02009 	mov	r2, r9
34805bb4:	e59f0058 	ldr	r0, [pc, #88]	; 34805c14 <find_dev_and_part+0x1b0>
34805bb8:	eb000d69 	bl	34809164 <printf>
34805bbc:	ea00000b 	b	34805bf0 <find_dev_and_part+0x18c>

	if ((*p++ != ',') || (*p == '\0')) {
		printf("no partition number specified\n");
		return 1;
	}
	pnum = simple_strtoul(p, (char **)&p, 0);
34805bc0:	e6ef707b 	uxtb	r7, fp
	if ((*dev = device_find(type, dnum)) == NULL) {
		printf("no such device %s%d\n", MTD_DEV_TYPE(type), dnum);
		return 1;
	}

	if ((*part = mtd_part_info(*dev, pnum)) == NULL) {
34805bc4:	e1a01007 	mov	r1, r7
34805bc8:	ebfffb62 	bl	34804958 <mtd_part_info>
34805bcc:	e3500000 	cmp	r0, #0
34805bd0:	e58a0000 	str	r0, [sl]
34805bd4:	e1a09000 	mov	r9, r0
		printf("no such partition\n");
		*dev = NULL;
		return 1;
	}

	*part_num = pnum;
34805bd8:	15c47000 	strbne	r7, [r4]

	return 0;
34805bdc:	11a00006 	movne	r0, r6
	if ((*dev = device_find(type, dnum)) == NULL) {
		printf("no such device %s%d\n", MTD_DEV_TYPE(type), dnum);
		return 1;
	}

	if ((*part = mtd_part_info(*dev, pnum)) == NULL) {
34805be0:	1a000003 	bne	34805bf4 <find_dev_and_part+0x190>
		printf("no such partition\n");
34805be4:	e59f002c 	ldr	r0, [pc, #44]	; 34805c18 <find_dev_and_part+0x1b4>
34805be8:	eb000d5d 	bl	34809164 <printf>
		*dev = NULL;
34805bec:	e5859000 	str	r9, [r5]
	*dev = NULL;
	*part = NULL;
	*part_num = 0;

	if (mtd_id_parse(p, &p, &type, &dnum) != 0)
		return 1;
34805bf0:	e3a00001 	mov	r0, #1
	}

	*part_num = pnum;

	return 0;
}
34805bf4:	e28dd010 	add	sp, sp, #16
34805bf8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34805bfc:	34829aac 	.word	0x34829aac
34805c00:	348246d5 	.word	0x348246d5
34805c04:	348246f4 	.word	0x348246f4
34805c08:	34824754 	.word	0x34824754
34805c0c:	34824751 	.word	0x34824751
34805c10:	34824383 	.word	0x34824383
34805c14:	34824718 	.word	0x34824718
34805c18:	3482472d 	.word	0x3482472d

34805c1c <mtdparts_init>:
 * device/partition list.
 *
 * @return 0 on success, 1 otherwise
 */
int mtdparts_init(void)
{
34805c1c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	const char *current_partition;
	int ids_changed;
	char tmp_ep[PARTITION_MAXLEN];

	debug("\n---mtdparts_init---\n");
	if (!initialized) {
34805c20:	e59f4594 	ldr	r4, [pc, #1428]	; 348061bc <mtdparts_init+0x5a0>
 * device/partition list.
 *
 * @return 0 on success, 1 otherwise
 */
int mtdparts_init(void)
{
34805c24:	e24dd028 	sub	sp, sp, #40	; 0x28
	const char *current_partition;
	int ids_changed;
	char tmp_ep[PARTITION_MAXLEN];

	debug("\n---mtdparts_init---\n");
	if (!initialized) {
34805c28:	e5945228 	ldr	r5, [r4, #552]	; 0x228
34805c2c:	e3550000 	cmp	r5, #0
34805c30:	1a000013 	bne	34805c84 <mtdparts_init+0x68>
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34805c34:	e2843e22 	add	r3, r4, #544	; 0x220
34805c38:	e5843220 	str	r3, [r4, #544]	; 0x220
	list->prev = list;
34805c3c:	e5843224 	str	r3, [r4, #548]	; 0x224
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34805c40:	e2843004 	add	r3, r4, #4
34805c44:	e5843004 	str	r3, [r4, #4]
	list->prev = list;
34805c48:	e5843008 	str	r3, [r4, #8]
		INIT_LIST_HEAD(&mtdids);
		INIT_LIST_HEAD(&devices);
		memset(last_ids, 0, MTDIDS_MAXLEN);
34805c4c:	e1a01005 	mov	r1, r5
34805c50:	e3a02080 	mov	r2, #128	; 0x80
34805c54:	e2840f8b 	add	r0, r4, #556	; 0x22c
34805c58:	eb005899 	bl	3481bec4 <memset>
		memset(last_parts, 0, MTDPARTS_MAXLEN);
34805c5c:	e1a01005 	mov	r1, r5
34805c60:	e3a02c02 	mov	r2, #512	; 0x200
34805c64:	e2840020 	add	r0, r4, #32
34805c68:	eb005895 	bl	3481bec4 <memset>
		memset(last_partition, 0, PARTITION_MAXLEN);
34805c6c:	e2840010 	add	r0, r4, #16
34805c70:	e1a01005 	mov	r1, r5
34805c74:	e3a02010 	mov	r2, #16
34805c78:	eb005891 	bl	3481bec4 <memset>
		initialized = 1;
34805c7c:	e3a03001 	mov	r3, #1
34805c80:	e5843228 	str	r3, [r4, #552]	; 0x228
	}

	/* get variables */
	ids = getenv("mtdids");
34805c84:	e59f0534 	ldr	r0, [pc, #1332]	; 348061c0 <mtdparts_init+0x5a4>
34805c88:	eb000647 	bl	348075ac <getenv>
34805c8c:	e1a05000 	mov	r5, r0
	parts = getenv("mtdparts");
34805c90:	e59f052c 	ldr	r0, [pc, #1324]	; 348061c4 <mtdparts_init+0x5a8>
34805c94:	eb000644 	bl	348075ac <getenv>
34805c98:	e1a04000 	mov	r4, r0
	current_partition = getenv("partition");
34805c9c:	e59f0524 	ldr	r0, [pc, #1316]	; 348061c8 <mtdparts_init+0x5ac>
34805ca0:	eb000641 	bl	348075ac <getenv>

	/* save it for later parsing, cannot rely on current partition pointer
	 * as 'partition' variable may be updated during init */
	tmp_ep[0] = '\0';
34805ca4:	e3a03000 	mov	r3, #0
	if (current_partition)
34805ca8:	e2501000 	subs	r1, r0, #0
	parts = getenv("mtdparts");
	current_partition = getenv("partition");

	/* save it for later parsing, cannot rely on current partition pointer
	 * as 'partition' variable may be updated during init */
	tmp_ep[0] = '\0';
34805cac:	e5cd3004 	strb	r3, [sp, #4]
	if (current_partition)
34805cb0:	0a000002 	beq	34805cc0 <mtdparts_init+0xa4>
		strncpy(tmp_ep, current_partition, PARTITION_MAXLEN);
34805cb4:	e28d0004 	add	r0, sp, #4
34805cb8:	e3a02010 	mov	r2, #16
34805cbc:	eb005782 	bl	3481bacc <strncpy>

	debug("last_partition : %s\n", last_partition);
	debug("env_partition  : %s\n", current_partition);

	/* if mtdids varible is empty try to use defaults */
	if (!ids) {
34805cc0:	e3550000 	cmp	r5, #0
34805cc4:	1a000003 	bne	34805cd8 <mtdparts_init+0xbc>
		if (mtdids_default) {
			debug("mtdids variable not defined, using default\n");
			ids = mtdids_default;
			setenv("mtdids", (char *)ids);
34805cc8:	e59f04f0 	ldr	r0, [pc, #1264]	; 348061c0 <mtdparts_init+0x5a4>
34805ccc:	e59f14f8 	ldr	r1, [pc, #1272]	; 348061cc <mtdparts_init+0x5b0>
34805cd0:	eb00052d 	bl	3480718c <setenv>

	/* if mtdids varible is empty try to use defaults */
	if (!ids) {
		if (mtdids_default) {
			debug("mtdids variable not defined, using default\n");
			ids = mtdids_default;
34805cd4:	e59f54f0 	ldr	r5, [pc, #1264]	; 348061cc <mtdparts_init+0x5b0>
		} else {
			printf("mtdids not defined, no default present\n");
			return 1;
		}
	}
	if (strlen(ids) > MTDIDS_MAXLEN - 1) {
34805cd8:	e1a00005 	mov	r0, r5
34805cdc:	eb0057d8 	bl	3481bc44 <strlen>
34805ce0:	e350007f 	cmp	r0, #127	; 0x7f
		printf("mtdids too long (> %d)\n", MTDIDS_MAXLEN);
34805ce4:	859f04e4 	ldrhi	r0, [pc, #1252]	; 348061d0 <mtdparts_init+0x5b4>
34805ce8:	83a01080 	movhi	r1, #128	; 0x80
		} else {
			printf("mtdids not defined, no default present\n");
			return 1;
		}
	}
	if (strlen(ids) > MTDIDS_MAXLEN - 1) {
34805cec:	8a00000a 	bhi	34805d1c <mtdparts_init+0x100>
		return 1;
	}

	/* do no try to use defaults when mtdparts variable is not defined,
	 * just check the length */
	if (!parts)
34805cf0:	e3540000 	cmp	r4, #0
34805cf4:	1a000002 	bne	34805d04 <mtdparts_init+0xe8>
		printf("mtdparts variable not set, see 'help mtdparts'\n");
34805cf8:	e59f04d4 	ldr	r0, [pc, #1236]	; 348061d4 <mtdparts_init+0x5b8>
34805cfc:	eb000d18 	bl	34809164 <printf>
34805d00:	ea000008 	b	34805d28 <mtdparts_init+0x10c>

	if (parts && (strlen(parts) > MTDPARTS_MAXLEN - 1)) {
34805d04:	e1a00004 	mov	r0, r4
34805d08:	eb0057cd 	bl	3481bc44 <strlen>
34805d0c:	e3500c02 	cmp	r0, #512	; 0x200
34805d10:	3a000004 	bcc	34805d28 <mtdparts_init+0x10c>
		printf("mtdparts too long (> %d)\n", MTDPARTS_MAXLEN);
34805d14:	e59f04bc 	ldr	r0, [pc, #1212]	; 348061d8 <mtdparts_init+0x5bc>
34805d18:	e3a01c02 	mov	r1, #512	; 0x200
34805d1c:	eb000d10 	bl	34809164 <printf>
		return 1;
34805d20:	e3a00001 	mov	r0, #1
34805d24:	ea00010c 	b	3480615c <mtdparts_init+0x540>
	}

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
34805d28:	e59f048c 	ldr	r0, [pc, #1164]	; 348061bc <mtdparts_init+0x5a0>
34805d2c:	e5d0322c 	ldrb	r3, [r0, #556]	; 0x22c
34805d30:	e3530000 	cmp	r3, #0
34805d34:	0a000005 	beq	34805d50 <mtdparts_init+0x134>
34805d38:	e1a01005 	mov	r1, r5
34805d3c:	e2800f8b 	add	r0, r0, #556	; 0x22c
34805d40:	eb00578b 	bl	3481bb74 <strcmp>
34805d44:	e3500000 	cmp	r0, #0
		ids_changed = 0;
34805d48:	01a05000 	moveq	r5, r0
		printf("mtdparts too long (> %d)\n", MTDPARTS_MAXLEN);
		return 1;
	}

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
34805d4c:	0a000088 	beq	34805f74 <mtdparts_init+0x358>
	int ret = 1;

	debug("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
34805d50:	e59f7464 	ldr	r7, [pc, #1124]	; 348061bc <mtdparts_init+0x5a0>
 * @param ids mapping string
 * @return 0 on success, 1 otherwise
 */
static int parse_mtdids(const char *const ids)
{
	const char *p = ids;
34805d54:	e58d5018 	str	r5, [sp, #24]
	int ret = 1;

	debug("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
34805d58:	e5b70220 	ldr	r0, [r7, #544]!	; 0x220
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34805d5c:	e3a0a000 	mov	sl, #0
34805d60:	e5906000 	ldr	r6, [r0]
34805d64:	ea000007 	b	34805d88 <mtdparts_init+0x16c>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34805d68:	e890000c 	ldm	r0, {r2, r3}
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34805d6c:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34805d70:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
34805d74:	e580a004 	str	sl, [r0, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34805d78:	e580a000 	str	sl, [r0]
		id_tmp = list_entry(entry, struct mtdids, link);
		debug("mtdids del: %d %d\n", id_tmp->type, id_tmp->num);
		list_del(entry);
		free(id_tmp);
34805d7c:	eb000e36 	bl	3480965c <free>
	int ret = 1;

	debug("\n---parse_mtdids---\nmtdids = %s\n\n", ids);

	/* clean global mtdids list */
	list_for_each_safe(entry, n, &mtdids) {
34805d80:	e1a00006 	mov	r0, r6
34805d84:	e5966000 	ldr	r6, [r6]
34805d88:	e1500007 	cmp	r0, r7
34805d8c:	e59f9428 	ldr	r9, [pc, #1064]	; 348061bc <mtdparts_init+0x5a0>
34805d90:	1afffff4 	bne	34805d68 <mtdparts_init+0x14c>
		id_tmp = list_entry(entry, struct mtdids, link);
		debug("mtdids del: %d %d\n", id_tmp->type, id_tmp->num);
		list_del(entry);
		free(id_tmp);
	}
	last_ids[0] = '\0';
34805d94:	e3a03000 	mov	r3, #0
34805d98:	e5c9322c 	strb	r3, [r9, #556]	; 0x22c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34805d9c:	e5890220 	str	r0, [r9, #544]	; 0x220
	list->prev = list;
34805da0:	e5890224 	str	r0, [r9, #548]	; 0x224
	struct mtdids *id;
	struct list_head *entry, *n;
	struct mtdids *id_tmp;
	u8 type, num;
	u32 size;
	int ret = 1;
34805da4:	e2833001 	add	r3, r3, #1
34805da8:	e1a0a005 	mov	sl, r5
34805dac:	ea000057 	b	34805f10 <mtdparts_init+0x2f4>

	while(p && (*p != '\0')) {

		ret = 1;
		/* parse 'nor'|'nand'|'onenand'<dev-num> */
		if (mtd_id_parse(p, &p, &type, &num) != 0)
34805db0:	e28d1018 	add	r1, sp, #24
34805db4:	e28d2027 	add	r2, sp, #39	; 0x27
34805db8:	e28d3020 	add	r3, sp, #32
34805dbc:	ebfffee4 	bl	34805954 <mtd_id_parse>
34805dc0:	e3500000 	cmp	r0, #0
34805dc4:	1a000059 	bne	34805f30 <mtdparts_init+0x314>
			break;

		if (*p != '=') {
34805dc8:	e59d3018 	ldr	r3, [sp, #24]
34805dcc:	e5d32000 	ldrb	r2, [r3]
34805dd0:	e352003d 	cmp	r2, #61	; 0x3d
			printf("mtdids: incorrect <dev-num>\n");
34805dd4:	159f0400 	ldrne	r0, [pc, #1024]	; 348061dc <mtdparts_init+0x5c0>
34805dd8:	1a000032 	bne	34805ea8 <mtdparts_init+0x28c>
			break;
		}
		p++;
34805ddc:	e2833001 	add	r3, r3, #1

		/* check if requested device exists */
		if (mtd_device_validate(type, num, &size) != 0)
34805de0:	e5dd0027 	ldrb	r0, [sp, #39]	; 0x27
34805de4:	e5dd1020 	ldrb	r1, [sp, #32]
34805de8:	e28d201c 	add	r2, sp, #28

		if (*p != '=') {
			printf("mtdids: incorrect <dev-num>\n");
			break;
		}
		p++;
34805dec:	e58d3018 	str	r3, [sp, #24]

		/* check if requested device exists */
		if (mtd_device_validate(type, num, &size) != 0)
34805df0:	ebfffd62 	bl	34805380 <mtd_device_validate>
34805df4:	e3500000 	cmp	r0, #0
34805df8:	1a00005b 	bne	34805f6c <mtdparts_init+0x350>
			return 1;

		/* locate <mtd-id> */
		mtd_id = p;
34805dfc:	e59d7018 	ldr	r7, [sp, #24]
		if ((p = strchr(mtd_id, ',')) != NULL) {
34805e00:	e3a0102c 	mov	r1, #44	; 0x2c
34805e04:	e1a00007 	mov	r0, r7
34805e08:	eb005777 	bl	3481bbec <strchr>
34805e0c:	e3500000 	cmp	r0, #0
34805e10:	e58d0018 	str	r0, [sp, #24]
			mtd_id_len = p - mtd_id + 1;
34805e14:	12676001 	rsbne	r6, r7, #1
34805e18:	10806006 	addne	r6, r0, r6
			p++;
34805e1c:	12800001 	addne	r0, r0, #1
34805e20:	158d0018 	strne	r0, [sp, #24]
34805e24:	1a000002 	bne	34805e34 <mtdparts_init+0x218>
		} else {
			mtd_id_len = strlen(mtd_id) + 1;
34805e28:	e1a00007 	mov	r0, r7
34805e2c:	eb005784 	bl	3481bc44 <strlen>
34805e30:	e2806001 	add	r6, r0, #1
		}
		if (mtd_id_len == 0) {
34805e34:	e3560000 	cmp	r6, #0
			printf("mtdids: no <mtd-id> identifier\n");
34805e38:	059f03a0 	ldreq	r0, [pc, #928]	; 348061e0 <mtdparts_init+0x5c4>
34805e3c:	0a000019 	beq	34805ea8 <mtdparts_init+0x28c>
			break;
		}

		/* check if this id is already on the list */
		int double_entry = 0;
		list_for_each(entry, &mtdids) {
34805e40:	e5993220 	ldr	r3, [r9, #544]	; 0x220
			id_tmp = list_entry(entry, struct mtdids, link);
			if ((id_tmp->type == type) && (id_tmp->num == num)) {
34805e44:	e5dd0027 	ldrb	r0, [sp, #39]	; 0x27
34805e48:	e5dd1020 	ldrb	r1, [sp, #32]
34805e4c:	ea000006 	b	34805e6c <mtdparts_init+0x250>
34805e50:	e5d32008 	ldrb	r2, [r3, #8]
34805e54:	e1520000 	cmp	r2, r0
34805e58:	1a000002 	bne	34805e68 <mtdparts_init+0x24c>
34805e5c:	e5d32009 	ldrb	r2, [r3, #9]
34805e60:	e1520001 	cmp	r2, r1
34805e64:	0a000004 	beq	34805e7c <mtdparts_init+0x260>
			break;
		}

		/* check if this id is already on the list */
		int double_entry = 0;
		list_for_each(entry, &mtdids) {
34805e68:	e5933000 	ldr	r3, [r3]
34805e6c:	e59f2370 	ldr	r2, [pc, #880]	; 348061e4 <mtdparts_init+0x5c8>
34805e70:	e1530002 	cmp	r3, r2
34805e74:	1afffff5 	bne	34805e50 <mtdparts_init+0x234>
34805e78:	ea0000b9 	b	34806164 <mtdparts_init+0x548>
				double_entry = 1;
				break;
			}
		}
		if (double_entry) {
			printf("device id %s%d redefined, please correct mtdids variable\n",
34805e7c:	e3500002 	cmp	r0, #2
34805e80:	059f1360 	ldreq	r1, [pc, #864]	; 348061e8 <mtdparts_init+0x5cc>
34805e84:	0a000003 	beq	34805e98 <mtdparts_init+0x27c>
					MTD_DEV_TYPE(type), num);
34805e88:	e59f335c 	ldr	r3, [pc, #860]	; 348061ec <mtdparts_init+0x5d0>
34805e8c:	e3500004 	cmp	r0, #4
34805e90:	e59f1358 	ldr	r1, [pc, #856]	; 348061f0 <mtdparts_init+0x5d4>
34805e94:	01a01003 	moveq	r1, r3
				double_entry = 1;
				break;
			}
		}
		if (double_entry) {
			printf("device id %s%d redefined, please correct mtdids variable\n",
34805e98:	e59f0354 	ldr	r0, [pc, #852]	; 348061f4 <mtdparts_init+0x5d8>
34805e9c:	eb000cb0 	bl	34809164 <printf>
34805ea0:	ea000022 	b	34805f30 <mtdparts_init+0x314>
			break;
		}

		/* allocate mtdids structure */
		if (!(id = (struct mtdids *)malloc(sizeof(struct mtdids) + mtd_id_len))) {
			printf("out of memory\n");
34805ea4:	e59f034c 	ldr	r0, [pc, #844]	; 348061f8 <mtdparts_init+0x5dc>
34805ea8:	eb000cad 	bl	34809164 <printf>
34805eac:	ea00001f 	b	34805f30 <mtdparts_init+0x314>
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
34805eb0:	e3a01000 	mov	r1, #0
34805eb4:	e1a0200b 	mov	r2, fp
34805eb8:	eb005801 	bl	3481bec4 <memset>
		id->num = num;
34805ebc:	e5dd3020 	ldrb	r3, [sp, #32]
		id->type = type;
		id->size = size;
		id->mtd_id = (char *)(id + 1);
34805ec0:	e2850014 	add	r0, r5, #20
		if (!(id = (struct mtdids *)malloc(sizeof(struct mtdids) + mtd_id_len))) {
			printf("out of memory\n");
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
		id->num = num;
34805ec4:	e5c53009 	strb	r3, [r5, #9]
		id->type = type;
34805ec8:	e5dd3027 	ldrb	r3, [sp, #39]	; 0x27
		id->size = size;
		id->mtd_id = (char *)(id + 1);
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
34805ecc:	e2462001 	sub	r2, r6, #1
			printf("out of memory\n");
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
		id->num = num;
		id->type = type;
34805ed0:	e5c53008 	strb	r3, [r5, #8]
		id->size = size;
34805ed4:	e59d301c 	ldr	r3, [sp, #28]
		id->mtd_id = (char *)(id + 1);
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
34805ed8:	e1a01007 	mov	r1, r7
			break;
		}
		memset(id, 0, sizeof(struct mtdids) + mtd_id_len);
		id->num = num;
		id->type = type;
		id->size = size;
34805edc:	e585300c 	str	r3, [r5, #12]
		id->mtd_id = (char *)(id + 1);
34805ee0:	e5850010 	str	r0, [r5, #16]
		strncpy(id->mtd_id, mtd_id, mtd_id_len - 1);
34805ee4:	eb0056f8 	bl	3481bacc <strncpy>
		id->mtd_id[mtd_id_len - 1] = '\0';
34805ee8:	e5953010 	ldr	r3, [r5, #16]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34805eec:	e59f12c8 	ldr	r1, [pc, #712]	; 348061bc <mtdparts_init+0x5a0>
34805ef0:	e0836006 	add	r6, r3, r6
34805ef4:	e3a03000 	mov	r3, #0
34805ef8:	e5463001 	strb	r3, [r6, #-1]
34805efc:	e5912224 	ldr	r2, [r1, #548]	; 0x224
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34805f00:	e5815224 	str	r5, [r1, #548]	; 0x224
	new->next = next;
34805f04:	e59f12d8 	ldr	r1, [pc, #728]	; 348061e4 <mtdparts_init+0x5c8>
	new->prev = prev;
34805f08:	e8850006 	stm	r5, {r1, r2}
	prev->next = new;
34805f0c:	e5825000 	str	r5, [r2]
		free(id_tmp);
	}
	last_ids[0] = '\0';
	INIT_LIST_HEAD(&mtdids);

	while(p && (*p != '\0')) {
34805f10:	e59d0018 	ldr	r0, [sp, #24]
34805f14:	e3500000 	cmp	r0, #0
34805f18:	0a000002 	beq	34805f28 <mtdparts_init+0x30c>
34805f1c:	e5d02000 	ldrb	r2, [r0]
34805f20:	e3520000 	cmp	r2, #0
34805f24:	1affffa1 	bne	34805db0 <mtdparts_init+0x194>
				id->size, id->mtd_id);

		list_add_tail(&id->link, &mtdids);
		ret = 0;
	}
	if (ret == 1) {
34805f28:	e3530001 	cmp	r3, #1
34805f2c:	1a000092 	bne	3480617c <mtdparts_init+0x560>
		/* clean mtdids list and free allocated memory */
		list_for_each_safe(entry, n, &mtdids) {
34805f30:	e59f5284 	ldr	r5, [pc, #644]	; 348061bc <mtdparts_init+0x5a0>
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34805f34:	e3a06000 	mov	r6, #0
34805f38:	e5b50220 	ldr	r0, [r5, #544]!	; 0x220
34805f3c:	e5904000 	ldr	r4, [r0]
34805f40:	ea000007 	b	34805f64 <mtdparts_init+0x348>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34805f44:	e890000c 	ldm	r0, {r2, r3}
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34805f48:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34805f4c:	e5832000 	str	r2, [r3]
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
	entry->prev = LIST_POISON2;
34805f50:	e5806004 	str	r6, [r0, #4]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34805f54:	e5806000 	str	r6, [r0]
			id_tmp = list_entry(entry, struct mtdids, link);
			list_del(entry);
			free(id_tmp);
34805f58:	eb000dbf 	bl	3480965c <free>
		list_add_tail(&id->link, &mtdids);
		ret = 0;
	}
	if (ret == 1) {
		/* clean mtdids list and free allocated memory */
		list_for_each_safe(entry, n, &mtdids) {
34805f5c:	e1a00004 	mov	r0, r4
34805f60:	e5944000 	ldr	r4, [r4]
34805f64:	e1500005 	cmp	r0, r5
34805f68:	1afffff5 	bne	34805f44 <mtdparts_init+0x328>
		ids_changed = 0;
	} else {
		ids_changed = 1;

		if (parse_mtdids(ids) != 0) {
			mtd_devices_init();
34805f6c:	ebfffc49 	bl	34805098 <mtd_devices_init>
34805f70:	eaffff6a 	b	34805d20 <mtdparts_init+0x104>
		/* ok it's good, save new ids */
		strncpy(last_ids, ids, MTDIDS_MAXLEN);
	}

	/* parse partitions if either mtdparts or mtdids were updated */
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
34805f74:	e3540000 	cmp	r4, #0
34805f78:	e59f023c 	ldr	r0, [pc, #572]	; 348061bc <mtdparts_init+0x5a0>
34805f7c:	0a000056 	beq	348060dc <mtdparts_init+0x4c0>
34805f80:	e5d03020 	ldrb	r3, [r0, #32]
34805f84:	e3530000 	cmp	r3, #0
34805f88:	0a000006 	beq	34805fa8 <mtdparts_init+0x38c>
34805f8c:	e2800020 	add	r0, r0, #32
34805f90:	e1a01004 	mov	r1, r4
34805f94:	eb0056f6 	bl	3481bb74 <strcmp>
34805f98:	e3500000 	cmp	r0, #0
34805f9c:	1a000001 	bne	34805fa8 <mtdparts_init+0x38c>
34805fa0:	e3550000 	cmp	r5, #0
34805fa4:	0a000080 	beq	348061ac <mtdparts_init+0x590>
 * @param mtdparts string specifing mtd partitions
 * @return 0 on success, 1 otherwise
 */
static int parse_mtdparts(const char *const mtdparts)
{
	const char *p = mtdparts;
34805fa8:	e58d4018 	str	r4, [sp, #24]
	int err = 1;

	debug("\n---parse_mtdparts---\nmtdparts = %s\n\n", p);

	/* delete all devices and partitions */
	if (mtd_devices_init() != 0) {
34805fac:	ebfffc39 	bl	34805098 <mtd_devices_init>
34805fb0:	e3500000 	cmp	r0, #0
		printf("could not initialise device list\n");
34805fb4:	159f0240 	ldrne	r0, [pc, #576]	; 348061fc <mtdparts_init+0x5e0>
	int err = 1;

	debug("\n---parse_mtdparts---\nmtdparts = %s\n\n", p);

	/* delete all devices and partitions */
	if (mtd_devices_init() != 0) {
34805fb8:	1a00003b 	bne	348060ac <mtdparts_init+0x490>
		printf("could not initialise device list\n");
		return err;
	}

	/* re-read 'mtdparts' variable, mtd_devices_init may be updating env */
	p = getenv("mtdparts");
34805fbc:	e59f0200 	ldr	r0, [pc, #512]	; 348061c4 <mtdparts_init+0x5a8>
34805fc0:	eb000579 	bl	348075ac <getenv>

	if (strncmp(p, "mtdparts=", 9) != 0) {
34805fc4:	e59f1234 	ldr	r1, [pc, #564]	; 34806200 <mtdparts_init+0x5e4>
34805fc8:	e3a02009 	mov	r2, #9
		printf("could not initialise device list\n");
		return err;
	}

	/* re-read 'mtdparts' variable, mtd_devices_init may be updating env */
	p = getenv("mtdparts");
34805fcc:	e58d0018 	str	r0, [sp, #24]

	if (strncmp(p, "mtdparts=", 9) != 0) {
34805fd0:	eb0056f3 	bl	3481bba4 <strncmp>
34805fd4:	e3500000 	cmp	r0, #0
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
34805fd8:	159f0224 	ldrne	r0, [pc, #548]	; 34806204 <mtdparts_init+0x5e8>
	}

	/* re-read 'mtdparts' variable, mtd_devices_init may be updating env */
	p = getenv("mtdparts");

	if (strncmp(p, "mtdparts=", 9) != 0) {
34805fdc:	1a000032 	bne	348060ac <mtdparts_init+0x490>
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
		return err;
	}
	p += 9;
34805fe0:	e59d3018 	ldr	r3, [sp, #24]
34805fe4:	e28d6028 	add	r6, sp, #40	; 0x28
34805fe8:	e2833009 	add	r3, r3, #9
34805fec:	e5263010 	str	r3, [r6, #-16]!

	while (p && (*p != '\0')) {
		err = 1;
		if ((device_parse(p, &p, &dev) != 0) || (!dev))
34805ff0:	e28d7014 	add	r7, sp, #20
 */
static int parse_mtdparts(const char *const mtdparts)
{
	const char *p = mtdparts;
	struct mtd_device *dev;
	int err = 1;
34805ff4:	e3a03001 	mov	r3, #1
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34805ff8:	e59f51bc 	ldr	r5, [pc, #444]	; 348061bc <mtdparts_init+0x5a0>
34805ffc:	ea00001f 	b	34806080 <mtdparts_init+0x464>
	}
	p += 9;

	while (p && (*p != '\0')) {
		err = 1;
		if ((device_parse(p, &p, &dev) != 0) || (!dev))
34806000:	e1a01006 	mov	r1, r6
34806004:	e1a02007 	mov	r2, r7
34806008:	ebfffcfb 	bl	348053fc <device_parse>
3480600c:	e3500000 	cmp	r0, #0
34806010:	1a000022 	bne	348060a0 <mtdparts_init+0x484>
34806014:	e59da014 	ldr	sl, [sp, #20]
34806018:	e35a0000 	cmp	sl, #0
3480601c:	0a00001f 	beq	348060a0 <mtdparts_init+0x484>

		debug("+ device: %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id);

		/* check if parsed device is already on the list */
		if (device_find(dev->id->type, dev->id->num) != NULL) {
34806020:	e59a3008 	ldr	r3, [sl, #8]
34806024:	e5d39008 	ldrb	r9, [r3, #8]
34806028:	e5d3b009 	ldrb	fp, [r3, #9]
3480602c:	e1a00009 	mov	r0, r9
34806030:	e1a0100b 	mov	r1, fp
34806034:	ebfffcdd 	bl	348053b0 <device_find>
34806038:	e2503000 	subs	r3, r0, #0
3480603c:	0a00000a 	beq	3480606c <mtdparts_init+0x450>
			printf("device %s%d redefined, please correct mtdparts variable\n",
34806040:	e3590002 	cmp	r9, #2
34806044:	059f119c 	ldreq	r1, [pc, #412]	; 348061e8 <mtdparts_init+0x5cc>
34806048:	0a000003 	beq	3480605c <mtdparts_init+0x440>
					MTD_DEV_TYPE(dev->id->type), dev->id->num);
3480604c:	e59f3198 	ldr	r3, [pc, #408]	; 348061ec <mtdparts_init+0x5d0>
34806050:	e3590004 	cmp	r9, #4
34806054:	e59f1194 	ldr	r1, [pc, #404]	; 348061f0 <mtdparts_init+0x5d4>
34806058:	01a01003 	moveq	r1, r3
		debug("+ device: %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id);

		/* check if parsed device is already on the list */
		if (device_find(dev->id->type, dev->id->num) != NULL) {
			printf("device %s%d redefined, please correct mtdparts variable\n",
3480605c:	e1a0200b 	mov	r2, fp
34806060:	e59f01a0 	ldr	r0, [pc, #416]	; 34806208 <mtdparts_init+0x5ec>
34806064:	eb000c3e 	bl	34809164 <printf>
34806068:	ea00000c 	b	348060a0 <mtdparts_init+0x484>
3480606c:	e5952008 	ldr	r2, [r5, #8]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34806070:	e59f1194 	ldr	r1, [pc, #404]	; 3480620c <mtdparts_init+0x5f0>
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34806074:	e585a008 	str	sl, [r5, #8]
	new->next = next;
34806078:	e88a0006 	stm	sl, {r1, r2}
	new->prev = prev;
	prev->next = new;
3480607c:	e582a000 	str	sl, [r2]
		printf("mtdparts variable doesn't start with 'mtdparts='\n");
		return err;
	}
	p += 9;

	while (p && (*p != '\0')) {
34806080:	e59d0018 	ldr	r0, [sp, #24]
34806084:	e3500000 	cmp	r0, #0
34806088:	0a000002 	beq	34806098 <mtdparts_init+0x47c>
3480608c:	e5d02000 	ldrb	r2, [r0]
34806090:	e3520000 	cmp	r2, #0
34806094:	1affffd9 	bne	34806000 <mtdparts_init+0x3e4>
		}

		list_add_tail(&dev->link, &devices);
		err = 0;
	}
	if (err == 1) {
34806098:	e3530001 	cmp	r3, #1
3480609c:	1a00003c 	bne	34806194 <mtdparts_init+0x578>
		device_delall(&devices);
348060a0:	ebfffbe3 	bl	34805034 <device_delall.clone.2>
348060a4:	eaffff1d 	b	34805d20 <mtdparts_init+0x104>
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
		if (parse_mtdparts(parts) != 0)
			return 1;

		if (list_empty(&devices)) {
			printf("mtdparts_init: no valid partitions\n");
348060a8:	e59f0160 	ldr	r0, [pc, #352]	; 34806210 <mtdparts_init+0x5f4>
348060ac:	eb000c2c 	bl	34809164 <printf>
348060b0:	eaffff1a 	b	34805d20 <mtdparts_init+0x104>
			return 1;
		}

		/* ok it's good, save new parts */
		strncpy(last_parts, parts, MTDPARTS_MAXLEN);
348060b4:	e2850020 	add	r0, r5, #32
348060b8:	e1a01004 	mov	r1, r4
348060bc:	e3a02c02 	mov	r2, #512	; 0x200
348060c0:	eb005681 	bl	3481bacc <strncpy>

		/* reset first partition from first dev from the list as current */
		current_mtd_dev = list_entry(devices.next, struct mtd_device, link);
348060c4:	e5953004 	ldr	r3, [r5, #4]
348060c8:	e5853000 	str	r3, [r5]
		current_mtd_partnum = 0;
348060cc:	e3a03000 	mov	r3, #0
348060d0:	e5c5300c 	strb	r3, [r5, #12]
		current_save();
348060d4:	ebfffa88 	bl	34804afc <current_save>
348060d8:	ea000033 	b	348061ac <mtdparts_init+0x590>
				MTD_DEV_TYPE(current_mtd_dev->id->type),
				current_mtd_dev->id->num, current_mtd_partnum);
	}

	/* mtdparts variable was reset to NULL, delete all devices/partitions */
	if (!parts && (last_parts[0] != '\0'))
348060dc:	e5d03020 	ldrb	r3, [r0, #32]
348060e0:	e3530000 	cmp	r3, #0
348060e4:	0a000019 	beq	34806150 <mtdparts_init+0x534>
		return mtd_devices_init();
348060e8:	ebfffbea 	bl	34805098 <mtd_devices_init>
348060ec:	ea00001a 	b	3480615c <mtdparts_init+0x540>
	/* do not process current partition if mtdparts variable is null */
	if (!parts)
		return 0;

	/* is current partition set in environment? if so, use it */
	if ((tmp_ep[0] != '\0') && (strcmp(tmp_ep, last_partition) != 0)) {
348060f0:	e59f50c4 	ldr	r5, [pc, #196]	; 348061bc <mtdparts_init+0x5a0>
348060f4:	e28d4004 	add	r4, sp, #4
348060f8:	e1a00004 	mov	r0, r4
348060fc:	e2851010 	add	r1, r5, #16
34806100:	eb00569b 	bl	3481bb74 <strcmp>
34806104:	e3500000 	cmp	r0, #0
34806108:	0a00000b 	beq	3480613c <mtdparts_init+0x520>
		struct mtd_device *cdev;
		u8 pnum;

		debug("--- getting current partition: %s\n", tmp_ep);

		if (find_dev_and_part(tmp_ep, &cdev, &pnum, &p) == 0) {
3480610c:	e1a00004 	mov	r0, r4
34806110:	e28d1014 	add	r1, sp, #20
34806114:	e28d2027 	add	r2, sp, #39	; 0x27
34806118:	e28d3020 	add	r3, sp, #32
3480611c:	ebfffe50 	bl	34805a64 <find_dev_and_part>
34806120:	e2504000 	subs	r4, r0, #0
34806124:	1a00000b 	bne	34806158 <mtdparts_init+0x53c>
			current_mtd_dev = cdev;
34806128:	e59d3014 	ldr	r3, [sp, #20]
3480612c:	e5853000 	str	r3, [r5]
			current_mtd_partnum = pnum;
34806130:	e5dd3027 	ldrb	r3, [sp, #39]	; 0x27
34806134:	e5c5300c 	strb	r3, [r5, #12]
34806138:	ea000003 	b	3480614c <mtdparts_init+0x530>
			current_save();
		}
	} else if (getenv("partition") == NULL) {
3480613c:	e59f0084 	ldr	r0, [pc, #132]	; 348061c8 <mtdparts_init+0x5ac>
34806140:	eb000519 	bl	348075ac <getenv>
34806144:	e2504000 	subs	r4, r0, #0
34806148:	1a000002 	bne	34806158 <mtdparts_init+0x53c>
		debug("no partition variable set, setting...\n");
		current_save();
3480614c:	ebfffa6a 	bl	34804afc <current_save>
	if (!parts && (last_parts[0] != '\0'))
		return mtd_devices_init();

	/* do not process current partition if mtdparts variable is null */
	if (!parts)
		return 0;
34806150:	e1a00004 	mov	r0, r4
34806154:	ea000000 	b	3480615c <mtdparts_init+0x540>
	} else if (getenv("partition") == NULL) {
		debug("no partition variable set, setting...\n");
		current_save();
	}

	return 0;
34806158:	e3a00000 	mov	r0, #0
}
3480615c:	e28dd028 	add	sp, sp, #40	; 0x28
34806160:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
					MTD_DEV_TYPE(type), num);
			break;
		}

		/* allocate mtdids structure */
		if (!(id = (struct mtdids *)malloc(sizeof(struct mtdids) + mtd_id_len))) {
34806164:	e286b014 	add	fp, r6, #20
34806168:	e1a0000b 	mov	r0, fp
3480616c:	eb000dc3 	bl	34809880 <malloc>
34806170:	e2505000 	subs	r5, r0, #0
34806174:	1affff4d 	bne	34805eb0 <mtdparts_init+0x294>
34806178:	eaffff49 	b	34805ea4 <mtdparts_init+0x288>
			mtd_devices_init();
			return 1;
		}

		/* ok it's good, save new ids */
		strncpy(last_ids, ids, MTDIDS_MAXLEN);
3480617c:	e59f0090 	ldr	r0, [pc, #144]	; 34806214 <mtdparts_init+0x5f8>
34806180:	e1a0100a 	mov	r1, sl
34806184:	e3a02080 	mov	r2, #128	; 0x80
34806188:	eb00564f 	bl	3481bacc <strncpy>

	/* check if we have already parsed those mtdids */
	if ((last_ids[0] != '\0') && (strcmp(last_ids, ids) == 0)) {
		ids_changed = 0;
	} else {
		ids_changed = 1;
3480618c:	e3a05001 	mov	r5, #1
34806190:	eaffff77 	b	34805f74 <mtdparts_init+0x358>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34806194:	e59f5020 	ldr	r5, [pc, #32]	; 348061bc <mtdparts_init+0x5a0>
	/* parse partitions if either mtdparts or mtdids were updated */
	if (parts && ((last_parts[0] == '\0') || ((strcmp(last_parts, parts) != 0)) || ids_changed)) {
		if (parse_mtdparts(parts) != 0)
			return 1;

		if (list_empty(&devices)) {
34806198:	e5952004 	ldr	r2, [r5, #4]
3480619c:	e2853004 	add	r3, r5, #4
348061a0:	e1520003 	cmp	r2, r3
348061a4:	1affffc2 	bne	348060b4 <mtdparts_init+0x498>
348061a8:	eaffffbe 	b	348060a8 <mtdparts_init+0x48c>
	/* do not process current partition if mtdparts variable is null */
	if (!parts)
		return 0;

	/* is current partition set in environment? if so, use it */
	if ((tmp_ep[0] != '\0') && (strcmp(tmp_ep, last_partition) != 0)) {
348061ac:	e5dd3004 	ldrb	r3, [sp, #4]
348061b0:	e3530000 	cmp	r3, #0
348061b4:	1affffcd 	bne	348060f0 <mtdparts_init+0x4d4>
348061b8:	eaffffdf 	b	3480613c <mtdparts_init+0x520>
348061bc:	34829aac 	.word	0x34829aac
348061c0:	34824759 	.word	0x34824759
348061c4:	348244cf 	.word	0x348244cf
348061c8:	34824b1a 	.word	0x34824b1a
348061cc:	34824740 	.word	0x34824740
348061d0:	34824760 	.word	0x34824760
348061d4:	34824778 	.word	0x34824778
348061d8:	348247a8 	.word	0x348247a8
348061dc:	348247c2 	.word	0x348247c2
348061e0:	348247df 	.word	0x348247df
348061e4:	34829ccc 	.word	0x34829ccc
348061e8:	34824754 	.word	0x34824754
348061ec:	34824751 	.word	0x34824751
348061f0:	34824383 	.word	0x34824383
348061f4:	348247ff 	.word	0x348247ff
348061f8:	348245b6 	.word	0x348245b6
348061fc:	34824839 	.word	0x34824839
34806200:	348244c5 	.word	0x348244c5
34806204:	3482485b 	.word	0x3482485b
34806208:	3482488d 	.word	0x3482488d
3480620c:	34829ab0 	.word	0x34829ab0
34806210:	348248c6 	.word	0x348248c6
34806214:	34829cd8 	.word	0x34829cd8

34806218 <do_mtdparts>:
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_mtdparts(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34806218:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	if (argc == 2) {
3480621c:	e3520002 	cmp	r2, #2
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_mtdparts(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34806220:	e24dd060 	sub	sp, sp, #96	; 0x60
34806224:	e1a05002 	mov	r5, r2
34806228:	e1a04003 	mov	r4, r3
	if (argc == 2) {
3480622c:	1a00001b 	bne	348062a0 <do_mtdparts+0x88>
		if (strcmp(argv[1], "default") == 0) {
34806230:	e5930004 	ldr	r0, [r3, #4]
34806234:	e59f157c 	ldr	r1, [pc, #1404]	; 348067b8 <do_mtdparts+0x5a0>
34806238:	eb00564d 	bl	3481bb74 <strcmp>
3480623c:	e2506000 	subs	r6, r0, #0
34806240:	1a00000b 	bne	34806274 <do_mtdparts+0x5c>
			setenv("mtdids", (char *)mtdids_default);
34806244:	e59f1570 	ldr	r1, [pc, #1392]	; 348067bc <do_mtdparts+0x5a4>
34806248:	e59f0570 	ldr	r0, [pc, #1392]	; 348067c0 <do_mtdparts+0x5a8>
3480624c:	eb0003ce 	bl	3480718c <setenv>
			setenv("mtdparts", (char *)mtdparts_default);
34806250:	e59f156c 	ldr	r1, [pc, #1388]	; 348067c4 <do_mtdparts+0x5ac>
34806254:	e59f056c 	ldr	r0, [pc, #1388]	; 348067c8 <do_mtdparts+0x5b0>
34806258:	eb0003cb 	bl	3480718c <setenv>
			setenv("partition", NULL);
3480625c:	e1a01006 	mov	r1, r6
34806260:	e59f0564 	ldr	r0, [pc, #1380]	; 348067cc <do_mtdparts+0x5b4>
34806264:	eb0003c8 	bl	3480718c <setenv>

			mtdparts_init();
34806268:	ebfffe6b 	bl	34805c1c <mtdparts_init>
			return 0;
3480626c:	e1a00006 	mov	r0, r6
34806270:	ea00014e 	b	348067b0 <do_mtdparts+0x598>
		} else if (strcmp(argv[1], "delall") == 0) {
34806274:	e5940004 	ldr	r0, [r4, #4]
34806278:	e59f1550 	ldr	r1, [pc, #1360]	; 348067d0 <do_mtdparts+0x5b8>
3480627c:	eb00563c 	bl	3481bb74 <strcmp>
34806280:	e2506000 	subs	r6, r0, #0
34806284:	1a000005 	bne	348062a0 <do_mtdparts+0x88>
			/* this may be the first run, initialize lists if needed */
			mtdparts_init();
34806288:	ebfffe63 	bl	34805c1c <mtdparts_init>

			setenv("mtdparts", NULL);
3480628c:	e1a01006 	mov	r1, r6
34806290:	e59f0530 	ldr	r0, [pc, #1328]	; 348067c8 <do_mtdparts+0x5b0>
34806294:	eb0003bc 	bl	3480718c <setenv>

			/* mtd_devices_init() calls current_save() */
			return mtd_devices_init();
34806298:	ebfffb7e 	bl	34805098 <mtd_devices_init>
3480629c:	ea000143 	b	348067b0 <do_mtdparts+0x598>
		}
	}

	/* make sure we are in sync with env variables */
	if (mtdparts_init() != 0)
348062a0:	ebfffe5d 	bl	34805c1c <mtdparts_init>
348062a4:	e3500000 	cmp	r0, #0
348062a8:	1a00013d 	bne	348067a4 <do_mtdparts+0x58c>
		return 1;

	if (argc == 1) {
348062ac:	e3550001 	cmp	r5, #1
348062b0:	1a00005b 	bne	34806424 <do_mtdparts+0x20c>
	struct list_head *dentry, *pentry;
	struct part_info *part;
	struct mtd_device *dev;
	int part_num;

	list_for_each(dentry, &devices) {
348062b4:	e59fa518 	ldr	sl, [pc, #1304]	; 348067d4 <do_mtdparts+0x5bc>
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
348062b8:	e59f9518 	ldr	r9, [pc, #1304]	; 348067d8 <do_mtdparts+0x5c0>
	struct list_head *dentry, *pentry;
	struct part_info *part;
	struct mtd_device *dev;
	int part_num;

	list_for_each(dentry, &devices) {
348062bc:	e5ba4004 	ldr	r4, [sl, #4]!
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
348062c0:	e59fb514 	ldr	fp, [pc, #1300]	; 348067dc <do_mtdparts+0x5c4>
348062c4:	ea000021 	b	34806350 <do_mtdparts+0x138>
348062c8:	e5943008 	ldr	r3, [r4, #8]
348062cc:	e5d31008 	ldrb	r1, [r3, #8]
			printf("%2d: %-20s0x%08x\t0x%08x%s\t0x%08x\t%d\n",
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
348062d0:	e3510002 	cmp	r1, #2
348062d4:	059f1504 	ldreq	r1, [pc, #1284]	; 348067e0 <do_mtdparts+0x5c8>
348062d8:	0a000002 	beq	348062e8 <do_mtdparts+0xd0>
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
348062dc:	e3510004 	cmp	r1, #4
348062e0:	11a01009 	movne	r1, r9
348062e4:	01a0100b 	moveq	r1, fp
			printf("%2d: %-20s0x%08x\t0x%08x%s\t0x%08x\t%d\n",
					part_num, part->name, part->size,
					net_size, size_note, part->offset,
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
348062e8:	e1d400bc 	ldrh	r0, [r4, #12]
348062ec:	e5d32009 	ldrb	r2, [r3, #9]
348062f0:	e58d0000 	str	r0, [sp]
348062f4:	e5933010 	ldr	r3, [r3, #16]
348062f8:	e59f04e4 	ldr	r0, [pc, #1252]	; 348067e4 <do_mtdparts+0x5cc>
348062fc:	eb000b98 	bl	34809164 <printf>
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
34806300:	e1a06004 	mov	r6, r4
					part->mask_flags);
#else /* !defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");
34806304:	e59f04dc 	ldr	r0, [pc, #1244]	; 348067e8 <do_mtdparts+0x5d0>
34806308:	eb000b95 	bl	34809164 <printf>
	int part_num;

	list_for_each(dentry, &devices) {
		dev = list_entry(dentry, struct mtd_device, link);
		/* list partitions for given device */
		part_num = 0;
3480630c:	e3a07000 	mov	r7, #0
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
34806310:	e5b65010 	ldr	r5, [r6, #16]!
34806314:	ea00000a 	b	34806344 <do_mtdparts+0x12c>
			part = list_entry(pentry, struct part_info, link);
			printf("%2d: %-20s0x%08x\t0x%08x\t%d\n",
34806318:	e5953014 	ldr	r3, [r5, #20]
3480631c:	e1a01007 	mov	r1, r7
34806320:	e58d3000 	str	r3, [sp]
34806324:	e595301c 	ldr	r3, [r5, #28]
34806328:	e59f04bc 	ldr	r0, [pc, #1212]	; 348067ec <do_mtdparts+0x5d4>
3480632c:	e58d3004 	str	r3, [sp, #4]
34806330:	e5952008 	ldr	r2, [r5, #8]
34806334:	e5953010 	ldr	r3, [r5, #16]
34806338:	eb000b89 	bl	34809164 <printf>
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
3480633c:	e5955000 	ldr	r5, [r5]
			part = list_entry(pentry, struct part_info, link);
			printf("%2d: %-20s0x%08x\t0x%08x\t%d\n",
					part_num, part->name, part->size,
					part->offset, part->mask_flags);
#endif /* defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
			part_num++;
34806340:	e2877001 	add	r7, r7, #1
		printf("\ndevice %s%d <%s>, # parts = %d\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num,
				dev->id->mtd_id, dev->num_parts);
		printf(" #: name\t\tsize\t\toffset\t\tmask_flags\n");

		list_for_each(pentry, &dev->parts) {
34806344:	e1550006 	cmp	r5, r6
34806348:	1afffff2 	bne	34806318 <do_mtdparts+0x100>
	struct list_head *dentry, *pentry;
	struct part_info *part;
	struct mtd_device *dev;
	int part_num;

	list_for_each(dentry, &devices) {
3480634c:	e5944000 	ldr	r4, [r4]
34806350:	e154000a 	cmp	r4, sl
34806354:	1affffdb 	bne	348062c8 <do_mtdparts+0xb0>
#endif /* defined(CONFIG_CMD_MTDPARTS_SHOW_NET_SIZES) */
			part_num++;
		}
	}

	if (list_empty(&devices))
34806358:	e59f3474 	ldr	r3, [pc, #1140]	; 348067d4 <do_mtdparts+0x5bc>
3480635c:	e5933004 	ldr	r3, [r3, #4]
34806360:	e1530004 	cmp	r3, r4
34806364:	1a000001 	bne	34806370 <do_mtdparts+0x158>
		printf("no partitions defined\n");
34806368:	e59f0480 	ldr	r0, [pc, #1152]	; 348067f0 <do_mtdparts+0x5d8>
3480636c:	eb000b7c 	bl	34809164 <printf>

	debug("\n---list_partitions---\n");
	print_partition_table();

	/* current_mtd_dev is not NULL only when we have non empty device list */
	if (current_mtd_dev) {
34806370:	e59f445c 	ldr	r4, [pc, #1116]	; 348067d4 <do_mtdparts+0x5bc>
34806374:	e5940000 	ldr	r0, [r4]
34806378:	e3500000 	cmp	r0, #0
3480637c:	0a00001b 	beq	348063f0 <do_mtdparts+0x1d8>
		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
34806380:	e5d4100c 	ldrb	r1, [r4, #12]
34806384:	ebfff973 	bl	34804958 <mtd_part_info>
		if (part) {
34806388:	e3500000 	cmp	r0, #0
3480638c:	0a000015 	beq	348063e8 <do_mtdparts+0x1d0>
			printf("\nactive partition: %s%d,%d - (%s) 0x%08x @ 0x%08x\n",
					MTD_DEV_TYPE(current_mtd_dev->id->type),
34806390:	e5943000 	ldr	r3, [r4]
34806394:	e5933008 	ldr	r3, [r3, #8]
34806398:	e5d32008 	ldrb	r2, [r3, #8]

	/* current_mtd_dev is not NULL only when we have non empty device list */
	if (current_mtd_dev) {
		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
		if (part) {
			printf("\nactive partition: %s%d,%d - (%s) 0x%08x @ 0x%08x\n",
3480639c:	e3520002 	cmp	r2, #2
348063a0:	059f1438 	ldreq	r1, [pc, #1080]	; 348067e0 <do_mtdparts+0x5c8>
348063a4:	0a000003 	beq	348063b8 <do_mtdparts+0x1a0>
					MTD_DEV_TYPE(current_mtd_dev->id->type),
348063a8:	e59fc428 	ldr	ip, [pc, #1064]	; 348067d8 <do_mtdparts+0x5c0>
348063ac:	e3520004 	cmp	r2, #4
348063b0:	e59f1424 	ldr	r1, [pc, #1060]	; 348067dc <do_mtdparts+0x5c4>
348063b4:	11a0100c 	movne	r1, ip

	/* current_mtd_dev is not NULL only when we have non empty device list */
	if (current_mtd_dev) {
		part = mtd_part_info(current_mtd_dev, current_mtd_partnum);
		if (part) {
			printf("\nactive partition: %s%d,%d - (%s) 0x%08x @ 0x%08x\n",
348063b8:	e5d32009 	ldrb	r2, [r3, #9]
348063bc:	e590c008 	ldr	ip, [r0, #8]
348063c0:	e59f340c 	ldr	r3, [pc, #1036]	; 348067d4 <do_mtdparts+0x5bc>
348063c4:	e5d3300c 	ldrb	r3, [r3, #12]
348063c8:	e58dc000 	str	ip, [sp]
348063cc:	e590c010 	ldr	ip, [r0, #16]
348063d0:	e58dc004 	str	ip, [sp, #4]
348063d4:	e5900014 	ldr	r0, [r0, #20]
348063d8:	e58d0008 	str	r0, [sp, #8]
348063dc:	e59f0410 	ldr	r0, [pc, #1040]	; 348067f4 <do_mtdparts+0x5dc>
348063e0:	eb000b5f 	bl	34809164 <printf>
348063e4:	ea000001 	b	348063f0 <do_mtdparts+0x1d8>
					MTD_DEV_TYPE(current_mtd_dev->id->type),
					current_mtd_dev->id->num, current_mtd_partnum,
					part->name, part->size, part->offset);
		} else {
			printf("could not get current partition info\n\n");
348063e8:	e59f0408 	ldr	r0, [pc, #1032]	; 348067f8 <do_mtdparts+0x5e0>
348063ec:	eb000b5c 	bl	34809164 <printf>
		}
	}

	printf("\ndefaults:\n");
348063f0:	e59f0404 	ldr	r0, [pc, #1028]	; 348067fc <do_mtdparts+0x5e4>
348063f4:	eb000b5a 	bl	34809164 <printf>
	printf("mtdids  : %s\n",
348063f8:	e59f13bc 	ldr	r1, [pc, #956]	; 348067bc <do_mtdparts+0x5a4>
348063fc:	e59f03fc 	ldr	r0, [pc, #1020]	; 34806800 <do_mtdparts+0x5e8>
34806400:	eb000b57 	bl	34809164 <printf>
	/*
	 * Using printf() here results in printbuffer overflow
	 * if default mtdparts string is greater than console
	 * printbuffer. Use puts() to prevent system crashes.
	 */
	puts("mtdparts: ");
34806404:	e59f03f8 	ldr	r0, [pc, #1016]	; 34806804 <do_mtdparts+0x5ec>
34806408:	eb000b4b 	bl	3480913c <puts>
	puts(mtdparts_default ? mtdparts_default : "none");
3480640c:	e59f03b0 	ldr	r0, [pc, #944]	; 348067c4 <do_mtdparts+0x5ac>
34806410:	eb000b49 	bl	3480913c <puts>
	puts("\n");
34806414:	e59f03ec 	ldr	r0, [pc, #1004]	; 34806808 <do_mtdparts+0x5f0>
34806418:	eb000b47 	bl	3480913c <puts>
	if (mtdparts_init() != 0)
		return 1;

	if (argc == 1) {
		list_partitions();
		return 0;
3480641c:	e3a00000 	mov	r0, #0
34806420:	ea0000e2 	b	348067b0 <do_mtdparts+0x598>
	}

	/* mtdparts add <mtd-dev> <size>[@<offset>] <name> [ro] */
	if (((argc == 5) || (argc == 6)) && (strncmp(argv[1], "add", 3) == 0)) {
34806424:	e2453005 	sub	r3, r5, #5
34806428:	e3530001 	cmp	r3, #1
3480642c:	8a000090 	bhi	34806674 <do_mtdparts+0x45c>
34806430:	e59f13d4 	ldr	r1, [pc, #980]	; 3480680c <do_mtdparts+0x5f4>
34806434:	e5940004 	ldr	r0, [r4, #4]
34806438:	e3a02003 	mov	r2, #3
3480643c:	eb0055d8 	bl	3481bba4 <strncmp>
34806440:	e2501000 	subs	r1, r0, #0
34806444:	1a0000d8 	bne	348067ac <do_mtdparts+0x594>
		struct mtd_device *dev;
		struct mtd_device *dev_tmp;
		struct mtdids *id;
		struct part_info *p;

		if (mtd_id_parse(argv[2], NULL, &type, &num) != 0)
34806448:	e5940008 	ldr	r0, [r4, #8]
3480644c:	e28d2054 	add	r2, sp, #84	; 0x54
34806450:	e28d305f 	add	r3, sp, #95	; 0x5f
34806454:	ebfffd3e 	bl	34805954 <mtd_id_parse>
34806458:	e3500000 	cmp	r0, #0
3480645c:	1a0000d0 	bne	348067a4 <do_mtdparts+0x58c>
static struct mtdids* id_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtdids *id;

	list_for_each(entry, &mtdids) {
34806460:	e59f336c 	ldr	r3, [pc, #876]	; 348067d4 <do_mtdparts+0x5bc>
		struct part_info *p;

		if (mtd_id_parse(argv[2], NULL, &type, &num) != 0)
			return 1;

		if ((id = id_find(type, num)) == NULL) {
34806464:	e5dd1054 	ldrb	r1, [sp, #84]	; 0x54
34806468:	e5dd205f 	ldrb	r2, [sp, #95]	; 0x5f
static struct mtdids* id_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtdids *id;

	list_for_each(entry, &mtdids) {
3480646c:	e5b35220 	ldr	r5, [r3, #544]!	; 0x220
34806470:	ea000006 	b	34806490 <do_mtdparts+0x278>
		id = list_entry(entry, struct mtdids, link);

		if ((id->type == type) && (id->num == num))
34806474:	e5d50008 	ldrb	r0, [r5, #8]
34806478:	e1500001 	cmp	r0, r1
3480647c:	1a000002 	bne	3480648c <do_mtdparts+0x274>
34806480:	e5d50009 	ldrb	r0, [r5, #9]
34806484:	e1500002 	cmp	r0, r2
34806488:	0a000003 	beq	3480649c <do_mtdparts+0x284>
static struct mtdids* id_find(u8 type, u8 num)
{
	struct list_head *entry;
	struct mtdids *id;

	list_for_each(entry, &mtdids) {
3480648c:	e5955000 	ldr	r5, [r5]
34806490:	e1550003 	cmp	r5, r3
34806494:	1afffff6 	bne	34806474 <do_mtdparts+0x25c>
34806498:	ea00000f 	b	348064dc <do_mtdparts+0x2c4>
		if ((id = id_find(type, num)) == NULL) {
			printf("no such device %s defined in mtdids variable\n", argv[2]);
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
3480649c:	e5950010 	ldr	r0, [r5, #16]
348064a0:	eb0055e7 	bl	3481bc44 <strlen>
348064a4:	e1a07000 	mov	r7, r0
		len += strlen(argv[3]);		/* size@offset */
348064a8:	e594000c 	ldr	r0, [r4, #12]
348064ac:	eb0055e4 	bl	3481bc44 <strlen>
348064b0:	e1a06000 	mov	r6, r0
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
348064b4:	e5940010 	ldr	r0, [r4, #16]
348064b8:	eb0055e1 	bl	3481bc44 <strlen>
			printf("no such device %s defined in mtdids variable\n", argv[2]);
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
		len += strlen(argv[3]);		/* size@offset */
348064bc:	e0876006 	add	r6, r7, r6
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
348064c0:	e2866003 	add	r6, r6, #3
348064c4:	e6e06076 	uxtab	r6, r0, r6
		if (argv[5] && (strlen(argv[5]) == 2))
348064c8:	e5940014 	ldr	r0, [r4, #20]
			return 1;
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
		len += strlen(argv[3]);		/* size@offset */
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
348064cc:	e6ef6076 	uxtb	r6, r6
		if (argv[5] && (strlen(argv[5]) == 2))
348064d0:	e3500000 	cmp	r0, #0
348064d4:	1a000003 	bne	348064e8 <do_mtdparts+0x2d0>
348064d8:	ea000006 	b	348064f8 <do_mtdparts+0x2e0>

		if (mtd_id_parse(argv[2], NULL, &type, &num) != 0)
			return 1;

		if ((id = id_find(type, num)) == NULL) {
			printf("no such device %s defined in mtdids variable\n", argv[2]);
348064dc:	e59f032c 	ldr	r0, [pc, #812]	; 34806810 <do_mtdparts+0x5f8>
348064e0:	e5941008 	ldr	r1, [r4, #8]
348064e4:	ea0000ad 	b	348067a0 <do_mtdparts+0x588>
		}

		len = strlen(id->mtd_id) + 1;	/* 'mtd_id:' */
		len += strlen(argv[3]);		/* size@offset */
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
		if (argv[5] && (strlen(argv[5]) == 2))
348064e8:	eb0055d5 	bl	3481bc44 <strlen>
348064ec:	e3500002 	cmp	r0, #2
			len += 2;		/* 'ro' */
348064f0:	02866002 	addeq	r6, r6, #2
348064f4:	06ef6076 	uxtbeq	r6, r6

		if (len >= PART_ADD_DESC_MAXLEN) {
348064f8:	e356003f 	cmp	r6, #63	; 0x3f
			printf("too long partition description\n");
348064fc:	859f0310 	ldrhi	r0, [pc, #784]	; 34806814 <do_mtdparts+0x5fc>
		len += strlen(argv[3]);		/* size@offset */
		len += strlen(argv[4]) + 2;	/* '(' name ')' */
		if (argv[5] && (strlen(argv[5]) == 2))
			len += 2;		/* 'ro' */

		if (len >= PART_ADD_DESC_MAXLEN) {
34806500:	8a0000a2 	bhi	34806790 <do_mtdparts+0x578>
			printf("too long partition description\n");
			return 1;
		}
		sprintf(tmpbuf, "%s:%s(%s)%s",
				id->mtd_id, argv[3], argv[4], argv[5] ? argv[5] : "");
34806504:	e5941014 	ldr	r1, [r4, #20]

		if (len >= PART_ADD_DESC_MAXLEN) {
			printf("too long partition description\n");
			return 1;
		}
		sprintf(tmpbuf, "%s:%s(%s)%s",
34806508:	e59fc308 	ldr	ip, [pc, #776]	; 34806818 <do_mtdparts+0x600>
3480650c:	e5940010 	ldr	r0, [r4, #16]
34806510:	e3510000 	cmp	r1, #0
34806514:	e594300c 	ldr	r3, [r4, #12]
34806518:	01a0100c 	moveq	r1, ip
3480651c:	e28d4014 	add	r4, sp, #20
34806520:	e5952010 	ldr	r2, [r5, #16]
34806524:	e88d0003 	stm	sp, {r0, r1}
34806528:	e1a00004 	mov	r0, r4
3480652c:	e59f12e8 	ldr	r1, [pc, #744]	; 3480681c <do_mtdparts+0x604>
34806530:	eb0059fc 	bl	3481cd28 <sprintf>
				id->mtd_id, argv[3], argv[4], argv[5] ? argv[5] : "");
		debug("add tmpbuf: %s\n", tmpbuf);

		if ((device_parse(tmpbuf, NULL, &dev) != 0) || (!dev))
34806534:	e1a00004 	mov	r0, r4
34806538:	e3a01000 	mov	r1, #0
3480653c:	e28d2058 	add	r2, sp, #88	; 0x58
34806540:	ebfffbad 	bl	348053fc <device_parse>
34806544:	e3500000 	cmp	r0, #0
34806548:	1a000095 	bne	348067a4 <do_mtdparts+0x58c>
3480654c:	e59d5058 	ldr	r5, [sp, #88]	; 0x58
34806550:	e3550000 	cmp	r5, #0
34806554:	0a000092 	beq	348067a4 <do_mtdparts+0x58c>
			spread_partition(mtd, p, &next_offset);
			debug("increased %s to %d bytes\n", p->name, p->size);
		}
#endif

		dev_tmp = device_find(dev->id->type, dev->id->num);
34806558:	e5953008 	ldr	r3, [r5, #8]
			return 1;

		debug("+ %s\t%d\t%s\n", MTD_DEV_TYPE(dev->id->type),
				dev->id->num, dev->id->mtd_id);

		p = list_entry(dev->parts.next, struct part_info, link);
3480655c:	e5954010 	ldr	r4, [r5, #16]
			spread_partition(mtd, p, &next_offset);
			debug("increased %s to %d bytes\n", p->name, p->size);
		}
#endif

		dev_tmp = device_find(dev->id->type, dev->id->num);
34806560:	e5d30008 	ldrb	r0, [r3, #8]
34806564:	e5d31009 	ldrb	r1, [r3, #9]
34806568:	ebfffb90 	bl	348053b0 <device_find>
		if (dev_tmp == NULL) {
3480656c:	e2506000 	subs	r6, r0, #0
34806570:	1a00000e 	bne	348065b0 <do_mtdparts+0x398>
34806574:	e59f3258 	ldr	r3, [pc, #600]	; 348067d4 <do_mtdparts+0x5bc>
 */
static void device_add(struct mtd_device *dev)
{
	u8 current_save_needed = 0;

	if (list_empty(&devices)) {
34806578:	e5931004 	ldr	r1, [r3, #4]
3480657c:	e2832004 	add	r2, r3, #4
34806580:	e1510002 	cmp	r1, r2
		current_mtd_dev = dev;
		current_mtd_partnum = 0;
34806584:	05c3600c 	strbeq	r6, [r3, #12]
static void device_add(struct mtd_device *dev)
{
	u8 current_save_needed = 0;

	if (list_empty(&devices)) {
		current_mtd_dev = dev;
34806588:	05835000 	streq	r5, [r3]
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
3480658c:	e59f3240 	ldr	r3, [pc, #576]	; 348067d4 <do_mtdparts+0x5bc>
		current_mtd_partnum = 0;
		current_save_needed = 1;
34806590:	03a06001 	moveq	r6, #1
34806594:	e5932008 	ldr	r2, [r3, #8]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34806598:	e5835008 	str	r5, [r3, #8]
	new->next = next;
3480659c:	e2833004 	add	r3, r3, #4
348065a0:	e5853000 	str	r3, [r5]
	new->prev = prev;
348065a4:	e5852004 	str	r2, [r5, #4]
	prev->next = new;
348065a8:	e5825000 	str	r5, [r2]
348065ac:	ea00006e 	b	3480676c <do_mtdparts+0x554>
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
348065b0:	e5943010 	ldr	r3, [r4, #16]
 * @return 0 on success, 1 otherwise
 */
static int part_add(struct mtd_device *dev, struct part_info *part)
{
	/* verify alignment and size */
	if (part_validate(dev->id, part) != 0)
348065b4:	e596c008 	ldr	ip, [r6, #8]
 * @param part partition to validate
 * @return 0 if partition is valid, 1 otherwise
 */
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
348065b8:	e3730001 	cmn	r3, #1
		part->size = id->size - part->offset;
348065bc:	059c200c 	ldreq	r2, [ip, #12]
348065c0:	05943014 	ldreq	r3, [r4, #20]
348065c4:	00633002 	rsbeq	r3, r3, r2
348065c8:	05843010 	streq	r3, [r4, #16]

	if (part->offset > id->size) {
348065cc:	e5942014 	ldr	r2, [r4, #20]
348065d0:	e59c300c 	ldr	r3, [ip, #12]
348065d4:	e1520003 	cmp	r2, r3
		printf("%s: offset %08x beyond flash size %08x\n",
348065d8:	859f0240 	ldrhi	r0, [pc, #576]	; 34806820 <do_mtdparts+0x608>
348065dc:	859c1010 	ldrhi	r1, [ip, #16]
static int part_validate(struct mtdids *id, struct part_info *part)
{
	if (part->size == SIZE_REMAINING)
		part->size = id->size - part->offset;

	if (part->offset > id->size) {
348065e0:	8a00000e 	bhi	34806620 <do_mtdparts+0x408>
		printf("%s: offset %08x beyond flash size %08x\n",
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
348065e4:	e5941010 	ldr	r1, [r4, #16]
348065e8:	e0821001 	add	r1, r2, r1
348065ec:	e1510002 	cmp	r1, r2
348065f0:	8a00000c 	bhi	34806628 <do_mtdparts+0x410>
		printf("%s%d: partition (%s) size too big\n",
				MTD_DEV_TYPE(id->type), id->num, part->name);
348065f4:	e5dc3008 	ldrb	r3, [ip, #8]
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
348065f8:	e3530002 	cmp	r3, #2
348065fc:	059f11dc 	ldreq	r1, [pc, #476]	; 348067e0 <do_mtdparts+0x5c8>
34806600:	0a000003 	beq	34806614 <do_mtdparts+0x3fc>
				MTD_DEV_TYPE(id->type), id->num, part->name);
34806604:	e59f21d0 	ldr	r2, [pc, #464]	; 348067dc <do_mtdparts+0x5c4>
34806608:	e3530004 	cmp	r3, #4
3480660c:	e59f11c4 	ldr	r1, [pc, #452]	; 348067d8 <do_mtdparts+0x5c0>
34806610:	01a01002 	moveq	r1, r2
				id->mtd_id, part->offset, id->size);
		return 1;
	}

	if ((part->offset + part->size) <= part->offset) {
		printf("%s%d: partition (%s) size too big\n",
34806614:	e59f0208 	ldr	r0, [pc, #520]	; 34806824 <do_mtdparts+0x60c>
34806618:	e5dc2009 	ldrb	r2, [ip, #9]
3480661c:	e5943008 	ldr	r3, [r4, #8]
34806620:	eb000acf 	bl	34809164 <printf>
34806624:	ea00000f 	b	34806668 <do_mtdparts+0x450>
				MTD_DEV_TYPE(id->type), id->num, part->name);
		return 1;
	}

	if (part->offset + part->size > id->size) {
34806628:	e1510003 	cmp	r1, r3
3480662c:	9a000003 	bls	34806640 <do_mtdparts+0x428>
		printf("%s: partitioning exceeds flash size\n", id->mtd_id);
34806630:	e59c1010 	ldr	r1, [ip, #16]
34806634:	e59f01ec 	ldr	r0, [pc, #492]	; 34806828 <do_mtdparts+0x610>
34806638:	eb000ac9 	bl	34809164 <printf>
3480663c:	ea000009 	b	34806668 <do_mtdparts+0x450>

	/*
	 * Now we need to check if the partition starts and ends on
	 * sector (eraseblock) regions
	 */
	return part_validate_eraseblock(id, part);
34806640:	e1a0000c 	mov	r0, ip
34806644:	e1a01004 	mov	r1, r4
34806648:	ebfffa09 	bl	34804e74 <part_validate_eraseblock>
 * @return 0 on success, 1 otherwise
 */
static int part_add(struct mtd_device *dev, struct part_info *part)
{
	/* verify alignment and size */
	if (part_validate(dev->id, part) != 0)
3480664c:	e3500000 	cmp	r0, #0
34806650:	1a000004 	bne	34806668 <do_mtdparts+0x450>
		return 1;

	/* partition is ok, add it to the list */
	if (part_sort_add(dev, part) != 0)
34806654:	e1a00006 	mov	r0, r6
34806658:	e1a01004 	mov	r1, r4
3480665c:	ebfff952 	bl	34804bac <part_sort_add>
34806660:	e3500000 	cmp	r0, #0
34806664:	0a000045 	beq	34806780 <do_mtdparts+0x568>
		dev_tmp = device_find(dev->id->type, dev->id->num);
		if (dev_tmp == NULL) {
			device_add(dev);
		} else if (part_add(dev_tmp, p) != 0) {
			/* merge new partition with existing ones*/
			device_del(dev);
34806668:	e59d0058 	ldr	r0, [sp, #88]	; 0x58
3480666c:	ebfff9aa 	bl	34804d1c <device_del>
34806670:	ea00004b 	b	348067a4 <do_mtdparts+0x58c>

		return 0;
	}

	/* mtdparts del part-id */
	if ((argc == 3) && (strcmp(argv[1], "del") == 0)) {
34806674:	e3550003 	cmp	r5, #3
34806678:	1a00004b 	bne	348067ac <do_mtdparts+0x594>
3480667c:	e5940004 	ldr	r0, [r4, #4]
34806680:	e59f11a4 	ldr	r1, [pc, #420]	; 3480682c <do_mtdparts+0x614>
34806684:	eb00553a 	bl	3481bb74 <strcmp>
34806688:	e3500000 	cmp	r0, #0
3480668c:	1a000046 	bne	348067ac <do_mtdparts+0x594>
		debug("del: part-id = %s\n", argv[2]);

		return delete_partition(argv[2]);
34806690:	e5944008 	ldr	r4, [r4, #8]
{
	u8 pnum;
	struct mtd_device *dev;
	struct part_info *part;

	if (find_dev_and_part(id, &dev, &pnum, &part) == 0) {
34806694:	e28d1058 	add	r1, sp, #88	; 0x58
34806698:	e1a00004 	mov	r0, r4
3480669c:	e28d205f 	add	r2, sp, #95	; 0x5f
348066a0:	e28d3054 	add	r3, sp, #84	; 0x54
348066a4:	ebfffcee 	bl	34805a64 <find_dev_and_part>
348066a8:	e2506000 	subs	r6, r0, #0
348066ac:	1a000039 	bne	34806798 <do_mtdparts+0x580>

		debug("delete_partition: device = %s%d, partition %d = (%s) 0x%08x@0x%08x\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum,
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
348066b0:	e59d5058 	ldr	r5, [sp, #88]	; 0x58
348066b4:	e59d4054 	ldr	r4, [sp, #84]	; 0x54
static int part_del(struct mtd_device *dev, struct part_info *part)
{
	u8 current_save_needed = 0;

	/* if there is only one partition, remove whole device */
	if (dev->num_parts == 1)
348066b8:	e1d570bc 	ldrh	r7, [r5, #12]
348066bc:	e3570001 	cmp	r7, #1
348066c0:	1a000005 	bne	348066dc <do_mtdparts+0x4c4>
		return device_del(dev);
348066c4:	e1a00005 	mov	r0, r5
348066c8:	ebfff993 	bl	34804d1c <device_del>

		debug("delete_partition: device = %s%d, partition %d = (%s) 0x%08x@0x%08x\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum,
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
348066cc:	e3500000 	cmp	r0, #0
			return 1;
348066d0:	11a00007 	movne	r0, r7

		debug("delete_partition: device = %s%d, partition %d = (%s) 0x%08x@0x%08x\n",
				MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum,
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
348066d4:	1a000035 	bne	348067b0 <do_mtdparts+0x598>
348066d8:	ea000028 	b	34806780 <do_mtdparts+0x568>
	if (dev->num_parts == 1)
		return device_del(dev);

	/* otherwise just delete this partition */

	if (dev == current_mtd_dev) {
348066dc:	e59f30f0 	ldr	r3, [pc, #240]	; 348067d4 <do_mtdparts+0x5bc>
348066e0:	e5932000 	ldr	r2, [r3]
348066e4:	e1550002 	cmp	r5, r2
348066e8:	1a000014 	bne	34806740 <do_mtdparts+0x528>
		/* we are modyfing partitions for the current device,
		 * update current */
		struct part_info *curr_pi;
		curr_pi = mtd_part_info(current_mtd_dev, current_mtd_partnum);
348066ec:	e1a00005 	mov	r0, r5
348066f0:	e5d3100c 	ldrb	r1, [r3, #12]
348066f4:	ebfff897 	bl	34804958 <mtd_part_info>

		if (curr_pi) {
348066f8:	e2506000 	subs	r6, r0, #0
348066fc:	0a00000f 	beq	34806740 <do_mtdparts+0x528>
			if (curr_pi == part) {
34806700:	e1560004 	cmp	r6, r4
34806704:	1a000004 	bne	3480671c <do_mtdparts+0x504>
				printf("current partition deleted, resetting current to 0\n");
34806708:	e59f0120 	ldr	r0, [pc, #288]	; 34806830 <do_mtdparts+0x618>
3480670c:	eb000a94 	bl	34809164 <printf>
				current_mtd_partnum = 0;
34806710:	e3a02000 	mov	r2, #0
34806714:	e59f30b8 	ldr	r3, [pc, #184]	; 348067d4 <do_mtdparts+0x5bc>
34806718:	ea000006 	b	34806738 <do_mtdparts+0x520>
			} else if (part->offset <= curr_pi->offset) {
3480671c:	e5942014 	ldr	r2, [r4, #20]
34806720:	e5963014 	ldr	r3, [r6, #20]
34806724:	e1520003 	cmp	r2, r3
34806728:	8a000003 	bhi	3480673c <do_mtdparts+0x524>
				current_mtd_partnum--;
3480672c:	e59f30a0 	ldr	r3, [pc, #160]	; 348067d4 <do_mtdparts+0x5bc>
34806730:	e5d3200c 	ldrb	r2, [r3, #12]
34806734:	e2422001 	sub	r2, r2, #1
34806738:	e5c3200c 	strb	r2, [r3, #12]
			}
			current_save_needed = 1;
3480673c:	e3a06001 	mov	r6, #1
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34806740:	e894000c 	ldm	r4, {r2, r3}
		}
	}

	list_del(&part->link);
	free(part);
34806744:	e1a00004 	mov	r0, r4
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34806748:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
3480674c:	e5832000 	str	r2, [r3]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
34806750:	e3a03000 	mov	r3, #0
34806754:	e5843000 	str	r3, [r4]
	entry->prev = LIST_POISON2;
34806758:	e5843004 	str	r3, [r4, #4]
3480675c:	eb000bbe 	bl	3480965c <free>
	dev->num_parts--;
34806760:	e1d530bc 	ldrh	r3, [r5, #12]
34806764:	e2433001 	sub	r3, r3, #1
34806768:	e1c530bc 	strh	r3, [r5, #12]

	if (current_save_needed > 0)
3480676c:	e3560000 	cmp	r6, #0
34806770:	0a000001 	beq	3480677c <do_mtdparts+0x564>
		current_save();
34806774:	ebfff8e0 	bl	34804afc <current_save>
34806778:	ea000000 	b	34806780 <do_mtdparts+0x568>
	else
		index_partitions();
3480677c:	ebfff89a 	bl	348049ec <index_partitions>
				part->name, part->size, part->offset);

		if (part_del(dev, part) != 0)
			return 1;

		if (generate_mtdparts_save(last_parts, MTDPARTS_MAXLEN) != 0) {
34806780:	ebfffa4d 	bl	348050bc <generate_mtdparts_save.clone.1>
34806784:	e3500000 	cmp	r0, #0
34806788:	0a000008 	beq	348067b0 <do_mtdparts+0x598>
			printf("generated mtdparts too long, reseting to null\n");
3480678c:	e59f00a0 	ldr	r0, [pc, #160]	; 34806834 <do_mtdparts+0x61c>
34806790:	eb000a73 	bl	34809164 <printf>
34806794:	ea000002 	b	348067a4 <do_mtdparts+0x58c>
			return 1;
		}
		return 0;
	}

	printf("partition %s not found\n", id);
34806798:	e59f0098 	ldr	r0, [pc, #152]	; 34806838 <do_mtdparts+0x620>
3480679c:	e1a01004 	mov	r1, r4
348067a0:	eb000a6f 	bl	34809164 <printf>
		sprintf(tmpbuf, "%s:%s(%s)%s",
				id->mtd_id, argv[3], argv[4], argv[5] ? argv[5] : "");
		debug("add tmpbuf: %s\n", tmpbuf);

		if ((device_parse(tmpbuf, NULL, &dev) != 0) || (!dev))
			return 1;
348067a4:	e3a00001 	mov	r0, #1
348067a8:	ea000000 	b	348067b0 <do_mtdparts+0x598>
#if defined(CONFIG_CMD_MTDPARTS_SPREAD)
	if ((argc == 2) && (strcmp(argv[1], "spread") == 0))
		return spread_partitions();
#endif /* CONFIG_CMD_MTDPARTS_SPREAD */

	return CMD_RET_USAGE;
348067ac:	e3e00000 	mvn	r0, #0
}
348067b0:	e28dd060 	add	sp, sp, #96	; 0x60
348067b4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348067b8:	348248ea 	.word	0x348248ea
348067bc:	34824740 	.word	0x34824740
348067c0:	34824759 	.word	0x34824759
348067c4:	3482019c 	.word	0x3482019c
348067c8:	348244cf 	.word	0x348244cf
348067cc:	34824b1a 	.word	0x34824b1a
348067d0:	348248f2 	.word	0x348248f2
348067d4:	34829aac 	.word	0x34829aac
348067d8:	34824383 	.word	0x34824383
348067dc:	34824751 	.word	0x34824751
348067e0:	34824754 	.word	0x34824754
348067e4:	348248f9 	.word	0x348248f9
348067e8:	3482491a 	.word	0x3482491a
348067ec:	3482493e 	.word	0x3482493e
348067f0:	3482495a 	.word	0x3482495a
348067f4:	34824971 	.word	0x34824971
348067f8:	348249a4 	.word	0x348249a4
348067fc:	348249cb 	.word	0x348249cb
34806800:	348249d7 	.word	0x348249d7
34806804:	348249e5 	.word	0x348249e5
34806808:	34826214 	.word	0x34826214
3480680c:	348249f0 	.word	0x348249f0
34806810:	348249f4 	.word	0x348249f4
34806814:	34824a22 	.word	0x34824a22
34806818:	34823cce 	.word	0x34823cce
3480681c:	34824a42 	.word	0x34824a42
34806820:	348245d5 	.word	0x348245d5
34806824:	348245fd 	.word	0x348245fd
34806828:	34824620 	.word	0x34824620
3480682c:	34824a7d 	.word	0x34824a7d
34806830:	34824a81 	.word	0x34824a81
34806834:	34824a4e 	.word	0x34824a4e
34806838:	34824ab4 	.word	0x34824ab4

3480683c <do_chpart>:
 * @param argc number of arguments supplied to the command
 * @param argv arguments list
 * @return 0 on success, 1 otherwise
 */
int do_chpart(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480683c:	e92d4030 	push	{r4, r5, lr}
34806840:	e24dd014 	sub	sp, sp, #20
34806844:	e1a04002 	mov	r4, r2
34806848:	e1a05003 	mov	r5, r3
/* command line only */
	struct mtd_device *dev;
	struct part_info *part;
	u8 pnum;

	if (mtdparts_init() !=0)
3480684c:	ebfffcf2 	bl	34805c1c <mtdparts_init>
34806850:	e3500000 	cmp	r0, #0
34806854:	1a000021 	bne	348068e0 <do_chpart+0xa4>
		return 1;

	if (argc < 2) {
34806858:	e3540001 	cmp	r4, #1
3480685c:	ca000002 	bgt	3480686c <do_chpart+0x30>
		printf("no partition id specified\n");
34806860:	e59f0084 	ldr	r0, [pc, #132]	; 348068ec <do_chpart+0xb0>
34806864:	eb000a3e 	bl	34809164 <printf>
34806868:	ea00001c 	b	348068e0 <do_chpart+0xa4>
		return 1;
	}

	if (find_dev_and_part(argv[1], &dev, &pnum, &part) != 0)
3480686c:	e5950004 	ldr	r0, [r5, #4]
34806870:	e28d1008 	add	r1, sp, #8
34806874:	e28d200f 	add	r2, sp, #15
34806878:	e28d3004 	add	r3, sp, #4
3480687c:	ebfffc78 	bl	34805a64 <find_dev_and_part>
34806880:	e3500000 	cmp	r0, #0
34806884:	1a000015 	bne	348068e0 <do_chpart+0xa4>
		return 1;

	current_mtd_dev = dev;
34806888:	e59f3060 	ldr	r3, [pc, #96]	; 348068f0 <do_chpart+0xb4>
3480688c:	e59d2008 	ldr	r2, [sp, #8]
34806890:	e5832000 	str	r2, [r3]
	current_mtd_partnum = pnum;
34806894:	e5dd200f 	ldrb	r2, [sp, #15]
34806898:	e5c3200c 	strb	r2, [r3, #12]
	current_save();
3480689c:	ebfff896 	bl	34804afc <current_save>

	printf("partition changed to %s%d,%d\n",
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);
348068a0:	e59d3008 	ldr	r3, [sp, #8]
348068a4:	e5933008 	ldr	r3, [r3, #8]
348068a8:	e5d32008 	ldrb	r2, [r3, #8]

	current_mtd_dev = dev;
	current_mtd_partnum = pnum;
	current_save();

	printf("partition changed to %s%d,%d\n",
348068ac:	e3520002 	cmp	r2, #2
348068b0:	059f103c 	ldreq	r1, [pc, #60]	; 348068f4 <do_chpart+0xb8>
348068b4:	0a000003 	beq	348068c8 <do_chpart+0x8c>
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);
348068b8:	e59f0038 	ldr	r0, [pc, #56]	; 348068f8 <do_chpart+0xbc>
348068bc:	e3520004 	cmp	r2, #4
348068c0:	e59f1034 	ldr	r1, [pc, #52]	; 348068fc <do_chpart+0xc0>
348068c4:	11a01000 	movne	r1, r0

	current_mtd_dev = dev;
	current_mtd_partnum = pnum;
	current_save();

	printf("partition changed to %s%d,%d\n",
348068c8:	e5d32009 	ldrb	r2, [r3, #9]
348068cc:	e59f002c 	ldr	r0, [pc, #44]	; 34806900 <do_chpart+0xc4>
348068d0:	e5dd300f 	ldrb	r3, [sp, #15]
348068d4:	eb000a22 	bl	34809164 <printf>
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);

	return 0;
348068d8:	e3a00000 	mov	r0, #0
348068dc:	ea000000 	b	348068e4 <do_chpart+0xa8>
		printf("no partition id specified\n");
		return 1;
	}

	if (find_dev_and_part(argv[1], &dev, &pnum, &part) != 0)
		return 1;
348068e0:	e3a00001 	mov	r0, #1

	printf("partition changed to %s%d,%d\n",
			MTD_DEV_TYPE(dev->id->type), dev->id->num, pnum);

	return 0;
}
348068e4:	e28dd014 	add	sp, sp, #20
348068e8:	e8bd8030 	pop	{r4, r5, pc}
348068ec:	34824acc 	.word	0x34824acc
348068f0:	34829aac 	.word	0x34829aac
348068f4:	34824754 	.word	0x34824754
348068f8:	34824383 	.word	0x34824383
348068fc:	34824751 	.word	0x34824751
34806900:	34824ae7 	.word	0x34824ae7

34806904 <do_env>:

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *cp;

	if (argc < 2)
34806904:	e3520001 	cmp	r2, #1
	fixup_cmdtable(cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
}
#endif

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34806908:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3480690c:	e1a05000 	mov	r5, r0
34806910:	e1a06001 	mov	r6, r1
34806914:	e1a04002 	mov	r4, r2
	cmd_tbl_t *cp;

	if (argc < 2)
		return CMD_RET_USAGE;
34806918:	d3e00000 	mvnle	r0, #0

static int do_env(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *cp;

	if (argc < 2)
3480691c:	d8bd80f8 	pople	{r3, r4, r5, r6, r7, pc}

	/* drop initial "env" arg */
	argc--;
	argv++;

	cp = find_cmd_tbl(argv[0], cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
34806920:	e5930004 	ldr	r0, [r3, #4]
34806924:	e59f1034 	ldr	r1, [pc, #52]	; 34806960 <do_env+0x5c>
34806928:	e3a02009 	mov	r2, #9
	if (argc < 2)
		return CMD_RET_USAGE;

	/* drop initial "env" arg */
	argc--;
	argv++;
3480692c:	e2837004 	add	r7, r3, #4

	cp = find_cmd_tbl(argv[0], cmd_env_sub, ARRAY_SIZE(cmd_env_sub));
34806930:	eb000883 	bl	34808b44 <find_cmd_tbl>

	if (cp)
34806934:	e3500000 	cmp	r0, #0
34806938:	0a000006 	beq	34806958 <do_env+0x54>
		return cp->cmd(cmdtp, flag, argc, argv);
3480693c:	e590c00c 	ldr	ip, [r0, #12]
34806940:	e1a01006 	mov	r1, r6
34806944:	e1a00005 	mov	r0, r5
34806948:	e2442001 	sub	r2, r4, #1
3480694c:	e1a03007 	mov	r3, r7
34806950:	e12fff3c 	blx	ip
34806954:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

	return CMD_RET_USAGE;
34806958:	e3e00000 	mvn	r0, #0
}
3480695c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34806960:	348283d8 	.word	0x348283d8

34806964 <do_env_delete>:
	return cmd_usage(cmdtp);
}

static int do_env_delete(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
34806964:	e92d4008 	push	{r3, lr}
	printf("Not implemented yet\n");
34806968:	e59f0008 	ldr	r0, [pc, #8]	; 34806978 <do_env_delete+0x14>
3480696c:	eb0009fc 	bl	34809164 <printf>
	return 0;
}
34806970:	e3a00000 	mov	r0, #0
34806974:	e8bd8008 	pop	{r3, pc}
34806978:	34825053 	.word	0x34825053

3480697c <do_env_import>:
 *	size:	length of input data; if missing, proper '\0'
 *		termination is mandatory
 */
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
3480697c:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	char	*cmd, *addr;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;
	int	del = 0;
34806980:	e3a0a000 	mov	sl, #0
 *	size:	length of input data; if missing, proper '\0'
 *		termination is mandatory
 */
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
34806984:	e1a04002 	mov	r4, r2
34806988:	e24dd01c 	sub	sp, sp, #28
	int	chk = 0;
	int	fmt = 0;
	int	del = 0;
	size_t	size;

	cmd = *argv;
3480698c:	e4931004 	ldr	r1, [r3], #4
			 int argc, char * const argv[])
{
	char	*cmd, *addr;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;
34806990:	e1a0200a 	mov	r2, sl
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	char	*cmd, *addr;
	char	sep = '\n';
	int	chk = 0;
34806994:	e1a0900a 	mov	r9, sl
 */
static int do_env_import(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	char	*cmd, *addr;
	char	sep = '\n';
34806998:	e3a0700a 	mov	r7, #10
	int	del = 0;
	size_t	size;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
3480699c:	ea00001d 	b	34806a18 <do_env_import+0x9c>
		char *arg = *argv;
		while (*++arg) {
			switch (*arg) {
348069a0:	e3500063 	cmp	r0, #99	; 0x63
348069a4:	0a00000c 	beq	348069dc <do_env_import+0x60>
348069a8:	8a000002 	bhi	348069b8 <do_env_import+0x3c>
348069ac:	e3500062 	cmp	r0, #98	; 0x62
348069b0:	1a000077 	bne	34806b94 <do_env_import+0x218>
348069b4:	ea000004 	b	348069cc <do_env_import+0x50>
348069b8:	e3500064 	cmp	r0, #100	; 0x64
348069bc:	0a000011 	beq	34806a08 <do_env_import+0x8c>
348069c0:	e3500074 	cmp	r0, #116	; 0x74
348069c4:	1a000072 	bne	34806b94 <do_env_import+0x218>
348069c8:	ea000009 	b	348069f4 <do_env_import+0x78>
			case 'b':		/* raw binary format */
				if (fmt++)
348069cc:	e3520000 	cmp	r2, #0
348069d0:	1a00006b 	bne	34806b84 <do_env_import+0x208>
348069d4:	e2822001 	add	r2, r2, #1
348069d8:	ea000003 	b	348069ec <do_env_import+0x70>
					goto sep_err;
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
348069dc:	e3520000 	cmp	r2, #0
348069e0:	1a000067 	bne	34806b84 <do_env_import+0x208>
348069e4:	e2822001 	add	r2, r2, #1
					goto sep_err;
				sep = '\0';
				chk = 1;
348069e8:	e1a09002 	mov	r9, r2
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
					goto sep_err;
				sep = '\0';
348069ec:	e3a07000 	mov	r7, #0
348069f0:	ea000005 	b	34806a0c <do_env_import+0x90>
				chk = 1;
				break;
			case 't':		/* text format */
				if (fmt++)
348069f4:	e3520000 	cmp	r2, #0
348069f8:	1a000061 	bne	34806b84 <do_env_import+0x208>
348069fc:	e2822001 	add	r2, r2, #1
					goto sep_err;
				sep = '\n';
34806a00:	e3a0700a 	mov	r7, #10
34806a04:	ea000000 	b	34806a0c <do_env_import+0x90>
				break;
			case 'd':
				del = 1;
34806a08:	e3a0a001 	mov	sl, #1

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;
		while (*++arg) {
34806a0c:	e5fc0001 	ldrb	r0, [ip, #1]!
34806a10:	e3500000 	cmp	r0, #0
34806a14:	1affffe1 	bne	348069a0 <do_env_import+0x24>
	int	del = 0;
	size_t	size;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
34806a18:	e2444001 	sub	r4, r4, #1
34806a1c:	e3540000 	cmp	r4, #0
34806a20:	da00005b 	ble	34806b94 <do_env_import+0x218>
34806a24:	e1a05003 	mov	r5, r3
34806a28:	e493c004 	ldr	ip, [r3], #4
34806a2c:	e5dc0000 	ldrb	r0, [ip]
34806a30:	e350002d 	cmp	r0, #45	; 0x2d
34806a34:	0afffff4 	beq	34806a0c <do_env_import+0x90>
34806a38:	ea000058 	b	34806ba0 <do_env_import+0x224>

	if (argc < 1)
		return CMD_RET_USAGE;

	if (!fmt)
		printf("## Warning: defaulting to text format\n");
34806a3c:	e59f0168 	ldr	r0, [pc, #360]	; 34806bac <do_env_import+0x230>
34806a40:	eb0009c7 	bl	34809164 <printf>

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
34806a44:	e3a02010 	mov	r2, #16
34806a48:	e5950000 	ldr	r0, [r5]
34806a4c:	e3a01000 	mov	r1, #0
34806a50:	eb00580e 	bl	3481ca90 <simple_strtoul>

	if (argc == 2) {
34806a54:	e3540002 	cmp	r4, #2
		return CMD_RET_USAGE;

	if (!fmt)
		printf("## Warning: defaulting to text format\n");

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
34806a58:	e1a06000 	mov	r6, r0

	if (argc == 2) {
34806a5c:	11a02000 	movne	r2, r0
34806a60:	13a03000 	movne	r3, #0
34806a64:	1a000006 	bne	34806a84 <do_env_import+0x108>
		size = simple_strtoul(argv[1], NULL, 16);
34806a68:	e5950004 	ldr	r0, [r5, #4]
34806a6c:	e3a01000 	mov	r1, #0
34806a70:	e3a02010 	mov	r2, #16
34806a74:	eb005805 	bl	3481ca90 <simple_strtoul>
34806a78:	e1a05000 	mov	r5, r0
34806a7c:	ea000013 	b	34806ad0 <do_env_import+0x154>
	} else {
		char *s = addr;

		size = 0;

		while (size < MAX_ENV_SIZE) {
34806a80:	e1a03005 	mov	r3, r5
			if ((*s == sep) && (*(s+1) == '\0'))
34806a84:	e4d21001 	ldrb	r1, [r2], #1
34806a88:	e2835001 	add	r5, r3, #1
34806a8c:	e1510007 	cmp	r1, r7
34806a90:	1a000002 	bne	34806aa0 <do_env_import+0x124>
34806a94:	e7d61005 	ldrb	r1, [r6, r5]
34806a98:	e3510000 	cmp	r1, #0
34806a9c:	0a000005 	beq	34806ab8 <do_env_import+0x13c>
	} else {
		char *s = addr;

		size = 0;

		while (size < MAX_ENV_SIZE) {
34806aa0:	e3550601 	cmp	r5, #1048576	; 0x100000
34806aa4:	1afffff5 	bne	34806a80 <do_env_import+0x104>
				break;
			++s;
			++size;
		}
		if (size == MAX_ENV_SIZE) {
			printf("## Warning: Input data exceeds %d bytes"
34806aa8:	e1a01005 	mov	r1, r5
34806aac:	e59f00fc 	ldr	r0, [pc, #252]	; 34806bb0 <do_env_import+0x234>
34806ab0:	eb0009ab 	bl	34809164 <printf>
34806ab4:	ea000000 	b	34806abc <do_env_import+0x140>
		char *s = addr;

		size = 0;

		while (size < MAX_ENV_SIZE) {
			if ((*s == sep) && (*(s+1) == '\0'))
34806ab8:	e1a05003 	mov	r5, r3
		}
		if (size == MAX_ENV_SIZE) {
			printf("## Warning: Input data exceeds %d bytes"
				" - truncated\n", MAX_ENV_SIZE);
		}
		size += 2;
34806abc:	e2855002 	add	r5, r5, #2
		printf("## Info: input data size = %zu = 0x%zX\n", size, size);
34806ac0:	e59f00ec 	ldr	r0, [pc, #236]	; 34806bb4 <do_env_import+0x238>
34806ac4:	e1a01005 	mov	r1, r5
34806ac8:	e1a02005 	mov	r2, r5
34806acc:	eb0009a4 	bl	34809164 <printf>
	}

	if (chk) {
34806ad0:	e3590000 	cmp	r9, #0
34806ad4:	0a00000f 	beq	34806b18 <do_env_import+0x19c>
		uint32_t crc;
		env_t *ep = (env_t *)addr;

		size -= offsetof(env_t, data);
		memcpy(&crc, &ep->crc, sizeof(crc));
34806ad8:	e1a01006 	mov	r1, r6
34806adc:	e3a02004 	mov	r2, #4

	if (chk) {
		uint32_t crc;
		env_t *ep = (env_t *)addr;

		size -= offsetof(env_t, data);
34806ae0:	e2455004 	sub	r5, r5, #4
		memcpy(&crc, &ep->crc, sizeof(crc));
34806ae4:	e28d0014 	add	r0, sp, #20

		if (crc32(0, ep->data, size) != crc) {
34806ae8:	e2866004 	add	r6, r6, #4
	if (chk) {
		uint32_t crc;
		env_t *ep = (env_t *)addr;

		size -= offsetof(env_t, data);
		memcpy(&crc, &ep->crc, sizeof(crc));
34806aec:	eb005518 	bl	3481bf54 <memcpy>

		if (crc32(0, ep->data, size) != crc) {
34806af0:	e3a00000 	mov	r0, #0
34806af4:	e1a01006 	mov	r1, r6
34806af8:	e1a02005 	mov	r2, r5
34806afc:	eb004d92 	bl	3481a14c <crc32>
34806b00:	e59d3014 	ldr	r3, [sp, #20]
34806b04:	e1500003 	cmp	r0, r3
34806b08:	0a000002 	beq	34806b18 <do_env_import+0x19c>
			puts("## Error: bad CRC, import failed\n");
34806b0c:	e59f00a4 	ldr	r0, [pc, #164]	; 34806bb8 <do_env_import+0x23c>
34806b10:	eb000989 	bl	3480913c <puts>
34806b14:	ea00001c 	b	34806b8c <do_env_import+0x210>
			return 1;
		}
		addr = (char *)ep->data;
	}

	if (himport_r(&env_htab, addr, size, sep, del ? 0 : H_NOCLEAR,
34806b18:	e3a04000 	mov	r4, #0
34806b1c:	e22aa001 	eor	sl, sl, #1
34806b20:	e59f0094 	ldr	r0, [pc, #148]	; 34806bbc <do_env_import+0x240>
34806b24:	e1a01006 	mov	r1, r6
34806b28:	e1a02005 	mov	r2, r5
34806b2c:	e1a03007 	mov	r3, r7
34806b30:	e58da000 	str	sl, [sp]
34806b34:	e58d4004 	str	r4, [sp, #4]
34806b38:	e58d4008 	str	r4, [sp, #8]
34806b3c:	e58d400c 	str	r4, [sp, #12]
34806b40:	eb005144 	bl	3481b058 <himport_r>
34806b44:	e1500004 	cmp	r0, r4
34806b48:	1a000008 	bne	34806b70 <do_env_import+0x1f4>
			0, NULL, 0 /* do_apply */) == 0) {
		error("Environment import failed: errno = %d\n", errno);
34806b4c:	e59f306c 	ldr	r3, [pc, #108]	; 34806bc0 <do_env_import+0x244>
34806b50:	e59f206c 	ldr	r2, [pc, #108]	; 34806bc4 <do_env_import+0x248>
34806b54:	e58d3000 	str	r3, [sp]
34806b58:	e59f3068 	ldr	r3, [pc, #104]	; 34806bc8 <do_env_import+0x24c>
34806b5c:	e59f0068 	ldr	r0, [pc, #104]	; 34806bcc <do_env_import+0x250>
34806b60:	e5931000 	ldr	r1, [r3]
34806b64:	e30033bd 	movw	r3, #957	; 0x3bd
34806b68:	eb00097d 	bl	34809164 <printf>
34806b6c:	ea000006 	b	34806b8c <do_env_import+0x210>
		return 1;
	}
	gd->flags |= GD_FLG_ENV_READY;
34806b70:	e5982004 	ldr	r2, [r8, #4]

	return 0;
34806b74:	e1a00004 	mov	r0, r4
	if (himport_r(&env_htab, addr, size, sep, del ? 0 : H_NOCLEAR,
			0, NULL, 0 /* do_apply */) == 0) {
		error("Environment import failed: errno = %d\n", errno);
		return 1;
	}
	gd->flags |= GD_FLG_ENV_READY;
34806b78:	e3822080 	orr	r2, r2, #128	; 0x80
34806b7c:	e5882004 	str	r2, [r8, #4]

	return 0;
34806b80:	ea000004 	b	34806b98 <do_env_import+0x21c>

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",
34806b84:	e59f0044 	ldr	r0, [pc, #68]	; 34806bd0 <do_env_import+0x254>
34806b88:	eb000975 	bl	34809164 <printf>
		cmd);
	return 1;
34806b8c:	e3a00001 	mov	r0, #1
34806b90:	ea000000 	b	34806b98 <do_env_import+0x21c>
			}
		}
	}

	if (argc < 1)
		return CMD_RET_USAGE;
34806b94:	e3e00000 	mvn	r0, #0

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",
		cmd);
	return 1;
}
34806b98:	e28dd01c 	add	sp, sp, #28
34806b9c:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	if (argc < 1)
		return CMD_RET_USAGE;

	if (!fmt)
34806ba0:	e3520000 	cmp	r2, #0
34806ba4:	1affffa6 	bne	34806a44 <do_env_import+0xc8>
34806ba8:	eaffffa3 	b	34806a3c <do_env_import+0xc0>
34806bac:	34825068 	.word	0x34825068
34806bb0:	3482508f 	.word	0x3482508f
34806bb4:	348250c4 	.word	0x348250c4
34806bb8:	348250ec 	.word	0x348250ec
34806bbc:	348289a4 	.word	0x348289a4
34806bc0:	34820218 	.word	0x34820218
34806bc4:	3482514b 	.word	0x3482514b
34806bc8:	3482bc40 	.word	0x3482bc40
34806bcc:	3482510e 	.word	0x3482510e
34806bd0:	34825158 	.word	0x34825158

34806bd4 <do_env_default>:
}

#ifndef CONFIG_SPL_BUILD
static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
			  int argc, char * const argv[])
{
34806bd4:	e92d4070 	push	{r4, r5, r6, lr}
	int all = 0, flag = 0;
34806bd8:	e3a0c000 	mov	ip, #0

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
34806bdc:	ea000009 	b	34806c08 <do_env_default+0x34>
		char *arg = *argv;

		while (*++arg) {
			switch (*arg) {
34806be0:	e3530061 	cmp	r3, #97	; 0x61
34806be4:	0a000002 	beq	34806bf4 <do_env_default+0x20>
34806be8:	e3530066 	cmp	r3, #102	; 0x66
34806bec:	1a000021 	bne	34806c78 <do_env_default+0xa4>
34806bf0:	ea000000 	b	34806bf8 <do_env_default+0x24>
			case 'a':		/* default all */
				all = 1;
34806bf4:	e3a0c001 	mov	ip, #1

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;

		while (*++arg) {
34806bf8:	e5f13001 	ldrb	r3, [r1, #1]!
34806bfc:	e3530000 	cmp	r3, #0
34806c00:	1afffff6 	bne	34806be0 <do_env_default+0xc>
34806c04:	e1a03004 	mov	r3, r4
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
34806c08:	e2422001 	sub	r2, r2, #1
34806c0c:	e3520000 	cmp	r2, #0
		char *arg = *argv;

		while (*++arg) {
34806c10:	e1a01003 	mov	r1, r3
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
34806c14:	da000006 	ble	34806c34 <do_env_default+0x60>

	return -1;
}

#ifndef CONFIG_SPL_BUILD
static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
34806c18:	e2834004 	add	r4, r3, #4
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
34806c1c:	e5933004 	ldr	r3, [r3, #4]

	return -1;
}

#ifndef CONFIG_SPL_BUILD
static int do_env_default(cmd_tbl_t *cmdtp, int __flag,
34806c20:	e1a01004 	mov	r1, r4
			  int argc, char * const argv[])
{
	int all = 0, flag = 0;

	debug("Initial value for argc=%d\n", argc);
	while (--argc > 0 && **++argv == '-') {
34806c24:	e5d35000 	ldrb	r5, [r3]
34806c28:	e355002d 	cmp	r5, #45	; 0x2d
34806c2c:	01a01003 	moveq	r1, r3
34806c30:	0afffff0 	beq	34806bf8 <do_env_default+0x24>
				return cmd_usage(cmdtp);
			}
		}
	}
	debug("Final value for argc=%d\n", argc);
	if (all && (argc == 0)) {
34806c34:	e3520000 	cmp	r2, #0
34806c38:	13a03000 	movne	r3, #0
34806c3c:	020c3001 	andeq	r3, ip, #1
34806c40:	e3530000 	cmp	r3, #0
34806c44:	0a000002 	beq	34806c54 <do_env_default+0x80>
		/* Reset the whole environment */
		set_default_env("## Resetting to default environment\n");
34806c48:	e59f0038 	ldr	r0, [pc, #56]	; 34806c88 <do_env_default+0xb4>
34806c4c:	eb000e5b 	bl	3480a5c0 <set_default_env>
		return 0;
34806c50:	ea00000a 	b	34806c80 <do_env_default+0xac>
	}
	if (!all && (argc > 0)) {
34806c54:	e22cc001 	eor	ip, ip, #1
34806c58:	e3520000 	cmp	r2, #0
34806c5c:	d3a0c000 	movle	ip, #0
34806c60:	c20cc001 	andgt	ip, ip, #1
34806c64:	e35c0000 	cmp	ip, #0
34806c68:	0a000002 	beq	34806c78 <do_env_default+0xa4>
		/* Reset individual variables */
		set_default_vars(argc, argv);
34806c6c:	e1a00002 	mov	r0, r2
34806c70:	eb000e81 	bl	3480a67c <set_default_vars>
		return 0;
34806c74:	ea000001 	b	34806c80 <do_env_default+0xac>
	}

	return cmd_usage(cmdtp);
}
34806c78:	e8bd4070 	pop	{r4, r5, r6, lr}
		/* Reset individual variables */
		set_default_vars(argc, argv);
		return 0;
	}

	return cmd_usage(cmdtp);
34806c7c:	ea0007e1 	b	34808c08 <cmd_usage>
}
34806c80:	e3a00000 	mov	r0, #0
34806c84:	e8bd8070 	pop	{r4, r5, r6, pc}
34806c88:	34825187 	.word	0x34825187

34806c8c <do_env_save>:
}

#ifndef CONFIG_SPL_BUILD
#if defined(CONFIG_CMD_SAVEENV) && !defined(CONFIG_ENV_IS_NOWHERE)
int do_env_save(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34806c8c:	e92d4008 	push	{r3, lr}
	printf("Saving Environment to %s...\n", env_name_spec);
34806c90:	e59f3018 	ldr	r3, [pc, #24]	; 34806cb0 <do_env_save+0x24>
34806c94:	e59f0018 	ldr	r0, [pc, #24]	; 34806cb4 <do_env_save+0x28>
34806c98:	e5931000 	ldr	r1, [r3]
34806c9c:	eb000930 	bl	34809164 <printf>

	return saveenv() ? 1 : 0;
34806ca0:	eb000ee5 	bl	3480a83c <saveenv>
}
34806ca4:	e2500000 	subs	r0, r0, #0
34806ca8:	13a00001 	movne	r0, #1
34806cac:	e8bd8008 	pop	{r3, pc}
34806cb0:	348289b4 	.word	0x348289b4
34806cb4:	348251ac 	.word	0x348251ac

34806cb8 <env_print>:
 * Command interface: print one or all environment variables
 *
 * Returns 0 in case of error, or length of printed string
 */
static int env_print(char *name)
{
34806cb8:	e92d4010 	push	{r4, lr}
	char *res = NULL;
34806cbc:	e3a02000 	mov	r2, #0
 * Command interface: print one or all environment variables
 *
 * Returns 0 in case of error, or length of printed string
 */
static int env_print(char *name)
{
34806cc0:	e24dd018 	sub	sp, sp, #24
	char *res = NULL;
	size_t len;

	if (name) {		/* print a single name */
34806cc4:	e2503000 	subs	r3, r0, #0
 *
 * Returns 0 in case of error, or length of printed string
 */
static int env_print(char *name)
{
	char *res = NULL;
34806cc8:	e58d2014 	str	r2, [sp, #20]
	size_t len;

	if (name) {		/* print a single name */
34806ccc:	0a000010 	beq	34806d14 <env_print+0x5c>
		ENTRY e, *ep;

		e.key = name;
34806cd0:	e58d3008 	str	r3, [sp, #8]
		e.data = NULL;
		hsearch_r(e, FIND, &ep, &env_htab);
34806cd4:	e59f3074 	ldr	r3, [pc, #116]	; 34806d50 <env_print+0x98>

	if (name) {		/* print a single name */
		ENTRY e, *ep;

		e.key = name;
		e.data = NULL;
34806cd8:	e58d200c 	str	r2, [sp, #12]
		hsearch_r(e, FIND, &ep, &env_htab);
34806cdc:	e58d3000 	str	r3, [sp]
34806ce0:	e28d3008 	add	r3, sp, #8
34806ce4:	e8930003 	ldm	r3, {r0, r1}
34806ce8:	e28d3010 	add	r3, sp, #16
34806cec:	eb004f48 	bl	3481aa14 <hsearch_r>
		if (ep == NULL)
34806cf0:	e59d3010 	ldr	r3, [sp, #16]
34806cf4:	e3530000 	cmp	r3, #0
			return 0;
34806cf8:	01a04003 	moveq	r4, r3
		ENTRY e, *ep;

		e.key = name;
		e.data = NULL;
		hsearch_r(e, FIND, &ep, &env_htab);
		if (ep == NULL)
34806cfc:	0a000010 	beq	34806d44 <env_print+0x8c>
			return 0;
		len = printf("%s=%s\n", ep->key, ep->data);
34806d00:	e59f004c 	ldr	r0, [pc, #76]	; 34806d54 <env_print+0x9c>
34806d04:	e8930006 	ldm	r3, {r1, r2}
34806d08:	eb000915 	bl	34809164 <printf>
34806d0c:	e1a04000 	mov	r4, r0
		return len;
34806d10:	ea00000b 	b	34806d44 <env_print+0x8c>
	}

	/* print whole list */
	len = hexport_r(&env_htab, '\n', &res, 0, 0, NULL);
34806d14:	e59f0034 	ldr	r0, [pc, #52]	; 34806d50 <env_print+0x98>
34806d18:	e3a0100a 	mov	r1, #10
34806d1c:	e28d2014 	add	r2, sp, #20
34806d20:	e58d3000 	str	r3, [sp]
34806d24:	e58d3004 	str	r3, [sp, #4]
34806d28:	eb00501f 	bl	3481adac <hexport_r>

	if (len > 0) {
34806d2c:	e2504000 	subs	r4, r0, #0
34806d30:	0a000003 	beq	34806d44 <env_print+0x8c>
		puts(res);
34806d34:	e59d0014 	ldr	r0, [sp, #20]
34806d38:	eb0008ff 	bl	3480913c <puts>
		free(res);
34806d3c:	e59d0014 	ldr	r0, [sp, #20]
34806d40:	eb000a45 	bl	3480965c <free>
		return len;
	}

	/* should never happen */
	return 0;
}
34806d44:	e1a00004 	mov	r0, r4
34806d48:	e28dd018 	add	sp, sp, #24
34806d4c:	e8bd8010 	pop	{r4, pc}
34806d50:	348289a4 	.word	0x348289a4
34806d54:	348251c9 	.word	0x348251c9

34806d58 <do_env_print>:
int do_env_print (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int i;
	int rcode = 0;

	if (argc == 1) {
34806d58:	e3520001 	cmp	r2, #1
	/* should never happen */
	return 0;
}

int do_env_print (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34806d5c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34806d60:	e1a04002 	mov	r4, r2
	int i;
	int rcode = 0;

	if (argc == 1) {
34806d64:	11a07003 	movne	r7, r3
34806d68:	13a05000 	movne	r5, #0
34806d6c:	13a06001 	movne	r6, #1
34806d70:	1a000012 	bne	34806dc0 <do_env_print+0x68>
		/* print all env vars */
		rcode = env_print(NULL);
34806d74:	e3a00000 	mov	r0, #0
34806d78:	ebffffce 	bl	34806cb8 <env_print>
		if (!rcode)
34806d7c:	e2501000 	subs	r1, r0, #0
			return 1;
34806d80:	01a05004 	moveq	r5, r4
	int rcode = 0;

	if (argc == 1) {
		/* print all env vars */
		rcode = env_print(NULL);
		if (!rcode)
34806d84:	0a00000f 	beq	34806dc8 <do_env_print+0x70>
			return 1;
		printf("\nEnvironment size: %d/%ld bytes\n",
34806d88:	e59f0040 	ldr	r0, [pc, #64]	; 34806dd0 <do_env_print+0x78>
34806d8c:	e59f2040 	ldr	r2, [pc, #64]	; 34806dd4 <do_env_print+0x7c>
34806d90:	eb0008f3 	bl	34809164 <printf>
			rcode, (ulong)ENV_SIZE);
		return 0;
34806d94:	e3a05000 	mov	r5, #0
34806d98:	ea00000a 	b	34806dc8 <do_env_print+0x70>
	}

	/* print selected env vars */
	for (i = 1; i < argc; ++i) {
		int rc = env_print(argv[i]);
34806d9c:	e5b70004 	ldr	r0, [r7, #4]!
34806da0:	ebffffc4 	bl	34806cb8 <env_print>
		if (!rc) {
34806da4:	e3500000 	cmp	r0, #0
34806da8:	1a000003 	bne	34806dbc <do_env_print+0x64>
			printf("## Error: \"%s\" not defined\n", argv[i]);
34806dac:	e59f0024 	ldr	r0, [pc, #36]	; 34806dd8 <do_env_print+0x80>
34806db0:	e5971000 	ldr	r1, [r7]
34806db4:	eb0008ea 	bl	34809164 <printf>
			++rcode;
34806db8:	e2855001 	add	r5, r5, #1
			rcode, (ulong)ENV_SIZE);
		return 0;
	}

	/* print selected env vars */
	for (i = 1; i < argc; ++i) {
34806dbc:	e2866001 	add	r6, r6, #1
34806dc0:	e1560004 	cmp	r6, r4
34806dc4:	bafffff4 	blt	34806d9c <do_env_print+0x44>
			++rcode;
		}
	}

	return rcode;
}
34806dc8:	e1a00005 	mov	r0, r5
34806dcc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34806dd0:	348251d0 	.word	0x348251d0
34806dd4:	0003fffc 	.word	0x0003fffc
34806dd8:	348251f1 	.word	0x348251f1

34806ddc <get_env_id>:
static int env_id = 1;

int get_env_id(void)
{
	return env_id;
}
34806ddc:	e59f3004 	ldr	r3, [pc, #4]	; 34806de8 <get_env_id+0xc>
34806de0:	e59300d8 	ldr	r0, [r3, #216]	; 0xd8
34806de4:	e12fff1e 	bx	lr
34806de8:	348283d8 	.word	0x348283d8

34806dec <env_check_apply>:
 * overwriting of write-once variables.
 */

int env_check_apply(const char *name, const char *oldval,
			const char *newval, int flag)
{
34806dec:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int   console = -1;

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";
34806df0:	e3520000 	cmp	r2, #0
 * overwriting of write-once variables.
 */

int env_check_apply(const char *name, const char *oldval,
			const char *newval, int flag)
{
34806df4:	e1a05001 	mov	r5, r1

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";

	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
34806df8:	e59f118c 	ldr	r1, [pc, #396]	; 34806f8c <env_check_apply+0x1a0>
 * overwriting of write-once variables.
 */

int env_check_apply(const char *name, const char *oldval,
			const char *newval, int flag)
{
34806dfc:	e1a04000 	mov	r4, r0
34806e00:	e1a07003 	mov	r7, r3
	int   console = -1;

	/* Default value for NULL to protect string-manipulating functions */
	newval = newval ? : "";
34806e04:	e59f6184 	ldr	r6, [pc, #388]	; 34806f90 <env_check_apply+0x1a4>
34806e08:	11a06002 	movne	r6, r2

	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
34806e0c:	eb005358 	bl	3481bb74 <strcmp>
34806e10:	e3500000 	cmp	r0, #0
34806e14:	0a00000b 	beq	34806e48 <env_check_apply+0x5c>
		console = stdin;
	else if (strcmp(name, "stdout") == 0)
34806e18:	e1a00004 	mov	r0, r4
34806e1c:	e59f1170 	ldr	r1, [pc, #368]	; 34806f94 <env_check_apply+0x1a8>
34806e20:	eb005353 	bl	3481bb74 <strcmp>
34806e24:	e3500000 	cmp	r0, #0
		console = stdout;
34806e28:	03a00001 	moveq	r0, #1
	newval = newval ? : "";

	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
		console = stdin;
	else if (strcmp(name, "stdout") == 0)
34806e2c:	0a000005 	beq	34806e48 <env_check_apply+0x5c>
		console = stdout;
	else if (strcmp(name, "stderr") == 0)
34806e30:	e1a00004 	mov	r0, r4
34806e34:	e59f115c 	ldr	r1, [pc, #348]	; 34806f98 <env_check_apply+0x1ac>
34806e38:	eb00534d 	bl	3481bb74 <strcmp>
34806e3c:	e3500000 	cmp	r0, #0
		console = stderr;
34806e40:	02800002 	addeq	r0, r0, #2
	/* Check for console redirection */
	if (strcmp(name, "stdin") == 0)
		console = stdin;
	else if (strcmp(name, "stdout") == 0)
		console = stdout;
	else if (strcmp(name, "stderr") == 0)
34806e44:	1a00000f 	bne	34806e88 <env_check_apply+0x9c>
		console = stderr;

	if (console != -1) {
		if ((newval == NULL) || (*newval == '\0')) {
34806e48:	e5d63000 	ldrb	r3, [r6]
34806e4c:	e3530000 	cmp	r3, #0
34806e50:	1a000004 	bne	34806e68 <env_check_apply+0x7c>
			/* We cannot delete stdin/stdout/stderr */
			if ((flag & H_FORCE) == 0)
34806e54:	e3170002 	tst	r7, #2
				printf("Can't delete \"%s\"\n", name);
34806e58:	059f013c 	ldreq	r0, [pc, #316]	; 34806f9c <env_check_apply+0x1b0>
34806e5c:	01a01004 	moveq	r1, r4
		console = stderr;

	if (console != -1) {
		if ((newval == NULL) || (*newval == '\0')) {
			/* We cannot delete stdin/stdout/stderr */
			if ((flag & H_FORCE) == 0)
34806e60:	1a000047 	bne	34806f84 <env_check_apply+0x198>
34806e64:	ea000025 	b	34806f00 <env_check_apply+0x114>
#ifdef CONFIG_CONSOLE_MUX
		if (iomux_doenv(console, newval))
			return 1;
#else
		/* Try assigning specified device */
		if (console_assign(console, newval) < 0)
34806e68:	e1a01006 	mov	r1, r6
34806e6c:	eb000910 	bl	348092b4 <console_assign>
34806e70:	e3500000 	cmp	r0, #0
34806e74:	ba000042 	blt	34806f84 <env_check_apply+0x198>
			return 1;

#ifdef CONFIG_SERIAL_MULTI
		if (serial_assign(newval) < 0)
34806e78:	e1a00006 	mov	r0, r6
34806e7c:	eb001dc6 	bl	3480e59c <serial_assign>
34806e80:	e3500000 	cmp	r0, #0
34806e84:	ba00003e 	blt	34806f84 <env_check_apply+0x198>
	/*
	 * When we change baudrate, or we are doing an env default -a
	 * (which will erase all variables prior to calling this),
	 * we want the baudrate to actually change - for real.
	 */
	if (oldval != NULL ||			/* variable exists */
34806e88:	e3550000 	cmp	r5, #0
34806e8c:	1a000001 	bne	34806e98 <env_check_apply+0xac>
34806e90:	e3170001 	tst	r7, #1
34806e94:	1a000027 	bne	34806f38 <env_check_apply+0x14c>
		(flag & H_NOCLEAR) == 0) {	/* or env is clear */
		/*
		 * Switch to new baudrate if new baudrate is supported
		 */
		if (strcmp(name, "baudrate") == 0) {
34806e98:	e59f1100 	ldr	r1, [pc, #256]	; 34806fa0 <env_check_apply+0x1b4>
34806e9c:	e1a00004 	mov	r0, r4
34806ea0:	eb005333 	bl	3481bb74 <strcmp>
34806ea4:	e2501000 	subs	r1, r0, #0
34806ea8:	1a000022 	bne	34806f38 <env_check_apply+0x14c>
			int baudrate = simple_strtoul(newval, NULL, 10);
34806eac:	e1a00006 	mov	r0, r6
34806eb0:	e3a0200a 	mov	r2, #10
34806eb4:	eb0056f5 	bl	3481ca90 <simple_strtoul>
			int i;
			for (i = 0; i < N_BAUDRATES; ++i) {
				if (baudrate == baudrate_table[i])
34806eb8:	e3500d96 	cmp	r0, #9600	; 0x2580
		(flag & H_NOCLEAR) == 0) {	/* or env is clear */
		/*
		 * Switch to new baudrate if new baudrate is supported
		 */
		if (strcmp(name, "baudrate") == 0) {
			int baudrate = simple_strtoul(newval, NULL, 10);
34806ebc:	e1a05000 	mov	r5, r0
			int i;
			for (i = 0; i < N_BAUDRATES; ++i) {
				if (baudrate == baudrate_table[i])
34806ec0:	0a000008 	beq	34806ee8 <env_check_apply+0xfc>
34806ec4:	e3500c4b 	cmp	r0, #19200	; 0x4b00
34806ec8:	0a000006 	beq	34806ee8 <env_check_apply+0xfc>
34806ecc:	e3500c96 	cmp	r0, #38400	; 0x9600
34806ed0:	0a000004 	beq	34806ee8 <env_check_apply+0xfc>
34806ed4:	e3500ce1 	cmp	r0, #57600	; 0xe100
34806ed8:	0a000002 	beq	34806ee8 <env_check_apply+0xfc>
34806edc:	e59f30c0 	ldr	r3, [pc, #192]	; 34806fa4 <env_check_apply+0x1b8>
34806ee0:	e1500003 	cmp	r0, r3
34806ee4:	1a000024 	bne	34806f7c <env_check_apply+0x190>
				if ((flag & H_FORCE) == 0)
					printf("## Baudrate %d bps not "
						"supported\n", baudrate);
				return 1;
			}
			if (gd->baudrate == baudrate) {
34806ee8:	e5983008 	ldr	r3, [r8, #8]
34806eec:	e1530005 	cmp	r3, r5
34806ef0:	1a000004 	bne	34806f08 <env_check_apply+0x11c>
34806ef4:	ea00001c 	b	34806f6c <env_check_apply+0x180>
				if (baudrate == baudrate_table[i])
					break;
			}
			if (i == N_BAUDRATES) {
				if ((flag & H_FORCE) == 0)
					printf("## Baudrate %d bps not "
34806ef8:	e59f00a8 	ldr	r0, [pc, #168]	; 34806fa8 <env_check_apply+0x1bc>
34806efc:	e1a01005 	mov	r1, r5
34806f00:	eb000897 	bl	34809164 <printf>
34806f04:	ea00001e 	b	34806f84 <env_check_apply+0x198>
			}
			if (gd->baudrate == baudrate) {
				/* If unchanged, we just say it's OK */
				return 0;
			}
			printf("## Switch baudrate to %d bps and"
34806f08:	e1a01005 	mov	r1, r5
34806f0c:	e59f0098 	ldr	r0, [pc, #152]	; 34806fac <env_check_apply+0x1c0>
34806f10:	eb000893 	bl	34809164 <printf>
				"press ENTER ...\n", baudrate);
			udelay(50000);
34806f14:	e30c0350 	movw	r0, #50000	; 0xc350
34806f18:	eb005498 	bl	3481c180 <udelay>
			gd->baudrate = baudrate;
34806f1c:	e5885008 	str	r5, [r8, #8]
#if defined(CONFIG_PPC) || defined(CONFIG_MCF52x2)
			gd->bd->bi_baudrate = baudrate;
#endif

			serial_setbrg();
34806f20:	eb001dd4 	bl	3480e678 <serial_setbrg>
			udelay(50000);
34806f24:	e30c0350 	movw	r0, #50000	; 0xc350
34806f28:	eb005494 	bl	3481c180 <udelay>
			while (getc() != '\r')
34806f2c:	eb000866 	bl	348090cc <getc>
34806f30:	e350000d 	cmp	r0, #13
34806f34:	1afffffc 	bne	34806f2c <env_check_apply+0x140>

	/*
	 * Some variables should be updated when the corresponding
	 * entry in the environment is changed
	 */
	if (strcmp(name, "loadaddr") == 0) {
34806f38:	e1a00004 	mov	r0, r4
34806f3c:	e59f106c 	ldr	r1, [pc, #108]	; 34806fb0 <env_check_apply+0x1c4>
34806f40:	eb00530b 	bl	3481bb74 <strcmp>
34806f44:	e2504000 	subs	r4, r0, #0
34806f48:	1a000009 	bne	34806f74 <env_check_apply+0x188>
		load_addr = simple_strtoul(newval, NULL, 16);
34806f4c:	e1a00006 	mov	r0, r6
34806f50:	e1a01004 	mov	r1, r4
34806f54:	e3a02010 	mov	r2, #16
34806f58:	eb0056cc 	bl	3481ca90 <simple_strtoul>
34806f5c:	e59f3050 	ldr	r3, [pc, #80]	; 34806fb4 <env_check_apply+0x1c8>
34806f60:	e58300dc 	str	r0, [r3, #220]	; 0xdc
		return 0;
34806f64:	e1a00004 	mov	r0, r4
34806f68:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
						"supported\n", baudrate);
				return 1;
			}
			if (gd->baudrate == baudrate) {
				/* If unchanged, we just say it's OK */
				return 0;
34806f6c:	e3a00000 	mov	r0, #0
34806f70:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	else if (strcmp(name, "bootfile") == 0) {
		copy_filename(BootFile, newval, sizeof(BootFile));
		return 0;
	}
#endif
	return 0;
34806f74:	e3a00000 	mov	r0, #0
}
34806f78:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
			for (i = 0; i < N_BAUDRATES; ++i) {
				if (baudrate == baudrate_table[i])
					break;
			}
			if (i == N_BAUDRATES) {
				if ((flag & H_FORCE) == 0)
34806f7c:	e3170002 	tst	r7, #2
34806f80:	0affffdc 	beq	34806ef8 <env_check_apply+0x10c>
					printf("## Baudrate %d bps not "
						"supported\n", baudrate);
				return 1;
34806f84:	e3a00001 	mov	r0, #1
34806f88:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34806f8c:	3482520d 	.word	0x3482520d
34806f90:	34823cce 	.word	0x34823cce
34806f94:	34825213 	.word	0x34825213
34806f98:	3482521a 	.word	0x3482521a
34806f9c:	34825221 	.word	0x34825221
34806fa0:	34822873 	.word	0x34822873
34806fa4:	0001c200 	.word	0x0001c200
34806fa8:	34825234 	.word	0x34825234
34806fac:	34825256 	.word	0x34825256
34806fb0:	34822884 	.word	0x34822884
34806fb4:	348283d8 	.word	0x348283d8

34806fb8 <_do_env_set>:
/*
 * Set a new environment variable,
 * or replace or delete an existing one.
*/
int _do_env_set(int flag, int argc, char * const argv[])
{
34806fb8:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	int   i, len;
	char  *name, *value, *s;
	ENTRY e, *ep;

	name = argv[1];
34806fbc:	e5924004 	ldr	r4, [r2, #4]
/*
 * Set a new environment variable,
 * or replace or delete an existing one.
*/
int _do_env_set(int flag, int argc, char * const argv[])
{
34806fc0:	e24dd01c 	sub	sp, sp, #28
34806fc4:	e1a06001 	mov	r6, r1
	ENTRY e, *ep;

	name = argv[1];
	value = argv[2];

	if (strchr(name, '=')) {
34806fc8:	e1a00004 	mov	r0, r4
34806fcc:	e3a0103d 	mov	r1, #61	; 0x3d
/*
 * Set a new environment variable,
 * or replace or delete an existing one.
*/
int _do_env_set(int flag, int argc, char * const argv[])
{
34806fd0:	e1a05002 	mov	r5, r2
	int   i, len;
	char  *name, *value, *s;
	ENTRY e, *ep;

	name = argv[1];
34806fd4:	e282a004 	add	sl, r2, #4
	value = argv[2];
34806fd8:	e5927008 	ldr	r7, [r2, #8]

	if (strchr(name, '=')) {
34806fdc:	eb005302 	bl	3481bbec <strchr>
34806fe0:	e2502000 	subs	r2, r0, #0
		printf("## Error: illegal character '='"
34806fe4:	159f0168 	ldrne	r0, [pc, #360]	; 34807154 <_do_env_set+0x19c>
34806fe8:	11a01004 	movne	r1, r4
	ENTRY e, *ep;

	name = argv[1];
	value = argv[2];

	if (strchr(name, '=')) {
34806fec:	1a000032 	bne	348070bc <_do_env_set+0x104>
		printf("## Error: illegal character '='"
		       "in variable name \"%s\"\n", name);
		return 1;
	}

	env_id++;
34806ff0:	e59f3160 	ldr	r3, [pc, #352]	; 34807158 <_do_env_set+0x1a0>
	/*
	 * search if variable with this name already exists
	 */
	e.key = name;
	e.data = NULL;
34806ff4:	e58d2010 	str	r2, [sp, #16]
		printf("## Error: illegal character '='"
		       "in variable name \"%s\"\n", name);
		return 1;
	}

	env_id++;
34806ff8:	e59310d8 	ldr	r1, [r3, #216]	; 0xd8
	/*
	 * search if variable with this name already exists
	 */
	e.key = name;
34806ffc:	e58d400c 	str	r4, [sp, #12]
		printf("## Error: illegal character '='"
		       "in variable name \"%s\"\n", name);
		return 1;
	}

	env_id++;
34807000:	e2811001 	add	r1, r1, #1
34807004:	e58310d8 	str	r1, [r3, #216]	; 0xd8
	/*
	 * search if variable with this name already exists
	 */
	e.key = name;
	e.data = NULL;
	hsearch_r(e, FIND, &ep, &env_htab);
34807008:	e59f314c 	ldr	r3, [pc, #332]	; 3480715c <_do_env_set+0x1a4>
3480700c:	e58d3000 	str	r3, [sp]
34807010:	e28d300c 	add	r3, sp, #12
34807014:	e8930003 	ldm	r3, {r0, r1}
34807018:	e28d3014 	add	r3, sp, #20
3480701c:	eb004e7c 	bl	3481aa14 <hsearch_r>

	/*
	 * Perform requested checks. Notice how since we are overwriting
	 * a single variable, we need to set H_NOCLEAR
	 */
	if (env_check_apply(name, ep ? ep->data : NULL, value, H_NOCLEAR)) {
34807020:	e59d1014 	ldr	r1, [sp, #20]
34807024:	e1a02007 	mov	r2, r7
34807028:	e3510000 	cmp	r1, #0
3480702c:	15911004 	ldrne	r1, [r1, #4]
34807030:	e1a00004 	mov	r0, r4
34807034:	e3a03001 	mov	r3, #1
34807038:	ebffff6b 	bl	34806dec <env_check_apply>
3480703c:	e2507000 	subs	r7, r0, #0
34807040:	1a000040 	bne	34807148 <_do_env_set+0x190>
		debug("check function did not approve, refusing\n");
		return 1;
	}

	/* Delete only ? */
	if (argc < 3 || argv[2] == NULL) {
34807044:	e3560002 	cmp	r6, #2
34807048:	da000004 	ble	34807060 <_do_env_set+0xa8>
3480704c:	e5953008 	ldr	r3, [r5, #8]
34807050:	e3530000 	cmp	r3, #0
34807054:	11a0900a 	movne	r9, sl
34807058:	13a05002 	movne	r5, #2
3480705c:	1a000006 	bne	3480707c <_do_env_set+0xc4>
		int rc = hdelete_r(name, &env_htab, 0);
34807060:	e1a00004 	mov	r0, r4
34807064:	e59f10f0 	ldr	r1, [pc, #240]	; 3480715c <_do_env_set+0x1a4>
34807068:	e3a02000 	mov	r2, #0
3480706c:	eb004f21 	bl	3481acf8 <hdelete_r>
		return !rc;
34807070:	e2700001 	rsbs	r0, r0, #1
34807074:	33a00000 	movcc	r0, #0
34807078:	ea000033 	b	3480714c <_do_env_set+0x194>

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
		len += strlen(argv[i]) + 1;
3480707c:	e5b90004 	ldr	r0, [r9, #4]!
34807080:	eb0052ef 	bl	3481bc44 <strlen>
	}

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
34807084:	e2855001 	add	r5, r5, #1
		len += strlen(argv[i]) + 1;
34807088:	e2800001 	add	r0, r0, #1
	}

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
3480708c:	e1550006 	cmp	r5, r6
		len += strlen(argv[i]) + 1;
34807090:	e0807007 	add	r7, r0, r7
	}

	/*
	 * Insert / replace new value
	 */
	for (i = 2, len = 0; i < argc; ++i)
34807094:	bafffff8 	blt	3480707c <_do_env_set+0xc4>
		len += strlen(argv[i]) + 1;

	value = malloc(len);
34807098:	e1a00007 	mov	r0, r7
3480709c:	eb0009f7 	bl	34809880 <malloc>
	if (value == NULL) {
348070a0:	e2505000 	subs	r5, r0, #0
348070a4:	11a0c005 	movne	ip, r5
348070a8:	13a01002 	movne	r1, #2
	for (i = 2, s = value; i < argc; ++i) {
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
348070ac:	13a07020 	movne	r7, #32
	 */
	for (i = 2, len = 0; i < argc; ++i)
		len += strlen(argv[i]) + 1;

	value = malloc(len);
	if (value == NULL) {
348070b0:	1a000003 	bne	348070c4 <_do_env_set+0x10c>
		printf("## Can't malloc %d bytes\n", len);
348070b4:	e59f00a4 	ldr	r0, [pc, #164]	; 34807160 <_do_env_set+0x1a8>
348070b8:	e1a01007 	mov	r1, r7
348070bc:	eb000828 	bl	34809164 <printf>
348070c0:	ea000020 	b	34807148 <_do_env_set+0x190>
		return 1;
348070c4:	e5bae004 	ldr	lr, [sl, #4]!
348070c8:	e1a0300c 	mov	r3, ip
	}
	for (i = 2, s = value; i < argc; ++i) {
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
348070cc:	e4de2001 	ldrb	r2, [lr], #1
348070d0:	e1a00003 	mov	r0, r3
348070d4:	e3520000 	cmp	r2, #0
348070d8:	e4c32001 	strb	r2, [r3], #1
348070dc:	e1a0c003 	mov	ip, r3
348070e0:	1afffff9 	bne	348070cc <_do_env_set+0x114>
	value = malloc(len);
	if (value == NULL) {
		printf("## Can't malloc %d bytes\n", len);
		return 1;
	}
	for (i = 2, s = value; i < argc; ++i) {
348070e4:	e2811001 	add	r1, r1, #1
348070e8:	e1510006 	cmp	r1, r6
		char *v = argv[i];

		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
348070ec:	e5c07000 	strb	r7, [r0]
	value = malloc(len);
	if (value == NULL) {
		printf("## Can't malloc %d bytes\n", len);
		return 1;
	}
	for (i = 2, s = value; i < argc; ++i) {
348070f0:	1afffff3 	bne	348070c4 <_do_env_set+0x10c>

		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
	}
	if (s != value)
348070f4:	e1530005 	cmp	r3, r5
		*--s = '\0';

	e.key	= name;
	e.data	= value;
	hsearch_r(e, ENTER, &ep, &env_htab);
348070f8:	e59f305c 	ldr	r3, [pc, #92]	; 3480715c <_do_env_set+0x1a4>
		while ((*s++ = *v++) != '\0')
			;
		*(s - 1) = ' ';
	}
	if (s != value)
		*--s = '\0';
348070fc:	15c02000 	strbne	r2, [r0]

	e.key	= name;
	e.data	= value;
	hsearch_r(e, ENTER, &ep, &env_htab);
34807100:	e58d3000 	str	r3, [sp]
	}
	if (s != value)
		*--s = '\0';

	e.key	= name;
	e.data	= value;
34807104:	e58d5010 	str	r5, [sp, #16]
	hsearch_r(e, ENTER, &ep, &env_htab);
34807108:	e28d300c 	add	r3, sp, #12
3480710c:	e8930003 	ldm	r3, {r0, r1}
34807110:	e3a02001 	mov	r2, #1
34807114:	e28d3014 	add	r3, sp, #20
34807118:	eb004e3d 	bl	3481aa14 <hsearch_r>
	free(value);
3480711c:	e1a00005 	mov	r0, r5
34807120:	eb00094d 	bl	3480965c <free>
	if (!ep) {
34807124:	e59d3014 	ldr	r3, [sp, #20]
34807128:	e3530000 	cmp	r3, #0
		printf("## Error inserting \"%s\" variable, errno=%d\n",
			name, errno);
		return 1;
	}

	return 0;
3480712c:	13a00000 	movne	r0, #0

	e.key	= name;
	e.data	= value;
	hsearch_r(e, ENTER, &ep, &env_htab);
	free(value);
	if (!ep) {
34807130:	1a000005 	bne	3480714c <_do_env_set+0x194>
		printf("## Error inserting \"%s\" variable, errno=%d\n",
34807134:	e59f3028 	ldr	r3, [pc, #40]	; 34807164 <_do_env_set+0x1ac>
34807138:	e59f0028 	ldr	r0, [pc, #40]	; 34807168 <_do_env_set+0x1b0>
3480713c:	e1a01004 	mov	r1, r4
34807140:	e5932000 	ldr	r2, [r3]
34807144:	eb000806 	bl	34809164 <printf>
	 * Perform requested checks. Notice how since we are overwriting
	 * a single variable, we need to set H_NOCLEAR
	 */
	if (env_check_apply(name, ep ? ep->data : NULL, value, H_NOCLEAR)) {
		debug("check function did not approve, refusing\n");
		return 1;
34807148:	e3a00001 	mov	r0, #1
			name, errno);
		return 1;
	}

	return 0;
}
3480714c:	e28dd01c 	add	sp, sp, #28
34807150:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
34807154:	34825287 	.word	0x34825287
34807158:	348283d8 	.word	0x348283d8
3480715c:	348289a4 	.word	0x348289a4
34807160:	348252bd 	.word	0x348252bd
34807164:	3482bc40 	.word	0x3482bc40
34807168:	348252d7 	.word	0x348252d7

3480716c <do_env_set>:
}

#ifndef CONFIG_SPL_BUILD
int do_env_set(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	if (argc < 2)
3480716c:	e3520001 	cmp	r2, #1
34807170:	da000003 	ble	34807184 <do_env_set+0x18>
		return CMD_RET_USAGE;

	return _do_env_set(flag, argc, argv);
34807174:	e1a00001 	mov	r0, r1
34807178:	e1a01002 	mov	r1, r2
3480717c:	e1a02003 	mov	r2, r3
34807180:	eaffff8c 	b	34806fb8 <_do_env_set>
}
34807184:	e3e00000 	mvn	r0, #0
34807188:	e12fff1e 	bx	lr

3480718c <setenv>:

	return 0;
}

int setenv(const char *varname, const char *varvalue)
{
3480718c:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };
34807190:	e59f3040 	ldr	r3, [pc, #64]	; 348071d8 <setenv+0x4c>
34807194:	e58d0004 	str	r0, [sp, #4]
34807198:	e3a00000 	mov	r0, #0

	if (varvalue == NULL || varvalue[0] == '\0')
3480719c:	e1510000 	cmp	r1, r0
	return 0;
}

int setenv(const char *varname, const char *varvalue)
{
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };
348071a0:	e58d3000 	str	r3, [sp]
348071a4:	e58d1008 	str	r1, [sp, #8]
348071a8:	e58d000c 	str	r0, [sp, #12]

	if (varvalue == NULL || varvalue[0] == '\0')
348071ac:	0a000003 	beq	348071c0 <setenv+0x34>
348071b0:	e5d13000 	ldrb	r3, [r1]
348071b4:	e1530000 	cmp	r3, r0
		return _do_env_set(0, 2, (char * const *)argv);
	else
		return _do_env_set(0, 3, (char * const *)argv);
348071b8:	13a01003 	movne	r1, #3

int setenv(const char *varname, const char *varvalue)
{
	const char * const argv[4] = { "setenv", varname, varvalue, NULL };

	if (varvalue == NULL || varvalue[0] == '\0')
348071bc:	1a000001 	bne	348071c8 <setenv+0x3c>
		return _do_env_set(0, 2, (char * const *)argv);
348071c0:	e3a00000 	mov	r0, #0
348071c4:	e3a01002 	mov	r1, #2
	else
		return _do_env_set(0, 3, (char * const *)argv);
348071c8:	e1a0200d 	mov	r2, sp
348071cc:	ebffff79 	bl	34806fb8 <_do_env_set>
}
348071d0:	e28dd014 	add	sp, sp, #20
348071d4:	e8bd8000 	pop	{pc}
348071d8:	34825303 	.word	0x34825303

348071dc <do_env_export>:
 *
 *	=> env import -d -t ${backup_addr}
 */
static int do_env_export(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
348071dc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	size_t	size = 0;
	ssize_t	len;
	env_t	*envp;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;
348071e0:	e3a0a000 	mov	sl, #0
 *
 *	=> env import -d -t ${backup_addr}
 */
static int do_env_export(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
348071e4:	e24dd038 	sub	sp, sp, #56	; 0x38
348071e8:	e1a0c000 	mov	ip, r0
348071ec:	e1a04002 	mov	r4, r2
348071f0:	e1a05003 	mov	r5, r3
	env_t	*envp;
	char	sep = '\n';
	int	chk = 0;
	int	fmt = 0;

	cmd = *argv;
348071f4:	e593b000 	ldr	fp, [r3]
	char	*addr, *cmd, *res;
	size_t	size = 0;
	ssize_t	len;
	env_t	*envp;
	char	sep = '\n';
	int	chk = 0;
348071f8:	e1a0900a 	mov	r9, sl
	char	buf[32];
	char	*addr, *cmd, *res;
	size_t	size = 0;
	ssize_t	len;
	env_t	*envp;
	char	sep = '\n';
348071fc:	e3a0600a 	mov	r6, #10
static int do_env_export(cmd_tbl_t *cmdtp, int flag,
			 int argc, char * const argv[])
{
	char	buf[32];
	char	*addr, *cmd, *res;
	size_t	size = 0;
34807200:	e1a0700a 	mov	r7, sl
	int	chk = 0;
	int	fmt = 0;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
34807204:	ea000027 	b	348072a8 <do_env_export+0xcc>
		char *arg = *argv;
		while (*++arg) {
			switch (*arg) {
34807208:	e3520063 	cmp	r2, #99	; 0x63
3480720c:	0a00000b 	beq	34807240 <do_env_export+0x64>
34807210:	8a000002 	bhi	34807220 <do_env_export+0x44>
34807214:	e3520062 	cmp	r2, #98	; 0x62
34807218:	1a000072 	bne	348073e8 <do_env_export+0x20c>
3480721c:	ea000004 	b	34807234 <do_env_export+0x58>
34807220:	e3520073 	cmp	r2, #115	; 0x73
34807224:	0a00000a 	beq	34807254 <do_env_export+0x78>
34807228:	e3520074 	cmp	r2, #116	; 0x74
3480722c:	1a00006d 	bne	348073e8 <do_env_export+0x20c>
34807230:	ea000014 	b	34807288 <do_env_export+0xac>
			case 'b':		/* raw binary format */
				if (fmt++)
34807234:	e3530000 	cmp	r3, #0
34807238:	0a000003 	beq	3480724c <do_env_export+0x70>
3480723c:	ea000064 	b	348073d4 <do_env_export+0x1f8>
					goto sep_err;
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
34807240:	e3530000 	cmp	r3, #0
34807244:	1a000062 	bne	348073d4 <do_env_export+0x1f8>
					goto sep_err;
				sep = '\0';
				chk = 1;
34807248:	e3a09001 	mov	r9, #1
				sep = '\0';
				break;
			case 'c':		/* external checksum format */
				if (fmt++)
					goto sep_err;
				sep = '\0';
3480724c:	e1a06003 	mov	r6, r3
34807250:	ea00000f 	b	34807294 <do_env_export+0xb8>
				chk = 1;
				break;
			case 's':		/* size given */
				if (--argc <= 0)
34807254:	e2544001 	subs	r4, r4, #1
34807258:	1a000002 	bne	34807268 <do_env_export+0x8c>
					return cmd_usage(cmdtp);
3480725c:	e1a0000c 	mov	r0, ip
34807260:	eb000668 	bl	34808c08 <cmd_usage>
34807264:	ea000060 	b	348073ec <do_env_export+0x210>
				size = simple_strtoul(*++argv, NULL, 16);
34807268:	e5b50004 	ldr	r0, [r5, #4]!
3480726c:	e3a01000 	mov	r1, #0
34807270:	e3a02010 	mov	r2, #16
34807274:	e58dc00c 	str	ip, [sp, #12]
34807278:	eb005604 	bl	3481ca90 <simple_strtoul>
				goto NXTARG;
3480727c:	e59dc00c 	ldr	ip, [sp, #12]
				chk = 1;
				break;
			case 's':		/* size given */
				if (--argc <= 0)
					return cmd_usage(cmdtp);
				size = simple_strtoul(*++argv, NULL, 16);
34807280:	e1a07000 	mov	r7, r0
				goto NXTARG;
34807284:	ea000007 	b	348072a8 <do_env_export+0xcc>
			case 't':		/* text format */
				if (fmt++)
34807288:	e3530000 	cmp	r3, #0
3480728c:	1a000050 	bne	348073d4 <do_env_export+0x1f8>
					goto sep_err;
				sep = '\n';
34807290:	e3a0600a 	mov	r6, #10
				if (--argc <= 0)
					return cmd_usage(cmdtp);
				size = simple_strtoul(*++argv, NULL, 16);
				goto NXTARG;
			case 't':		/* text format */
				if (fmt++)
34807294:	e3a03001 	mov	r3, #1

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;
		while (*++arg) {
34807298:	e5f02001 	ldrb	r2, [r0, #1]!
				if (--argc <= 0)
					return cmd_usage(cmdtp);
				size = simple_strtoul(*++argv, NULL, 16);
				goto NXTARG;
			case 't':		/* text format */
				if (fmt++)
3480729c:	e1a0a003 	mov	sl, r3

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
		char *arg = *argv;
		while (*++arg) {
348072a0:	e3520000 	cmp	r2, #0
348072a4:	1affffd7 	bne	34807208 <do_env_export+0x2c>
	int	chk = 0;
	int	fmt = 0;

	cmd = *argv;

	while (--argc > 0 && **++argv == '-') {
348072a8:	e2444001 	sub	r4, r4, #1
348072ac:	e3540000 	cmp	r4, #0
348072b0:	da00004c 	ble	348073e8 <do_env_export+0x20c>
348072b4:	e5b50004 	ldr	r0, [r5, #4]!
348072b8:	e5d03000 	ldrb	r3, [r0]
348072bc:	e353002d 	cmp	r3, #45	; 0x2d
348072c0:	1a00004b 	bne	348073f4 <do_env_export+0x218>
348072c4:	e1a0300a 	mov	r3, sl
348072c8:	eafffff2 	b	34807298 <do_env_export+0xbc>
		return CMD_RET_USAGE;

	addr = (char *)simple_strtoul(argv[0], NULL, 16);

	if (size)
		memset(addr, '\0', size);
348072cc:	e3a01000 	mov	r1, #0
348072d0:	e1a02007 	mov	r2, r7
348072d4:	eb0052fa 	bl	3481bec4 <memset>

	argc--;
	argv++;

	if (sep) {		/* export as text file */
348072d8:	e3560000 	cmp	r6, #0
	addr = (char *)simple_strtoul(argv[0], NULL, 16);

	if (size)
		memset(addr, '\0', size);

	argc--;
348072dc:	e2444001 	sub	r4, r4, #1
	argv++;
348072e0:	e2855004 	add	r5, r5, #4

	if (sep) {		/* export as text file */
348072e4:	0a000013 	beq	34807338 <do_env_export+0x15c>
		len = hexport_r(&env_htab, sep, &addr, size, argc, argv);
348072e8:	e28d2034 	add	r2, sp, #52	; 0x34
348072ec:	e59f011c 	ldr	r0, [pc, #284]	; 34807410 <do_env_export+0x234>
348072f0:	e1a01006 	mov	r1, r6
348072f4:	e1a03007 	mov	r3, r7
348072f8:	e88d0030 	stm	sp, {r4, r5}
348072fc:	eb004eaa 	bl	3481adac <hexport_r>
		if (len < 0) {
34807300:	e2502000 	subs	r2, r0, #0
34807304:	aa000007 	bge	34807328 <do_env_export+0x14c>
			error("Cannot export environment: errno = %d\n", errno);
34807308:	e59f3104 	ldr	r3, [pc, #260]	; 34807414 <do_env_export+0x238>
3480730c:	e59f0104 	ldr	r0, [pc, #260]	; 34807418 <do_env_export+0x23c>
34807310:	e58d3000 	str	r3, [sp]
34807314:	e59f3100 	ldr	r3, [pc, #256]	; 3480741c <do_env_export+0x240>
34807318:	e59f2100 	ldr	r2, [pc, #256]	; 34807420 <do_env_export+0x244>
3480731c:	e5931000 	ldr	r1, [r3]
34807320:	e3003333 	movw	r3, #819	; 0x333
34807324:	ea000017 	b	34807388 <do_env_export+0x1ac>
			return 1;
		}
		sprintf(buf, "%zX", (size_t)len);
34807328:	e28d4010 	add	r4, sp, #16
3480732c:	e1a00004 	mov	r0, r4
34807330:	e59f10ec 	ldr	r1, [pc, #236]	; 34807424 <do_env_export+0x248>
34807334:	ea000020 	b	348073bc <do_env_export+0x1e0>
		setenv("filesize", buf);

		return 0;
	}

	envp = (env_t *)addr;
34807338:	e59d6034 	ldr	r6, [sp, #52]	; 0x34

	if (chk)		/* export as checksum protected block */
3480733c:	e3590000 	cmp	r9, #0
		res = (char *)envp->data;
34807340:	12863004 	addne	r3, r6, #4
34807344:	158d3030 	strne	r3, [sp, #48]	; 0x30
	else			/* export as raw binary data */
		res = addr;

	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, argc, argv);
34807348:	e59f00c0 	ldr	r0, [pc, #192]	; 34807410 <do_env_export+0x234>
3480734c:	e3a01000 	mov	r1, #0
34807350:	e28d2030 	add	r2, sp, #48	; 0x30
34807354:	e59f30cc 	ldr	r3, [pc, #204]	; 34807428 <do_env_export+0x24c>
	envp = (env_t *)addr;

	if (chk)		/* export as checksum protected block */
		res = (char *)envp->data;
	else			/* export as raw binary data */
		res = addr;
34807358:	058d6030 	streq	r6, [sp, #48]	; 0x30

	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, argc, argv);
3480735c:	e88d0030 	stm	sp, {r4, r5}
34807360:	eb004e91 	bl	3481adac <hexport_r>
	if (len < 0) {
34807364:	e2505000 	subs	r5, r0, #0
34807368:	aa000008 	bge	34807390 <do_env_export+0x1b4>
		error("Cannot export environment: errno = %d\n", errno);
3480736c:	e59f30a0 	ldr	r3, [pc, #160]	; 34807414 <do_env_export+0x238>
34807370:	e59f00a0 	ldr	r0, [pc, #160]	; 34807418 <do_env_export+0x23c>
34807374:	e58d3000 	str	r3, [sp]
34807378:	e59f309c 	ldr	r3, [pc, #156]	; 3480741c <do_env_export+0x240>
3480737c:	e59f209c 	ldr	r2, [pc, #156]	; 34807420 <do_env_export+0x244>
34807380:	e5931000 	ldr	r1, [r3]
34807384:	e3003345 	movw	r3, #837	; 0x345
34807388:	eb000775 	bl	34809164 <printf>
3480738c:	ea000013 	b	348073e0 <do_env_export+0x204>
		return 1;
	}

	if (chk) {
34807390:	e3590000 	cmp	r9, #0
34807394:	0a000004 	beq	348073ac <do_env_export+0x1d0>
		envp->crc = crc32(0, envp->data, ENV_SIZE);
34807398:	e3a00000 	mov	r0, #0
3480739c:	e2861004 	add	r1, r6, #4
348073a0:	e59f2080 	ldr	r2, [pc, #128]	; 34807428 <do_env_export+0x24c>
348073a4:	eb004b68 	bl	3481a14c <crc32>
348073a8:	e5860000 	str	r0, [r6]
#ifdef CONFIG_ENV_ADDR_REDUND
		envp->flags = ACTIVE_FLAG;
#endif
	}
	sprintf(buf, "%zX", (size_t)(len + offsetof(env_t, data)));
348073ac:	e28d4010 	add	r4, sp, #16
348073b0:	e59f106c 	ldr	r1, [pc, #108]	; 34807424 <do_env_export+0x248>
348073b4:	e1a00004 	mov	r0, r4
348073b8:	e2852004 	add	r2, r5, #4
348073bc:	eb005659 	bl	3481cd28 <sprintf>
	setenv("filesize", buf);
348073c0:	e59f0064 	ldr	r0, [pc, #100]	; 3480742c <do_env_export+0x250>
348073c4:	e1a01004 	mov	r1, r4
348073c8:	ebffff6f 	bl	3480718c <setenv>

	return 0;
348073cc:	e3a00000 	mov	r0, #0
348073d0:	ea000005 	b	348073ec <do_env_export+0x210>

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",	cmd);
348073d4:	e59f0054 	ldr	r0, [pc, #84]	; 34807430 <do_env_export+0x254>
348073d8:	e1a0100b 	mov	r1, fp
348073dc:	eb000760 	bl	34809164 <printf>
	return 1;
348073e0:	e3a00001 	mov	r0, #1
348073e4:	ea000000 	b	348073ec <do_env_export+0x210>
		}
NXTARG:		;
	}

	if (argc < 1)
		return CMD_RET_USAGE;
348073e8:	e3e00000 	mvn	r0, #0
	return 0;

sep_err:
	printf("## %s: only one of \"-b\", \"-c\" or \"-t\" allowed\n",	cmd);
	return 1;
}
348073ec:	e28dd038 	add	sp, sp, #56	; 0x38
348073f0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (argc < 1)
		return CMD_RET_USAGE;

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
348073f4:	e3a01000 	mov	r1, #0
348073f8:	e3a02010 	mov	r2, #16
348073fc:	eb0055a3 	bl	3481ca90 <simple_strtoul>

	if (size)
34807400:	e3570000 	cmp	r7, #0
	}

	if (argc < 1)
		return CMD_RET_USAGE;

	addr = (char *)simple_strtoul(argv[0], NULL, 16);
34807404:	e58d0034 	str	r0, [sp, #52]	; 0x34

	if (size)
34807408:	0affffb2 	beq	348072d8 <do_env_export+0xfc>
3480740c:	eaffffae 	b	348072cc <do_env_export+0xf0>
34807410:	348289a4 	.word	0x348289a4
34807414:	34820228 	.word	0x34820228
34807418:	3482530a 	.word	0x3482530a
3480741c:	3482bc40 	.word	0x3482bc40
34807420:	3482514b 	.word	0x3482514b
34807424:	34825347 	.word	0x34825347
34807428:	0003fffc 	.word	0x0003fffc
3480742c:	3482318c 	.word	0x3482318c
34807430:	34825158 	.word	0x34825158

34807434 <setenv_ulong>:
 * @param varname	Environmet variable to set
 * @param value		Value to set it to
 * @return 0 if ok, 1 on error
 */
int setenv_ulong(const char *varname, ulong value)
{
34807434:	e92d4010 	push	{r4, lr}
34807438:	e1a04000 	mov	r4, r0
	/* TODO: this should be unsigned */
	char *str = simple_itoa(value);
3480743c:	e1a00001 	mov	r0, r1
34807440:	eb005657 	bl	3481cda4 <simple_itoa>
34807444:	e1a01000 	mov	r1, r0

	return setenv(varname, str);
34807448:	e1a00004 	mov	r0, r4
}
3480744c:	e8bd4010 	pop	{r4, lr}
int setenv_ulong(const char *varname, ulong value)
{
	/* TODO: this should be unsigned */
	char *str = simple_itoa(value);

	return setenv(varname, str);
34807450:	eaffff4d 	b	3480718c <setenv>

34807454 <setenv_addr>:
 * @param varname	Environmet variable to set
 * @param addr		Value to set it to
 * @return 0 if ok, 1 on error
 */
int setenv_addr(const char *varname, const void *addr)
{
34807454:	e92d4030 	push	{r4, r5, lr}
34807458:	e24dd01c 	sub	sp, sp, #28
	char str[17];

	sprintf(str, "%lx", (uintptr_t)addr);
3480745c:	e28d4004 	add	r4, sp, #4
 * @param varname	Environmet variable to set
 * @param addr		Value to set it to
 * @return 0 if ok, 1 on error
 */
int setenv_addr(const char *varname, const void *addr)
{
34807460:	e1a05000 	mov	r5, r0
34807464:	e1a02001 	mov	r2, r1
	char str[17];

	sprintf(str, "%lx", (uintptr_t)addr);
34807468:	e1a00004 	mov	r0, r4
3480746c:	e59f1014 	ldr	r1, [pc, #20]	; 34807488 <setenv_addr+0x34>
34807470:	eb00562c 	bl	3481cd28 <sprintf>
	return setenv(varname, str);
34807474:	e1a00005 	mov	r0, r5
34807478:	e1a01004 	mov	r1, r4
3480747c:	ebffff42 	bl	3480718c <setenv>
}
34807480:	e28dd01c 	add	sp, sp, #28
34807484:	e8bd8030 	pop	{r4, r5, pc}
34807488:	3482307f 	.word	0x3482307f

3480748c <envmatch>:
 * s1 is either a simple 'name', or a 'name=value' pair.
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
3480748c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34807490:	e1a05001 	mov	r5, r1
			return i2;

	if (*s1 == '\0' && env_get_char(i2-1) == '=')
		return i2;

	return -1;
34807494:	e1a06000 	mov	r6, r0
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
	while (*s1 == env_get_char(i2++))
34807498:	ea000003 	b	348074ac <envmatch+0x20>
		if (*s1++ == '=')
3480749c:	e5563001 	ldrb	r3, [r6, #-1]
348074a0:	e353003d 	cmp	r3, #61	; 0x3d
348074a4:	0a00000f 	beq	348074e8 <envmatch+0x5c>
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
	while (*s1 == env_get_char(i2++))
348074a8:	e1a05004 	mov	r5, r4
348074ac:	e1a00005 	mov	r0, r5
		if (*s1++ == '=')
348074b0:	e1a07006 	mov	r7, r6
 * i2 is the environment index for a 'name2=value2' pair.
 * If the names match, return the index for the value2, else -1.
 */
int envmatch(uchar *s1, int i2)
{
	while (*s1 == env_get_char(i2++))
348074b4:	e4d6a001 	ldrb	sl, [r6], #1
348074b8:	eb000c33 	bl	3480a58c <env_get_char>
348074bc:	e15a0000 	cmp	sl, r0
348074c0:	e2854001 	add	r4, r5, #1
348074c4:	0afffff4 	beq	3480749c <envmatch+0x10>
		if (*s1++ == '=')
			return i2;

	if (*s1 == '\0' && env_get_char(i2-1) == '=')
348074c8:	e5d73000 	ldrb	r3, [r7]
348074cc:	e3530000 	cmp	r3, #0
		return i2;

	return -1;
348074d0:	13e04000 	mvnne	r4, #0
{
	while (*s1 == env_get_char(i2++))
		if (*s1++ == '=')
			return i2;

	if (*s1 == '\0' && env_get_char(i2-1) == '=')
348074d4:	1a000003 	bne	348074e8 <envmatch+0x5c>
348074d8:	e1a00005 	mov	r0, r5
348074dc:	eb000c2a 	bl	3480a58c <env_get_char>
		return i2;

	return -1;
348074e0:	e350003d 	cmp	r0, #61	; 0x3d
348074e4:	13e04000 	mvnne	r4, #0
}
348074e8:	e1a00004 	mov	r0, r4
348074ec:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

348074f0 <getenv_f>:

/*
 * Look up variable from environment for restricted C runtime env.
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
348074f0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348074f4:	e1a05000 	mov	r5, r0
348074f8:	e1a06001 	mov	r6, r1
348074fc:	e1a0a002 	mov	sl, r2
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34807500:	e3a0b000 	mov	fp, #0
		int val, n;

		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
			if (nxt >= CONFIG_ENV_SIZE)
34807504:	e59f9098 	ldr	r9, [pc, #152]	; 348075a4 <getenv_f+0xb4>
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34807508:	ea00001d 	b	34807584 <getenv_f+0x94>
		int val, n;

		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
			if (nxt >= CONFIG_ENV_SIZE)
3480750c:	e1570009 	cmp	r7, r9
34807510:	ca000020 	bgt	34807598 <getenv_f+0xa8>
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
		int val, n;

		for (nxt = i; env_get_char(nxt) != '\0'; ++nxt) {
34807514:	e2877001 	add	r7, r7, #1
34807518:	e1a00007 	mov	r0, r7
3480751c:	eb000c1a 	bl	3480a58c <env_get_char>
34807520:	e2504000 	subs	r4, r0, #0
34807524:	1afffff8 	bne	3480750c <getenv_f+0x1c>
			if (nxt >= CONFIG_ENV_SIZE)
				return -1;
		}

		val = envmatch((uchar *)name, i);
34807528:	e1a0100b 	mov	r1, fp
3480752c:	e1a00005 	mov	r0, r5
34807530:	ebffffd5 	bl	3480748c <envmatch>
		if (val < 0)
34807534:	e250b000 	subs	fp, r0, #0
34807538:	aa000006 	bge	34807558 <getenv_f+0x68>
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
3480753c:	e287b001 	add	fp, r7, #1
34807540:	ea00000f 	b	34807584 <getenv_f+0x94>
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
			*buf = env_get_char(val++);
34807544:	eb000c10 	bl	3480a58c <env_get_char>
			if (*buf == '\0')
34807548:	e3500000 	cmp	r0, #0
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
			*buf = env_get_char(val++);
3480754c:	e4c60001 	strb	r0, [r6], #1
			if (*buf == '\0')
34807550:	0a000011 	beq	3480759c <getenv_f+0xac>
		val = envmatch((uchar *)name, i);
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
34807554:	e2844001 	add	r4, r4, #1
34807558:	e154000a 	cmp	r4, sl
}

/*
 * Look up variable from environment for restricted C runtime env.
 */
int getenv_f(const char *name, char *buf, unsigned len)
3480755c:	e084000b 	add	r0, r4, fp
		val = envmatch((uchar *)name, i);
		if (val < 0)
			continue;

		/* found; copy out */
		for (n = 0; n < len; ++n, ++buf) {
34807560:	3afffff7 	bcc	34807544 <getenv_f+0x54>
			*buf = env_get_char(val++);
			if (*buf == '\0')
				return n;
		}

		if (n)
34807564:	e3540000 	cmp	r4, #0
			*--buf = '\0';
34807568:	13a03000 	movne	r3, #0
3480756c:	15463001 	strbne	r3, [r6, #-1]

		printf("env_buf [%d bytes] too small for value of \"%s\"\n",
34807570:	e1a0100a 	mov	r1, sl
34807574:	e1a02005 	mov	r2, r5
34807578:	e59f0028 	ldr	r0, [pc, #40]	; 348075a8 <getenv_f+0xb8>
3480757c:	eb0006f8 	bl	34809164 <printf>
			len, name);

		return n;
34807580:	ea000005 	b	3480759c <getenv_f+0xac>
 */
int getenv_f(const char *name, char *buf, unsigned len)
{
	int i, nxt;

	for (i = 0; env_get_char(i) != '\0'; i = nxt + 1) {
34807584:	e1a0000b 	mov	r0, fp
34807588:	eb000bff 	bl	3480a58c <env_get_char>
3480758c:	e3500000 	cmp	r0, #0
34807590:	11a0700b 	movne	r7, fp
34807594:	1affffdf 	bne	34807518 <getenv_f+0x28>
			len, name);

		return n;
	}

	return -1;
34807598:	e3e04000 	mvn	r4, #0
}
3480759c:	e1a00004 	mov	r0, r4
348075a0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348075a4:	0003ffff 	.word	0x0003ffff
348075a8:	3482534b 	.word	0x3482534b

348075ac <getenv>:
 * Look up variable from environment,
 * return address of storage for that variable,
 * or NULL if not found
 */
char *getenv(const char *name)
{
348075ac:	e92d4010 	push	{r4, lr}
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
348075b0:	e5984004 	ldr	r4, [r8, #4]
 * Look up variable from environment,
 * return address of storage for that variable,
 * or NULL if not found
 */
char *getenv(const char *name)
{
348075b4:	e24dd018 	sub	sp, sp, #24
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
348075b8:	e2144080 	ands	r4, r4, #128	; 0x80
348075bc:	0a00000c 	beq	348075f4 <getenv+0x48>

		WATCHDOG_RESET();

		e.key	= name;
		e.data	= NULL;
		hsearch_r(e, FIND, &ep, &env_htab);
348075c0:	e59f304c 	ldr	r3, [pc, #76]	; 34807614 <getenv+0x68>
		ENTRY e, *ep;

		WATCHDOG_RESET();

		e.key	= name;
		e.data	= NULL;
348075c4:	e3a02000 	mov	r2, #0
		hsearch_r(e, FIND, &ep, &env_htab);
348075c8:	e58d3000 	str	r3, [sp]
	if (gd->flags & GD_FLG_ENV_READY) { /* after import into hashtable */
		ENTRY e, *ep;

		WATCHDOG_RESET();

		e.key	= name;
348075cc:	e58d000c 	str	r0, [sp, #12]
		e.data	= NULL;
348075d0:	e58d2010 	str	r2, [sp, #16]
		hsearch_r(e, FIND, &ep, &env_htab);
348075d4:	e28d300c 	add	r3, sp, #12
348075d8:	e8930003 	ldm	r3, {r0, r1}
348075dc:	e28d3014 	add	r3, sp, #20
348075e0:	eb004d0b 	bl	3481aa14 <hsearch_r>

		return ep ? ep->data : NULL;
348075e4:	e59d0014 	ldr	r0, [sp, #20]
348075e8:	e3500000 	cmp	r0, #0
348075ec:	15900004 	ldrne	r0, [r0, #4]
348075f0:	ea000005 	b	3480760c <getenv+0x60>
	}

	/* restricted capabilities before import */
	if (getenv_f(name, (char *)(gd->env_buf), sizeof(gd->env_buf)) > 0)
348075f4:	e2881058 	add	r1, r8, #88	; 0x58
348075f8:	e3a02020 	mov	r2, #32
348075fc:	ebffffbb 	bl	348074f0 <getenv_f>
34807600:	e3500000 	cmp	r0, #0
		return (char *)(gd->env_buf);
34807604:	c2880058 	addgt	r0, r8, #88	; 0x58

	return NULL;
34807608:	d1a00004 	movle	r0, r4
}
3480760c:	e28dd018 	add	sp, sp, #24
34807610:	e8bd8010 	pop	{r4, pc}
34807614:	348289a4 	.word	0x348289a4

34807618 <getenv_ulong>:
 * @param default_val	Default value to return if the variable is not
 *			found
 * @return the decoded value, or default_val if not found
 */
ulong getenv_ulong(const char *name, int base, ulong default_val)
{
34807618:	e92d4070 	push	{r4, r5, r6, lr}
3480761c:	e1a04001 	mov	r4, r1
34807620:	e1a05002 	mov	r5, r2
	/*
	 * We can use getenv() here, even before relocation, since the
	 * environment variable value is an integer and thus short.
	 */
	const char *str = getenv(name);
34807624:	ebffffe0 	bl	348075ac <getenv>

	return str ? simple_strtoul(str, NULL, base) : default_val;
34807628:	e3500000 	cmp	r0, #0
3480762c:	0a000003 	beq	34807640 <getenv_ulong+0x28>
34807630:	e3a01000 	mov	r1, #0
34807634:	e1a02004 	mov	r2, r4
}
34807638:	e8bd4070 	pop	{r4, r5, r6, lr}
	 * We can use getenv() here, even before relocation, since the
	 * environment variable value is an integer and thus short.
	 */
	const char *str = getenv(name);

	return str ? simple_strtoul(str, NULL, base) : default_val;
3480763c:	ea005513 	b	3481ca90 <simple_strtoul>
}
34807640:	e1a00005 	mov	r0, r5
34807644:	e8bd8070 	pop	{r4, r5, r6, pc}

34807648 <do_env_edit>:
/*
 * Interactively edit an environment variable
 */
#if defined(CONFIG_CMD_EDITENV)
int do_env_edit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34807648:	e92d4030 	push	{r4, r5, lr}
	char buffer[CONFIG_SYS_CBSIZE];
	char *init_val;

	if (argc < 2)
3480764c:	e3520001 	cmp	r2, #1
/*
 * Interactively edit an environment variable
 */
#if defined(CONFIG_CMD_EDITENV)
int do_env_edit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34807650:	e24ddf41 	sub	sp, sp, #260	; 0x104
34807654:	e1a05003 	mov	r5, r3
	char buffer[CONFIG_SYS_CBSIZE];
	char *init_val;

	if (argc < 2)
		return CMD_RET_USAGE;
34807658:	d3e00000 	mvnle	r0, #0
int do_env_edit(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	char buffer[CONFIG_SYS_CBSIZE];
	char *init_val;

	if (argc < 2)
3480765c:	da00000f 	ble	348076a0 <do_env_edit+0x58>
		return CMD_RET_USAGE;

	/* Set read buffer to initial value or empty sting */
	init_val = getenv(argv[1]);
34807660:	e5930004 	ldr	r0, [r3, #4]
34807664:	ebffffd0 	bl	348075ac <getenv>
	if (init_val)
34807668:	e2502000 	subs	r2, r0, #0
		sprintf(buffer, "%s", init_val);
	else
		buffer[0] = '\0';
3480766c:	05cd2000 	strbeq	r2, [sp]
	if (argc < 2)
		return CMD_RET_USAGE;

	/* Set read buffer to initial value or empty sting */
	init_val = getenv(argv[1]);
	if (init_val)
34807670:	0a000002 	beq	34807680 <do_env_edit+0x38>
		sprintf(buffer, "%s", init_val);
34807674:	e1a0000d 	mov	r0, sp
34807678:	e59f1028 	ldr	r1, [pc, #40]	; 348076a8 <do_env_edit+0x60>
3480767c:	eb0055a9 	bl	3481cd28 <sprintf>
	else
		buffer[0] = '\0';

	readline_into_buffer("edit: ", buffer, 0);
34807680:	e1a0100d 	mov	r1, sp
34807684:	e59f0020 	ldr	r0, [pc, #32]	; 348076ac <do_env_edit+0x64>
34807688:	e3a02000 	mov	r2, #0
3480768c:	eb0017b0 	bl	3480d554 <readline_into_buffer>

	return setenv(argv[1], buffer);
34807690:	e5950004 	ldr	r0, [r5, #4]
34807694:	e1a0100d 	mov	r1, sp
	if (init_val)
		sprintf(buffer, "%s", init_val);
	else
		buffer[0] = '\0';

	readline_into_buffer("edit: ", buffer, 0);
34807698:	e1a0400d 	mov	r4, sp

	return setenv(argv[1], buffer);
3480769c:	ebfffeba 	bl	3480718c <setenv>
}
348076a0:	e28ddf41 	add	sp, sp, #260	; 0x104
348076a4:	e8bd8030 	pop	{r4, r5, pc}
348076a8:	34824a4b 	.word	0x34824a4b
348076ac:	3482537b 	.word	0x3482537b

348076b0 <do_onenand>:

static int do_onenand(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *c;

	if (argc < 2)
348076b0:	e3520001 	cmp	r2, #1
	fixup_cmdtable(cmd_onenand_sub, ARRAY_SIZE(cmd_onenand_sub));
}
#endif

static int do_onenand(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348076b4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
348076b8:	e1a05000 	mov	r5, r0
348076bc:	e1a06001 	mov	r6, r1
348076c0:	e1a04002 	mov	r4, r2
	cmd_tbl_t *c;

	if (argc < 2)
		return CMD_RET_USAGE;
348076c4:	d3e00000 	mvnle	r0, #0

static int do_onenand(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	cmd_tbl_t *c;

	if (argc < 2)
348076c8:	d8bd80f8 	pople	{r3, r4, r5, r6, r7, pc}
		return CMD_RET_USAGE;

	mtd = &onenand_mtd;
348076cc:	e59f1044 	ldr	r1, [pc, #68]	; 34807718 <do_onenand+0x68>
348076d0:	e59f2044 	ldr	r2, [pc, #68]	; 3480771c <do_onenand+0x6c>

	/* Strip off leading 'onenand' command argument */
	argc--;
	argv++;

	c = find_cmd_tbl(argv[0], &cmd_onenand_sub[0], ARRAY_SIZE(cmd_onenand_sub));
348076d4:	e5930004 	ldr	r0, [r3, #4]
	cmd_tbl_t *c;

	if (argc < 2)
		return CMD_RET_USAGE;

	mtd = &onenand_mtd;
348076d8:	e5821000 	str	r1, [r2]

	/* Strip off leading 'onenand' command argument */
	argc--;
	argv++;

	c = find_cmd_tbl(argv[0], &cmd_onenand_sub[0], ARRAY_SIZE(cmd_onenand_sub));
348076dc:	e59f103c 	ldr	r1, [pc, #60]	; 34807720 <do_onenand+0x70>
348076e0:	e3a02009 	mov	r2, #9

	mtd = &onenand_mtd;

	/* Strip off leading 'onenand' command argument */
	argc--;
	argv++;
348076e4:	e2837004 	add	r7, r3, #4

	c = find_cmd_tbl(argv[0], &cmd_onenand_sub[0], ARRAY_SIZE(cmd_onenand_sub));
348076e8:	eb000515 	bl	34808b44 <find_cmd_tbl>

	if (c)
348076ec:	e3500000 	cmp	r0, #0
348076f0:	0a000006 	beq	34807710 <do_onenand+0x60>
		return c->cmd(cmdtp, flag, argc, argv);
348076f4:	e590c00c 	ldr	ip, [r0, #12]
348076f8:	e1a01006 	mov	r1, r6
348076fc:	e1a00005 	mov	r0, r5
34807700:	e2442001 	sub	r2, r4, #1
34807704:	e1a03007 	mov	r3, r7
34807708:	e12fff3c 	blx	ip
3480770c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	else
		return CMD_RET_USAGE;
34807710:	e3e00000 	mvn	r0, #0
}
34807714:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34807718:	3482bac0 	.word	0x3482bac0
3480771c:	34829d60 	.word	0x34829d60
34807720:	348284b8 	.word	0x348284b8

34807724 <str2long>:

static loff_t next_ofs;
static loff_t skip_ofs;

static inline int str2long(char *p, ulong *num)
{
34807724:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
34807728:	e1a05001 	mov	r5, r1
	char *endptr;

	*num = simple_strtoul(p, &endptr, 16);
3480772c:	e3a02010 	mov	r2, #16
34807730:	e28d1004 	add	r1, sp, #4

static loff_t next_ofs;
static loff_t skip_ofs;

static inline int str2long(char *p, ulong *num)
{
34807734:	e1a04000 	mov	r4, r0
	char *endptr;

	*num = simple_strtoul(p, &endptr, 16);
34807738:	eb0054d4 	bl	3481ca90 <simple_strtoul>
3480773c:	e5850000 	str	r0, [r5]
	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
34807740:	e5d40000 	ldrb	r0, [r4]
34807744:	e3500000 	cmp	r0, #0
34807748:	0a000003 	beq	3480775c <str2long+0x38>
3480774c:	e59d3004 	ldr	r3, [sp, #4]
static struct mtd_info *mtd;

static loff_t next_ofs;
static loff_t skip_ofs;

static inline int str2long(char *p, ulong *num)
34807750:	e5d30000 	ldrb	r0, [r3]
34807754:	e2700001 	rsbs	r0, r0, #1
34807758:	33a00000 	movcc	r0, #0
{
	char *endptr;

	*num = simple_strtoul(p, &endptr, 16);
	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
}
3480775c:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}

34807760 <do_onenand_markbad>:

	return ret == 0 ? 1 : 0;
}

static int do_onenand_markbad(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34807760:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int ret = 0;
	ulong addr;

	argc -= 2;
34807764:	e2425002 	sub	r5, r2, #2
	argv += 2;

	if (argc <= 0)
34807768:	e3550000 	cmp	r5, #0
		return CMD_RET_USAGE;
3480776c:	d3e04000 	mvnle	r4, #0
	ulong addr;

	argc -= 2;
	argv += 2;

	if (argc <= 0)
34807770:	da00001a 	ble	348077e0 <do_onenand_markbad+0x80>
		return CMD_RET_USAGE;

	while (argc > 0) {
		addr = simple_strtoul(*argv, NULL, 16);

		if (mtd->block_markbad(mtd, addr)) {
34807774:	e59fa06c 	ldr	sl, [pc, #108]	; 348077e8 <do_onenand_markbad+0x88>
		ret = onenand_dump(mtd, ofs, 0);

	return ret == 0 ? 1 : 0;
}

static int do_onenand_markbad(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
34807778:	e2836004 	add	r6, r3, #4
3480777c:	e3a04000 	mov	r4, #0

	if (argc <= 0)
		return CMD_RET_USAGE;

	while (argc > 0) {
		addr = simple_strtoul(*argv, NULL, 16);
34807780:	e3a01000 	mov	r1, #0
34807784:	e3a02010 	mov	r2, #16
34807788:	e5b60004 	ldr	r0, [r6, #4]!
3480778c:	eb0054bf 	bl	3481ca90 <simple_strtoul>
34807790:	e1a07000 	mov	r7, r0

		if (mtd->block_markbad(mtd, addr)) {
34807794:	e59a0000 	ldr	r0, [sl]
34807798:	e1a02007 	mov	r2, r7
3480779c:	e590107c 	ldr	r1, [r0, #124]	; 0x7c
348077a0:	e3a03000 	mov	r3, #0
348077a4:	e12fff31 	blx	r1
348077a8:	e3500000 	cmp	r0, #0
348077ac:	0a000005 	beq	348077c8 <do_onenand_markbad+0x68>
			printf("block 0x%08lx NOT marked "
348077b0:	e1a02004 	mov	r2, r4
348077b4:	e59f0030 	ldr	r0, [pc, #48]	; 348077ec <do_onenand_markbad+0x8c>
348077b8:	e1a01007 	mov	r1, r7
348077bc:	eb000668 	bl	34809164 <printf>
				"as bad! ERROR %d\n",
				addr, ret);
			ret = 1;
348077c0:	e3a04001 	mov	r4, #1
348077c4:	ea000002 	b	348077d4 <do_onenand_markbad+0x74>
		} else {
			printf("block 0x%08lx successfully "
348077c8:	e59f0020 	ldr	r0, [pc, #32]	; 348077f0 <do_onenand_markbad+0x90>
348077cc:	e1a01007 	mov	r1, r7
348077d0:	eb000663 	bl	34809164 <printf>
				"marked as bad\n",
				addr);
		}
		--argc;
348077d4:	e2455001 	sub	r5, r5, #1
	argv += 2;

	if (argc <= 0)
		return CMD_RET_USAGE;

	while (argc > 0) {
348077d8:	e3550000 	cmp	r5, #0
348077dc:	caffffe7 	bgt	34807780 <do_onenand_markbad+0x20>
		}
		--argc;
		++argv;
	}
	return ret;
}
348077e0:	e1a00004 	mov	r0, r4
348077e4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
348077e8:	34829d60 	.word	0x34829d60
348077ec:	348257c3 	.word	0x348257c3
348077f0:	348257ee 	.word	0x348257ee

348077f4 <do_onenand_bad>:
	printf("%s\n", mtd->name);
	return 0;
}

static int do_onenand_bad(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348077f4:	e92d4038 	push	{r3, r4, r5, lr}
	ulong ofs;

	mtd = &onenand_mtd;
348077f8:	e59f3070 	ldr	r3, [pc, #112]	; 34807870 <do_onenand_bad+0x7c>
348077fc:	e59f5070 	ldr	r5, [pc, #112]	; 34807874 <do_onenand_bad+0x80>
	/* Currently only one OneNAND device is supported */
	printf("\nDevice %d bad blocks:\n", 0);
34807800:	e59f0070 	ldr	r0, [pc, #112]	; 34807878 <do_onenand_bad+0x84>
34807804:	e3a01000 	mov	r1, #0

static int do_onenand_bad(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	ulong ofs;

	mtd = &onenand_mtd;
34807808:	e5853000 	str	r3, [r5]
	/* Currently only one OneNAND device is supported */
	printf("\nDevice %d bad blocks:\n", 0);
	for (ofs = 0; ofs < mtd->size; ofs += mtd->erasesize) {
3480780c:	e3a04000 	mov	r4, #0
{
	ulong ofs;

	mtd = &onenand_mtd;
	/* Currently only one OneNAND device is supported */
	printf("\nDevice %d bad blocks:\n", 0);
34807810:	eb000653 	bl	34809164 <printf>
	for (ofs = 0; ofs < mtd->size; ofs += mtd->erasesize) {
34807814:	ea00000b 	b	34807848 <do_onenand_bad+0x54>
		if (mtd->block_isbad(mtd, ofs))
34807818:	e5901078 	ldr	r1, [r0, #120]	; 0x78
3480781c:	e1a02004 	mov	r2, r4
34807820:	e3a03000 	mov	r3, #0
34807824:	e12fff31 	blx	r1
34807828:	e3500000 	cmp	r0, #0
3480782c:	0a000002 	beq	3480783c <do_onenand_bad+0x48>
			printf("  %08x\n", (u32)ofs);
34807830:	e59f0044 	ldr	r0, [pc, #68]	; 3480787c <do_onenand_bad+0x88>
34807834:	e1a01004 	mov	r1, r4
34807838:	eb000649 	bl	34809164 <printf>
	ulong ofs;

	mtd = &onenand_mtd;
	/* Currently only one OneNAND device is supported */
	printf("\nDevice %d bad blocks:\n", 0);
	for (ofs = 0; ofs < mtd->size; ofs += mtd->erasesize) {
3480783c:	e5953000 	ldr	r3, [r5]
34807840:	e5933010 	ldr	r3, [r3, #16]
34807844:	e0844003 	add	r4, r4, r3
34807848:	e5950000 	ldr	r0, [r5]
3480784c:	e590300c 	ldr	r3, [r0, #12]
34807850:	e3530000 	cmp	r3, #0
34807854:	8affffef 	bhi	34807818 <do_onenand_bad+0x24>
34807858:	1a000002 	bne	34807868 <do_onenand_bad+0x74>
3480785c:	e5903008 	ldr	r3, [r0, #8]
34807860:	e1530004 	cmp	r3, r4
34807864:	8affffeb 	bhi	34807818 <do_onenand_bad+0x24>
		if (mtd->block_isbad(mtd, ofs))
			printf("  %08x\n", (u32)ofs);
	}

	return 0;
}
34807868:	e3a00000 	mov	r0, #0
3480786c:	e8bd8038 	pop	{r3, r4, r5, pc}
34807870:	3482bac0 	.word	0x3482bac0
34807874:	34829d60 	.word	0x34829d60
34807878:	34825818 	.word	0x34825818
3480787c:	3482644f 	.word	0x3482644f

34807880 <do_onenand_info>:

	return 0;
}

static int do_onenand_info(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34807880:	e92d4008 	push	{r3, lr}
	printf("%s\n", mtd->name);
34807884:	e59f3014 	ldr	r3, [pc, #20]	; 348078a0 <do_onenand_info+0x20>
34807888:	e59f0014 	ldr	r0, [pc, #20]	; 348078a4 <do_onenand_info+0x24>
3480788c:	e5933000 	ldr	r3, [r3]
34807890:	e5931020 	ldr	r1, [r3, #32]
34807894:	eb000632 	bl	34809164 <printf>
	return 0;
}
34807898:	e3a00000 	mov	r0, #0
3480789c:	e8bd8008 	pop	{r3, pc}
348078a0:	34829d60 	.word	0x34829d60
348078a4:	34825ea6 	.word	0x34825ea6

348078a8 <arg_off_size>:
	*num = simple_strtoul(p, &endptr, 16);
	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
}

static int arg_off_size(int argc, char * const argv[], ulong *off, size_t *size)
{
348078a8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	if (argc >= 1) {
348078ac:	e2507000 	subs	r7, r0, #0
	*num = simple_strtoul(p, &endptr, 16);
	return (*p != '\0' && *endptr == '\0') ? 1 : 0;
}

static int arg_off_size(int argc, char * const argv[], ulong *off, size_t *size)
{
348078b0:	e1a04001 	mov	r4, r1
348078b4:	e1a05002 	mov	r5, r2
348078b8:	e1a06003 	mov	r6, r3
	if (argc >= 1) {
348078bc:	da000007 	ble	348078e0 <arg_off_size+0x38>
		if (!(str2long(argv[0], off))) {
348078c0:	e5910000 	ldr	r0, [r1]
348078c4:	e1a01002 	mov	r1, r2
348078c8:	ebffff95 	bl	34807724 <str2long>
348078cc:	e3500000 	cmp	r0, #0
			printf("'%s' is not a number\n", argv[0]);
348078d0:	059f00d0 	ldreq	r0, [pc, #208]	; 348079a8 <arg_off_size+0x100>
348078d4:	05941000 	ldreq	r1, [r4]
}

static int arg_off_size(int argc, char * const argv[], ulong *off, size_t *size)
{
	if (argc >= 1) {
		if (!(str2long(argv[0], off))) {
348078d8:	1a000003 	bne	348078ec <arg_off_size+0x44>
348078dc:	ea00000b 	b	34807910 <arg_off_size+0x68>
			printf("'%s' is not a number\n", argv[0]);
			return -1;
		}
	} else {
		*off = 0;
348078e0:	e3a03000 	mov	r3, #0
348078e4:	e5823000 	str	r3, [r2]
348078e8:	ea00000a 	b	34807918 <arg_off_size+0x70>
	}

	if (argc >= 2) {
348078ec:	e3570001 	cmp	r7, #1
348078f0:	0a000008 	beq	34807918 <arg_off_size+0x70>
		if (!(str2long(argv[1], (ulong *)size))) {
348078f4:	e5940004 	ldr	r0, [r4, #4]
348078f8:	e1a01006 	mov	r1, r6
348078fc:	ebffff88 	bl	34807724 <str2long>
34807900:	e3500000 	cmp	r0, #0
34807904:	1a000009 	bne	34807930 <arg_off_size+0x88>
			printf("'%s' is not a number\n", argv[1]);
34807908:	e59f0098 	ldr	r0, [pc, #152]	; 348079a8 <arg_off_size+0x100>
3480790c:	e5941004 	ldr	r1, [r4, #4]
34807910:	eb000613 	bl	34809164 <printf>
34807914:	ea000014 	b	3480796c <arg_off_size+0xc4>
			return -1;
		}
	} else {
		*size = mtd->size - *off;
34807918:	e59f308c 	ldr	r3, [pc, #140]	; 348079ac <arg_off_size+0x104>
3480791c:	e5933000 	ldr	r3, [r3]
34807920:	e5932008 	ldr	r2, [r3, #8]
34807924:	e5953000 	ldr	r3, [r5]
34807928:	e0633002 	rsb	r3, r3, r2
3480792c:	e5863000 	str	r3, [r6]
	}

	if ((*off + *size) > mtd->size) {
34807930:	e59f3074 	ldr	r3, [pc, #116]	; 348079ac <arg_off_size+0x104>
34807934:	e5951000 	ldr	r1, [r5]
34807938:	e5933000 	ldr	r3, [r3]
3480793c:	e5962000 	ldr	r2, [r6]
34807940:	e593400c 	ldr	r4, [r3, #12]
34807944:	e593c008 	ldr	ip, [r3, #8]
34807948:	e3a03000 	mov	r3, #0
3480794c:	e1530004 	cmp	r3, r4
34807950:	e0820001 	add	r0, r2, r1
34807954:	1a000006 	bne	34807974 <arg_off_size+0xcc>
34807958:	e150000c 	cmp	r0, ip
3480795c:	9a000004 	bls	34807974 <arg_off_size+0xcc>
		printf("total chip size (0x%llx) exceeded!\n", mtd->size);
34807960:	e59f0048 	ldr	r0, [pc, #72]	; 348079b0 <arg_off_size+0x108>
34807964:	e1a0200c 	mov	r2, ip
34807968:	eb0005fd 	bl	34809164 <printf>
		return -1;
3480796c:	e3e00000 	mvn	r0, #0
34807970:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	}

	if (*size == mtd->size)
34807974:	e152000c 	cmp	r2, ip
34807978:	1a000006 	bne	34807998 <arg_off_size+0xf0>
3480797c:	e3a03000 	mov	r3, #0
34807980:	e1530004 	cmp	r3, r4
34807984:	1a000003 	bne	34807998 <arg_off_size+0xf0>
		puts("whole chip\n");
34807988:	e59f0024 	ldr	r0, [pc, #36]	; 348079b4 <arg_off_size+0x10c>
3480798c:	eb0005ea 	bl	3480913c <puts>
	else
		printf("offset 0x%lx, size 0x%x\n", *off, *size);

	return 0;
34807990:	e1a00004 	mov	r0, r4
34807994:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	}

	if (*size == mtd->size)
		puts("whole chip\n");
	else
		printf("offset 0x%lx, size 0x%x\n", *off, *size);
34807998:	e59f0018 	ldr	r0, [pc, #24]	; 348079b8 <arg_off_size+0x110>
3480799c:	eb0005f0 	bl	34809164 <printf>

	return 0;
348079a0:	e3a00000 	mov	r0, #0
}
348079a4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
348079a8:	34825830 	.word	0x34825830
348079ac:	34829d60 	.word	0x34829d60
348079b0:	34825846 	.word	0x34825846
348079b4:	3482586a 	.word	0x3482586a
348079b8:	34825876 	.word	0x34825876

348079bc <do_onenand_read>:

	return 0;
}

static int do_onenand_read(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348079bc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	ulong addr, ofs;
	size_t len;
	int ret = 0;
	size_t retlen = 0;

	if (argc < 3)
348079c0:	e3520002 	cmp	r2, #2

	return 0;
}

static int do_onenand_read(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348079c4:	e24dd048 	sub	sp, sp, #72	; 0x48
348079c8:	e1a04002 	mov	r4, r2
348079cc:	e1a06003 	mov	r6, r3
	size_t len;
	int ret = 0;
	size_t retlen = 0;

	if (argc < 3)
		return CMD_RET_USAGE;
348079d0:	d3e00000 	mvnle	r0, #0
	ulong addr, ofs;
	size_t len;
	int ret = 0;
	size_t retlen = 0;

	if (argc < 3)
348079d4:	da000065 	ble	34807b70 <do_onenand_read+0x1b4>
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
348079d8:	e5930000 	ldr	r0, [r3]
348079dc:	e3a0102e 	mov	r1, #46	; 0x2e
348079e0:	eb005081 	bl	3481bbec <strchr>
	if ((s != NULL) && (!strcmp(s, ".oob")))
348079e4:	e2503000 	subs	r3, r0, #0
}

static int do_onenand_read(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	char *s;
	int oob = 0;
348079e8:	058d300c 	streq	r3, [sp, #12]

	if (argc < 3)
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
	if ((s != NULL) && (!strcmp(s, ".oob")))
348079ec:	0a000004 	beq	34807a04 <do_onenand_read+0x48>
348079f0:	e59f1180 	ldr	r1, [pc, #384]	; 34807b78 <do_onenand_read+0x1bc>
348079f4:	eb00505e 	bl	3481bb74 <strcmp>
}

static int do_onenand_read(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	char *s;
	int oob = 0;
348079f8:	e2700001 	rsbs	r0, r0, #1
348079fc:	33a00000 	movcc	r0, #0
34807a00:	e58d000c 	str	r0, [sp, #12]

	s = strchr(argv[0], '.');
	if ((s != NULL) && (!strcmp(s, ".oob")))
		oob = 1;

	addr = (ulong)simple_strtoul(argv[1], NULL, 16);
34807a04:	e3a01000 	mov	r1, #0
34807a08:	e3a02010 	mov	r2, #16
34807a0c:	e5960004 	ldr	r0, [r6, #4]
34807a10:	eb00541e 	bl	3481ca90 <simple_strtoul>
34807a14:	e1a07000 	mov	r7, r0

	printf("\nOneNAND read: ");
34807a18:	e59f015c 	ldr	r0, [pc, #348]	; 34807b7c <do_onenand_read+0x1c0>
34807a1c:	eb0005d0 	bl	34809164 <printf>
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
34807a20:	e2861008 	add	r1, r6, #8
34807a24:	e2440002 	sub	r0, r4, #2
34807a28:	e28d2044 	add	r2, sp, #68	; 0x44
34807a2c:	e28d3040 	add	r3, sp, #64	; 0x40
34807a30:	ebffff9c 	bl	348078a8 <arg_off_size>
34807a34:	e2501000 	subs	r1, r0, #0
		return 1;
34807a38:	13a00001 	movne	r0, #1
		oob = 1;

	addr = (ulong)simple_strtoul(argv[1], NULL, 16);

	printf("\nOneNAND read: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
34807a3c:	1a00004b 	bne	34807b70 <do_onenand_read+0x1b4>
}

static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
34807a40:	e59f3138 	ldr	r3, [pc, #312]	; 34807b80 <do_onenand_read+0x1c4>
	int blocks = (int) len >> this->erase_shift;
	int blocksize = (1 << this->erase_shift);
34807a44:	e3a0a001 	mov	sl, #1
}

static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
34807a48:	e5933000 	ldr	r3, [r3]
	int blocks = (int) len >> this->erase_shift;
34807a4c:	e59db040 	ldr	fp, [sp, #64]	; 0x40
}

static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
34807a50:	e5933094 	ldr	r3, [r3, #148]	; 0x94
	int blocks = (int) len >> this->erase_shift;
	int blocksize = (1 << this->erase_shift);
	loff_t ofs = from;
	struct mtd_oob_ops ops = {
34807a54:	e3a02020 	mov	r2, #32
}

static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
34807a58:	e58d301c 	str	r3, [sp, #28]
	int blocks = (int) len >> this->erase_shift;
34807a5c:	e5933030 	ldr	r3, [r3, #48]	; 0x30
	int blocksize = (1 << this->erase_shift);
	loff_t ofs = from;
	struct mtd_oob_ops ops = {
34807a60:	e28d0020 	add	r0, sp, #32
static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
	int blocks = (int) len >> this->erase_shift;
	int blocksize = (1 << this->erase_shift);
34807a64:	e1a0a31a 	lsl	sl, sl, r3

	printf("\nOneNAND read: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_read(ofs, len, &retlen, (u8 *)addr, oob);
34807a68:	e59d4044 	ldr	r4, [sp, #68]	; 0x44

static int onenand_block_read(loff_t from, size_t len,
			      size_t *retlen, u_char *buf, int oob)
{
	struct onenand_chip *this = mtd->priv;
	int blocks = (int) len >> this->erase_shift;
34807a6c:	e1a0b35b 	asr	fp, fp, r3
	int blocksize = (1 << this->erase_shift);
	loff_t ofs = from;
	struct mtd_oob_ops ops = {
34807a70:	eb005113 	bl	3481bec4 <memset>
		.retlen		= 0,
	};
	int ret;

	if (oob)
34807a74:	e59d200c 	ldr	r2, [sp, #12]

	printf("\nOneNAND read: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_read(ofs, len, &retlen, (u8 *)addr, oob);
34807a78:	e3a05000 	mov	r5, #0
	struct mtd_oob_ops ops = {
		.retlen		= 0,
	};
	int ret;

	if (oob)
34807a7c:	e3520000 	cmp	r2, #0
34807a80:	e1a0200a 	mov	r2, sl
34807a84:	e1a03fc2 	asr	r3, r2, #31
		ops.ooblen = blocksize;
	else
		ops.len = blocksize;
34807a88:	058da024 	streq	sl, [sp, #36]	; 0x24
		.retlen		= 0,
	};
	int ret;

	if (oob)
		ops.ooblen = blocksize;
34807a8c:	158da02c 	strne	sl, [sp, #44]	; 0x2c
	if (argc < 3)
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
	if ((s != NULL) && (!strcmp(s, ".oob")))
		oob = 1;
34807a90:	e3a09000 	mov	r9, #0
		ops.ooblen = blocksize;
	else
		ops.len = blocksize;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
34807a94:	e59f60e4 	ldr	r6, [pc, #228]	; 34807b80 <do_onenand_read+0x1c4>
34807a98:	e1cd21f0 	strd	r2, [sp, #16]
34807a9c:	ea00002c 	b	34807b54 <do_onenand_read+0x198>
34807aa0:	e5960000 	ldr	r0, [r6]
34807aa4:	e1a02004 	mov	r2, r4
34807aa8:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34807aac:	e1a03005 	mov	r3, r5
34807ab0:	e12fff31 	blx	r1
		if (ret) {
34807ab4:	e3500000 	cmp	r0, #0
34807ab8:	0a000008 	beq	34807ae0 <do_onenand_read+0x124>
			printk("Bad blocks %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34807abc:	e59d301c 	ldr	r3, [sp, #28]
34807ac0:	e1a00004 	mov	r0, r4
34807ac4:	e5932030 	ldr	r2, [r3, #48]	; 0x30
34807ac8:	e1a01005 	mov	r1, r5
34807acc:	eb00614d 	bl	34820008 <__ashrdi3>
		ops.len = blocksize;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printk("Bad blocks %d at 0x%x\n",
34807ad0:	e1a02004 	mov	r2, r4
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34807ad4:	e1a01000 	mov	r1, r0
		ops.len = blocksize;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printk("Bad blocks %d at 0x%x\n",
34807ad8:	e59f00a4 	ldr	r0, [pc, #164]	; 34807b84 <do_onenand_read+0x1c8>
34807adc:	ea000010 	b	34807b24 <do_onenand_read+0x168>
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			ofs += blocksize;
			continue;
		}

		if (oob)
34807ae0:	e59d300c 	ldr	r3, [sp, #12]
			ops.oobbuf = buf;
		else
			ops.datbuf = buf;

		ops.retlen = 0;
		ret = mtd->read_oob(mtd, ofs, &ops);
34807ae4:	e5960000 	ldr	r0, [r6]
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			ofs += blocksize;
			continue;
		}

		if (oob)
34807ae8:	e3530000 	cmp	r3, #0
			ops.oobbuf = buf;
		else
			ops.datbuf = buf;

		ops.retlen = 0;
		ret = mtd->read_oob(mtd, ofs, &ops);
34807aec:	e28d3020 	add	r3, sp, #32
34807af0:	e58d3000 	str	r3, [sp]
		if (oob)
			ops.oobbuf = buf;
		else
			ops.datbuf = buf;

		ops.retlen = 0;
34807af4:	e3a02000 	mov	r2, #0
			ofs += blocksize;
			continue;
		}

		if (oob)
			ops.oobbuf = buf;
34807af8:	158d703c 	strne	r7, [sp, #60]	; 0x3c
		else
			ops.datbuf = buf;
34807afc:	058d7038 	streq	r7, [sp, #56]	; 0x38

		ops.retlen = 0;
34807b00:	e58d2028 	str	r2, [sp, #40]	; 0x28
		ret = mtd->read_oob(mtd, ofs, &ops);
34807b04:	e590104c 	ldr	r1, [r0, #76]	; 0x4c
34807b08:	e1a02004 	mov	r2, r4
34807b0c:	e1a03005 	mov	r3, r5
34807b10:	e12fff31 	blx	r1
		if (ret) {
34807b14:	e2502000 	subs	r2, r0, #0
34807b18:	0a000006 	beq	34807b38 <do_onenand_read+0x17c>
			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
34807b1c:	e59f0064 	ldr	r0, [pc, #100]	; 34807b88 <do_onenand_read+0x1cc>
34807b20:	e1a01004 	mov	r1, r4
34807b24:	eb00058e 	bl	34809164 <printf>
			ofs += blocksize;
34807b28:	e1cd21d0 	ldrd	r2, [sp, #16]
34807b2c:	e0944002 	adds	r4, r4, r2
34807b30:	e0a55003 	adc	r5, r5, r3
34807b34:	ea000006 	b	34807b54 <do_onenand_read+0x198>
			continue;
		}
		ofs += blocksize;
34807b38:	e1cd21d0 	ldrd	r2, [sp, #16]
34807b3c:	e0944002 	adds	r4, r4, r2
34807b40:	e0a55003 	adc	r5, r5, r3
		buf += blocksize;
		blocks--;
		*retlen += ops.retlen;
34807b44:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
			ofs += blocksize;
			continue;
		}
		ofs += blocksize;
		buf += blocksize;
34807b48:	e087700a 	add	r7, r7, sl
		blocks--;
34807b4c:	e24bb001 	sub	fp, fp, #1
		*retlen += ops.retlen;
34807b50:	e0899003 	add	r9, r9, r3
	if (oob)
		ops.ooblen = blocksize;
	else
		ops.len = blocksize;

	while (blocks) {
34807b54:	e35b0000 	cmp	fp, #0
34807b58:	1affffd0 	bne	34807aa0 <do_onenand_read+0xe4>
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_read(ofs, len, &retlen, (u8 *)addr, oob);

	printf(" %d bytes read: %s\n", retlen, ret ? "ERROR" : "OK");
34807b5c:	e59f0028 	ldr	r0, [pc, #40]	; 34807b8c <do_onenand_read+0x1d0>
34807b60:	e1a01009 	mov	r1, r9
34807b64:	e59f2024 	ldr	r2, [pc, #36]	; 34807b90 <do_onenand_read+0x1d4>
34807b68:	eb00057d 	bl	34809164 <printf>

	return ret == 0 ? 0 : 1;
34807b6c:	e1a0000b 	mov	r0, fp
}
34807b70:	e28dd048 	add	sp, sp, #72	; 0x48
34807b74:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34807b78:	3482588f 	.word	0x3482588f
34807b7c:	34825894 	.word	0x34825894
34807b80:	34829d60 	.word	0x34829d60
34807b84:	348258a4 	.word	0x348258a4
34807b88:	348258bb 	.word	0x348258bb
34807b8c:	348258d1 	.word	0x348258d1
34807b90:	34824048 	.word	0x34824048

34807b94 <onenand_dump>:

	return 0;
}

static int onenand_dump(struct mtd_info *mtd, ulong off, int only_oob)
{
34807b94:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34807b98:	e1a06000 	mov	r6, r0
	int i;
	u_char *datbuf, *oobbuf, *p;
	struct mtd_oob_ops ops;
	loff_t addr;

	datbuf = malloc(mtd->writesize + mtd->oobsize);
34807b9c:	e5963014 	ldr	r3, [r6, #20]
34807ba0:	e5900018 	ldr	r0, [r0, #24]

	return 0;
}

static int onenand_dump(struct mtd_info *mtd, ulong off, int only_oob)
{
34807ba4:	e24dd058 	sub	sp, sp, #88	; 0x58
	int i;
	u_char *datbuf, *oobbuf, *p;
	struct mtd_oob_ops ops;
	loff_t addr;

	datbuf = malloc(mtd->writesize + mtd->oobsize);
34807ba8:	e0800003 	add	r0, r0, r3

	return 0;
}

static int onenand_dump(struct mtd_info *mtd, ulong off, int only_oob)
{
34807bac:	e1a09001 	mov	r9, r1
34807bb0:	e1a0b002 	mov	fp, r2
	int i;
	u_char *datbuf, *oobbuf, *p;
	struct mtd_oob_ops ops;
	loff_t addr;

	datbuf = malloc(mtd->writesize + mtd->oobsize);
34807bb4:	eb000731 	bl	34809880 <malloc>
34807bb8:	e1a05000 	mov	r5, r0
	oobbuf = malloc(mtd->oobsize);
34807bbc:	e5960018 	ldr	r0, [r6, #24]
34807bc0:	eb00072e 	bl	34809880 <malloc>
	if (!datbuf || !oobbuf) {
34807bc4:	e3550000 	cmp	r5, #0
34807bc8:	13500000 	cmpne	r0, #0
34807bcc:	e1a07000 	mov	r7, r0
34807bd0:	13a04000 	movne	r4, #0
34807bd4:	03a04001 	moveq	r4, #1
34807bd8:	1a000002 	bne	34807be8 <onenand_dump+0x54>
		puts("No memory for page buffer\n");
34807bdc:	e59f01b4 	ldr	r0, [pc, #436]	; 34807d98 <onenand_dump+0x204>
34807be0:	eb000555 	bl	3480913c <puts>
34807be4:	ea00001d 	b	34807c60 <onenand_dump+0xcc>
		return 1;
	}
	off &= ~(mtd->writesize - 1);
34807be8:	e596a014 	ldr	sl, [r6, #20]
	addr = (loff_t) off;
	memset(&ops, 0, sizeof(ops));
34807bec:	e1a01004 	mov	r1, r4
	oobbuf = malloc(mtd->oobsize);
	if (!datbuf || !oobbuf) {
		puts("No memory for page buffer\n");
		return 1;
	}
	off &= ~(mtd->writesize - 1);
34807bf0:	e26aa000 	rsb	sl, sl, #0
34807bf4:	e009a00a 	and	sl, r9, sl
	addr = (loff_t) off;
	memset(&ops, 0, sizeof(ops));
34807bf8:	e28d9038 	add	r9, sp, #56	; 0x38
34807bfc:	e3a02020 	mov	r2, #32
34807c00:	e1a00009 	mov	r0, r9
34807c04:	eb0050ae 	bl	3481bec4 <memset>
	ops.datbuf = datbuf;
	ops.oobbuf = oobbuf;
	ops.len = mtd->writesize;
34807c08:	e5963014 	ldr	r3, [r6, #20]
		return 1;
	}
	off &= ~(mtd->writesize - 1);
	addr = (loff_t) off;
	memset(&ops, 0, sizeof(ops));
	ops.datbuf = datbuf;
34807c0c:	e58d5050 	str	r5, [sp, #80]	; 0x50
	ops.oobbuf = oobbuf;
	ops.len = mtd->writesize;
34807c10:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	ops.ooblen = mtd->oobsize;
34807c14:	e5963018 	ldr	r3, [r6, #24]
	ops.retlen = 0;
	i = mtd->read_oob(mtd, addr, &ops);
34807c18:	e58d9000 	str	r9, [sp]
	addr = (loff_t) off;
	memset(&ops, 0, sizeof(ops));
	ops.datbuf = datbuf;
	ops.oobbuf = oobbuf;
	ops.len = mtd->writesize;
	ops.ooblen = mtd->oobsize;
34807c1c:	e58d3044 	str	r3, [sp, #68]	; 0x44
	ops.retlen = 0;
	i = mtd->read_oob(mtd, addr, &ops);
34807c20:	e596104c 	ldr	r1, [r6, #76]	; 0x4c
	}
	off &= ~(mtd->writesize - 1);
	addr = (loff_t) off;
	memset(&ops, 0, sizeof(ops));
	ops.datbuf = datbuf;
	ops.oobbuf = oobbuf;
34807c24:	e58d7054 	str	r7, [sp, #84]	; 0x54
	ops.len = mtd->writesize;
	ops.ooblen = mtd->oobsize;
	ops.retlen = 0;
34807c28:	e58d4040 	str	r4, [sp, #64]	; 0x40
	i = mtd->read_oob(mtd, addr, &ops);
34807c2c:	e1a00006 	mov	r0, r6
34807c30:	e1a0200a 	mov	r2, sl
34807c34:	e1a03004 	mov	r3, r4
34807c38:	e12fff31 	blx	r1
	if (i < 0) {
34807c3c:	e2501000 	subs	r1, r0, #0
34807c40:	aa000008 	bge	34807c68 <onenand_dump+0xd4>
		printf("Error (%d) reading page %08lx\n", i, off);
34807c44:	e1a0200a 	mov	r2, sl
34807c48:	e59f014c 	ldr	r0, [pc, #332]	; 34807d9c <onenand_dump+0x208>
34807c4c:	eb000544 	bl	34809164 <printf>
		free(datbuf);
34807c50:	e1a00005 	mov	r0, r5
34807c54:	eb000680 	bl	3480965c <free>
		free(oobbuf);
34807c58:	e1a00007 	mov	r0, r7
34807c5c:	eb00067e 	bl	3480965c <free>
		return 1;
34807c60:	e3a00001 	mov	r0, #1
34807c64:	ea000049 	b	34807d90 <onenand_dump+0x1fc>
	}
	printf("Page %08lx dump:\n", off);
34807c68:	e1a0100a 	mov	r1, sl
34807c6c:	e59f012c 	ldr	r0, [pc, #300]	; 34807da0 <onenand_dump+0x20c>
34807c70:	eb00053b 	bl	34809164 <printf>
	i = mtd->writesize >> 4;
34807c74:	e596a014 	ldr	sl, [r6, #20]
	p = datbuf;

	while (i--) {
34807c78:	e1a04005 	mov	r4, r5
		free(datbuf);
		free(oobbuf);
		return 1;
	}
	printf("Page %08lx dump:\n", off);
	i = mtd->writesize >> 4;
34807c7c:	e1a0a22a 	lsr	sl, sl, #4
	p = datbuf;

	while (i--) {
34807c80:	ea000022 	b	34807d10 <onenand_dump+0x17c>
		if (!only_oob)
34807c84:	e35b0000 	cmp	fp, #0
34807c88:	1a00001e 	bne	34807d08 <onenand_dump+0x174>
			printf("\t%02x %02x %02x %02x %02x %02x %02x %02x"
34807c8c:	e5d40003 	ldrb	r0, [r4, #3]
34807c90:	e5d41000 	ldrb	r1, [r4]
34807c94:	e5d42001 	ldrb	r2, [r4, #1]
34807c98:	e5d43002 	ldrb	r3, [r4, #2]
34807c9c:	e58d0000 	str	r0, [sp]
34807ca0:	e5d40004 	ldrb	r0, [r4, #4]
34807ca4:	e58d0004 	str	r0, [sp, #4]
34807ca8:	e5d40005 	ldrb	r0, [r4, #5]
34807cac:	e58d0008 	str	r0, [sp, #8]
34807cb0:	e5d40006 	ldrb	r0, [r4, #6]
34807cb4:	e58d000c 	str	r0, [sp, #12]
34807cb8:	e5d40007 	ldrb	r0, [r4, #7]
34807cbc:	e58d0010 	str	r0, [sp, #16]
34807cc0:	e5d40008 	ldrb	r0, [r4, #8]
34807cc4:	e58d0014 	str	r0, [sp, #20]
34807cc8:	e5d40009 	ldrb	r0, [r4, #9]
34807ccc:	e58d0018 	str	r0, [sp, #24]
34807cd0:	e5d4000a 	ldrb	r0, [r4, #10]
34807cd4:	e58d001c 	str	r0, [sp, #28]
34807cd8:	e5d4000b 	ldrb	r0, [r4, #11]
34807cdc:	e58d0020 	str	r0, [sp, #32]
34807ce0:	e5d4000c 	ldrb	r0, [r4, #12]
34807ce4:	e58d0024 	str	r0, [sp, #36]	; 0x24
34807ce8:	e5d4000d 	ldrb	r0, [r4, #13]
34807cec:	e58d0028 	str	r0, [sp, #40]	; 0x28
34807cf0:	e5d4000e 	ldrb	r0, [r4, #14]
34807cf4:	e58d002c 	str	r0, [sp, #44]	; 0x2c
34807cf8:	e5d4000f 	ldrb	r0, [r4, #15]
34807cfc:	e58d0030 	str	r0, [sp, #48]	; 0x30
34807d00:	e59f009c 	ldr	r0, [pc, #156]	; 34807da4 <onenand_dump+0x210>
34807d04:	eb000516 	bl	34809164 <printf>
			       "  %02x %02x %02x %02x %02x %02x %02x %02x\n",
			       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
			       p[8], p[9], p[10], p[11], p[12], p[13], p[14],
			       p[15]);
		p += 16;
34807d08:	e2844010 	add	r4, r4, #16
34807d0c:	e24aa001 	sub	sl, sl, #1
	}
	printf("Page %08lx dump:\n", off);
	i = mtd->writesize >> 4;
	p = datbuf;

	while (i--) {
34807d10:	e35a0000 	cmp	sl, #0
34807d14:	1affffda 	bne	34807c84 <onenand_dump+0xf0>
			       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7],
			       p[8], p[9], p[10], p[11], p[12], p[13], p[14],
			       p[15]);
		p += 16;
	}
	puts("OOB:\n");
34807d18:	e59f0088 	ldr	r0, [pc, #136]	; 34807da8 <onenand_dump+0x214>
34807d1c:	eb000506 	bl	3480913c <puts>
	i = mtd->oobsize >> 3;
34807d20:	e5966018 	ldr	r6, [r6, #24]
34807d24:	e1a04007 	mov	r4, r7
34807d28:	e1a061a6 	lsr	r6, r6, #3
	p = oobbuf;

	while (i--) {
34807d2c:	ea00000f 	b	34807d70 <onenand_dump+0x1dc>
		printf("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
34807d30:	e5540005 	ldrb	r0, [r4, #-5]
34807d34:	e5541008 	ldrb	r1, [r4, #-8]
34807d38:	e5542007 	ldrb	r2, [r4, #-7]
34807d3c:	e5543006 	ldrb	r3, [r4, #-6]
34807d40:	e58d0000 	str	r0, [sp]
34807d44:	e5540004 	ldrb	r0, [r4, #-4]
34807d48:	e2466001 	sub	r6, r6, #1
34807d4c:	e58d0004 	str	r0, [sp, #4]
34807d50:	e5540003 	ldrb	r0, [r4, #-3]
34807d54:	e58d0008 	str	r0, [sp, #8]
34807d58:	e5540002 	ldrb	r0, [r4, #-2]
34807d5c:	e58d000c 	str	r0, [sp, #12]
34807d60:	e5540001 	ldrb	r0, [r4, #-1]
34807d64:	e58d0010 	str	r0, [sp, #16]
34807d68:	e59f003c 	ldr	r0, [pc, #60]	; 34807dac <onenand_dump+0x218>
34807d6c:	eb0004fc 	bl	34809164 <printf>
	}
	puts("OOB:\n");
	i = mtd->oobsize >> 3;
	p = oobbuf;

	while (i--) {
34807d70:	e3560000 	cmp	r6, #0
		printf("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
34807d74:	e2844008 	add	r4, r4, #8
	}
	puts("OOB:\n");
	i = mtd->oobsize >> 3;
	p = oobbuf;

	while (i--) {
34807d78:	1affffec 	bne	34807d30 <onenand_dump+0x19c>
		printf("\t%02x %02x %02x %02x %02x %02x %02x %02x\n",
		       p[0], p[1], p[2], p[3], p[4], p[5], p[6], p[7]);
		p += 8;
	}
	free(datbuf);
34807d7c:	e1a00005 	mov	r0, r5
34807d80:	eb000635 	bl	3480965c <free>
	free(oobbuf);
34807d84:	e1a00007 	mov	r0, r7
34807d88:	eb000633 	bl	3480965c <free>

	return 0;
34807d8c:	e1a00006 	mov	r0, r6
}
34807d90:	e28dd058 	add	sp, sp, #88	; 0x58
34807d94:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34807d98:	348258e5 	.word	0x348258e5
34807d9c:	34825900 	.word	0x34825900
34807da0:	3482591f 	.word	0x3482591f
34807da4:	34825931 	.word	0x34825931
34807da8:	34825984 	.word	0x34825984
34807dac:	3482598a 	.word	0x3482598a

34807db0 <do_onenand_dump>:
{
	ulong ofs;
	int ret = 0;
	char *s;

	if (argc < 2)
34807db0:	e3520001 	cmp	r2, #1

	return ret == 0 ? 0 : 1;
}

static int do_onenand_dump(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34807db4:	e92d4038 	push	{r3, r4, r5, lr}
34807db8:	e1a05003 	mov	r5, r3
	ulong ofs;
	int ret = 0;
	char *s;

	if (argc < 2)
34807dbc:	da00001b 	ble	34807e30 <do_onenand_dump+0x80>
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
34807dc0:	e5930000 	ldr	r0, [r3]
34807dc4:	e3a0102e 	mov	r1, #46	; 0x2e
34807dc8:	eb004f87 	bl	3481bbec <strchr>
	ofs = (int)simple_strtoul(argv[1], NULL, 16);
34807dcc:	e3a01000 	mov	r1, #0
	char *s;

	if (argc < 2)
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
34807dd0:	e1a04000 	mov	r4, r0
	ofs = (int)simple_strtoul(argv[1], NULL, 16);
34807dd4:	e3a02010 	mov	r2, #16
34807dd8:	e5950004 	ldr	r0, [r5, #4]
34807ddc:	eb00532b 	bl	3481ca90 <simple_strtoul>

	if (s != NULL && strcmp(s, ".oob") == 0)
34807de0:	e3540000 	cmp	r4, #0

	if (argc < 2)
		return CMD_RET_USAGE;

	s = strchr(argv[0], '.');
	ofs = (int)simple_strtoul(argv[1], NULL, 16);
34807de4:	e1a05000 	mov	r5, r0

	if (s != NULL && strcmp(s, ".oob") == 0)
34807de8:	0a000008 	beq	34807e10 <do_onenand_dump+0x60>
34807dec:	e1a00004 	mov	r0, r4
34807df0:	e59f1040 	ldr	r1, [pc, #64]	; 34807e38 <do_onenand_dump+0x88>
34807df4:	eb004f5e 	bl	3481bb74 <strcmp>
34807df8:	e3500000 	cmp	r0, #0
		ret = onenand_dump(mtd, ofs, 1);
34807dfc:	059f3038 	ldreq	r3, [pc, #56]	; 34807e3c <do_onenand_dump+0x8c>
34807e00:	01a01005 	moveq	r1, r5
34807e04:	05930000 	ldreq	r0, [r3]
34807e08:	03a02001 	moveq	r2, #1
34807e0c:	0a000003 	beq	34807e20 <do_onenand_dump+0x70>
	else
		ret = onenand_dump(mtd, ofs, 0);
34807e10:	e59f3024 	ldr	r3, [pc, #36]	; 34807e3c <do_onenand_dump+0x8c>
34807e14:	e1a01005 	mov	r1, r5
34807e18:	e5930000 	ldr	r0, [r3]
34807e1c:	e3a02000 	mov	r2, #0
34807e20:	ebffff5b 	bl	34807b94 <onenand_dump>

	return ret == 0 ? 1 : 0;
34807e24:	e2700001 	rsbs	r0, r0, #1
34807e28:	33a00000 	movcc	r0, #0
34807e2c:	e8bd8038 	pop	{r3, r4, r5, pc}
	ulong ofs;
	int ret = 0;
	char *s;

	if (argc < 2)
		return CMD_RET_USAGE;
34807e30:	e3e00000 	mvn	r0, #0
		ret = onenand_dump(mtd, ofs, 1);
	else
		ret = onenand_dump(mtd, ofs, 0);

	return ret == 0 ? 1 : 0;
}
34807e34:	e8bd8038 	pop	{r3, r4, r5, pc}
34807e38:	3482588f 	.word	0x3482588f
34807e3c:	34829d60 	.word	0x34829d60

34807e40 <do_onenand_test>:

	return ret == 0 ? 0 : 1;
}

static int do_onenand_test(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34807e40:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	 * Syntax is:
	 *   0       1     2       3    4
	 *   onenand test [force] [off size]
	 */

	printf("\nOneNAND test: ");
34807e44:	e59f0258 	ldr	r0, [pc, #600]	; 348080a4 <do_onenand_test+0x264>

	return ret == 0 ? 0 : 1;
}

static int do_onenand_test(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
34807e48:	e24dd078 	sub	sp, sp, #120	; 0x78
34807e4c:	e1a04002 	mov	r4, r2
34807e50:	e1a06003 	mov	r6, r3
	 * Syntax is:
	 *   0       1     2       3    4
	 *   onenand test [force] [off size]
	 */

	printf("\nOneNAND test: ");
34807e54:	eb0004c2 	bl	34809164 <printf>

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
34807e58:	e2861004 	add	r1, r6, #4
34807e5c:	e2440001 	sub	r0, r4, #1
34807e60:	e28d2074 	add	r2, sp, #116	; 0x74
34807e64:	e28d3070 	add	r3, sp, #112	; 0x70
34807e68:	ebfffe8e 	bl	348078a8 <arg_off_size>
34807e6c:	e2501000 	subs	r1, r0, #0
		return 1;
34807e70:	13a00001 	movne	r0, #1
	 */

	printf("\nOneNAND test: ");

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
34807e74:	1a000088 	bne	3480809c <do_onenand_test+0x25c>
	return 0;
}

static int onenand_block_test(u32 start, u32 size)
{
	struct onenand_chip *this = mtd->priv;
34807e78:	e59f6228 	ldr	r6, [pc, #552]	; 348080a8 <do_onenand_test+0x268>
	struct erase_info instr = {
34807e7c:	e3a02048 	mov	r2, #72	; 0x48
	return 0;
}

static int onenand_block_test(u32 start, u32 size)
{
	struct onenand_chip *this = mtd->priv;
34807e80:	e5963000 	ldr	r3, [r6]
	struct erase_info instr = {
34807e84:	e28d0020 	add	r0, sp, #32
	return 0;
}

static int onenand_block_test(u32 start, u32 size)
{
	struct onenand_chip *this = mtd->priv;
34807e88:	e5937094 	ldr	r7, [r3, #148]	; 0x94

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_test(ofs, len);
34807e8c:	e59d4074 	ldr	r4, [sp, #116]	; 0x74
34807e90:	e59db070 	ldr	fp, [sp, #112]	; 0x70
}

static int onenand_block_test(u32 start, u32 size)
{
	struct onenand_chip *this = mtd->priv;
	struct erase_info instr = {
34807e94:	eb00500a 	bl	3481bec4 <memset>
		.priv		= 0,
	};

	int blocks;
	loff_t ofs;
	int blocksize = 1 << this->erase_shift;
34807e98:	e5973030 	ldr	r3, [r7, #48]	; 0x30
34807e9c:	e3a0a001 	mov	sl, #1
34807ea0:	e1a0a31a 	lsl	sl, sl, r3
	size_t retlen;
	u_char *buf;
	u_char *verify_buf;
	int ret;

	buf = malloc(blocksize);
34807ea4:	e1a0000a 	mov	r0, sl
34807ea8:	eb000674 	bl	34809880 <malloc>
	if (!buf) {
34807eac:	e3500000 	cmp	r0, #0
34807eb0:	e58d0010 	str	r0, [sp, #16]
34807eb4:	0a000004 	beq	34807ecc <do_onenand_test+0x8c>
		printf("Not enough malloc space available!\n");
		return -1;
	}

	verify_buf = malloc(blocksize);
34807eb8:	e1a0000a 	mov	r0, sl
34807ebc:	eb00066f 	bl	34809880 <malloc>
	if (!verify_buf) {
34807ec0:	e3500000 	cmp	r0, #0
34807ec4:	e58d0014 	str	r0, [sp, #20]
34807ec8:	1a000004 	bne	34807ee0 <do_onenand_test+0xa0>
		printf("Not enough malloc space available!\n");
34807ecc:	e59f01d8 	ldr	r0, [pc, #472]	; 348080ac <do_onenand_test+0x26c>
34807ed0:	eb0004a3 	bl	34809164 <printf>
	start_block = start >> this->erase_shift;
	end_block = (start + size) >> this->erase_shift;

	/* Protect boot-loader from badblock testing */
	if (start_block < 2)
		start_block = 2;
34807ed4:	e3e04000 	mvn	r4, #0
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_test(ofs, len);

	printf("%s\n", ret ? "ERROR" : "OK");
34807ed8:	e59f11d0 	ldr	r1, [pc, #464]	; 348080b0 <do_onenand_test+0x270>
34807edc:	ea00006b 	b	34808090 <do_onenand_test+0x250>
	if (!verify_buf) {
		printf("Not enough malloc space available!\n");
		return -1;
	}

	start_block = start >> this->erase_shift;
34807ee0:	e5972030 	ldr	r2, [r7, #48]	; 0x30

	/* Protect boot-loader from badblock testing */
	if (start_block < 2)
		start_block = 2;

	if (end_block > (mtd->size >> this->erase_shift))
34807ee4:	e5963000 	ldr	r3, [r6]
		printf("Not enough malloc space available!\n");
		return -1;
	}

	start_block = start >> this->erase_shift;
	end_block = (start + size) >> this->erase_shift;
34807ee8:	e08bb004 	add	fp, fp, r4
34807eec:	e1a0b23b 	lsr	fp, fp, r2

	/* Protect boot-loader from badblock testing */
	if (start_block < 2)
		start_block = 2;

	if (end_block > (mtd->size >> this->erase_shift))
34807ef0:	e1c300d8 	ldrd	r0, [r3, #8]
	if (!verify_buf) {
		printf("Not enough malloc space available!\n");
		return -1;
	}

	start_block = start >> this->erase_shift;
34807ef4:	e1a09234 	lsr	r9, r4, r2

	/* Protect boot-loader from badblock testing */
	if (start_block < 2)
		start_block = 2;

	if (end_block > (mtd->size >> this->erase_shift))
34807ef8:	eb00603b 	bl	3481ffec <__lshrdi3>
34807efc:	e1a0200b 	mov	r2, fp
34807f00:	e1a03fc2 	asr	r3, r2, #31
	start_block = start >> this->erase_shift;
	end_block = (start + size) >> this->erase_shift;

	/* Protect boot-loader from badblock testing */
	if (start_block < 2)
		start_block = 2;
34807f04:	e3590002 	cmp	r9, #2
34807f08:	b3a09002 	movlt	r9, #2

	if (end_block > (mtd->size >> this->erase_shift))
34807f0c:	e1530001 	cmp	r3, r1
34807f10:	8a000002 	bhi	34807f20 <do_onenand_test+0xe0>
34807f14:	1a000002 	bne	34807f24 <do_onenand_test+0xe4>
34807f18:	e1520000 	cmp	r2, r0
34807f1c:	9a000000 	bls	34807f24 <do_onenand_test+0xe4>
		end_block = mtd->size >> this->erase_shift;
34807f20:	e1a0b000 	mov	fp, r0
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			goto next;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34807f24:	e1a0200a 	mov	r2, sl
34807f28:	e1a03fc2 	asr	r3, r2, #31

	if (end_block > (mtd->size >> this->erase_shift))
		end_block = mtd->size >> this->erase_shift;

	blocks = start_block;
	ofs = start;
34807f2c:	e3a05000 	mov	r5, #0
	while (blocks < end_block) {
		printf("\rTesting block %d at 0x%x", (u32)(ofs >> this->erase_shift), (u32)ofs);

		ret = mtd->block_isbad(mtd, ofs);
34807f30:	e59f6170 	ldr	r6, [pc, #368]	; 348080a8 <do_onenand_test+0x268>
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			goto next;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34807f34:	e1cd21f8 	strd	r2, [sp, #24]
34807f38:	ea00004a 	b	34808068 <do_onenand_test+0x228>
		end_block = mtd->size >> this->erase_shift;

	blocks = start_block;
	ofs = start;
	while (blocks < end_block) {
		printf("\rTesting block %d at 0x%x", (u32)(ofs >> this->erase_shift), (u32)ofs);
34807f3c:	e5972030 	ldr	r2, [r7, #48]	; 0x30
34807f40:	e1a00004 	mov	r0, r4
34807f44:	e1a01005 	mov	r1, r5
34807f48:	eb00602e 	bl	34820008 <__ashrdi3>
34807f4c:	e1a02004 	mov	r2, r4
34807f50:	e1a01000 	mov	r1, r0
34807f54:	e59f0158 	ldr	r0, [pc, #344]	; 348080b4 <do_onenand_test+0x274>
34807f58:	eb000481 	bl	34809164 <printf>

		ret = mtd->block_isbad(mtd, ofs);
34807f5c:	e5960000 	ldr	r0, [r6]
34807f60:	e1a02004 	mov	r2, r4
34807f64:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34807f68:	e1a03005 	mov	r3, r5
34807f6c:	e12fff31 	blx	r1
		if (ret) {
34807f70:	e3500000 	cmp	r0, #0
34807f74:	0a000007 	beq	34807f98 <do_onenand_test+0x158>
			printf("Skip erase bad block %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34807f78:	e5972030 	ldr	r2, [r7, #48]	; 0x30
34807f7c:	e1a00004 	mov	r0, r4
34807f80:	e1a01005 	mov	r1, r5
34807f84:	eb00601f 	bl	34820008 <__ashrdi3>
	while (blocks < end_block) {
		printf("\rTesting block %d at 0x%x", (u32)(ofs >> this->erase_shift), (u32)ofs);

		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printf("Skip erase bad block %d at 0x%x\n",
34807f88:	e1a02004 	mov	r2, r4
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34807f8c:	e1a01000 	mov	r1, r0
	while (blocks < end_block) {
		printf("\rTesting block %d at 0x%x", (u32)(ofs >> this->erase_shift), (u32)ofs);

		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printf("Skip erase bad block %d at 0x%x\n",
34807f90:	e59f0120 	ldr	r0, [pc, #288]	; 348080b8 <do_onenand_test+0x278>
34807f94:	ea00000a 	b	34807fc4 <do_onenand_test+0x184>
			goto next;
		}

		instr.addr = ofs;
		instr.len = blocksize;
		ret = mtd->erase(mtd, &instr);
34807f98:	e5960000 	ldr	r0, [r6]
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			goto next;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34807f9c:	e1cd21d8 	ldrd	r2, [sp, #24]
			printf("Skip erase bad block %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			goto next;
		}

		instr.addr = ofs;
34807fa0:	e1cd42f8 	strd	r4, [sp, #40]	; 0x28
		instr.len = blocksize;
34807fa4:	e1cd23f0 	strd	r2, [sp, #48]	; 0x30
		ret = mtd->erase(mtd, &instr);
34807fa8:	e28d1020 	add	r1, sp, #32
34807fac:	e5903034 	ldr	r3, [r0, #52]	; 0x34
34807fb0:	e12fff33 	blx	r3
		if (ret) {
34807fb4:	e2502000 	subs	r2, r0, #0
34807fb8:	0a000003 	beq	34807fcc <do_onenand_test+0x18c>
			printk("Erase failed 0x%x, %d\n", (u32)ofs, ret);
34807fbc:	e59f00f8 	ldr	r0, [pc, #248]	; 348080bc <do_onenand_test+0x27c>
34807fc0:	e1a01004 	mov	r1, r4
34807fc4:	eb000466 	bl	34809164 <printf>
34807fc8:	ea000022 	b	34808058 <do_onenand_test+0x218>
			goto next;
		}

		ret = mtd->write(mtd, ofs, blocksize, &retlen, buf);
34807fcc:	e59d2010 	ldr	r2, [sp, #16]
34807fd0:	e5960000 	ldr	r0, [r6]
34807fd4:	e28d306c 	add	r3, sp, #108	; 0x6c
34807fd8:	e58d3004 	str	r3, [sp, #4]
34807fdc:	e58d2008 	str	r2, [sp, #8]
34807fe0:	e58da000 	str	sl, [sp]
34807fe4:	e1a02004 	mov	r2, r4
34807fe8:	e5901044 	ldr	r1, [r0, #68]	; 0x44
34807fec:	e1a03005 	mov	r3, r5
34807ff0:	e12fff31 	blx	r1
		if (ret) {
34807ff4:	e2502000 	subs	r2, r0, #0
			printk("Write failed 0x%x, %d\n", (u32)ofs, ret);
34807ff8:	159f00c0 	ldrne	r0, [pc, #192]	; 348080c0 <do_onenand_test+0x280>
			printk("Erase failed 0x%x, %d\n", (u32)ofs, ret);
			goto next;
		}

		ret = mtd->write(mtd, ofs, blocksize, &retlen, buf);
		if (ret) {
34807ffc:	1affffef 	bne	34807fc0 <do_onenand_test+0x180>
			printk("Write failed 0x%x, %d\n", (u32)ofs, ret);
			goto next;
		}

		ret = mtd->read(mtd, ofs, blocksize, &retlen, verify_buf);
34808000:	e59d2014 	ldr	r2, [sp, #20]
34808004:	e5960000 	ldr	r0, [r6]
34808008:	e28d306c 	add	r3, sp, #108	; 0x6c
3480800c:	e58d3004 	str	r3, [sp, #4]
34808010:	e58d2008 	str	r2, [sp, #8]
34808014:	e58da000 	str	sl, [sp]
34808018:	e1a02004 	mov	r2, r4
3480801c:	e5901040 	ldr	r1, [r0, #64]	; 0x40
34808020:	e1a03005 	mov	r3, r5
34808024:	e12fff31 	blx	r1
		if (ret) {
34808028:	e2502000 	subs	r2, r0, #0
			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
3480802c:	159f0090 	ldrne	r0, [pc, #144]	; 348080c4 <do_onenand_test+0x284>
			printk("Write failed 0x%x, %d\n", (u32)ofs, ret);
			goto next;
		}

		ret = mtd->read(mtd, ofs, blocksize, &retlen, verify_buf);
		if (ret) {
34808030:	1affffe2 	bne	34807fc0 <do_onenand_test+0x180>
			printk("Read failed 0x%x, %d\n", (u32)ofs, ret);
			goto next;
		}

		if (memcmp(buf, verify_buf, blocksize))
34808034:	e59d0010 	ldr	r0, [sp, #16]
34808038:	e59d1014 	ldr	r1, [sp, #20]
3480803c:	e1a0200a 	mov	r2, sl
34808040:	eb004ff6 	bl	3481c020 <memcmp>
34808044:	e3500000 	cmp	r0, #0
34808048:	0a000002 	beq	34808058 <do_onenand_test+0x218>
			printk("\nRead/Write test failed at 0x%x\n", (u32)ofs);
3480804c:	e59f0074 	ldr	r0, [pc, #116]	; 348080c8 <do_onenand_test+0x288>
34808050:	e1a01004 	mov	r1, r4
34808054:	eb000442 	bl	34809164 <printf>

next:
		ofs += blocksize;
34808058:	e1cd21d8 	ldrd	r2, [sp, #24]
3480805c:	e0944002 	adds	r4, r4, r2
34808060:	e0a55003 	adc	r5, r5, r3
		blocks++;
34808064:	e2899001 	add	r9, r9, #1
	if (end_block > (mtd->size >> this->erase_shift))
		end_block = mtd->size >> this->erase_shift;

	blocks = start_block;
	ofs = start;
	while (blocks < end_block) {
34808068:	e159000b 	cmp	r9, fp
3480806c:	baffffb2 	blt	34807f3c <do_onenand_test+0xfc>

next:
		ofs += blocksize;
		blocks++;
	}
	printf("...Done\n");
34808070:	e59f0054 	ldr	r0, [pc, #84]	; 348080cc <do_onenand_test+0x28c>
34808074:	eb00043a 	bl	34809164 <printf>

	free(buf);
34808078:	e59d0010 	ldr	r0, [sp, #16]
3480807c:	eb000576 	bl	3480965c <free>
	free(verify_buf);
34808080:	e59d0014 	ldr	r0, [sp, #20]
34808084:	eb000574 	bl	3480965c <free>
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_test(ofs, len);

	printf("%s\n", ret ? "ERROR" : "OK");
34808088:	e59f1040 	ldr	r1, [pc, #64]	; 348080d0 <do_onenand_test+0x290>
	printf("...Done\n");

	free(buf);
	free(verify_buf);

	return 0;
3480808c:	e3a04000 	mov	r4, #0
	if (arg_off_size(argc - 1, argv + 1, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_test(ofs, len);

	printf("%s\n", ret ? "ERROR" : "OK");
34808090:	e59f003c 	ldr	r0, [pc, #60]	; 348080d4 <do_onenand_test+0x294>
34808094:	eb000432 	bl	34809164 <printf>

	return ret == 0 ? 0 : 1;
34808098:	e2640000 	rsb	r0, r4, #0
}
3480809c:	e28dd078 	add	sp, sp, #120	; 0x78
348080a0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348080a4:	348259b4 	.word	0x348259b4
348080a8:	34829d60 	.word	0x34829d60
348080ac:	348259c4 	.word	0x348259c4
348080b0:	3482404b 	.word	0x3482404b
348080b4:	348259e8 	.word	0x348259e8
348080b8:	34825a02 	.word	0x34825a02
348080bc:	34825a23 	.word	0x34825a23
348080c0:	34825a3a 	.word	0x34825a3a
348080c4:	348258bb 	.word	0x348258bb
348080c8:	34825a51 	.word	0x34825a51
348080cc:	34825a72 	.word	0x34825a72
348080d0:	34824048 	.word	0x34824048
348080d4:	34825ea6 	.word	0x34825ea6

348080d8 <do_onenand_write>:

	return ret == 0 ? 0 : 1;
}

static int do_onenand_write(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348080d8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	ulong addr, ofs;
	size_t len;
	int ret = 0, withoob = 0;
	size_t retlen = 0;

	if (argc < 3)
348080dc:	e3520002 	cmp	r2, #2

	return ret == 0 ? 0 : 1;
}

static int do_onenand_write(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348080e0:	e24dd078 	sub	sp, sp, #120	; 0x78
348080e4:	e1a04002 	mov	r4, r2
348080e8:	e1a07003 	mov	r7, r3
	size_t len;
	int ret = 0, withoob = 0;
	size_t retlen = 0;

	if (argc < 3)
		return CMD_RET_USAGE;
348080ec:	d3e00000 	mvnle	r0, #0
	ulong addr, ofs;
	size_t len;
	int ret = 0, withoob = 0;
	size_t retlen = 0;

	if (argc < 3)
348080f0:	da0000b5 	ble	348083cc <do_onenand_write+0x2f4>
		return CMD_RET_USAGE;

	if (strncmp(argv[0] + 6, "yaffs", 5) == 0)
348080f4:	e5930000 	ldr	r0, [r3]
348080f8:	e59f12d4 	ldr	r1, [pc, #724]	; 348083d4 <do_onenand_write+0x2fc>
348080fc:	e3a02005 	mov	r2, #5
34808100:	e2800006 	add	r0, r0, #6
34808104:	eb004ea6 	bl	3481bba4 <strncmp>
		withoob = 1;

	addr = (ulong)simple_strtoul(argv[1], NULL, 16);
34808108:	e3a01000 	mov	r1, #0
3480810c:	e3a02010 	mov	r2, #16
	size_t retlen = 0;

	if (argc < 3)
		return CMD_RET_USAGE;

	if (strncmp(argv[0] + 6, "yaffs", 5) == 0)
34808110:	e58d001c 	str	r0, [sp, #28]
		withoob = 1;

	addr = (ulong)simple_strtoul(argv[1], NULL, 16);
34808114:	e5970004 	ldr	r0, [r7, #4]
34808118:	eb00525c 	bl	3481ca90 <simple_strtoul>
3480811c:	e1a06000 	mov	r6, r0

	printf("\nOneNAND write: ");
34808120:	e59f02b0 	ldr	r0, [pc, #688]	; 348083d8 <do_onenand_write+0x300>
34808124:	eb00040e 	bl	34809164 <printf>
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
34808128:	e2440002 	sub	r0, r4, #2
3480812c:	e2871008 	add	r1, r7, #8
34808130:	e28d2074 	add	r2, sp, #116	; 0x74
34808134:	e28d3070 	add	r3, sp, #112	; 0x70
34808138:	ebfffdda 	bl	348078a8 <arg_off_size>
3480813c:	e3500000 	cmp	r0, #0
		return 1;
34808140:	13a00001 	movne	r0, #1
		withoob = 1;

	addr = (ulong)simple_strtoul(argv[1], NULL, 16);

	printf("\nOneNAND write: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
34808144:	1a0000a0 	bne	348083cc <do_onenand_write+0x2f4>
}

static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
34808148:	e59fc28c 	ldr	ip, [pc, #652]	; 348083dc <do_onenand_write+0x304>

	printf("\nOneNAND write: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);
3480814c:	e59d1070 	ldr	r1, [sp, #112]	; 0x70
}

static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
34808150:	e59c3000 	ldr	r3, [ip]

	printf("\nOneNAND write: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);
34808154:	e59d4074 	ldr	r4, [sp, #116]	; 0x74
}

static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
34808158:	e5933094 	ldr	r3, [r3, #148]	; 0x94

	printf("\nOneNAND write: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);
3480815c:	e3a05000 	mov	r5, #0
}

static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
34808160:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	int blocks = len >> this->erase_shift;
34808164:	e5933030 	ldr	r3, [r3, #48]	; 0x30

	printf("\nOneNAND write: ");
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);
34808168:	e58d6014 	str	r6, [sp, #20]

static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
	int blocks = len >> this->erase_shift;
3480816c:	e1a02331 	lsr	r2, r1, r3
34808170:	e58d2018 	str	r2, [sp, #24]
	int blocksize = (1 << this->erase_shift);
34808174:	e3a02001 	mov	r2, #1
34808178:	e1a02312 	lsl	r2, r2, r3
	loff_t ofs;
	size_t _retlen = 0;
	int ret;

	if (to == next_ofs) {
3480817c:	e59c3008 	ldr	r3, [ip, #8]
static int onenand_block_write(loff_t to, size_t len,
			       size_t *retlen, const u_char * buf, int withoob)
{
	struct onenand_chip *this = mtd->priv;
	int blocks = len >> this->erase_shift;
	int blocksize = (1 << this->erase_shift);
34808180:	e58d2024 	str	r2, [sp, #36]	; 0x24
	loff_t ofs;
	size_t _retlen = 0;
	int ret;

	if (to == next_ofs) {
34808184:	e1530004 	cmp	r3, r4
{
	struct onenand_chip *this = mtd->priv;
	int blocks = len >> this->erase_shift;
	int blocksize = (1 << this->erase_shift);
	loff_t ofs;
	size_t _retlen = 0;
34808188:	e58d006c 	str	r0, [sp, #108]	; 0x6c
	int ret;

	if (to == next_ofs) {
3480818c:	1a000010 	bne	348081d4 <do_onenand_write+0xfc>
34808190:	e59c300c 	ldr	r3, [ip, #12]
34808194:	e3530000 	cmp	r3, #0
34808198:	1a00000d 	bne	348081d4 <do_onenand_write+0xfc>
		next_ofs = to + len;
3480819c:	e0942001 	adds	r2, r4, r1
348081a0:	e2a53000 	adc	r3, r5, #0
348081a4:	e1cc20f8 	strd	r2, [ip, #8]
		to += skip_ofs;
348081a8:	e1cc21d0 	ldrd	r2, [ip, #16]
348081ac:	e0944002 	adds	r4, r4, r2
348081b0:	e0a55003 	adc	r5, r5, r3
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
		else
			ret = onenand_write_oneblock_withoob(ofs, buf, &_retlen);
		if (ret) {
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
348081b4:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
		if (ret)
			break;
		to += mtd->writesize;
	}

	*retlen = (ret) ? 0 : mtd->erasesize;
348081b8:	e3a03000 	mov	r3, #0
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
		else
			ret = onenand_write_oneblock_withoob(ofs, buf, &_retlen);
		if (ret) {
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
348081bc:	e1a00001 	mov	r0, r1
348081c0:	e1a01fc0 	asr	r1, r0, #31
		if (ret)
			break;
		to += mtd->writesize;
	}

	*retlen = (ret) ? 0 : mtd->erasesize;
348081c4:	e58d3020 	str	r3, [sp, #32]
		skip_ofs = 0;
	}
	ofs = to;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
348081c8:	e59f620c 	ldr	r6, [pc, #524]	; 348083dc <do_onenand_write+0x304>
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
		else
			ret = onenand_write_oneblock_withoob(ofs, buf, &_retlen);
		if (ret) {
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
348081cc:	e1cd03f0 	strd	r0, [sp, #48]	; 0x30
348081d0:	ea000075 	b	348083ac <do_onenand_write+0x2d4>

	if (to == next_ofs) {
		next_ofs = to + len;
		to += skip_ofs;
	} else {
		next_ofs = to + len;
348081d4:	e0942001 	adds	r2, r4, r1
348081d8:	e59f01fc 	ldr	r0, [pc, #508]	; 348083dc <do_onenand_write+0x304>
348081dc:	e2a53000 	adc	r3, r5, #0
348081e0:	e1c020f8 	strd	r2, [r0, #8]
		skip_ofs = 0;
348081e4:	e3a02000 	mov	r2, #0
348081e8:	e3a03000 	mov	r3, #0
348081ec:	e1c021f0 	strd	r2, [r0, #16]
348081f0:	eaffffef 	b	348081b4 <do_onenand_write+0xdc>
	}
	ofs = to;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
348081f4:	e5960000 	ldr	r0, [r6]
348081f8:	e1a02004 	mov	r2, r4
348081fc:	e5901078 	ldr	r1, [r0, #120]	; 0x78
34808200:	e1a03005 	mov	r3, r5
34808204:	e12fff31 	blx	r1
		if (ret) {
34808208:	e3500000 	cmp	r0, #0
3480820c:	e58d0010 	str	r0, [sp, #16]
34808210:	0a000008 	beq	34808238 <do_onenand_write+0x160>
			printk("Bad blocks %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
34808214:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
34808218:	e1a00004 	mov	r0, r4
3480821c:	e5932030 	ldr	r2, [r3, #48]	; 0x30
34808220:	e1a01005 	mov	r1, r5
34808224:	eb005f77 	bl	34820008 <__ashrdi3>
	ofs = to;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printk("Bad blocks %d at 0x%x\n",
34808228:	e1a02004 	mov	r2, r4
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
3480822c:	e1a01000 	mov	r1, r0
	ofs = to;

	while (blocks) {
		ret = mtd->block_isbad(mtd, ofs);
		if (ret) {
			printk("Bad blocks %d at 0x%x\n",
34808230:	e59f01a8 	ldr	r0, [pc, #424]	; 348083e0 <do_onenand_write+0x308>
34808234:	ea000047 	b	34808358 <do_onenand_write+0x280>
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			skip_ofs += blocksize;
			goto next;
		}

		if (!withoob)
34808238:	e59d101c 	ldr	r1, [sp, #28]
3480823c:	e3510000 	cmp	r1, #0
34808240:	0a00000b 	beq	34808274 <do_onenand_write+0x19c>
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
34808244:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
34808248:	e59d1014 	ldr	r1, [sp, #20]
3480824c:	e5960000 	ldr	r0, [r6]
34808250:	e28d306c 	add	r3, sp, #108	; 0x6c
34808254:	e88d000c 	stm	sp, {r2, r3}
34808258:	e58d1008 	str	r1, [sp, #8]
3480825c:	e5901044 	ldr	r1, [r0, #68]	; 0x44
34808260:	e1a02004 	mov	r2, r4
34808264:	e1a03005 	mov	r3, r5
34808268:	e12fff31 	blx	r1
3480826c:	e58d0010 	str	r0, [sp, #16]
34808270:	ea000032 	b	34808340 <do_onenand_write+0x268>

static int onenand_write_oneblock_withoob(loff_t to, const u_char * buf,
					  size_t *retlen)
{
	struct mtd_oob_ops ops = {
		.len = mtd->writesize,
34808274:	e5963000 	ldr	r3, [r6]
}

static int onenand_write_oneblock_withoob(loff_t to, const u_char * buf,
					  size_t *retlen)
{
	struct mtd_oob_ops ops = {
34808278:	e3a02020 	mov	r2, #32
3480827c:	e28d004c 	add	r0, sp, #76	; 0x4c
34808280:	e59d101c 	ldr	r1, [sp, #28]
		.len = mtd->writesize,
34808284:	e5937014 	ldr	r7, [r3, #20]
		.ooblen = mtd->oobsize,
34808288:	e593a018 	ldr	sl, [r3, #24]
}

static int onenand_write_oneblock_withoob(loff_t to, const u_char * buf,
					  size_t *retlen)
{
	struct mtd_oob_ops ops = {
3480828c:	eb004f0c 	bl	3481bec4 <memset>
		.len = mtd->writesize,
		.ooblen = mtd->oobsize,
		.mode = MTD_OOB_AUTO,
	};
	int page, ret = 0;
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
34808290:	e59dc01c 	ldr	ip, [sp, #28]
}

static int onenand_write_oneblock_withoob(loff_t to, const u_char * buf,
					  size_t *retlen)
{
	struct mtd_oob_ops ops = {
34808294:	e3a02001 	mov	r2, #1
34808298:	e1cd42f8 	strd	r4, [sp, #40]	; 0x28
3480829c:	e1cd44f0 	strd	r4, [sp, #64]	; 0x40
348082a0:	e58d204c 	str	r2, [sp, #76]	; 0x4c
348082a4:	e58d7050 	str	r7, [sp, #80]	; 0x50
348082a8:	e58da058 	str	sl, [sp, #88]	; 0x58
348082ac:	e59d9014 	ldr	r9, [sp, #20]
348082b0:	e1a0400c 	mov	r4, ip
348082b4:	ea000013 	b	34808308 <do_onenand_write+0x230>
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
		ops.datbuf = (u_char *)buf;
		buf += mtd->writesize;
		ops.oobbuf = (u_char *)buf;
		buf += mtd->oobsize;
		ret = mtd->write_oob(mtd, to, &ops);
348082b8:	e28d304c 	add	r3, sp, #76	; 0x4c
		.ooblen = mtd->oobsize,
		.mode = MTD_OOB_AUTO,
	};
	int page, ret = 0;
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
		ops.datbuf = (u_char *)buf;
348082bc:	e58d9064 	str	r9, [sp, #100]	; 0x64
		buf += mtd->writesize;
348082c0:	e0899007 	add	r9, r9, r7
		ops.oobbuf = (u_char *)buf;
		buf += mtd->oobsize;
348082c4:	e59b7018 	ldr	r7, [fp, #24]
		ret = mtd->write_oob(mtd, to, &ops);
348082c8:	e58d3000 	str	r3, [sp]
	};
	int page, ret = 0;
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
		ops.datbuf = (u_char *)buf;
		buf += mtd->writesize;
		ops.oobbuf = (u_char *)buf;
348082cc:	e58d9068 	str	r9, [sp, #104]	; 0x68
		buf += mtd->oobsize;
		ret = mtd->write_oob(mtd, to, &ops);
348082d0:	e59b1050 	ldr	r1, [fp, #80]	; 0x50
348082d4:	e1a0000b 	mov	r0, fp
348082d8:	e1cd22d8 	ldrd	r2, [sp, #40]	; 0x28
348082dc:	e12fff31 	blx	r1
		if (ret)
348082e0:	e3500000 	cmp	r0, #0
348082e4:	1a000011 	bne	34808330 <do_onenand_write+0x258>
			break;
		to += mtd->writesize;
348082e8:	e5963000 	ldr	r3, [r6]
348082ec:	e1cd02d8 	ldrd	r0, [sp, #40]	; 0x28
348082f0:	e5933014 	ldr	r3, [r3, #20]
	int page, ret = 0;
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
		ops.datbuf = (u_char *)buf;
		buf += mtd->writesize;
		ops.oobbuf = (u_char *)buf;
		buf += mtd->oobsize;
348082f4:	e0899007 	add	r9, r9, r7
		ret = mtd->write_oob(mtd, to, &ops);
		if (ret)
			break;
		to += mtd->writesize;
348082f8:	e0900003 	adds	r0, r0, r3
348082fc:	e2a11000 	adc	r1, r1, #0
34808300:	e1cd02f8 	strd	r0, [sp, #40]	; 0x28
		.len = mtd->writesize,
		.ooblen = mtd->oobsize,
		.mode = MTD_OOB_AUTO,
	};
	int page, ret = 0;
	for (page = 0; page < (mtd->erasesize / mtd->writesize); page ++) {
34808304:	e2844001 	add	r4, r4, #1
34808308:	e596b000 	ldr	fp, [r6]
3480830c:	e59ba010 	ldr	sl, [fp, #16]
34808310:	e59b7014 	ldr	r7, [fp, #20]
34808314:	e1a0000a 	mov	r0, sl
34808318:	e1a01007 	mov	r1, r7
3480831c:	eb005e1f 	bl	3481fba0 <__udivsi3>
34808320:	e1540000 	cmp	r4, r0
34808324:	3affffe3 	bcc	348082b8 <do_onenand_write+0x1e0>
34808328:	e1cd44d0 	ldrd	r4, [sp, #64]	; 0x40
3480832c:	ea000002 	b	3480833c <do_onenand_write+0x264>
		ops.datbuf = (u_char *)buf;
		buf += mtd->writesize;
		ops.oobbuf = (u_char *)buf;
		buf += mtd->oobsize;
		ret = mtd->write_oob(mtd, to, &ops);
34808330:	e58d0010 	str	r0, [sp, #16]
		if (ret)
			break;
		to += mtd->writesize;
	}

	*retlen = (ret) ? 0 : mtd->erasesize;
34808334:	e3a0a000 	mov	sl, #0
34808338:	e1cd44d0 	ldrd	r4, [sp, #64]	; 0x40
3480833c:	e58da06c 	str	sl, [sp, #108]	; 0x6c

		if (!withoob)
			ret = mtd->write(mtd, ofs, blocksize, &_retlen, buf);
		else
			ret = onenand_write_oneblock_withoob(ofs, buf, &_retlen);
		if (ret) {
34808340:	e59d1010 	ldr	r1, [sp, #16]
34808344:	e3510000 	cmp	r1, #0
34808348:	0a000009 	beq	34808374 <do_onenand_write+0x29c>
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
3480834c:	e59f0090 	ldr	r0, [pc, #144]	; 348083e4 <do_onenand_write+0x30c>
34808350:	e59d2010 	ldr	r2, [sp, #16]
34808354:	e1a01004 	mov	r1, r4
34808358:	eb000381 	bl	34809164 <printf>
			skip_ofs += blocksize;
3480835c:	e1c621d0 	ldrd	r2, [r6, #16]
34808360:	e1cd03d0 	ldrd	r0, [sp, #48]	; 0x30
34808364:	e0922000 	adds	r2, r2, r0
34808368:	e0a33001 	adc	r3, r3, r1
3480836c:	e1c621f0 	strd	r2, [r6, #16]
34808370:	ea00000a 	b	348083a0 <do_onenand_write+0x2c8>
			goto next;
		}

		buf += blocksize;
		blocks--;
34808374:	e59d3018 	ldr	r3, [sp, #24]
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
			goto next;
		}

		buf += blocksize;
34808378:	e59d1014 	ldr	r1, [sp, #20]
		blocks--;
3480837c:	e2433001 	sub	r3, r3, #1
		*retlen += _retlen;
34808380:	e59d0020 	ldr	r0, [sp, #32]
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
			goto next;
		}

		buf += blocksize;
34808384:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
		blocks--;
34808388:	e58d3018 	str	r3, [sp, #24]
		*retlen += _retlen;
3480838c:	e59d306c 	ldr	r3, [sp, #108]	; 0x6c
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
			goto next;
		}

		buf += blocksize;
34808390:	e0811002 	add	r1, r1, r2
		blocks--;
		*retlen += _retlen;
34808394:	e0800003 	add	r0, r0, r3
			printk("Write failed 0x%x, %d", (u32)ofs, ret);
			skip_ofs += blocksize;
			goto next;
		}

		buf += blocksize;
34808398:	e58d1014 	str	r1, [sp, #20]
		blocks--;
		*retlen += _retlen;
3480839c:	e58d0020 	str	r0, [sp, #32]
next:
		ofs += blocksize;
348083a0:	e1cd23d0 	ldrd	r2, [sp, #48]	; 0x30
348083a4:	e0944002 	adds	r4, r4, r2
348083a8:	e0a55003 	adc	r5, r5, r3
		next_ofs = to + len;
		skip_ofs = 0;
	}
	ofs = to;

	while (blocks) {
348083ac:	e59d3018 	ldr	r3, [sp, #24]
348083b0:	e3530000 	cmp	r3, #0
348083b4:	1affff8e 	bne	348081f4 <do_onenand_write+0x11c>
	if (arg_off_size(argc - 2, argv + 2, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_write(ofs, len, &retlen, (u8 *)addr, withoob);

	printf(" %d bytes written: %s\n", retlen, ret ? "ERROR" : "OK");
348083b8:	e59f0028 	ldr	r0, [pc, #40]	; 348083e8 <do_onenand_write+0x310>
348083bc:	e59d1020 	ldr	r1, [sp, #32]
348083c0:	e59f2024 	ldr	r2, [pc, #36]	; 348083ec <do_onenand_write+0x314>
348083c4:	eb000366 	bl	34809164 <printf>

	return ret == 0 ? 0 : 1;
348083c8:	e59d0018 	ldr	r0, [sp, #24]
}
348083cc:	e28dd078 	add	sp, sp, #120	; 0x78
348083d0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348083d4:	34825d00 	.word	0x34825d00
348083d8:	34825a7b 	.word	0x34825a7b
348083dc:	34829d60 	.word	0x34829d60
348083e0:	348258a4 	.word	0x348258a4
348083e4:	34825a8c 	.word	0x34825a8c
348083e8:	34825aa2 	.word	0x34825aa2
348083ec:	34824048 	.word	0x34824048

348083f0 <do_onenand_erase>:

static int do_onenand_erase(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348083f0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	 *   0       1     2       3    4
	 *   onenand erase [force] [off size]
	 */
	argc--;
	argv++;
	if (argc)
348083f4:	e2526001 	subs	r6, r2, #1

	return ret == 0 ? 0 : 1;
}

static int do_onenand_erase(cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
348083f8:	e24dd068 	sub	sp, sp, #104	; 0x68
	 * Syntax is:
	 *   0       1     2       3    4
	 *   onenand erase [force] [off size]
	 */
	argc--;
	argv++;
348083fc:	e2834004 	add	r4, r3, #4
	if (argc)
34808400:	0a000005 	beq	3480841c <do_onenand_erase+0x2c>
	{
		if (!strcmp("force", argv[0]))
34808404:	e59f0134 	ldr	r0, [pc, #308]	; 34808540 <do_onenand_erase+0x150>
34808408:	e5931004 	ldr	r1, [r3, #4]
3480840c:	eb004dd8 	bl	3481bb74 <strcmp>
34808410:	e3500000 	cmp	r0, #0
		{
			force = 1;
			argc--;
34808414:	02466001 	subeq	r6, r6, #1
			argv++;
34808418:	02844004 	addeq	r4, r4, #4
		}
	}
	printf("\nOneNAND erase: ");
3480841c:	e59f0120 	ldr	r0, [pc, #288]	; 34808544 <do_onenand_erase+0x154>
34808420:	eb00034f 	bl	34809164 <printf>

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
34808424:	e1a00006 	mov	r0, r6
34808428:	e1a01004 	mov	r1, r4
3480842c:	e28d2064 	add	r2, sp, #100	; 0x64
34808430:	e28d3060 	add	r3, sp, #96	; 0x60
34808434:	ebfffd1b 	bl	348078a8 <arg_off_size>
34808438:	e2509000 	subs	r9, r0, #0
		return 1;
3480843c:	13a00001 	movne	r0, #1
		}
	}
	printf("\nOneNAND erase: ");

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
34808440:	1a00003c 	bne	34808538 <do_onenand_erase+0x148>
	return 0;
}

static int onenand_block_erase(u32 start, u32 size, int force)
{
	struct onenand_chip *this = mtd->priv;
34808444:	e59f60fc 	ldr	r6, [pc, #252]	; 34808548 <do_onenand_erase+0x158>

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_erase(ofs, len, force);
34808448:	e59d3060 	ldr	r3, [sp, #96]	; 0x60
	return 0;
}

static int onenand_block_erase(u32 start, u32 size, int force)
{
	struct onenand_chip *this = mtd->priv;
3480844c:	e5962000 	ldr	r2, [r6]
	struct erase_info instr = {
34808450:	e28db018 	add	fp, sp, #24
	return 0;
}

static int onenand_block_erase(u32 start, u32 size, int force)
{
	struct onenand_chip *this = mtd->priv;
34808454:	e5927094 	ldr	r7, [r2, #148]	; 0x94
	struct erase_info instr = {
34808458:	e1a01009 	mov	r1, r9
3480845c:	e3a02048 	mov	r2, #72	; 0x48
34808460:	e1a0000b 	mov	r0, fp

	/* skip first two or three arguments, look for offset and size */
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_erase(ofs, len, force);
34808464:	e59da064 	ldr	sl, [sp, #100]	; 0x64
}

static int onenand_block_erase(u32 start, u32 size, int force)
{
	struct onenand_chip *this = mtd->priv;
	struct erase_info instr = {
34808468:	e58d3004 	str	r3, [sp, #4]
3480846c:	eb004e94 	bl	3481bec4 <memset>
		.callback	= NULL,
	};
	loff_t ofs;
	int ret;
	int blocksize = 1 << this->erase_shift;
34808470:	e5971030 	ldr	r1, [r7, #48]	; 0x30
34808474:	e3a02001 	mov	r2, #1
34808478:	e1a0c112 	lsl	ip, r2, r1

	for (ofs = start; ofs < (start + size); ofs += blocksize) {
3480847c:	e59d3004 	ldr	r3, [sp, #4]
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			continue;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34808480:	e1a0000c 	mov	r0, ip
34808484:	e1a01fc0 	asr	r1, r0, #31
	};
	loff_t ofs;
	int ret;
	int blocksize = 1 << this->erase_shift;

	for (ofs = start; ofs < (start + size); ofs += blocksize) {
34808488:	e083300a 	add	r3, r3, sl
3480848c:	e1a0400a 	mov	r4, sl
34808490:	e3a05000 	mov	r5, #0
34808494:	e58d3014 	str	r3, [sp, #20]
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			continue;
		}

		instr.addr = ofs;
		instr.len = blocksize;
34808498:	e1cd00f8 	strd	r0, [sp, #8]
		instr.priv = force;
3480849c:	e1a0a002 	mov	sl, r2
348084a0:	ea00001a 	b	34808510 <do_onenand_erase+0x120>
	loff_t ofs;
	int ret;
	int blocksize = 1 << this->erase_shift;

	for (ofs = start; ofs < (start + size); ofs += blocksize) {
		ret = mtd->block_isbad(mtd, ofs);
348084a4:	e5960000 	ldr	r0, [r6]
348084a8:	e1a02004 	mov	r2, r4
348084ac:	e5901078 	ldr	r1, [r0, #120]	; 0x78
348084b0:	e1a03005 	mov	r3, r5
348084b4:	e12fff31 	blx	r1
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			continue;
		}

		instr.addr = ofs;
		instr.len = blocksize;
348084b8:	e1cd20d8 	ldrd	r2, [sp, #8]
		instr.priv = force;
		instr.mtd = mtd;
348084bc:	e5960000 	ldr	r0, [r6]
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			continue;
		}

		instr.addr = ofs;
		instr.len = blocksize;
348084c0:	e1cd22f8 	strd	r2, [sp, #40]	; 0x28
			printf("Skip erase bad block %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
			continue;
		}

		instr.addr = ofs;
348084c4:	e1cd42f0 	strd	r4, [sp, #32]
		instr.len = blocksize;
		instr.priv = force;
348084c8:	e58da04c 	str	sl, [sp, #76]	; 0x4c
		instr.mtd = mtd;
348084cc:	e58d0018 	str	r0, [sp, #24]
		ret = mtd->erase(mtd, &instr);
348084d0:	e5903034 	ldr	r3, [r0, #52]	; 0x34
348084d4:	e1a0100b 	mov	r1, fp
348084d8:	e12fff33 	blx	r3
		if (ret) {
348084dc:	e3500000 	cmp	r0, #0
348084e0:	0a000007 	beq	34808504 <do_onenand_erase+0x114>
			printf("erase failed block %d at 0x%x\n",
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
348084e4:	e5972030 	ldr	r2, [r7, #48]	; 0x30
348084e8:	e1a00004 	mov	r0, r4
348084ec:	e1a01005 	mov	r1, r5
348084f0:	eb005ec4 	bl	34820008 <__ashrdi3>
		instr.len = blocksize;
		instr.priv = force;
		instr.mtd = mtd;
		ret = mtd->erase(mtd, &instr);
		if (ret) {
			printf("erase failed block %d at 0x%x\n",
348084f4:	e1a02004 	mov	r2, r4
			       (u32)(ofs >> this->erase_shift), (u32)ofs);
348084f8:	e1a01000 	mov	r1, r0
		instr.len = blocksize;
		instr.priv = force;
		instr.mtd = mtd;
		ret = mtd->erase(mtd, &instr);
		if (ret) {
			printf("erase failed block %d at 0x%x\n",
348084fc:	e59f0048 	ldr	r0, [pc, #72]	; 3480854c <do_onenand_erase+0x15c>
34808500:	eb000317 	bl	34809164 <printf>
	};
	loff_t ofs;
	int ret;
	int blocksize = 1 << this->erase_shift;

	for (ofs = start; ofs < (start + size); ofs += blocksize) {
34808504:	e1cd00d8 	ldrd	r0, [sp, #8]
34808508:	e0944000 	adds	r4, r4, r0
3480850c:	e0a55001 	adc	r5, r5, r1
34808510:	e1590005 	cmp	r9, r5
34808514:	caffffe2 	bgt	348084a4 <do_onenand_erase+0xb4>
34808518:	1a000002 	bne	34808528 <do_onenand_erase+0x138>
3480851c:	e59d1014 	ldr	r1, [sp, #20]
34808520:	e1510004 	cmp	r1, r4
34808524:	8affffde 	bhi	348084a4 <do_onenand_erase+0xb4>
	if (arg_off_size(argc, argv, &ofs, &len) != 0)
		return 1;

	ret = onenand_block_erase(ofs, len, force);

	printf("%s\n", ret ? "ERROR" : "OK");
34808528:	e59f0020 	ldr	r0, [pc, #32]	; 34808550 <do_onenand_erase+0x160>
3480852c:	e59f1020 	ldr	r1, [pc, #32]	; 34808554 <do_onenand_erase+0x164>
34808530:	eb00030b 	bl	34809164 <printf>

	return ret == 0 ? 0 : 1;
34808534:	e3a00000 	mov	r0, #0
}
34808538:	e28dd068 	add	sp, sp, #104	; 0x68
3480853c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34808540:	34825ab9 	.word	0x34825ab9
34808544:	34825abf 	.word	0x34825abf
34808548:	34829d60 	.word	0x34829d60
3480854c:	34825ad0 	.word	0x34825ad0
34808550:	34825ea6 	.word	0x34825ea6
34808554:	34824048 	.word	0x34824048

34808558 <do_reginfo>:
# endif

#endif /* CONFIG_BLACKFIN */

	return 0;
}
34808558:	e3a00000 	mov	r0, #0
3480855c:	e12fff1e 	bx	lr

34808560 <__fswab32>:
34808560:	e6bf0f30 	rev	r0, r0
34808564:	e12fff1e 	bx	lr

34808568 <source>:
#include <mpc8xx.h>
#endif

int
source (ulong addr, const char *fit_uname)
{
34808568:	e92d4070 	push	{r4, r5, r6, lr}
3480856c:	e1a04000 	mov	r4, r0
	int		noffset;
	const void	*fit_data;
	size_t		fit_len;
#endif

	verify = getenv_yesno ("verify");
34808570:	e59f00b0 	ldr	r0, [pc, #176]	; 34808628 <source+0xc0>
34808574:	eb0011b0 	bl	3480cc3c <getenv_yesno>
34808578:	e1a05000 	mov	r5, r0

	switch (genimg_get_format ((void *)addr)) {
3480857c:	e1a00004 	mov	r0, r4
34808580:	eb0012a1 	bl	3480d00c <genimg_get_format>
34808584:	e3500001 	cmp	r0, #1
		data = (ulong *)fit_data;
		len = (ulong)fit_len;
		break;
#endif
	default:
		puts ("Wrong image format for \"source\" command\n");
34808588:	159f009c 	ldrne	r0, [pc, #156]	; 3480862c <source+0xc4>
	size_t		fit_len;
#endif

	verify = getenv_yesno ("verify");

	switch (genimg_get_format ((void *)addr)) {
3480858c:	1a00001f 	bne	34808610 <source+0xa8>
#define image_get_hdr_l(f) \
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
34808590:	e5940000 	ldr	r0, [r4]
34808594:	ebfffff1 	bl	34808560 <__fswab32>
	case IMAGE_FORMAT_LEGACY:
		hdr = (image_header_t *)addr;

		if (!image_check_magic (hdr)) {
34808598:	e59f3090 	ldr	r3, [pc, #144]	; 34808630 <source+0xc8>
3480859c:	e1500003 	cmp	r0, r3
			puts ("Bad magic number\n");
348085a0:	159f008c 	ldrne	r0, [pc, #140]	; 34808634 <source+0xcc>

	switch (genimg_get_format ((void *)addr)) {
	case IMAGE_FORMAT_LEGACY:
		hdr = (image_header_t *)addr;

		if (!image_check_magic (hdr)) {
348085a4:	1a000019 	bne	34808610 <source+0xa8>
			puts ("Bad magic number\n");
			return 1;
		}

		if (!image_check_hcrc (hdr)) {
348085a8:	e1a00004 	mov	r0, r4
348085ac:	eb001155 	bl	3480cb08 <image_check_hcrc>
348085b0:	e3500000 	cmp	r0, #0
			puts ("Bad header crc\n");
348085b4:	059f007c 	ldreq	r0, [pc, #124]	; 34808638 <source+0xd0>
		if (!image_check_magic (hdr)) {
			puts ("Bad magic number\n");
			return 1;
		}

		if (!image_check_hcrc (hdr)) {
348085b8:	0a000014 	beq	34808610 <source+0xa8>
			puts ("Bad header crc\n");
			return 1;
		}

		if (verify) {
348085bc:	e3550000 	cmp	r5, #0
348085c0:	0a000004 	beq	348085d8 <source+0x70>
			if (!image_check_dcrc (hdr)) {
348085c4:	e1a00004 	mov	r0, r4
348085c8:	eb001162 	bl	3480cb58 <image_check_dcrc>
348085cc:	e3500000 	cmp	r0, #0
				puts ("Bad data crc\n");
348085d0:	059f0064 	ldreq	r0, [pc, #100]	; 3480863c <source+0xd4>
			puts ("Bad header crc\n");
			return 1;
		}

		if (verify) {
			if (!image_check_dcrc (hdr)) {
348085d4:	0a00000d 	beq	34808610 <source+0xa8>
				puts ("Bad data crc\n");
				return 1;
			}
		}

		if (!image_check_type (hdr, IH_TYPE_SCRIPT)) {
348085d8:	e5d4301e 	ldrb	r3, [r4, #30]
348085dc:	e3530006 	cmp	r3, #6
			puts ("Bad image type\n");
348085e0:	159f0058 	ldrne	r0, [pc, #88]	; 34808640 <source+0xd8>
				puts ("Bad data crc\n");
				return 1;
			}
		}

		if (!image_check_type (hdr, IH_TYPE_SCRIPT)) {
348085e4:	1a000009 	bne	34808610 <source+0xa8>
		}

		/* get length of script */
		data = (ulong *)image_get_data (hdr);

		if ((len = uimage_to_cpu (*data)) == 0) {
348085e8:	e5940040 	ldr	r0, [r4, #64]	; 0x40
348085ec:	ebffffdb 	bl	34808560 <__fswab32>
348085f0:	e2501000 	subs	r1, r0, #0
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
348085f4:	e2845040 	add	r5, r4, #64	; 0x40
			puts ("Empty Script\n");
348085f8:	059f0044 	ldreq	r0, [pc, #68]	; 34808644 <source+0xdc>
		}

		/* get length of script */
		data = (ulong *)image_get_data (hdr);

		if ((len = uimage_to_cpu (*data)) == 0) {
348085fc:	0a000003 	beq	34808610 <source+0xa8>
		/*
		 * scripts are just multi-image files with one component, seek
		 * past the zero-terminated sequence of image lengths to get
		 * to the actual image data
		 */
		while (*data++);
34808600:	e4952004 	ldr	r2, [r5], #4
34808604:	e3520000 	cmp	r2, #0
34808608:	1afffffc 	bne	34808600 <source+0x98>
3480860c:	ea000002 	b	3480861c <source+0xb4>
		data = (ulong *)fit_data;
		len = (ulong)fit_len;
		break;
#endif
	default:
		puts ("Wrong image format for \"source\" command\n");
34808610:	eb0002c9 	bl	3480913c <puts>
		return 1;
	}

	debug ("** Script length: %ld\n", len);
	return run_command_list((char *)data, len, 0);
}
34808614:	e3a00001 	mov	r0, #1
34808618:	e8bd8070 	pop	{r4, r5, r6, pc}
		puts ("Wrong image format for \"source\" command\n");
		return 1;
	}

	debug ("** Script length: %ld\n", len);
	return run_command_list((char *)data, len, 0);
3480861c:	e1a00005 	mov	r0, r5
}
34808620:	e8bd4070 	pop	{r4, r5, r6, lr}
		puts ("Wrong image format for \"source\" command\n");
		return 1;
	}

	debug ("** Script length: %ld\n", len);
	return run_command_list((char *)data, len, 0);
34808624:	ea001631 	b	3480def0 <run_command_list>
34808628:	34822f2d 	.word	0x34822f2d
3480862c:	34825d84 	.word	0x34825d84
34808630:	27051956 	.word	0x27051956
34808634:	34825d36 	.word	0x34825d36
34808638:	34825d48 	.word	0x34825d48
3480863c:	34825d58 	.word	0x34825d58
34808640:	34825d66 	.word	0x34825d66
34808644:	34825d76 	.word	0x34825d76

34808648 <do_source>:
	ulong addr;
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
34808648:	e3520001 	cmp	r2, #1

/**************************************************/
#if defined(CONFIG_CMD_SOURCE)
int
do_source (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480864c:	e92d4010 	push	{r4, lr}
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
		addr = CONFIG_SYS_LOAD_ADDR;
34808650:	d3a0430d 	movle	r4, #872415232	; 0x34000000
	ulong addr;
	int rcode;
	const char *fit_uname = NULL;

	/* Find script image */
	if (argc < 2) {
34808654:	da000004 	ble	3480866c <do_source+0x24>
	} else if (fit_parse_subimage (argv[1], load_addr, &addr, &fit_uname)) {
		debug ("*  source: subimage '%s' from FIT image at 0x%08lx\n",
				fit_uname, addr);
#endif
	} else {
		addr = simple_strtoul(argv[1], NULL, 16);
34808658:	e5930004 	ldr	r0, [r3, #4]
3480865c:	e3a01000 	mov	r1, #0
34808660:	e3a02010 	mov	r2, #16
34808664:	eb005109 	bl	3481ca90 <simple_strtoul>
34808668:	e1a04000 	mov	r4, r0
		debug ("*  source: cmdline image address = 0x%08lx\n", addr);
	}

	printf ("## Executing script at %08lx\n", addr);
3480866c:	e1a01004 	mov	r1, r4
34808670:	e59f0010 	ldr	r0, [pc, #16]	; 34808688 <do_source+0x40>
34808674:	eb0002ba 	bl	34809164 <printf>
	rcode = source (addr, fit_uname);
34808678:	e1a00004 	mov	r0, r4
3480867c:	e3a01000 	mov	r1, #0
	return rcode;
}
34808680:	e8bd4010 	pop	{r4, lr}
		addr = simple_strtoul(argv[1], NULL, 16);
		debug ("*  source: cmdline image address = 0x%08lx\n", addr);
	}

	printf ("## Executing script at %08lx\n", addr);
	rcode = source (addr, fit_uname);
34808684:	eaffffb7 	b	34808568 <source>
34808688:	34825dad 	.word	0x34825dad

3480868c <do_false>:
);

int do_false(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return 1;
}
3480868c:	e3a00001 	mov	r0, #1
34808690:	e12fff1e 	bx	lr

34808694 <do_true>:
);

int do_true(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	return 0;
}
34808694:	e3a00000 	mov	r0, #0
34808698:	e12fff1e 	bx	lr

3480869c <do_test>:
{
	char * const *ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
3480869c:	e3520002 	cmp	r2, #2

#include <common.h>
#include <command.h>

int do_test(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348086a0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	char * const *ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
348086a4:	da0000fd 	ble	34808aa0 <do_test+0x404>
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
348086a8:	e5930004 	ldr	r0, [r3, #4]
348086ac:	e59f141c 	ldr	r1, [pc, #1052]	; 34808ad0 <do_test+0x434>
			debug(" '%s'", argv[left++]);
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
348086b0:	e2426001 	sub	r6, r2, #1
348086b4:	e2834004 	add	r4, r3, #4
	if (left > 0 && strcmp(ap[0], "!") == 0) {
348086b8:	eb004d2d 	bl	3481bb74 <strcmp>
		left--;
	} else
		neg = 0;

	expr = -1;
	last_cmp = -1;
348086bc:	e3e05000 	mvn	r5, #0
	}
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
348086c0:	e3500000 	cmp	r0, #0
		neg = 1;
		ap++;
348086c4:	02844004 	addeq	r4, r4, #4
		left--;
348086c8:	02466001 	subeq	r6, r6, #1
#endif

	last_expr = 0;
	left = argc - 1; ap = argv + 1;
	if (left > 0 && strcmp(ap[0], "!") == 0) {
		neg = 1;
348086cc:	03a0b001 	moveq	fp, #1
		ap++;
		left--;
	} else
		neg = 0;
348086d0:	13a0b000 	movne	fp, #0

	expr = -1;
	last_cmp = -1;
	last_expr = -1;
348086d4:	e1a07005 	mov	r7, r5
		ap++;
		left--;
	} else
		neg = 0;

	expr = -1;
348086d8:	e1a0a005 	mov	sl, r5
	last_cmp = -1;
	last_expr = -1;
	while (left > 0) {

		if (strcmp(ap[0], "-o") == 0 || strcmp(ap[0], "-a") == 0)
348086dc:	e5940000 	ldr	r0, [r4]
348086e0:	e59f13ec 	ldr	r1, [pc, #1004]	; 34808ad4 <do_test+0x438>
348086e4:	eb004d22 	bl	3481bb74 <strcmp>
348086e8:	e3500000 	cmp	r0, #0
348086ec:	0a0000ed 	beq	34808aa8 <do_test+0x40c>
348086f0:	e5940000 	ldr	r0, [r4]
348086f4:	e59f13dc 	ldr	r1, [pc, #988]	; 34808ad8 <do_test+0x43c>
348086f8:	eb004d1d 	bl	3481bb74 <strcmp>
348086fc:	e3500000 	cmp	r0, #0
34808700:	0a0000e8 	beq	34808aa8 <do_test+0x40c>
			adv = 1;
		else if (strcmp(ap[0], "-z") == 0 || strcmp(ap[0], "-n") == 0)
34808704:	e5940000 	ldr	r0, [r4]
34808708:	e59f13cc 	ldr	r1, [pc, #972]	; 34808adc <do_test+0x440>
3480870c:	eb004d18 	bl	3481bb74 <strcmp>
34808710:	e3500000 	cmp	r0, #0
			adv = 2;
34808714:	03a09002 	moveq	r9, #2
	last_expr = -1;
	while (left > 0) {

		if (strcmp(ap[0], "-o") == 0 || strcmp(ap[0], "-a") == 0)
			adv = 1;
		else if (strcmp(ap[0], "-z") == 0 || strcmp(ap[0], "-n") == 0)
34808718:	0a000005 	beq	34808734 <do_test+0x98>
3480871c:	e5940000 	ldr	r0, [r4]
34808720:	e59f13b8 	ldr	r1, [pc, #952]	; 34808ae0 <do_test+0x444>
34808724:	eb004d12 	bl	3481bb74 <strcmp>
			adv = 2;
		else
			adv = 3;
34808728:	e3500000 	cmp	r0, #0
3480872c:	03a09002 	moveq	r9, #2
34808730:	13a09003 	movne	r9, #3

		if (left < adv) {
34808734:	e1560009 	cmp	r6, r9
34808738:	aa000006 	bge	34808758 <do_test+0xbc>
3480873c:	ea0000cf 	b	34808a80 <do_test+0x3e4>

		if (adv == 1) {
			if (strcmp(ap[0], "-o") == 0) {
				last_expr = expr;
				last_cmp = 0;
			} else if (strcmp(ap[0], "-a") == 0) {
34808740:	e5940000 	ldr	r0, [r4]
34808744:	e59f138c 	ldr	r1, [pc, #908]	; 34808ad8 <do_test+0x43c>
34808748:	eb004d09 	bl	3481bb74 <strcmp>
3480874c:	e3500000 	cmp	r0, #0
34808750:	0a0000da 	beq	34808ac0 <do_test+0x424>
34808754:	ea0000c9 	b	34808a80 <do_test+0x3e4>
				expr = 1;
				break;
			}
		}

		if (adv == 2) {
34808758:	e3590002 	cmp	r9, #2
3480875c:	1a00001e 	bne	348087dc <do_test+0x140>
			if (strcmp(ap[0], "-z") == 0)
34808760:	e5940000 	ldr	r0, [r4]
34808764:	e59f1370 	ldr	r1, [pc, #880]	; 34808adc <do_test+0x440>
34808768:	eb004d01 	bl	3481bb74 <strcmp>
3480876c:	e3500000 	cmp	r0, #0
34808770:	1a000004 	bne	34808788 <do_test+0xec>
				expr = strlen(ap[1]) == 0 ? 1 : 0;
34808774:	e5940004 	ldr	r0, [r4, #4]
34808778:	eb004d31 	bl	3481bc44 <strlen>
3480877c:	e270a001 	rsbs	sl, r0, #1
34808780:	33a0a000 	movcc	sl, #0
34808784:	ea000008 	b	348087ac <do_test+0x110>
			else if (strcmp(ap[0], "-n") == 0)
34808788:	e5940000 	ldr	r0, [r4]
3480878c:	e59f134c 	ldr	r1, [pc, #844]	; 34808ae0 <do_test+0x444>
34808790:	eb004cf7 	bl	3481bb74 <strcmp>
34808794:	e3500000 	cmp	r0, #0
34808798:	1a0000b8 	bne	34808a80 <do_test+0x3e4>
				expr = strlen(ap[1]) == 0 ? 0 : 1;
3480879c:	e5940004 	ldr	r0, [r4, #4]
348087a0:	eb004d27 	bl	3481bc44 <strlen>
348087a4:	e250a000 	subs	sl, r0, #0
348087a8:	13a0a001 	movne	sl, #1
			else {
				expr = 1;
				break;
			}

			if (last_cmp == 0)
348087ac:	e3550000 	cmp	r5, #0
348087b0:	1a000003 	bne	348087c4 <do_test+0x128>
				expr = last_expr || expr;
348087b4:	e19aa007 	orrs	sl, sl, r7
348087b8:	03a0a000 	moveq	sl, #0
348087bc:	13a0a001 	movne	sl, #1
348087c0:	ea0000a8 	b	34808a68 <do_test+0x3cc>
			else if (last_cmp == 1)
348087c4:	e3550001 	cmp	r5, #1
348087c8:	1a0000a6 	bne	34808a68 <do_test+0x3cc>
				expr = last_expr && expr;
348087cc:	e3570000 	cmp	r7, #0
348087d0:	03a0a000 	moveq	sl, #0
348087d4:	120aa001 	andne	sl, sl, #1
348087d8:	ea0000a2 	b	34808a68 <do_test+0x3cc>
			last_cmp = -1;
		}

		if (adv == 3) {
			if (strcmp(ap[1], "=") == 0)
348087dc:	e5940004 	ldr	r0, [r4, #4]
348087e0:	e59f12fc 	ldr	r1, [pc, #764]	; 34808ae4 <do_test+0x448>
348087e4:	eb004ce2 	bl	3481bb74 <strcmp>
348087e8:	e3500000 	cmp	r0, #0
348087ec:	e284a004 	add	sl, r4, #4
348087f0:	1a000005 	bne	3480880c <do_test+0x170>
				expr = strcmp(ap[0], ap[2]) == 0;
348087f4:	e5940000 	ldr	r0, [r4]
348087f8:	e5941008 	ldr	r1, [r4, #8]
348087fc:	eb004cdc 	bl	3481bb74 <strcmp>
34808800:	e270a001 	rsbs	sl, r0, #1
34808804:	33a0a000 	movcc	sl, #0
34808808:	ea00008a 	b	34808a38 <do_test+0x39c>
			else if (strcmp(ap[1], "!=") == 0)
3480880c:	e5940004 	ldr	r0, [r4, #4]
34808810:	e59f12d0 	ldr	r1, [pc, #720]	; 34808ae8 <do_test+0x44c>
34808814:	eb004cd6 	bl	3481bb74 <strcmp>
34808818:	e3500000 	cmp	r0, #0
3480881c:	1a000005 	bne	34808838 <do_test+0x19c>
				expr = strcmp(ap[0], ap[2]) != 0;
34808820:	e5940000 	ldr	r0, [r4]
34808824:	e5941008 	ldr	r1, [r4, #8]
34808828:	eb004cd1 	bl	3481bb74 <strcmp>
3480882c:	e250a000 	subs	sl, r0, #0
34808830:	13a0a001 	movne	sl, #1
34808834:	ea00007f 	b	34808a38 <do_test+0x39c>
			else if (strcmp(ap[1], ">") == 0)
34808838:	e59a0000 	ldr	r0, [sl]
3480883c:	e59f12a8 	ldr	r1, [pc, #680]	; 34808aec <do_test+0x450>
34808840:	eb004ccb 	bl	3481bb74 <strcmp>
34808844:	e3500000 	cmp	r0, #0
34808848:	1a000006 	bne	34808868 <do_test+0x1cc>
				expr = strcmp(ap[0], ap[2]) > 0;
3480884c:	e5940000 	ldr	r0, [r4]
34808850:	e5941008 	ldr	r1, [r4, #8]
34808854:	eb004cc6 	bl	3481bb74 <strcmp>
34808858:	e3500000 	cmp	r0, #0
3480885c:	d3a0a000 	movle	sl, #0
34808860:	c3a0a001 	movgt	sl, #1
34808864:	ea000073 	b	34808a38 <do_test+0x39c>
			else if (strcmp(ap[1], "<") == 0)
34808868:	e59a0000 	ldr	r0, [sl]
3480886c:	e59f127c 	ldr	r1, [pc, #636]	; 34808af0 <do_test+0x454>
34808870:	eb004cbf 	bl	3481bb74 <strcmp>
34808874:	e3500000 	cmp	r0, #0
34808878:	1a000004 	bne	34808890 <do_test+0x1f4>
				expr = strcmp(ap[0], ap[2]) < 0;
3480887c:	e5940000 	ldr	r0, [r4]
34808880:	e5941008 	ldr	r1, [r4, #8]
34808884:	eb004cba 	bl	3481bb74 <strcmp>
34808888:	e1a0afa0 	lsr	sl, r0, #31
3480888c:	ea000069 	b	34808a38 <do_test+0x39c>
			else if (strcmp(ap[1], "-eq") == 0)
34808890:	e59a0000 	ldr	r0, [sl]
34808894:	e59f1258 	ldr	r1, [pc, #600]	; 34808af4 <do_test+0x458>
34808898:	eb004cb5 	bl	3481bb74 <strcmp>
3480889c:	e2509000 	subs	r9, r0, #0
348088a0:	1a00000c 	bne	348088d8 <do_test+0x23c>
				expr = simple_strtol(ap[0], NULL, 10) == simple_strtol(ap[2], NULL, 10);
348088a4:	e1a01009 	mov	r1, r9
348088a8:	e3a0200a 	mov	r2, #10
348088ac:	e5940000 	ldr	r0, [r4]
348088b0:	eb0050bf 	bl	3481cbb4 <simple_strtol>
348088b4:	e1a01009 	mov	r1, r9
348088b8:	e1a0a000 	mov	sl, r0
348088bc:	e3a0200a 	mov	r2, #10
348088c0:	e5940008 	ldr	r0, [r4, #8]
348088c4:	eb0050ba 	bl	3481cbb4 <simple_strtol>
348088c8:	e15a0000 	cmp	sl, r0
348088cc:	13a0a000 	movne	sl, #0
348088d0:	03a0a001 	moveq	sl, #1
348088d4:	ea000057 	b	34808a38 <do_test+0x39c>
			else if (strcmp(ap[1], "-ne") == 0)
348088d8:	e59a0000 	ldr	r0, [sl]
348088dc:	e59f1214 	ldr	r1, [pc, #532]	; 34808af8 <do_test+0x45c>
348088e0:	eb004ca3 	bl	3481bb74 <strcmp>
348088e4:	e2509000 	subs	r9, r0, #0
348088e8:	1a00000b 	bne	3480891c <do_test+0x280>
				expr = simple_strtol(ap[0], NULL, 10) != simple_strtol(ap[2], NULL, 10);
348088ec:	e1a01009 	mov	r1, r9
348088f0:	e3a0200a 	mov	r2, #10
348088f4:	e5940000 	ldr	r0, [r4]
348088f8:	eb0050ad 	bl	3481cbb4 <simple_strtol>
348088fc:	e1a01009 	mov	r1, r9
34808900:	e1a0a000 	mov	sl, r0
34808904:	e3a0200a 	mov	r2, #10
34808908:	e5940008 	ldr	r0, [r4, #8]
3480890c:	eb0050a8 	bl	3481cbb4 <simple_strtol>
34808910:	e05aa000 	subs	sl, sl, r0
34808914:	13a0a001 	movne	sl, #1
34808918:	ea000046 	b	34808a38 <do_test+0x39c>
			else if (strcmp(ap[1], "-lt") == 0)
3480891c:	e59a0000 	ldr	r0, [sl]
34808920:	e59f11d4 	ldr	r1, [pc, #468]	; 34808afc <do_test+0x460>
34808924:	eb004c92 	bl	3481bb74 <strcmp>
34808928:	e2509000 	subs	r9, r0, #0
3480892c:	1a00000c 	bne	34808964 <do_test+0x2c8>
				expr = simple_strtol(ap[0], NULL, 10) < simple_strtol(ap[2], NULL, 10);
34808930:	e1a01009 	mov	r1, r9
34808934:	e3a0200a 	mov	r2, #10
34808938:	e5940000 	ldr	r0, [r4]
3480893c:	eb00509c 	bl	3481cbb4 <simple_strtol>
34808940:	e1a01009 	mov	r1, r9
34808944:	e1a0a000 	mov	sl, r0
34808948:	e3a0200a 	mov	r2, #10
3480894c:	e5940008 	ldr	r0, [r4, #8]
34808950:	eb005097 	bl	3481cbb4 <simple_strtol>
34808954:	e15a0000 	cmp	sl, r0
34808958:	a3a0a000 	movge	sl, #0
3480895c:	b3a0a001 	movlt	sl, #1
34808960:	ea000034 	b	34808a38 <do_test+0x39c>
			else if (strcmp(ap[1], "-le") == 0)
34808964:	e59a0000 	ldr	r0, [sl]
34808968:	e59f1190 	ldr	r1, [pc, #400]	; 34808b00 <do_test+0x464>
3480896c:	eb004c80 	bl	3481bb74 <strcmp>
34808970:	e3500000 	cmp	r0, #0
34808974:	1a00000c 	bne	348089ac <do_test+0x310>
				expr = simple_strtol(ap[0], NULL, 10) <= simple_strtol(ap[2], NULL, 10);
34808978:	e3a01000 	mov	r1, #0
3480897c:	e3a0200a 	mov	r2, #10
34808980:	e5940000 	ldr	r0, [r4]
34808984:	eb00508a 	bl	3481cbb4 <simple_strtol>
34808988:	e3a01000 	mov	r1, #0
3480898c:	e1a0a000 	mov	sl, r0
34808990:	e3a0200a 	mov	r2, #10
34808994:	e5940008 	ldr	r0, [r4, #8]
34808998:	eb005085 	bl	3481cbb4 <simple_strtol>
3480899c:	e15a0000 	cmp	sl, r0
348089a0:	c3a0a000 	movgt	sl, #0
348089a4:	d3a0a001 	movle	sl, #1
348089a8:	ea000022 	b	34808a38 <do_test+0x39c>
			else if (strcmp(ap[1], "-gt") == 0)
348089ac:	e59a0000 	ldr	r0, [sl]
348089b0:	e59f114c 	ldr	r1, [pc, #332]	; 34808b04 <do_test+0x468>
348089b4:	eb004c6e 	bl	3481bb74 <strcmp>
348089b8:	e2509000 	subs	r9, r0, #0
348089bc:	1a00000c 	bne	348089f4 <do_test+0x358>
				expr = simple_strtol(ap[0], NULL, 10) > simple_strtol(ap[2], NULL, 10);
348089c0:	e1a01009 	mov	r1, r9
348089c4:	e3a0200a 	mov	r2, #10
348089c8:	e5940000 	ldr	r0, [r4]
348089cc:	eb005078 	bl	3481cbb4 <simple_strtol>
348089d0:	e1a01009 	mov	r1, r9
348089d4:	e1a0a000 	mov	sl, r0
348089d8:	e3a0200a 	mov	r2, #10
348089dc:	e5940008 	ldr	r0, [r4, #8]
348089e0:	eb005073 	bl	3481cbb4 <simple_strtol>
348089e4:	e15a0000 	cmp	sl, r0
348089e8:	d3a0a000 	movle	sl, #0
348089ec:	c3a0a001 	movgt	sl, #1
348089f0:	ea000010 	b	34808a38 <do_test+0x39c>
			else if (strcmp(ap[1], "-ge") == 0)
348089f4:	e59a0000 	ldr	r0, [sl]
348089f8:	e59f1108 	ldr	r1, [pc, #264]	; 34808b08 <do_test+0x46c>
348089fc:	eb004c5c 	bl	3481bb74 <strcmp>
34808a00:	e2509000 	subs	r9, r0, #0
34808a04:	1a00001d 	bne	34808a80 <do_test+0x3e4>
				expr = simple_strtol(ap[0], NULL, 10) >= simple_strtol(ap[2], NULL, 10);
34808a08:	e1a01009 	mov	r1, r9
34808a0c:	e3a0200a 	mov	r2, #10
34808a10:	e5940000 	ldr	r0, [r4]
34808a14:	eb005066 	bl	3481cbb4 <simple_strtol>
34808a18:	e1a01009 	mov	r1, r9
34808a1c:	e1a0a000 	mov	sl, r0
34808a20:	e3a0200a 	mov	r2, #10
34808a24:	e5940008 	ldr	r0, [r4, #8]
34808a28:	eb005061 	bl	3481cbb4 <simple_strtol>
34808a2c:	e15a0000 	cmp	sl, r0
34808a30:	b3a0a000 	movlt	sl, #0
34808a34:	a3a0a001 	movge	sl, #1
			else {
				expr = 1;
				break;
			}

			if (last_cmp == 0)
34808a38:	e3550000 	cmp	r5, #0
34808a3c:	1a000003 	bne	34808a50 <do_test+0x3b4>
				expr = last_expr || expr;
34808a40:	e19aa007 	orrs	sl, sl, r7
34808a44:	03a0a000 	moveq	sl, #0
34808a48:	13a0a001 	movne	sl, #1
34808a4c:	ea000004 	b	34808a64 <do_test+0x3c8>
			else if (last_cmp == 1)
34808a50:	e3550001 	cmp	r5, #1
34808a54:	1a000002 	bne	34808a64 <do_test+0x3c8>
				expr = last_expr && expr;
34808a58:	e3570000 	cmp	r7, #0
34808a5c:	03a0a000 	moveq	sl, #0
34808a60:	120aa001 	andne	sl, sl, #1
				break;
			}

			if (last_cmp == 0)
				expr = last_expr || expr;
			else if (last_cmp == 1)
34808a64:	e3a09003 	mov	r9, #3
				expr = last_expr && expr;
			last_cmp = -1;
34808a68:	e3e05000 	mvn	r5, #0
		}

		ap += adv; left -= adv;
34808a6c:	e0696006 	rsb	r6, r9, r6
		neg = 0;

	expr = -1;
	last_cmp = -1;
	last_expr = -1;
	while (left > 0) {
34808a70:	e3560000 	cmp	r6, #0
34808a74:	da000002 	ble	34808a84 <do_test+0x3e8>
			else if (last_cmp == 1)
				expr = last_expr && expr;
			last_cmp = -1;
		}

		ap += adv; left -= adv;
34808a78:	e0844109 	add	r4, r4, r9, lsl #2
34808a7c:	eaffff16 	b	348086dc <do_test+0x40>
			else if (strcmp(ap[1], "-gt") == 0)
				expr = simple_strtol(ap[0], NULL, 10) > simple_strtol(ap[2], NULL, 10);
			else if (strcmp(ap[1], "-ge") == 0)
				expr = simple_strtol(ap[0], NULL, 10) >= simple_strtol(ap[2], NULL, 10);
			else {
				expr = 1;
34808a80:	e3a0a001 	mov	sl, #1
		}

		ap += adv; left -= adv;
	}

	if (neg)
34808a84:	e35b0000 	cmp	fp, #0
34808a88:	0a000001 	beq	34808a94 <do_test+0x3f8>
		expr = !expr;
34808a8c:	e27aa001 	rsbs	sl, sl, #1
34808a90:	33a0a000 	movcc	sl, #0

	expr = !expr;
34808a94:	e27a0001 	rsbs	r0, sl, #1
34808a98:	33a00000 	movcc	r0, #0

	debug (": returns %d\n", expr);

	return expr;
34808a9c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	char * const *ap;
	int left, adv, expr, last_expr, neg, last_cmp;

	/* args? */
	if (argc < 3)
		return 1;
34808aa0:	e3a00001 	mov	r0, #1
	expr = !expr;

	debug (": returns %d\n", expr);

	return expr;
}
34808aa4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			expr = 1;
			break;
		}

		if (adv == 1) {
			if (strcmp(ap[0], "-o") == 0) {
34808aa8:	e5940000 	ldr	r0, [r4]
34808aac:	e59f1020 	ldr	r1, [pc, #32]	; 34808ad4 <do_test+0x438>
34808ab0:	eb004c2f 	bl	3481bb74 <strcmp>
34808ab4:	e2505000 	subs	r5, r0, #0
34808ab8:	0a000001 	beq	34808ac4 <do_test+0x428>
34808abc:	eaffff1f 	b	34808740 <do_test+0xa4>
				last_expr = expr;
				last_cmp = 0;
			} else if (strcmp(ap[0], "-a") == 0) {
				last_expr = expr;
				last_cmp = 1;
34808ac0:	e3a05001 	mov	r5, #1

			if (last_cmp == 0)
				expr = last_expr || expr;
			else if (last_cmp == 1)
				expr = last_expr && expr;
			last_cmp = -1;
34808ac4:	e1a0700a 	mov	r7, sl
34808ac8:	e3a09001 	mov	r9, #1
34808acc:	eaffffe6 	b	34808a6c <do_test+0x3d0>
34808ad0:	34827132 	.word	0x34827132
34808ad4:	34825e37 	.word	0x34825e37
34808ad8:	34825e3a 	.word	0x34825e3a
34808adc:	34825e3d 	.word	0x34825e3d
34808ae0:	34825e40 	.word	0x34825e40
34808ae4:	348238f5 	.word	0x348238f5
34808ae8:	348238f4 	.word	0x348238f4
34808aec:	348238f8 	.word	0x348238f8
34808af0:	348238e3 	.word	0x348238e3
34808af4:	348238e9 	.word	0x348238e9
34808af8:	348238f0 	.word	0x348238f0
34808afc:	348238df 	.word	0x348238df
34808b00:	34823901 	.word	0x34823901
34808b04:	348238e5 	.word	0x348238e5
34808b08:	348238fa 	.word	0x348238fa

34808b0c <do_version>:
#include <linux/compiler.h>

const char __weak version_string[] = U_BOOT_VERSION_STRING;

int do_version(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
34808b0c:	e92d4008 	push	{r3, lr}
	printf("\n%s\n", version_string);
34808b10:	e59f101c 	ldr	r1, [pc, #28]	; 34808b34 <do_version+0x28>
34808b14:	e59f001c 	ldr	r0, [pc, #28]	; 34808b38 <do_version+0x2c>
34808b18:	eb000191 	bl	34809164 <printf>
#ifdef CC_VERSION_STRING
	puts(CC_VERSION_STRING "\n");
34808b1c:	e59f0018 	ldr	r0, [pc, #24]	; 34808b3c <do_version+0x30>
34808b20:	eb000185 	bl	3480913c <puts>
#endif
#ifdef LD_VERSION_STRING
	puts(LD_VERSION_STRING "\n");
34808b24:	e59f0014 	ldr	r0, [pc, #20]	; 34808b40 <do_version+0x34>
34808b28:	eb000183 	bl	3480913c <puts>
#endif

	return 0;
}
34808b2c:	e3a00000 	mov	r0, #0
34808b30:	e8bd8008 	pop	{r3, pc}
34808b34:	34820238 	.word	0x34820238
34808b38:	34825ea5 	.word	0x34825ea5
34808b3c:	34825eaa 	.word	0x34825eaa
34808b40:	34825ecf 	.word	0x34825ecf

34808b44 <find_cmd_tbl>:

/***************************************************************************
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd_tbl (const char *cmd, cmd_tbl_t *table, int table_len)
{
34808b44:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
34808b48:	e2505000 	subs	r5, r0, #0

/***************************************************************************
 * find command table entry for a command
 */
cmd_tbl_t *find_cmd_tbl (const char *cmd, cmd_tbl_t *table, int table_len)
{
34808b4c:	e1a04002 	mov	r4, r2
34808b50:	e1a06001 	mov	r6, r1
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
		return NULL;
34808b54:	01a04005 	moveq	r4, r5
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;

	if (!cmd)
34808b58:	0a00001e 	beq	34808bd8 <find_cmd_tbl+0x94>
		return NULL;
	/*
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);
34808b5c:	e3a0102e 	mov	r1, #46	; 0x2e
34808b60:	eb004c21 	bl	3481bbec <strchr>
34808b64:	e3500000 	cmp	r0, #0
34808b68:	1065a000 	rsbne	sl, r5, r0
34808b6c:	1a000002 	bne	34808b7c <find_cmd_tbl+0x38>
34808b70:	e1a00005 	mov	r0, r5
34808b74:	eb004c32 	bl	3481bc44 <strlen>
34808b78:	e1a0a000 	mov	sl, r0

	for (cmdtp = table;
	     cmdtp != table + table_len;
34808b7c:	e3a09018 	mov	r9, #24
34808b80:	e0296499 	mla	r9, r9, r4, r6
{
	cmd_tbl_t *cmdtp;
	cmd_tbl_t *cmdtp_temp = table;	/*Init value */
	const char *p;
	int len;
	int n_found = 0;
34808b84:	e3a07000 	mov	r7, #0
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = table;
34808b88:	e1a04006 	mov	r4, r6
34808b8c:	ea00000c 	b	34808bc4 <find_cmd_tbl+0x80>
	     cmdtp != table + table_len;
	     cmdtp++) {
		if (strncmp (cmd, cmdtp->name, len) == 0) {
34808b90:	e1a00005 	mov	r0, r5
34808b94:	e5941000 	ldr	r1, [r4]
34808b98:	e1a0200a 	mov	r2, sl
34808b9c:	eb004c00 	bl	3481bba4 <strncmp>
34808ba0:	e3500000 	cmp	r0, #0
34808ba4:	1a000005 	bne	34808bc0 <find_cmd_tbl+0x7c>
			if (len == strlen (cmdtp->name))
34808ba8:	e5940000 	ldr	r0, [r4]
34808bac:	eb004c24 	bl	3481bc44 <strlen>
34808bb0:	e15a0000 	cmp	sl, r0
34808bb4:	0a000007 	beq	34808bd8 <find_cmd_tbl+0x94>
				return cmdtp;	/* full match */

			cmdtp_temp = cmdtp;	/* abbreviated command ? */
			n_found++;
34808bb8:	e2877001 	add	r7, r7, #1
34808bbc:	e1a06004 	mov	r6, r4
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = table;
	     cmdtp != table + table_len;
	     cmdtp++) {
34808bc0:	e2844018 	add	r4, r4, #24
	 * Some commands allow length modifiers (like "cp.b");
	 * compare command name only until first dot.
	 */
	len = ((p = strchr(cmd, '.')) == NULL) ? strlen (cmd) : (p - cmd);

	for (cmdtp = table;
34808bc4:	e1540009 	cmp	r4, r9
34808bc8:	1afffff0 	bne	34808b90 <find_cmd_tbl+0x4c>
	}
	if (n_found == 1) {			/* exactly one match */
		return cmdtp_temp;
	}

	return NULL;	/* not found or ambiguous command */
34808bcc:	e3570001 	cmp	r7, #1
34808bd0:	01a04006 	moveq	r4, r6
34808bd4:	13a04000 	movne	r4, #0
}
34808bd8:	e1a00004 	mov	r0, r4
34808bdc:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

34808be0 <find_cmd>:

cmd_tbl_t *find_cmd (const char *cmd)
{
	int len = &__u_boot_cmd_end - &__u_boot_cmd_start;
	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
34808be0:	e59f1014 	ldr	r1, [pc, #20]	; 34808bfc <find_cmd+0x1c>
	return NULL;	/* not found or ambiguous command */
}

cmd_tbl_t *find_cmd (const char *cmd)
{
	int len = &__u_boot_cmd_end - &__u_boot_cmd_start;
34808be4:	e59f3014 	ldr	r3, [pc, #20]	; 34808c00 <find_cmd+0x20>
	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
34808be8:	e59f2014 	ldr	r2, [pc, #20]	; 34808c04 <find_cmd+0x24>
	return NULL;	/* not found or ambiguous command */
}

cmd_tbl_t *find_cmd (const char *cmd)
{
	int len = &__u_boot_cmd_end - &__u_boot_cmd_start;
34808bec:	e0613003 	rsb	r3, r1, r3
34808bf0:	e1a031c3 	asr	r3, r3, #3
	return find_cmd_tbl(cmd, &__u_boot_cmd_start, len);
34808bf4:	e0020392 	mul	r2, r2, r3
34808bf8:	eaffffd1 	b	34808b44 <find_cmd_tbl>
34808bfc:	34829498 	.word	0x34829498
34808c00:	34829900 	.word	0x34829900
34808c04:	aaaaaaab 	.word	0xaaaaaaab

34808c08 <cmd_usage>:
}

int cmd_usage(const cmd_tbl_t *cmdtp)
{
34808c08:	e92d4010 	push	{r4, lr}
34808c0c:	e1a04000 	mov	r4, r0
	printf("%s - %s\n\n", cmdtp->name, cmdtp->usage);
34808c10:	e5941000 	ldr	r1, [r4]
34808c14:	e5942010 	ldr	r2, [r4, #16]
34808c18:	e59f0038 	ldr	r0, [pc, #56]	; 34808c58 <cmd_usage+0x50>
34808c1c:	eb000150 	bl	34809164 <printf>

#ifdef	CONFIG_SYS_LONGHELP
	printf("Usage:\n%s ", cmdtp->name);
34808c20:	e59f0034 	ldr	r0, [pc, #52]	; 34808c5c <cmd_usage+0x54>
34808c24:	e5941000 	ldr	r1, [r4]
34808c28:	eb00014d 	bl	34809164 <printf>

	if (!cmdtp->help) {
34808c2c:	e5940014 	ldr	r0, [r4, #20]
34808c30:	e3500000 	cmp	r0, #0
34808c34:	1a000002 	bne	34808c44 <cmd_usage+0x3c>
		puts ("- No additional help available.\n");
34808c38:	e59f0020 	ldr	r0, [pc, #32]	; 34808c60 <cmd_usage+0x58>
34808c3c:	eb00013e 	bl	3480913c <puts>
		return 1;
34808c40:	ea000002 	b	34808c50 <cmd_usage+0x48>
	}

	puts (cmdtp->help);
34808c44:	eb00013c 	bl	3480913c <puts>
	putc ('\n');
34808c48:	e3a0000a 	mov	r0, #10
34808c4c:	eb000130 	bl	34809114 <putc>
#endif	/* CONFIG_SYS_LONGHELP */
	return 1;
}
34808c50:	e3a00001 	mov	r0, #1
34808c54:	e8bd8010 	pop	{r4, pc}
34808c58:	34825f16 	.word	0x34825f16
34808c5c:	34825f20 	.word	0x34825f20
34808c60:	34825f2b 	.word	0x34825f2b

34808c64 <_do_help>:
 * for long help messages
 */

int _do_help (cmd_tbl_t *cmd_start, int cmd_items, cmd_tbl_t * cmdtp, int
	      flag, int argc, char * const argv[])
{
34808c64:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34808c68:	e28db01c 	add	fp, sp, #28
34808c6c:	e24dd010 	sub	sp, sp, #16
34808c70:	e59b9004 	ldr	r9, [fp, #4]
34808c74:	e1a0a000 	mov	sl, r0
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
34808c78:	e3590001 	cmp	r9, #1
 * for long help messages
 */

int _do_help (cmd_tbl_t *cmd_start, int cmd_items, cmd_tbl_t * cmdtp, int
	      flag, int argc, char * const argv[])
{
34808c7c:	e1a04001 	mov	r4, r1
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
34808c80:	159b7008 	ldrne	r7, [fp, #8]
34808c84:	13a05000 	movne	r5, #0
34808c88:	13a06001 	movne	r6, #1
34808c8c:	1a00004f 	bne	34808dd0 <_do_help+0x16c>
		cmd_tbl_t *cmd_array[cmd_items];
34808c90:	e1a03101 	lsl	r3, r1, #2
34808c94:	e283300e 	add	r3, r3, #14
34808c98:	e3c33007 	bic	r3, r3, #7
	      flag, int argc, char * const argv[])
{
	int i;
	int rcode = 0;

	if (argc == 1) {	/*show list of commands */
34808c9c:	e50bd024 	str	sp, [fp, #-36]	; 0x24
		cmd_tbl_t *cmd_array[cmd_items];
34808ca0:	e04dd003 	sub	sp, sp, r3
34808ca4:	e1a0300d 	mov	r3, sp
34808ca8:	e50bd020 	str	sp, [fp, #-32]
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = cmd_start;
		for (i = 0; i < cmd_items; i++) {
34808cac:	e1a0100d 	mov	r1, sp
34808cb0:	e3a02000 	mov	r2, #0
34808cb4:	ea000002 	b	34808cc4 <_do_help+0x60>
			cmd_array[i] = cmdtp++;
34808cb8:	e481a004 	str	sl, [r1], #4
		cmd_tbl_t *cmd_array[cmd_items];
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = cmd_start;
		for (i = 0; i < cmd_items; i++) {
34808cbc:	e2822001 	add	r2, r2, #1
			cmd_array[i] = cmdtp++;
34808cc0:	e28aa018 	add	sl, sl, #24
		cmd_tbl_t *cmd_array[cmd_items];
		int i, j, swaps;

		/* Make array of commands from .uboot_cmd section */
		cmdtp = cmd_start;
		for (i = 0; i < cmd_items; i++) {
34808cc4:	e1520004 	cmp	r2, r4
34808cc8:	bafffffa 	blt	34808cb8 <_do_help+0x54>
			cmd_array[i] = cmdtp++;
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
34808ccc:	e2446001 	sub	r6, r4, #1
34808cd0:	ea000017 	b	34808d34 <_do_help+0xd0>
34808cd4:	e3a07000 	mov	r7, #0
34808cd8:	e1a05003 	mov	r5, r3
34808cdc:	e1a0a007 	mov	sl, r7
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
34808ce0:	e5952000 	ldr	r2, [r5]
					    cmd_array[j + 1]->name) > 0) {
34808ce4:	e5b59004 	ldr	r9, [r5, #4]!

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
34808ce8:	e5920000 	ldr	r0, [r2]
34808cec:	e5991000 	ldr	r1, [r9]
34808cf0:	e50b2028 	str	r2, [fp, #-40]	; 0x28
34808cf4:	e50b302c 	str	r3, [fp, #-44]	; 0x2c
34808cf8:	eb004b9d 	bl	3481bb74 <strcmp>
34808cfc:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
34808d00:	e3500000 	cmp	r0, #0
					    cmd_array[j + 1]->name) > 0) {
34808d04:	e28aa001 	add	sl, sl, #1

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
34808d08:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
					    cmd_array[j + 1]->name) > 0) {
					cmd_tbl_t *tmp;
					tmp = cmd_array[j];
					cmd_array[j] = cmd_array[j + 1];
					cmd_array[j + 1] = tmp;
					++swaps;
34808d0c:	c2877001 	addgt	r7, r7, #1
			for (j = 0; j < i; ++j) {
				if (strcmp (cmd_array[j]->name,
					    cmd_array[j + 1]->name) > 0) {
					cmd_tbl_t *tmp;
					tmp = cmd_array[j];
					cmd_array[j] = cmd_array[j + 1];
34808d10:	c5059004 	strgt	r9, [r5, #-4]
					cmd_array[j + 1] = tmp;
34808d14:	c5852000 	strgt	r2, [r5]
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
			swaps = 0;
			for (j = 0; j < i; ++j) {
34808d18:	e15a0006 	cmp	sl, r6
34808d1c:	baffffef 	blt	34808ce0 <_do_help+0x7c>
					cmd_array[j] = cmd_array[j + 1];
					cmd_array[j + 1] = tmp;
					++swaps;
				}
			}
			if (!swaps)
34808d20:	e3570000 	cmp	r7, #0
34808d24:	1a000001 	bne	34808d30 <_do_help+0xcc>
		for (i = 0; i < cmd_items; i++) {
			cmd_array[i] = cmdtp++;
		}

		/* Sort command list (trivial bubble sort) */
		for (i = cmd_items - 1; i > 0; --i) {
34808d28:	e3a05000 	mov	r5, #0
34808d2c:	ea000012 	b	34808d7c <_do_help+0x118>
34808d30:	e2466001 	sub	r6, r6, #1
34808d34:	e3560000 	cmp	r6, #0
34808d38:	caffffe5 	bgt	34808cd4 <_do_help+0x70>
34808d3c:	eafffff9 	b	34808d28 <_do_help+0xc4>
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
			const char *usage = cmd_array[i]->usage;
34808d40:	e51b3020 	ldr	r3, [fp, #-32]
34808d44:	e4937004 	ldr	r7, [r3], #4
34808d48:	e50b3020 	str	r3, [fp, #-32]
34808d4c:	e5976010 	ldr	r6, [r7, #16]

			/* allow user abort */
			if (ctrlc ())
34808d50:	eb000128 	bl	348091f8 <ctrlc>
34808d54:	e3500000 	cmp	r0, #0
34808d58:	1a00000b 	bne	34808d8c <_do_help+0x128>
				return 1;
			if (usage == NULL)
34808d5c:	e3560000 	cmp	r6, #0
34808d60:	0a000004 	beq	34808d78 <_do_help+0x114>
				continue;
			printf("%-*s- %s\n", CONFIG_SYS_HELP_CMD_WIDTH,
34808d64:	e59f0078 	ldr	r0, [pc, #120]	; 34808de4 <_do_help+0x180>
34808d68:	e3a01008 	mov	r1, #8
34808d6c:	e5972000 	ldr	r2, [r7]
34808d70:	e1a03006 	mov	r3, r6
34808d74:	eb0000fa 	bl	34809164 <printf>
			if (!swaps)
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
34808d78:	e2855001 	add	r5, r5, #1
34808d7c:	e1550004 	cmp	r5, r4
34808d80:	baffffee 	blt	34808d40 <_do_help+0xdc>
			if (usage == NULL)
				continue;
			printf("%-*s- %s\n", CONFIG_SYS_HELP_CMD_WIDTH,
			       cmd_array[i]->name, usage);
		}
		return 0;
34808d84:	e3a05000 	mov	r5, #0
34808d88:	ea000000 	b	34808d90 <_do_help+0x12c>
		for (i = 0; i < cmd_items; i++) {
			const char *usage = cmd_array[i]->usage;

			/* allow user abort */
			if (ctrlc ())
				return 1;
34808d8c:	e3a05001 	mov	r5, #1
			if (!swaps)
				break;
		}

		/* print short help (usage) */
		for (i = 0; i < cmd_items; i++) {
34808d90:	e51bd024 	ldr	sp, [fp, #-36]	; 0x24
34808d94:	ea00000f 	b	34808dd8 <_do_help+0x174>
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
		if ((cmdtp = find_cmd_tbl (argv[i], cmd_start, cmd_items )) != NULL) {
34808d98:	e5b70004 	ldr	r0, [r7, #4]!
34808d9c:	e1a0100a 	mov	r1, sl
34808da0:	e1a02004 	mov	r2, r4
34808da4:	ebffff66 	bl	34808b44 <find_cmd_tbl>
34808da8:	e3500000 	cmp	r0, #0
34808dac:	0a000002 	beq	34808dbc <_do_help+0x158>
			rcode |= cmd_usage(cmdtp);
34808db0:	ebffff94 	bl	34808c08 <cmd_usage>
34808db4:	e1855000 	orr	r5, r5, r0
34808db8:	ea000003 	b	34808dcc <_do_help+0x168>
		} else {
			printf ("Unknown command '%s' - try 'help'"
34808dbc:	e59f0024 	ldr	r0, [pc, #36]	; 34808de8 <_do_help+0x184>
34808dc0:	e5971000 	ldr	r1, [r7]
34808dc4:	eb0000e6 	bl	34809164 <printf>
				" without arguments for list of all"
				" known commands\n\n", argv[i]
					);
			rcode = 1;
34808dc8:	e3a05001 	mov	r5, #1
		return 0;
	}
	/*
	 * command help (long version)
	 */
	for (i = 1; i < argc; ++i) {
34808dcc:	e2866001 	add	r6, r6, #1
34808dd0:	e1560009 	cmp	r6, r9
34808dd4:	baffffef 	blt	34808d98 <_do_help+0x134>
					);
			rcode = 1;
		}
	}
	return rcode;
}
34808dd8:	e1a00005 	mov	r0, r5
34808ddc:	e24bd01c 	sub	sp, fp, #28
34808de0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34808de4:	34825f4c 	.word	0x34825f4c
34808de8:	34825f56 	.word	0x34825f56

34808dec <cmd_get_data_size>:

#endif

#ifdef CMD_DATA_SIZE
int cmd_get_data_size(char* arg, int default_size)
{
34808dec:	e92d4038 	push	{r3, r4, r5, lr}
34808df0:	e1a04000 	mov	r4, r0
34808df4:	e1a05001 	mov	r5, r1
	/* Check for a size specification .b, .w or .l.
	 */
	int len = strlen(arg);
34808df8:	eb004b91 	bl	3481bc44 <strlen>
	if (len > 2 && arg[len-2] == '.') {
34808dfc:	e3500002 	cmp	r0, #2
34808e00:	da00000a 	ble	34808e30 <cmd_get_data_size+0x44>
34808e04:	e0844000 	add	r4, r4, r0
34808e08:	e5543002 	ldrb	r3, [r4, #-2]
34808e0c:	e353002e 	cmp	r3, #46	; 0x2e
34808e10:	1a000006 	bne	34808e30 <cmd_get_data_size+0x44>
		switch(arg[len-1]) {
34808e14:	e5543001 	ldrb	r3, [r4, #-1]
34808e18:	e2433062 	sub	r3, r3, #98	; 0x62
34808e1c:	e6ef3073 	uxtb	r3, r3
34808e20:	e3530015 	cmp	r3, #21
34808e24:	959f200c 	ldrls	r2, [pc, #12]	; 34808e38 <cmd_get_data_size+0x4c>
34808e28:	83e05000 	mvnhi	r5, #0
34808e2c:	97925103 	ldrls	r5, [r2, r3, lsl #2]
		default:
			return -1;
		}
	}
	return default_size;
}
34808e30:	e1a00005 	mov	r0, r5
34808e34:	e8bd8038 	pop	{r3, r4, r5, pc}
34808e38:	34820260 	.word	0x34820260

34808e3c <cmd_process>:
	return result;
}

enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
			       int *repeatable)
{
34808e3c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34808e40:	e1a05000 	mov	r5, r0
	enum command_ret_t rc = CMD_RET_SUCCESS;
	cmd_tbl_t *cmdtp;

	/* Look up command in command table */
	cmdtp = find_cmd(argv[0]);
34808e44:	e5920000 	ldr	r0, [r2]
	return result;
}

enum command_ret_t cmd_process(int flag, int argc, char * const argv[],
			       int *repeatable)
{
34808e48:	e1a0a001 	mov	sl, r1
34808e4c:	e1a06002 	mov	r6, r2
34808e50:	e1a07003 	mov	r7, r3
	enum command_ret_t rc = CMD_RET_SUCCESS;
	cmd_tbl_t *cmdtp;

	/* Look up command in command table */
	cmdtp = find_cmd(argv[0]);
34808e54:	ebffff61 	bl	34808be0 <find_cmd>
	if (cmdtp == NULL) {
34808e58:	e2504000 	subs	r4, r0, #0
34808e5c:	1a000003 	bne	34808e70 <cmd_process+0x34>
		printf("Unknown command '%s' - try 'help'\n", argv[0]);
34808e60:	e5961000 	ldr	r1, [r6]
34808e64:	e59f0078 	ldr	r0, [pc, #120]	; 34808ee4 <cmd_process+0xa8>
34808e68:	eb0000bd 	bl	34809164 <printf>
34808e6c:	ea00000b 	b	34808ea0 <cmd_process+0x64>
		return 1;
	}

	/* found - check max args */
	if (argc > cmdtp->maxargs)
34808e70:	e5943004 	ldr	r3, [r4, #4]
34808e74:	e15a0003 	cmp	sl, r3
34808e78:	ca00000a 	bgt	34808ea8 <cmd_process+0x6c>
		rc = CMD_RET_USAGE;

#if defined(CONFIG_CMD_BOOTD)
	/* avoid "bootd" recursion */
	else if (cmdtp->cmd == do_bootd) {
34808e7c:	e594c00c 	ldr	ip, [r4, #12]
34808e80:	e59f3060 	ldr	r3, [pc, #96]	; 34808ee8 <cmd_process+0xac>
34808e84:	e15c0003 	cmp	ip, r3
34808e88:	1a000009 	bne	34808eb4 <cmd_process+0x78>
		if (flag & CMD_FLAG_BOOTD) {
34808e8c:	e3150002 	tst	r5, #2
			puts("'bootd' recursion detected\n");
			rc = CMD_RET_FAILURE;
		} else {
			flag |= CMD_FLAG_BOOTD;
34808e90:	03855002 	orreq	r5, r5, #2
		rc = CMD_RET_USAGE;

#if defined(CONFIG_CMD_BOOTD)
	/* avoid "bootd" recursion */
	else if (cmdtp->cmd == do_bootd) {
		if (flag & CMD_FLAG_BOOTD) {
34808e94:	0a000006 	beq	34808eb4 <cmd_process+0x78>
			puts("'bootd' recursion detected\n");
34808e98:	e59f004c 	ldr	r0, [pc, #76]	; 34808eec <cmd_process+0xb0>
34808e9c:	eb0000a6 	bl	3480913c <puts>
			rc = CMD_RET_FAILURE;
34808ea0:	e3a00001 	mov	r0, #1
34808ea4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
	}
	if (rc == CMD_RET_USAGE)
		rc = cmd_usage(cmdtp);
34808ea8:	e1a00004 	mov	r0, r4
	return rc;
}
34808eac:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
	}
	if (rc == CMD_RET_USAGE)
		rc = cmd_usage(cmdtp);
34808eb0:	eaffff54 	b	34808c08 <cmd_usage>
 */
static int cmd_call(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
	int result;

	result = (cmdtp->cmd)(cmdtp, flag, argc, argv);
34808eb4:	e1a0200a 	mov	r2, sl
34808eb8:	e1a03006 	mov	r3, r6
34808ebc:	e1a00004 	mov	r0, r4
34808ec0:	e1a01005 	mov	r1, r5
34808ec4:	e12fff3c 	blx	ip
#endif

	/* If OK so far, then do the command */
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
34808ec8:	e5972000 	ldr	r2, [r7]
34808ecc:	e5943008 	ldr	r3, [r4, #8]
	}
	if (rc == CMD_RET_USAGE)
34808ed0:	e3700001 	cmn	r0, #1
#endif

	/* If OK so far, then do the command */
	if (!rc) {
		rc = cmd_call(cmdtp, flag, argc, argv);
		*repeatable &= cmdtp->repeatable;
34808ed4:	e0023003 	and	r3, r2, r3
34808ed8:	e5873000 	str	r3, [r7]
	}
	if (rc == CMD_RET_USAGE)
34808edc:	18bd84f0 	popne	{r4, r5, r6, r7, sl, pc}
34808ee0:	eafffff0 	b	34808ea8 <cmd_process+0x6c>
34808ee4:	34825fab 	.word	0x34825fab
34808ee8:	34801b1c 	.word	0x34801b1c
34808eec:	34825fce 	.word	0x34825fce

34808ef0 <console_setfile>:
#endif /* CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE */

#endif /* CONFIG_SYS_CONSOLE_IS_IN_ENV */

static int console_setfile(int file, struct stdio_dev * dev)
{
34808ef0:	e92d4038 	push	{r3, r4, r5, lr}
	int error = 0;

	if (dev == NULL)
34808ef4:	e2515000 	subs	r5, r1, #0
#endif /* CONFIG_SYS_CONSOLE_OVERWRITE_ROUTINE */

#endif /* CONFIG_SYS_CONSOLE_IS_IN_ENV */

static int console_setfile(int file, struct stdio_dev * dev)
{
34808ef8:	e1a04000 	mov	r4, r0
	int error = 0;

	if (dev == NULL)
		return -1;
34808efc:	03e00000 	mvneq	r0, #0

static int console_setfile(int file, struct stdio_dev * dev)
{
	int error = 0;

	if (dev == NULL)
34808f00:	08bd8038 	popeq	{r3, r4, r5, pc}
		return -1;

	switch (file) {
34808f04:	e3540002 	cmp	r4, #2
34808f08:	8a00001d 	bhi	34808f84 <console_setfile+0x94>
	case stdin:
	case stdout:
	case stderr:
		/* Start new device */
		if (dev->start) {
34808f0c:	e5950018 	ldr	r0, [r5, #24]
34808f10:	e3500000 	cmp	r0, #0
34808f14:	0a000002 	beq	34808f24 <console_setfile+0x34>
			error = dev->start();
34808f18:	e12fff30 	blx	r0
			/* If it's not started dont use it */
			if (error < 0)
34808f1c:	e3500000 	cmp	r0, #0
34808f20:	b8bd8038 	poplt	{r3, r4, r5, pc}
				break;
		}

		/* Assign the new device (leaving the existing one started) */
		stdio_devices[file] = dev;
34808f24:	e59f3060 	ldr	r3, [pc, #96]	; 34808f8c <console_setfile+0x9c>

		/*
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
34808f28:	e3540000 	cmp	r4, #0
			if (error < 0)
				break;
		}

		/* Assign the new device (leaving the existing one started) */
		stdio_devices[file] = dev;
34808f2c:	e7835104 	str	r5, [r3, r4, lsl #2]

		/*
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
34808f30:	0a000002 	beq	34808f40 <console_setfile+0x50>
34808f34:	e3540001 	cmp	r4, #1
34808f38:	18bd8038 	popne	{r3, r4, r5, pc}
34808f3c:	ea000006 	b	34808f5c <console_setfile+0x6c>
		case stdin:
			gd->jt[XF_getc] = dev->getc;
34808f40:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34808f44:	e595102c 	ldr	r1, [r5, #44]	; 0x2c
			gd->jt[XF_tstc] = dev->tstc;
34808f48:	e5983054 	ldr	r3, [r8, #84]	; 0x54
		 * Update monitor functions
		 * (to use the console stuff by other applications)
		 */
		switch (file) {
		case stdin:
			gd->jt[XF_getc] = dev->getc;
34808f4c:	e5821004 	str	r1, [r2, #4]
			gd->jt[XF_tstc] = dev->tstc;
34808f50:	e5952028 	ldr	r2, [r5, #40]	; 0x28
34808f54:	e5832008 	str	r2, [r3, #8]
			break;
34808f58:	e8bd8038 	pop	{r3, r4, r5, pc}
		case stdout:
			gd->jt[XF_putc] = dev->putc;
34808f5c:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34808f60:	e5951020 	ldr	r1, [r5, #32]
34808f64:	e582100c 	str	r1, [r2, #12]
			gd->jt[XF_puts] = dev->puts;
34808f68:	e5982054 	ldr	r2, [r8, #84]	; 0x54
34808f6c:	e5951024 	ldr	r1, [r5, #36]	; 0x24
			gd->jt[XF_printf] = printf;
34808f70:	e5983054 	ldr	r3, [r8, #84]	; 0x54
			gd->jt[XF_getc] = dev->getc;
			gd->jt[XF_tstc] = dev->tstc;
			break;
		case stdout:
			gd->jt[XF_putc] = dev->putc;
			gd->jt[XF_puts] = dev->puts;
34808f74:	e5821010 	str	r1, [r2, #16]
			gd->jt[XF_printf] = printf;
34808f78:	e59f2010 	ldr	r2, [pc, #16]	; 34808f90 <console_setfile+0xa0>
34808f7c:	e5832014 	str	r2, [r3, #20]
			break;
34808f80:	e8bd8038 	pop	{r3, r4, r5, pc}
		}
		break;

	default:		/* Invalid file ID */
		error = -1;
34808f84:	e3e00000 	mvn	r0, #0
	}
	return error;
}
34808f88:	e8bd8038 	pop	{r3, r4, r5, pc}
34808f8c:	3482b5c0 	.word	0x3482b5c0
34808f90:	34809164 	.word	0x34809164

34808f94 <serial_printf>:
#endif /* defined(CONFIG_CONSOLE_MUX) */

/** U-Boot INITIAL CONSOLE-NOT COMPATIBLE FUNCTIONS *************************/

int serial_printf(const char *fmt, ...)
{
34808f94:	e92d000f 	push	{r0, r1, r2, r3}
34808f98:	e92d4030 	push	{r4, r5, lr}
34808f9c:	e24ddf63 	sub	sp, sp, #396	; 0x18c
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34808fa0:	e28d4004 	add	r4, sp, #4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
34808fa4:	e28d2f67 	add	r2, sp, #412	; 0x19c

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34808fa8:	e59d1198 	ldr	r1, [sp, #408]	; 0x198
34808fac:	e1a00004 	mov	r0, r4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
34808fb0:	e58d2184 	str	r2, [sp, #388]	; 0x184

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34808fb4:	eb004f5a 	bl	3481cd24 <vsprintf>
34808fb8:	e1a05000 	mov	r5, r0
	va_end(args);

	serial_puts(printbuffer);
34808fbc:	e1a00004 	mov	r0, r4
34808fc0:	eb0015c2 	bl	3480e6d0 <serial_puts>
	return i;
}
34808fc4:	e1a00005 	mov	r0, r5
34808fc8:	e28ddf63 	add	sp, sp, #396	; 0x18c
34808fcc:	e8bd4030 	pop	{r4, r5, lr}
34808fd0:	e28dd010 	add	sp, sp, #16
34808fd4:	e12fff1e 	bx	lr

34808fd8 <fgetc>:

int fgetc(int file)
{
	if (file < MAX_FILES) {
34808fd8:	e3500002 	cmp	r0, #2
	serial_puts(printbuffer);
	return i;
}

int fgetc(int file)
{
34808fdc:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES) {
34808fe0:	ca000004 	bgt	34808ff8 <fgetc+0x20>
	iomux_doenv(file, dev->name);
}
#else
static inline int console_getc(int file)
{
	return stdio_devices[file]->getc();
34808fe4:	e59f3014 	ldr	r3, [pc, #20]	; 34809000 <fgetc+0x28>
34808fe8:	e7933100 	ldr	r3, [r3, r0, lsl #2]
34808fec:	e593302c 	ldr	r3, [r3, #44]	; 0x2c
34808ff0:	e12fff33 	blx	r3
			 */
			 udelay(1);
#endif
		}
#else
		return console_getc(file);
34808ff4:	e8bd8008 	pop	{r3, pc}
#endif
	}

	return -1;
34808ff8:	e3e00000 	mvn	r0, #0
}
34808ffc:	e8bd8008 	pop	{r3, pc}
34809000:	3482b5c0 	.word	0x3482b5c0

34809004 <ftstc>:

int ftstc(int file)
{
	if (file < MAX_FILES)
34809004:	e3500002 	cmp	r0, #2

	return -1;
}

int ftstc(int file)
{
34809008:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES)
3480900c:	ca000004 	bgt	34809024 <ftstc+0x20>
	return stdio_devices[file]->getc();
}

static inline int console_tstc(int file)
{
	return stdio_devices[file]->tstc();
34809010:	e59f3014 	ldr	r3, [pc, #20]	; 3480902c <ftstc+0x28>
34809014:	e7933100 	ldr	r3, [r3, r0, lsl #2]
34809018:	e5933028 	ldr	r3, [r3, #40]	; 0x28
3480901c:	e12fff33 	blx	r3
}

int ftstc(int file)
{
	if (file < MAX_FILES)
		return console_tstc(file);
34809020:	e8bd8008 	pop	{r3, pc}

	return -1;
34809024:	e3e00000 	mvn	r0, #0
}
34809028:	e8bd8008 	pop	{r3, pc}
3480902c:	3482b5c0 	.word	0x3482b5c0

34809030 <fputc>:

void fputc(int file, const char c)
{
	if (file < MAX_FILES)
34809030:	e3500002 	cmp	r0, #2

	return -1;
}

void fputc(int file, const char c)
{
34809034:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES)
34809038:	c8bd8008 	popgt	{r3, pc}
	return stdio_devices[file]->tstc();
}

static inline void console_putc(int file, const char c)
{
	stdio_devices[file]->putc(c);
3480903c:	e59f2010 	ldr	r2, [pc, #16]	; 34809054 <fputc+0x24>
34809040:	e7923100 	ldr	r3, [r2, r0, lsl #2]
34809044:	e1a00001 	mov	r0, r1
34809048:	e5933020 	ldr	r3, [r3, #32]
3480904c:	e12fff33 	blx	r3
34809050:	e8bd8008 	pop	{r3, pc}
34809054:	3482b5c0 	.word	0x3482b5c0

34809058 <fputs>:
		console_putc(file, c);
}

void fputs(int file, const char *s)
{
	if (file < MAX_FILES)
34809058:	e3500002 	cmp	r0, #2
	if (file < MAX_FILES)
		console_putc(file, c);
}

void fputs(int file, const char *s)
{
3480905c:	e92d4008 	push	{r3, lr}
	if (file < MAX_FILES)
34809060:	c8bd8008 	popgt	{r3, pc}
	stdio_devices[file]->putc(c);
}

static inline void console_puts(int file, const char *s)
{
	stdio_devices[file]->puts(s);
34809064:	e59f2010 	ldr	r2, [pc, #16]	; 3480907c <fputs+0x24>
34809068:	e7923100 	ldr	r3, [r2, r0, lsl #2]
3480906c:	e1a00001 	mov	r0, r1
34809070:	e5933024 	ldr	r3, [r3, #36]	; 0x24
34809074:	e12fff33 	blx	r3
34809078:	e8bd8008 	pop	{r3, pc}
3480907c:	3482b5c0 	.word	0x3482b5c0

34809080 <fprintf>:
	if (file < MAX_FILES)
		console_puts(file, s);
}

int fprintf(int file, const char *fmt, ...)
{
34809080:	e92d000e 	push	{r1, r2, r3}
34809084:	e92d4070 	push	{r4, r5, r6, lr}
34809088:	e24ddf63 	sub	sp, sp, #396	; 0x18c
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
3480908c:	e28d4004 	add	r4, sp, #4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
34809090:	e28d2e1a 	add	r2, sp, #416	; 0x1a0
	if (file < MAX_FILES)
		console_puts(file, s);
}

int fprintf(int file, const char *fmt, ...)
{
34809094:	e1a05000 	mov	r5, r0
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809098:	e59d119c 	ldr	r1, [sp, #412]	; 0x19c
3480909c:	e1a00004 	mov	r0, r4
{
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

	va_start(args, fmt);
348090a0:	e58d2184 	str	r2, [sp, #388]	; 0x184

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
348090a4:	eb004f1e 	bl	3481cd24 <vsprintf>
	va_end(args);

	/* Send to desired file */
	fputs(file, printbuffer);
348090a8:	e1a01004 	mov	r1, r4
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
348090ac:	e1a06000 	mov	r6, r0
	va_end(args);

	/* Send to desired file */
	fputs(file, printbuffer);
348090b0:	e1a00005 	mov	r0, r5
348090b4:	ebffffe7 	bl	34809058 <fputs>
	return i;
}
348090b8:	e1a00006 	mov	r0, r6
348090bc:	e28ddf63 	add	sp, sp, #396	; 0x18c
348090c0:	e8bd4070 	pop	{r4, r5, r6, lr}
348090c4:	e28dd00c 	add	sp, sp, #12
348090c8:	e12fff1e 	bx	lr

348090cc <getc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return 0;
#endif

	if (!gd->have_console)
348090cc:	e598000c 	ldr	r0, [r8, #12]
348090d0:	e3500000 	cmp	r0, #0
348090d4:	012fff1e 	bxeq	lr
		return 0;

	if (gd->flags & GD_FLG_DEVINIT) {
348090d8:	e5983004 	ldr	r3, [r8, #4]
348090dc:	e3130002 	tst	r3, #2
348090e0:	0a000001 	beq	348090ec <getc+0x20>
		/* Get from the standard input */
		return fgetc(stdin);
348090e4:	e3a00000 	mov	r0, #0
348090e8:	eaffffba 	b	34808fd8 <fgetc>
	}

	/* Send directly to the handler */
	return serial_getc();
348090ec:	ea001566 	b	3480e68c <serial_getc>

348090f0 <tstc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return 0;
#endif

	if (!gd->have_console)
348090f0:	e598000c 	ldr	r0, [r8, #12]
348090f4:	e3500000 	cmp	r0, #0
348090f8:	012fff1e 	bxeq	lr
		return 0;

	if (gd->flags & GD_FLG_DEVINIT) {
348090fc:	e5983004 	ldr	r3, [r8, #4]
34809100:	e3130002 	tst	r3, #2
34809104:	0a000001 	beq	34809110 <tstc+0x20>
		/* Test the standard input */
		return ftstc(stdin);
34809108:	e3a00000 	mov	r0, #0
3480910c:	eaffffbc 	b	34809004 <ftstc>
	}

	/* Send directly to the handler */
	return serial_tstc();
34809110:	ea001562 	b	3480e6a0 <serial_tstc>

34809114 <putc>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
34809114:	e598200c 	ldr	r2, [r8, #12]
static inline void pre_console_puts(const char *s) {}
static inline void print_pre_console_buffer(void) {}
#endif

void putc(const char c)
{
34809118:	e1a01000 	mov	r1, r0
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
3480911c:	e3520000 	cmp	r2, #0
34809120:	012fff1e 	bxeq	lr
		return pre_console_putc(c);

	if (gd->flags & GD_FLG_DEVINIT) {
34809124:	e5983004 	ldr	r3, [r8, #4]
34809128:	e3130002 	tst	r3, #2
3480912c:	0a000001 	beq	34809138 <putc+0x24>
		/* Send to the standard output */
		fputc(stdout, c);
34809130:	e3a00001 	mov	r0, #1
34809134:	eaffffbd 	b	34809030 <fputc>
	} else {
		/* Send directly to the handler */
		serial_putc(c);
34809138:	ea00155d 	b	3480e6b4 <serial_putc>

3480913c <puts>:
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
3480913c:	e598200c 	ldr	r2, [r8, #12]
		serial_putc(c);
	}
}

void puts(const char *s)
{
34809140:	e1a01000 	mov	r1, r0
#ifdef CONFIG_DISABLE_CONSOLE
	if (gd->flags & GD_FLG_DISABLE_CONSOLE)
		return;
#endif

	if (!gd->have_console)
34809144:	e3520000 	cmp	r2, #0
34809148:	012fff1e 	bxeq	lr
		return pre_console_puts(s);

	if (gd->flags & GD_FLG_DEVINIT) {
3480914c:	e5983004 	ldr	r3, [r8, #4]
34809150:	e3130002 	tst	r3, #2
34809154:	0a000001 	beq	34809160 <puts+0x24>
		/* Send to the standard output */
		fputs(stdout, s);
34809158:	e3a00001 	mov	r0, #1
3480915c:	eaffffbd 	b	34809058 <fputs>
	} else {
		/* Send directly to the handler */
		serial_puts(s);
34809160:	ea00155a 	b	3480e6d0 <serial_puts>

34809164 <printf>:
	}
}

int printf(const char *fmt, ...)
{
34809164:	e92d000f 	push	{r0, r1, r2, r3}
34809168:	e92d4030 	push	{r4, r5, lr}
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
3480916c:	e598500c 	ldr	r5, [r8, #12]
		serial_puts(s);
	}
}

int printf(const char *fmt, ...)
{
34809170:	e24ddf63 	sub	sp, sp, #396	; 0x18c
	va_list args;
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
34809174:	e3550000 	cmp	r5, #0
34809178:	0a000008 	beq	348091a0 <printf+0x3c>
	va_start(args, fmt);

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
3480917c:	e28d4004 	add	r4, sp, #4
#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
		return 0;
#endif

	va_start(args, fmt);
34809180:	e28d2f67 	add	r2, sp, #412	; 0x19c

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809184:	e1a00004 	mov	r0, r4
34809188:	e59d1198 	ldr	r1, [sp, #408]	; 0x198
#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
		return 0;
#endif

	va_start(args, fmt);
3480918c:	e58d2184 	str	r2, [sp, #388]	; 0x184

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
34809190:	eb004ee3 	bl	3481cd24 <vsprintf>
34809194:	e1a05000 	mov	r5, r0
	va_end(args);

	/* Print the string */
	puts(printbuffer);
34809198:	e1a00004 	mov	r0, r4
3480919c:	ebffffe6 	bl	3480913c <puts>
	return i;
}
348091a0:	e1a00005 	mov	r0, r5
348091a4:	e28ddf63 	add	sp, sp, #396	; 0x18c
348091a8:	e8bd4030 	pop	{r4, r5, lr}
348091ac:	e28dd010 	add	sp, sp, #16
348091b0:	e12fff1e 	bx	lr

348091b4 <vprintf>:

int vprintf(const char *fmt, va_list args)
{
348091b4:	e92d4030 	push	{r4, r5, lr}
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
348091b8:	e598500c 	ldr	r5, [r8, #12]
	puts(printbuffer);
	return i;
}

int vprintf(const char *fmt, va_list args)
{
348091bc:	e24ddf61 	sub	sp, sp, #388	; 0x184
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
348091c0:	e3550000 	cmp	r5, #0
	puts(printbuffer);
	return i;
}

int vprintf(const char *fmt, va_list args)
{
348091c4:	e1a03000 	mov	r3, r0
348091c8:	e1a02001 	mov	r2, r1
	uint i;
	char printbuffer[CONFIG_SYS_PBSIZE];

#ifndef CONFIG_PRE_CONSOLE_BUFFER
	if (!gd->have_console)
348091cc:	0a000006 	beq	348091ec <vprintf+0x38>
#endif

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
348091d0:	e1a0000d 	mov	r0, sp
348091d4:	e1a01003 	mov	r1, r3
348091d8:	eb004ed1 	bl	3481cd24 <vsprintf>
348091dc:	e1a05000 	mov	r5, r0

	/* Print the string */
	puts(printbuffer);
348091e0:	e1a0000d 	mov	r0, sp
#endif

	/* For this to work, printbuffer must be larger than
	 * anything we ever want to print.
	 */
	i = vscnprintf(printbuffer, sizeof(printbuffer), fmt, args);
348091e4:	e1a0400d 	mov	r4, sp

	/* Print the string */
	puts(printbuffer);
348091e8:	ebffffd3 	bl	3480913c <puts>
	return i;
}
348091ec:	e1a00005 	mov	r0, r5
348091f0:	e28ddf61 	add	sp, sp, #388	; 0x184
348091f4:	e8bd8030 	pop	{r4, r5, pc}

348091f8 <ctrlc>:

/* test if ctrl-c was pressed */
static int ctrlc_disabled = 0;	/* see disable_ctrl() */
static int ctrlc_was_pressed = 0;
int ctrlc(void)
{
348091f8:	e92d4038 	push	{r3, r4, r5, lr}
	if (!ctrlc_disabled && gd->have_console) {
348091fc:	e59f503c 	ldr	r5, [pc, #60]	; 34809240 <ctrlc+0x48>
34809200:	e5954000 	ldr	r4, [r5]
34809204:	e3540000 	cmp	r4, #0
			default:
				break;
			}
		}
	}
	return 0;
34809208:	13a00000 	movne	r0, #0
/* test if ctrl-c was pressed */
static int ctrlc_disabled = 0;	/* see disable_ctrl() */
static int ctrlc_was_pressed = 0;
int ctrlc(void)
{
	if (!ctrlc_disabled && gd->have_console) {
3480920c:	18bd8038 	popne	{r3, r4, r5, pc}
34809210:	e598000c 	ldr	r0, [r8, #12]
34809214:	e3500000 	cmp	r0, #0
34809218:	08bd8038 	popeq	{r3, r4, r5, pc}
		if (tstc()) {
3480921c:	ebffffb3 	bl	348090f0 <tstc>
34809220:	e3500000 	cmp	r0, #0
34809224:	08bd8038 	popeq	{r3, r4, r5, pc}
			switch (getc()) {
34809228:	ebffffa7 	bl	348090cc <getc>
3480922c:	e3500003 	cmp	r0, #3
			case 0x03:		/* ^C - Control C */
				ctrlc_was_pressed = 1;
34809230:	03a00001 	moveq	r0, #1
34809234:	05850004 	streq	r0, [r5, #4]
			default:
				break;
			}
		}
	}
	return 0;
34809238:	11a00004 	movne	r0, r4
}
3480923c:	e8bd8038 	pop	{r3, r4, r5, pc}
34809240:	34829d78 	.word	0x34829d78

34809244 <disable_ctrlc>:
/* pass 1 to disable ctrlc() checking, 0 to enable.
 * returns previous state
 */
int disable_ctrlc(int disable)
{
	int prev = ctrlc_disabled;	/* save previous state */
34809244:	e59f300c 	ldr	r3, [pc, #12]	; 34809258 <disable_ctrlc+0x14>
34809248:	e5932000 	ldr	r2, [r3]

	ctrlc_disabled = disable;
3480924c:	e5830000 	str	r0, [r3]
	return prev;
}
34809250:	e1a00002 	mov	r0, r2
34809254:	e12fff1e 	bx	lr
34809258:	34829d78 	.word	0x34829d78

3480925c <had_ctrlc>:

int had_ctrlc (void)
{
	return ctrlc_was_pressed;
}
3480925c:	e59f3004 	ldr	r3, [pc, #4]	; 34809268 <had_ctrlc+0xc>
34809260:	e5930004 	ldr	r0, [r3, #4]
34809264:	e12fff1e 	bx	lr
34809268:	34829d78 	.word	0x34829d78

3480926c <clear_ctrlc>:

void clear_ctrlc(void)
{
	ctrlc_was_pressed = 0;
3480926c:	e59f3008 	ldr	r3, [pc, #8]	; 3480927c <clear_ctrlc+0x10>
34809270:	e3a02000 	mov	r2, #0
34809274:	e5832004 	str	r2, [r3, #4]
}
34809278:	e12fff1e 	bx	lr
3480927c:	34829d78 	.word	0x34829d78

34809280 <dbg>:
	cursor += strlen(printbuffer);

}
#else
inline void dbg(const char *fmt, ...)
{
34809280:	e92d000f 	push	{r0, r1, r2, r3}
}
34809284:	e28dd010 	add	sp, sp, #16
34809288:	e12fff1e 	bx	lr

3480928c <search_device>:
#endif

/** U-Boot INIT FUNCTIONS *************************************************/

struct stdio_dev *search_device(int flags, const char *name)
{
3480928c:	e92d4010 	push	{r4, lr}
34809290:	e1a04000 	mov	r4, r0
	struct stdio_dev *dev;

	dev = stdio_get_by_name(name);
34809294:	e1a00001 	mov	r0, r1
34809298:	eb001516 	bl	3480e6f8 <stdio_get_by_name>

	if (dev && (dev->flags & flags))
3480929c:	e3500000 	cmp	r0, #0
348092a0:	08bd8010 	popeq	{r4, pc}
348092a4:	e5903000 	ldr	r3, [r0]
348092a8:	e0144003 	ands	r4, r4, r3
		return dev;

	return NULL;
348092ac:	01a00004 	moveq	r0, r4
}
348092b0:	e8bd8010 	pop	{r4, pc}

348092b4 <console_assign>:

int console_assign(int file, const char *devname)
{
348092b4:	e92d4010 	push	{r4, lr}
	int flag;
	struct stdio_dev *dev;

	/* Check for valid file */
	switch (file) {
348092b8:	e2504000 	subs	r4, r0, #0
	case stdin:
		flag = DEV_FLAGS_INPUT;
348092bc:	03a00001 	moveq	r0, #1
{
	int flag;
	struct stdio_dev *dev;

	/* Check for valid file */
	switch (file) {
348092c0:	0a000003 	beq	348092d4 <console_assign+0x20>
348092c4:	ba000008 	blt	348092ec <console_assign+0x38>
348092c8:	e3540002 	cmp	r4, #2
348092cc:	ca000006 	bgt	348092ec <console_assign+0x38>
	case stdin:
		flag = DEV_FLAGS_INPUT;
		break;
	case stdout:
	case stderr:
		flag = DEV_FLAGS_OUTPUT;
348092d0:	e3a00002 	mov	r0, #2
		return -1;
	}

	/* Check for valid device name */

	dev = search_device(flag, devname);
348092d4:	ebffffec 	bl	3480928c <search_device>

	if (dev)
348092d8:	e2501000 	subs	r1, r0, #0
348092dc:	0a000002 	beq	348092ec <console_assign+0x38>
		return console_setfile(file, dev);
348092e0:	e1a00004 	mov	r0, r4

	return -1;
}
348092e4:	e8bd4010 	pop	{r4, lr}
	/* Check for valid device name */

	dev = search_device(flag, devname);

	if (dev)
		return console_setfile(file, dev);
348092e8:	eaffff00 	b	34808ef0 <console_setfile>

	return -1;
}
348092ec:	e3e00000 	mvn	r0, #0
348092f0:	e8bd8010 	pop	{r4, pc}

348092f4 <console_init_f>:

/* Called before relocation - use serial functions */
int console_init_f(void)
{
	gd->have_console = 1;
348092f4:	e3a02001 	mov	r2, #1
348092f8:	e588200c 	str	r2, [r8, #12]
#endif

	print_pre_console_buffer();

	return 0;
}
348092fc:	e3a00000 	mov	r0, #0
34809300:	e12fff1e 	bx	lr

34809304 <stdio_print_current_devices>:

void stdio_print_current_devices(void)
{
34809304:	e92d4010 	push	{r4, lr}
#ifndef CONFIG_SYS_CONSOLE_INFO_QUIET
	/* Print information */
	puts("In:    ");
34809308:	e59f008c 	ldr	r0, [pc, #140]	; 3480939c <stdio_print_current_devices+0x98>
3480930c:	ebffff8a 	bl	3480913c <puts>
	if (stdio_devices[stdin] == NULL) {
34809310:	e59f3088 	ldr	r3, [pc, #136]	; 348093a0 <stdio_print_current_devices+0x9c>
34809314:	e5931000 	ldr	r1, [r3]
34809318:	e3510000 	cmp	r1, #0
3480931c:	1a000002 	bne	3480932c <stdio_print_current_devices+0x28>
		puts("No input devices available!\n");
34809320:	e59f007c 	ldr	r0, [pc, #124]	; 348093a4 <stdio_print_current_devices+0xa0>
34809324:	ebffff84 	bl	3480913c <puts>
34809328:	ea000002 	b	34809338 <stdio_print_current_devices+0x34>
	} else {
		printf ("%s\n", stdio_devices[stdin]->name);
3480932c:	e59f0074 	ldr	r0, [pc, #116]	; 348093a8 <stdio_print_current_devices+0xa4>
34809330:	e2811008 	add	r1, r1, #8
34809334:	ebffff8a 	bl	34809164 <printf>
	}

	puts("Out:   ");
34809338:	e59f006c 	ldr	r0, [pc, #108]	; 348093ac <stdio_print_current_devices+0xa8>
3480933c:	ebffff7e 	bl	3480913c <puts>
	if (stdio_devices[stdout] == NULL) {
34809340:	e59f3058 	ldr	r3, [pc, #88]	; 348093a0 <stdio_print_current_devices+0x9c>
34809344:	e5931004 	ldr	r1, [r3, #4]
34809348:	e3510000 	cmp	r1, #0
3480934c:	1a000002 	bne	3480935c <stdio_print_current_devices+0x58>
		puts("No output devices available!\n");
34809350:	e59f0058 	ldr	r0, [pc, #88]	; 348093b0 <stdio_print_current_devices+0xac>
34809354:	ebffff78 	bl	3480913c <puts>
34809358:	ea000002 	b	34809368 <stdio_print_current_devices+0x64>
	} else {
		printf ("%s\n", stdio_devices[stdout]->name);
3480935c:	e59f0044 	ldr	r0, [pc, #68]	; 348093a8 <stdio_print_current_devices+0xa4>
34809360:	e2811008 	add	r1, r1, #8
34809364:	ebffff7e 	bl	34809164 <printf>
	}

	puts("Err:   ");
34809368:	e59f0044 	ldr	r0, [pc, #68]	; 348093b4 <stdio_print_current_devices+0xb0>
3480936c:	ebffff72 	bl	3480913c <puts>
	if (stdio_devices[stderr] == NULL) {
34809370:	e59f3028 	ldr	r3, [pc, #40]	; 348093a0 <stdio_print_current_devices+0x9c>
34809374:	e5931008 	ldr	r1, [r3, #8]
34809378:	e3510000 	cmp	r1, #0
3480937c:	1a000002 	bne	3480938c <stdio_print_current_devices+0x88>
		puts("No error devices available!\n");
34809380:	e59f0030 	ldr	r0, [pc, #48]	; 348093b8 <stdio_print_current_devices+0xb4>
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
	}
#endif /* CONFIG_SYS_CONSOLE_INFO_QUIET */
}
34809384:	e8bd4010 	pop	{r4, lr}
		printf ("%s\n", stdio_devices[stdout]->name);
	}

	puts("Err:   ");
	if (stdio_devices[stderr] == NULL) {
		puts("No error devices available!\n");
34809388:	eaffff6b 	b	3480913c <puts>
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
3480938c:	e59f0014 	ldr	r0, [pc, #20]	; 348093a8 <stdio_print_current_devices+0xa4>
34809390:	e2811008 	add	r1, r1, #8
	}
#endif /* CONFIG_SYS_CONSOLE_INFO_QUIET */
}
34809394:	e8bd4010 	pop	{r4, lr}

	puts("Err:   ");
	if (stdio_devices[stderr] == NULL) {
		puts("No error devices available!\n");
	} else {
		printf ("%s\n", stdio_devices[stderr]->name);
34809398:	eaffff71 	b	34809164 <printf>
3480939c:	34825fea 	.word	0x34825fea
348093a0:	3482b5c0 	.word	0x3482b5c0
348093a4:	34825ff2 	.word	0x34825ff2
348093a8:	34825ea6 	.word	0x34825ea6
348093ac:	3482600f 	.word	0x3482600f
348093b0:	34826017 	.word	0x34826017
348093b4:	34826035 	.word	0x34826035
348093b8:	3482603d 	.word	0x3482603d

348093bc <console_init_r>:
#ifdef CONFIG_CONSOLE_MUX
	int iomux_err = 0;
#endif

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
348093bc:	e5982054 	ldr	r2, [r8, #84]	; 0x54
348093c0:	e59f1124 	ldr	r1, [pc, #292]	; 348094ec <console_init_r+0x130>
}

#ifdef CONFIG_SYS_CONSOLE_IS_IN_ENV
/* Called after the relocation - use desired console functions */
int console_init_r(void)
{
348093c4:	e92d4070 	push	{r4, r5, r6, lr}
#ifdef CONFIG_CONSOLE_MUX
	int iomux_err = 0;
#endif

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
348093c8:	e5821004 	str	r1, [r2, #4]
	gd->jt[XF_tstc] = serial_tstc;
348093cc:	e5982054 	ldr	r2, [r8, #84]	; 0x54
348093d0:	e59f1118 	ldr	r1, [pc, #280]	; 348094f0 <console_init_r+0x134>
	gd->jt[XF_puts] = serial_puts;
	gd->jt[XF_printf] = serial_printf;

	/* stdin stdout and stderr are in environment */
	/* scan for it */
	stdinname  = getenv("stdin");
348093d4:	e59f0118 	ldr	r0, [pc, #280]	; 348094f4 <console_init_r+0x138>
	int iomux_err = 0;
#endif

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
	gd->jt[XF_tstc] = serial_tstc;
348093d8:	e5821008 	str	r1, [r2, #8]
	gd->jt[XF_putc] = serial_putc;
348093dc:	e5982054 	ldr	r2, [r8, #84]	; 0x54
348093e0:	e59f1110 	ldr	r1, [pc, #272]	; 348094f8 <console_init_r+0x13c>
348093e4:	e582100c 	str	r1, [r2, #12]
	gd->jt[XF_puts] = serial_puts;
348093e8:	e5982054 	ldr	r2, [r8, #84]	; 0x54
348093ec:	e59f1108 	ldr	r1, [pc, #264]	; 348094fc <console_init_r+0x140>
	gd->jt[XF_printf] = serial_printf;
348093f0:	e5983054 	ldr	r3, [r8, #84]	; 0x54

	/* set default handlers at first */
	gd->jt[XF_getc] = serial_getc;
	gd->jt[XF_tstc] = serial_tstc;
	gd->jt[XF_putc] = serial_putc;
	gd->jt[XF_puts] = serial_puts;
348093f4:	e5821010 	str	r1, [r2, #16]
	gd->jt[XF_printf] = serial_printf;
348093f8:	e59f2100 	ldr	r2, [pc, #256]	; 34809500 <console_init_r+0x144>
348093fc:	e5832014 	str	r2, [r3, #20]

	/* stdin stdout and stderr are in environment */
	/* scan for it */
	stdinname  = getenv("stdin");
34809400:	ebfff869 	bl	348075ac <getenv>
34809404:	e1a04000 	mov	r4, r0
	stdoutname = getenv("stdout");
34809408:	e59f00f4 	ldr	r0, [pc, #244]	; 34809504 <console_init_r+0x148>
3480940c:	ebfff866 	bl	348075ac <getenv>
34809410:	e1a06000 	mov	r6, r0
	stderrname = getenv("stderr");
34809414:	e59f00ec 	ldr	r0, [pc, #236]	; 34809508 <console_init_r+0x14c>
34809418:	ebfff863 	bl	348075ac <getenv>

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
3480941c:	e1a01004 	mov	r1, r4

	/* stdin stdout and stderr are in environment */
	/* scan for it */
	stdinname  = getenv("stdin");
	stdoutname = getenv("stdout");
	stderrname = getenv("stderr");
34809420:	e1a05000 	mov	r5, r0

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
34809424:	e3a00001 	mov	r0, #1
34809428:	ebffff97 	bl	3480928c <search_device>
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
3480942c:	e1a01006 	mov	r1, r6
	stdinname  = getenv("stdin");
	stdoutname = getenv("stdout");
	stderrname = getenv("stderr");

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
34809430:	e1a04000 	mov	r4, r0
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
34809434:	e3a00002 	mov	r0, #2
34809438:	ebffff93 	bl	3480928c <search_device>
		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
3480943c:	e1a01005 	mov	r1, r5
	stdoutname = getenv("stdout");
	stderrname = getenv("stderr");

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
34809440:	e1a06000 	mov	r6, r0
		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
34809444:	e3a00002 	mov	r0, #2
34809448:	ebffff8f 	bl	3480928c <search_device>
			/* Successful, so skip all the code below. */
			goto done;
#endif
	}
	/* if the devices are overwritten or not found, use default device */
	if (inputdev == NULL) {
3480944c:	e3540000 	cmp	r4, #0
	stderrname = getenv("stderr");

	if (OVERWRITE_CONSOLE == 0) {	/* if not overwritten by config switch */
		inputdev  = search_device(DEV_FLAGS_INPUT,  stdinname);
		outputdev = search_device(DEV_FLAGS_OUTPUT, stdoutname);
		errdev    = search_device(DEV_FLAGS_OUTPUT, stderrname);
34809450:	e1a05000 	mov	r5, r0
			/* Successful, so skip all the code below. */
			goto done;
#endif
	}
	/* if the devices are overwritten or not found, use default device */
	if (inputdev == NULL) {
34809454:	1a000003 	bne	34809468 <console_init_r+0xac>
		inputdev  = search_device(DEV_FLAGS_INPUT,  "serial");
34809458:	e3a00001 	mov	r0, #1
3480945c:	e59f10a8 	ldr	r1, [pc, #168]	; 3480950c <console_init_r+0x150>
34809460:	ebffff89 	bl	3480928c <search_device>
34809464:	e1a04000 	mov	r4, r0
	}
	if (outputdev == NULL) {
34809468:	e3560000 	cmp	r6, #0
3480946c:	1a000003 	bne	34809480 <console_init_r+0xc4>
		outputdev = search_device(DEV_FLAGS_OUTPUT, "serial");
34809470:	e3a00002 	mov	r0, #2
34809474:	e59f1090 	ldr	r1, [pc, #144]	; 3480950c <console_init_r+0x150>
34809478:	ebffff83 	bl	3480928c <search_device>
3480947c:	e1a06000 	mov	r6, r0
	}
	if (errdev == NULL) {
34809480:	e3550000 	cmp	r5, #0
34809484:	1a000003 	bne	34809498 <console_init_r+0xdc>
		errdev    = search_device(DEV_FLAGS_OUTPUT, "serial");
34809488:	e3a00002 	mov	r0, #2
3480948c:	e59f1078 	ldr	r1, [pc, #120]	; 3480950c <console_init_r+0x150>
34809490:	ebffff7d 	bl	3480928c <search_device>
34809494:	e1a05000 	mov	r5, r0
	}
	/* Initializes output console first */
	if (outputdev != NULL) {
34809498:	e3560000 	cmp	r6, #0
3480949c:	0a000002 	beq	348094ac <console_init_r+0xf0>
	printf("%s\n", stdio_devices[file]->name);
}

static inline void console_doenv(int file, struct stdio_dev *dev)
{
	console_setfile(file, dev);
348094a0:	e3a00001 	mov	r0, #1
348094a4:	e1a01006 	mov	r1, r6
348094a8:	ebfffe90 	bl	34808ef0 <console_setfile>
	/* Initializes output console first */
	if (outputdev != NULL) {
		/* need to set a console if not done above. */
		console_doenv(stdout, outputdev);
	}
	if (errdev != NULL) {
348094ac:	e3550000 	cmp	r5, #0
348094b0:	0a000002 	beq	348094c0 <console_init_r+0x104>
	printf("%s\n", stdio_devices[file]->name);
}

static inline void console_doenv(int file, struct stdio_dev *dev)
{
	console_setfile(file, dev);
348094b4:	e3a00002 	mov	r0, #2
348094b8:	e1a01005 	mov	r1, r5
348094bc:	ebfffe8b 	bl	34808ef0 <console_setfile>
	}
	if (errdev != NULL) {
		/* need to set a console if not done above. */
		console_doenv(stderr, errdev);
	}
	if (inputdev != NULL) {
348094c0:	e3540000 	cmp	r4, #0
348094c4:	0a000002 	beq	348094d4 <console_init_r+0x118>
	printf("%s\n", stdio_devices[file]->name);
}

static inline void console_doenv(int file, struct stdio_dev *dev)
{
	console_setfile(file, dev);
348094c8:	e3a00000 	mov	r0, #0
348094cc:	e1a01004 	mov	r1, r4
348094d0:	ebfffe86 	bl	34808ef0 <console_setfile>

#ifdef CONFIG_CONSOLE_MUX
done:
#endif

	gd->flags |= GD_FLG_DEVINIT;	/* device initialization completed */
348094d4:	e5982004 	ldr	r2, [r8, #4]
348094d8:	e3822002 	orr	r2, r2, #2
348094dc:	e5882004 	str	r2, [r8, #4]

	stdio_print_current_devices();
348094e0:	ebffff87 	bl	34809304 <stdio_print_current_devices>
	/* If nothing usable installed, use only the initial console */
	if ((stdio_devices[stdin] == NULL) && (stdio_devices[stdout] == NULL))
		return 0;
#endif
	return 0;
}
348094e4:	e3a00000 	mov	r0, #0
348094e8:	e8bd8070 	pop	{r4, r5, r6, pc}
348094ec:	3480e68c 	.word	0x3480e68c
348094f0:	3480e6a0 	.word	0x3480e6a0
348094f4:	3482520d 	.word	0x3482520d
348094f8:	3480e6b4 	.word	0x3480e6b4
348094fc:	3480e6d0 	.word	0x3480e6d0
34809500:	34808f94 	.word	0x34808f94
34809504:	34825213 	.word	0x34825213
34809508:	3482521a 	.word	0x3482521a
3480950c:	3482605a 	.word	0x3482605a

34809510 <sbrk>:
ulong mem_malloc_start = 0;
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
34809510:	e92d4038 	push	{r3, r4, r5, lr}
	ulong old = mem_malloc_brk;
34809514:	e59f304c 	ldr	r3, [pc, #76]	; 34809568 <sbrk+0x58>

	/*
	 * if we are giving memory back make sure we clear it out since
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
34809518:	e3500000 	cmp	r0, #0
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
	ulong old = mem_malloc_brk;
3480951c:	e5935000 	ldr	r5, [r3]
ulong mem_malloc_start = 0;
ulong mem_malloc_end = 0;
ulong mem_malloc_brk = 0;

void *sbrk(ptrdiff_t increment)
{
34809520:	e1a02000 	mov	r2, r0
	ulong old = mem_malloc_brk;
	ulong new = old + increment;
34809524:	e0804005 	add	r4, r0, r5

	/*
	 * if we are giving memory back make sure we clear it out since
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
34809528:	aa000003 	bge	3480953c <sbrk+0x2c>
		memset((void *)new, 0, -increment);
3480952c:	e1a00004 	mov	r0, r4
34809530:	e3a01000 	mov	r1, #0
34809534:	e2622000 	rsb	r2, r2, #0
34809538:	eb004a61 	bl	3481bec4 <memset>

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
3480953c:	e59f3024 	ldr	r3, [pc, #36]	; 34809568 <sbrk+0x58>
34809540:	e5932004 	ldr	r2, [r3, #4]
34809544:	e1540002 	cmp	r4, r2
		return (void *)MORECORE_FAILURE;
34809548:	33e00000 	mvncc	r0, #0
	 * we set MORECORE_CLEARS to 1
	 */
	if (increment < 0)
		memset((void *)new, 0, -increment);

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
3480954c:	38bd8038 	popcc	{r3, r4, r5, pc}
34809550:	e5932008 	ldr	r2, [r3, #8]
34809554:	e1540002 	cmp	r4, r2
		return (void *)MORECORE_FAILURE;

	mem_malloc_brk = new;
34809558:	95834000 	strls	r4, [r3]

	return (void *)old;
3480955c:	91a00005 	movls	r0, r5
	 */
	if (increment < 0)
		memset((void *)new, 0, -increment);

	if ((new < mem_malloc_start) || (new > mem_malloc_end))
		return (void *)MORECORE_FAILURE;
34809560:	83e00000 	mvnhi	r0, #0

	mem_malloc_brk = new;

	return (void *)old;
}
34809564:	e8bd8038 	pop	{r3, r4, r5, pc}
34809568:	34829d80 	.word	0x34829d80

3480956c <mem_malloc_init>:

void mem_malloc_init(ulong start, ulong size)
{
3480956c:	e1a02001 	mov	r2, r1
	mem_malloc_start = start;
34809570:	e59f1010 	ldr	r1, [pc, #16]	; 34809588 <mem_malloc_init+0x1c>
	mem_malloc_end = start + size;
34809574:	e082c000 	add	ip, r2, r0
	return (void *)old;
}

void mem_malloc_init(ulong start, ulong size)
{
	mem_malloc_start = start;
34809578:	e9811001 	stmib	r1, {r0, ip}
	mem_malloc_end = start + size;
	mem_malloc_brk = start;
3480957c:	e5810000 	str	r0, [r1]

	memset((void *)mem_malloc_start, 0, size);
34809580:	e3a01000 	mov	r1, #0
34809584:	ea004a4e 	b	3481bec4 <memset>
34809588:	34829d80 	.word	0x34829d80

3480958c <malloc_trim>:
#if __STD_C
int malloc_trim(size_t pad)
#else
int malloc_trim(pad) size_t pad;
#endif
{
3480958c:	e92d4070 	push	{r4, r5, r6, lr}
  char* current_brk;     /* address returned by pre-check sbrk call */
  char* new_brk;         /* address returned by negative sbrk call */

  unsigned long pagesz = malloc_getpagesize;

  top_size = chunksize(top);
34809590:	e59f40bc 	ldr	r4, [pc, #188]	; 34809654 <malloc_trim+0xc8>
34809594:	e5943008 	ldr	r3, [r4, #8]
34809598:	e5936004 	ldr	r6, [r3, #4]
3480959c:	e3c66003 	bic	r6, r6, #3
  extra = ((top_size - pad - MINSIZE + (pagesz-1)) / pagesz - 1) * pagesz;
348095a0:	e0605006 	rsb	r5, r0, r6
348095a4:	e2855efe 	add	r5, r5, #4064	; 0xfe0
348095a8:	e285500f 	add	r5, r5, #15
348095ac:	e3c55eff 	bic	r5, r5, #4080	; 0xff0
348095b0:	e3c5500f 	bic	r5, r5, #15
348095b4:	e2455a01 	sub	r5, r5, #4096	; 0x1000

  if (extra < (long)pagesz)  /* Not enough memory to release */
348095b8:	e3550a01 	cmp	r5, #4096	; 0x1000
348095bc:	ba000020 	blt	34809644 <malloc_trim+0xb8>
    return 0;

  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
348095c0:	e3a00000 	mov	r0, #0
348095c4:	ebffffd1 	bl	34809510 <sbrk>
    if (current_brk != (char*)(top) + top_size)
348095c8:	e5943008 	ldr	r3, [r4, #8]
348095cc:	e0833006 	add	r3, r3, r6
348095d0:	e1500003 	cmp	r0, r3
348095d4:	1a00001a 	bne	34809644 <malloc_trim+0xb8>
      return 0;     /* Apparently we don't own memory; must fail */

    else
    {
      new_brk = (char*)(MORECORE (-extra));
348095d8:	e2650000 	rsb	r0, r5, #0
348095dc:	ebffffcb 	bl	34809510 <sbrk>

      if (new_brk == (char*)(MORECORE_FAILURE)) /* sbrk failed? */
348095e0:	e3700001 	cmn	r0, #1
348095e4:	1a00000c 	bne	3480961c <malloc_trim+0x90>
      {
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
348095e8:	e2800001 	add	r0, r0, #1
348095ec:	ebffffc7 	bl	34809510 <sbrk>
	top_size = current_brk - (char*)top;
348095f0:	e5943008 	ldr	r3, [r4, #8]
348095f4:	e0632000 	rsb	r2, r3, r0
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
348095f8:	e352000f 	cmp	r2, #15
348095fc:	da000012 	ble	3480964c <malloc_trim+0xc0>
	{
	  sbrked_mem = current_brk - sbrk_base;
34809600:	e5941408 	ldr	r1, [r4, #1032]	; 0x408
	  set_head(top, top_size | PREV_INUSE);
34809604:	e3822001 	orr	r2, r2, #1
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
	top_size = current_brk - (char*)top;
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
	{
	  sbrked_mem = current_brk - sbrk_base;
34809608:	e0610000 	rsb	r0, r1, r0
3480960c:	e59f1044 	ldr	r1, [pc, #68]	; 34809658 <malloc_trim+0xcc>
	  set_head(top, top_size | PREV_INUSE);
34809610:	e5832004 	str	r2, [r3, #4]
	/* Try to figure out what we have */
	current_brk = (char*)(MORECORE (0));
	top_size = current_brk - (char*)top;
	if (top_size >= (long)MINSIZE) /* if not, we are very very dead! */
	{
	  sbrked_mem = current_brk - sbrk_base;
34809614:	e581000c 	str	r0, [r1, #12]
34809618:	ea000009 	b	34809644 <malloc_trim+0xb8>
      }

      else
      {
	/* Success. Adjust top accordingly. */
	set_head(top, (top_size - extra) | PREV_INUSE);
3480961c:	e5943008 	ldr	r3, [r4, #8]
34809620:	e0656006 	rsb	r6, r5, r6
34809624:	e3866001 	orr	r6, r6, #1
34809628:	e5836004 	str	r6, [r3, #4]
	sbrked_mem -= extra;
3480962c:	e59f3024 	ldr	r3, [pc, #36]	; 34809658 <malloc_trim+0xcc>
	check_chunk(top);
	return 1;
34809630:	e3a00001 	mov	r0, #1

      else
      {
	/* Success. Adjust top accordingly. */
	set_head(top, (top_size - extra) | PREV_INUSE);
	sbrked_mem -= extra;
34809634:	e593200c 	ldr	r2, [r3, #12]
34809638:	e0655002 	rsb	r5, r5, r2
3480963c:	e583500c 	str	r5, [r3, #12]
	check_chunk(top);
	return 1;
34809640:	e8bd8070 	pop	{r4, r5, r6, pc}
  else
  {
    /* Test to make sure no one else called sbrk */
    current_brk = (char*)(MORECORE (0));
    if (current_brk != (char*)(top) + top_size)
      return 0;     /* Apparently we don't own memory; must fail */
34809644:	e3a00000 	mov	r0, #0
34809648:	e8bd8070 	pop	{r4, r5, r6, pc}
	{
	  sbrked_mem = current_brk - sbrk_base;
	  set_head(top, top_size | PREV_INUSE);
	}
	check_chunk(top);
	return 0;
3480964c:	e3a00000 	mov	r0, #0
	check_chunk(top);
	return 1;
      }
    }
  }
}
34809650:	e8bd8070 	pop	{r4, r5, r6, pc}
34809654:	34828590 	.word	0x34828590
34809658:	34829d80 	.word	0x34829d80

3480965c <free>:
#if __STD_C
void fREe(Void_t* mem)
#else
void fREe(mem) Void_t* mem;
#endif
{
3480965c:	e92d4070 	push	{r4, r5, r6, lr}
  INTERNAL_SIZE_T prevsz; /* size of previous contiguous chunk */
  mchunkptr bck;       /* misc temp for linking */
  mchunkptr fwd;       /* misc temp for linking */
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
34809660:	e2504000 	subs	r4, r0, #0
34809664:	08bd8070 	popeq	{r4, r5, r6, pc}
    return;

  p = mem2chunk(mem);
  hd = p->size;
34809668:	e5140004 	ldr	r0, [r4, #-4]

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
3480966c:	e59f51fc 	ldr	r5, [pc, #508]	; 34809870 <free+0x214>
  }
#endif

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
34809670:	e3c02001 	bic	r2, r0, #1
  int       islr;      /* track whether merging with last_remainder */

  if (mem == 0)                              /* free(0) has no effect */
    return;

  p = mem2chunk(mem);
34809674:	e2443008 	sub	r3, r4, #8
#endif

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
34809678:	e0831002 	add	r1, r3, r2
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
3480967c:	e5956008 	ldr	r6, [r5, #8]

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
34809680:	e591c004 	ldr	ip, [r1, #4]

  if (next == top)                            /* merge with top */
34809684:	e1510006 	cmp	r1, r6

  check_inuse_chunk(p);

  sz = hd & ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
34809688:	e3ccc003 	bic	ip, ip, #3
3480968c:	e2000001 	and	r0, r0, #1

  if (next == top)                            /* merge with top */
34809690:	1a000014 	bne	348096e8 <free+0x8c>
  {
    sz += nextsz;

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
34809694:	e3500000 	cmp	r0, #0
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);

  if (next == top)                            /* merge with top */
  {
    sz += nextsz;
34809698:	e08c2002 	add	r2, ip, r2

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
3480969c:	1a000006 	bne	348096bc <free+0x60>
    {
      prevsz = p->prev_size;
348096a0:	e5141008 	ldr	r1, [r4, #-8]
      p = chunk_at_offset(p, -((long) prevsz));
348096a4:	e0613003 	rsb	r3, r1, r3
      sz += prevsz;
      unlink(p, bck, fwd);
348096a8:	e5930008 	ldr	r0, [r3, #8]

    if (!(hd & PREV_INUSE))                    /* consolidate backward */
    {
      prevsz = p->prev_size;
      p = chunk_at_offset(p, -((long) prevsz));
      sz += prevsz;
348096ac:	e0822001 	add	r2, r2, r1
      unlink(p, bck, fwd);
348096b0:	e593100c 	ldr	r1, [r3, #12]
348096b4:	e580100c 	str	r1, [r0, #12]
348096b8:	e5810008 	str	r0, [r1, #8]
    }

    set_head(p, sz | PREV_INUSE);
348096bc:	e3821001 	orr	r1, r2, #1
348096c0:	e5831004 	str	r1, [r3, #4]
    top = p;
348096c4:	e59f11a4 	ldr	r1, [pc, #420]	; 34809870 <free+0x214>
348096c8:	e5813008 	str	r3, [r1, #8]
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
348096cc:	e591340c 	ldr	r3, [r1, #1036]	; 0x40c
348096d0:	e1520003 	cmp	r2, r3
348096d4:	38bd8070 	popcc	{r4, r5, r6, pc}
      malloc_trim(top_pad);
348096d8:	e59f3194 	ldr	r3, [pc, #404]	; 34809874 <free+0x218>
348096dc:	e5930034 	ldr	r0, [r3, #52]	; 0x34

  set_head(p, sz | PREV_INUSE);
  set_foot(p, sz);
  if (!islr)
    frontlink(p, sz, idx, bck, fwd);
}
348096e0:	e8bd4070 	pop	{r4, r5, r6, lr}
    }

    set_head(p, sz | PREV_INUSE);
    top = p;
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
      malloc_trim(top_pad);
348096e4:	eaffffa8 	b	3480958c <malloc_trim>

  set_head(next, nextsz);                    /* clear inuse bit */

  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
348096e8:	e3500000 	cmp	r0, #0
    if ((unsigned long)(sz) >= (unsigned long)trim_threshold)
      malloc_trim(top_pad);
    return;
  }

  set_head(next, nextsz);                    /* clear inuse bit */
348096ec:	e581c004 	str	ip, [r1, #4]

  islr = 0;
348096f0:	13a00000 	movne	r0, #0

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
348096f4:	1a000009 	bne	34809720 <free+0xc4>
  {
    prevsz = p->prev_size;
348096f8:	e5144008 	ldr	r4, [r4, #-8]
    p = chunk_at_offset(p, -((long) prevsz));
    sz += prevsz;

    if (p->fd == last_remainder)             /* keep as last_remainder */
348096fc:	e2855008 	add	r5, r5, #8
  islr = 0;

  if (!(hd & PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -((long) prevsz));
34809700:	e0643003 	rsb	r3, r4, r3
    sz += prevsz;
34809704:	e0822004 	add	r2, r2, r4

    if (p->fd == last_remainder)             /* keep as last_remainder */
34809708:	e5934008 	ldr	r4, [r3, #8]
3480970c:	e1540005 	cmp	r4, r5
      islr = 1;
    else
      unlink(p, bck, fwd);
34809710:	1593500c 	ldrne	r5, [r3, #12]
    prevsz = p->prev_size;
    p = chunk_at_offset(p, -((long) prevsz));
    sz += prevsz;

    if (p->fd == last_remainder)             /* keep as last_remainder */
      islr = 1;
34809714:	03a00001 	moveq	r0, #1
    else
      unlink(p, bck, fwd);
34809718:	1584500c 	strne	r5, [r4, #12]
3480971c:	15854008 	strne	r4, [r5, #8]
  }

  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
34809720:	e081400c 	add	r4, r1, ip
34809724:	e5944004 	ldr	r4, [r4, #4]
34809728:	e3140001 	tst	r4, #1
3480972c:	1a000010 	bne	34809774 <free+0x118>
  {
    sz += nextsz;

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
34809730:	e3500000 	cmp	r0, #0
      unlink(p, bck, fwd);
  }

  if (!(inuse_bit_at_offset(next, nextsz)))   /* consolidate forward */
  {
    sz += nextsz;
34809734:	e082200c 	add	r2, r2, ip

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
34809738:	1a000009 	bne	34809764 <free+0x108>
3480973c:	e591c008 	ldr	ip, [r1, #8]
34809740:	e59f4130 	ldr	r4, [pc, #304]	; 34809878 <free+0x21c>
34809744:	e15c0004 	cmp	ip, r4
34809748:	1a000005 	bne	34809764 <free+0x108>
    {
      islr = 1;
      link_last_remainder(p);
3480974c:	e58c300c 	str	r3, [ip, #12]
34809750:	e58c3008 	str	r3, [ip, #8]
34809754:	e583c00c 	str	ip, [r3, #12]
34809758:	e583c008 	str	ip, [r3, #8]
  {
    sz += nextsz;

    if (!islr && next->fd == last_remainder)  /* re-insert last_remainder */
    {
      islr = 1;
3480975c:	e2800001 	add	r0, r0, #1
      link_last_remainder(p);
34809760:	ea000003 	b	34809774 <free+0x118>
    }
    else
      unlink(next, bck, fwd);
34809764:	e591c00c 	ldr	ip, [r1, #12]
34809768:	e5911008 	ldr	r1, [r1, #8]
3480976c:	e581c00c 	str	ip, [r1, #12]
34809770:	e58c1008 	str	r1, [ip, #8]
  }


  set_head(p, sz | PREV_INUSE);
34809774:	e3821001 	orr	r1, r2, #1
  set_foot(p, sz);
  if (!islr)
34809778:	e3500000 	cmp	r0, #0
    else
      unlink(next, bck, fwd);
  }


  set_head(p, sz | PREV_INUSE);
3480977c:	e5831004 	str	r1, [r3, #4]
  set_foot(p, sz);
34809780:	e7832002 	str	r2, [r3, r2]
  if (!islr)
34809784:	18bd8070 	popne	{r4, r5, r6, pc}
    frontlink(p, sz, idx, bck, fwd);
34809788:	e3520c02 	cmp	r2, #512	; 0x200
3480978c:	2a000009 	bcs	348097b8 <free+0x15c>
34809790:	e59f10d8 	ldr	r1, [pc, #216]	; 34809870 <free+0x214>
34809794:	e1a021a2 	lsr	r2, r2, #3
34809798:	e591c004 	ldr	ip, [r1, #4]
3480979c:	e1a00142 	asr	r0, r2, #2
348097a0:	e3a04001 	mov	r4, #1
348097a4:	e18c0014 	orr	r0, ip, r4, lsl r0
348097a8:	e0812182 	add	r2, r1, r2, lsl #3
348097ac:	e5810004 	str	r0, [r1, #4]
348097b0:	e5921008 	ldr	r1, [r2, #8]
348097b4:	ea000028 	b	3480985c <free+0x200>
348097b8:	e1a004a2 	lsr	r0, r2, #9
348097bc:	e3500004 	cmp	r0, #4
348097c0:	91a00322 	lsrls	r0, r2, #6
348097c4:	92800038 	addls	r0, r0, #56	; 0x38
348097c8:	9a00000f 	bls	3480980c <free+0x1b0>
348097cc:	e3500014 	cmp	r0, #20
348097d0:	9280005b 	addls	r0, r0, #91	; 0x5b
348097d4:	9a00000c 	bls	3480980c <free+0x1b0>
348097d8:	e3500054 	cmp	r0, #84	; 0x54
348097dc:	91a00622 	lsrls	r0, r2, #12
348097e0:	9280006e 	addls	r0, r0, #110	; 0x6e
348097e4:	9a000008 	bls	3480980c <free+0x1b0>
348097e8:	e3500f55 	cmp	r0, #340	; 0x154
348097ec:	91a007a2 	lsrls	r0, r2, #15
348097f0:	92800077 	addls	r0, r0, #119	; 0x77
348097f4:	9a000004 	bls	3480980c <free+0x1b0>
348097f8:	e3001554 	movw	r1, #1364	; 0x554
348097fc:	e1500001 	cmp	r0, r1
34809800:	91a00922 	lsrls	r0, r2, #18
34809804:	9280007c 	addls	r0, r0, #124	; 0x7c
34809808:	83a0007e 	movhi	r0, #126	; 0x7e
3480980c:	e59fc05c 	ldr	ip, [pc, #92]	; 34809870 <free+0x214>
34809810:	e08c4180 	add	r4, ip, r0, lsl #3
34809814:	e5941008 	ldr	r1, [r4, #8]
34809818:	e1510004 	cmp	r1, r4
3480981c:	1a000009 	bne	34809848 <free+0x1ec>
34809820:	e59c2004 	ldr	r2, [ip, #4]
34809824:	e1a00140 	asr	r0, r0, #2
34809828:	e3a04001 	mov	r4, #1
3480982c:	e1820014 	orr	r0, r2, r4, lsl r0
34809830:	e1a02001 	mov	r2, r1
34809834:	e58c0004 	str	r0, [ip, #4]
34809838:	ea000007 	b	3480985c <free+0x200>
3480983c:	e5911008 	ldr	r1, [r1, #8]
34809840:	e1510004 	cmp	r1, r4
34809844:	0a000003 	beq	34809858 <free+0x1fc>
34809848:	e5910004 	ldr	r0, [r1, #4]
3480984c:	e3c00003 	bic	r0, r0, #3
34809850:	e1520000 	cmp	r2, r0
34809854:	3afffff8 	bcc	3480983c <free+0x1e0>
34809858:	e591200c 	ldr	r2, [r1, #12]
3480985c:	e583200c 	str	r2, [r3, #12]
34809860:	e5831008 	str	r1, [r3, #8]
34809864:	e5823008 	str	r3, [r2, #8]
34809868:	e581300c 	str	r3, [r1, #12]
3480986c:	e8bd8070 	pop	{r4, r5, r6, pc}
34809870:	34828590 	.word	0x34828590
34809874:	34829d80 	.word	0x34829d80
34809878:	34828598 	.word	0x34828598

3480987c <cfree>:
void cfree(Void_t *mem)
#else
void cfree(mem) Void_t *mem;
#endif
{
  fREe(mem);
3480987c:	eaffff76 	b	3480965c <free>

34809880 <malloc>:
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  /* check if mem_malloc_init() was run */
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
34809880:	e59f35a0 	ldr	r3, [pc, #1440]	; 34809e28 <malloc+0x5a8>
#if __STD_C
Void_t* mALLOc(size_t bytes)
#else
Void_t* mALLOc(bytes) size_t bytes;
#endif
{
34809884:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  /* check if mem_malloc_init() was run */
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
34809888:	e5932004 	ldr	r2, [r3, #4]
3480988c:	e3520000 	cmp	r2, #0
34809890:	1a000003 	bne	348098a4 <malloc+0x24>
34809894:	e5933008 	ldr	r3, [r3, #8]
34809898:	e3530000 	cmp	r3, #0
    /* not initialized yet */
    return 0;
3480989c:	01a00003 	moveq	r0, r3
  mbinptr q;                         /* misc temp */

  INTERNAL_SIZE_T nb;

  /* check if mem_malloc_init() was run */
  if ((mem_malloc_start == 0) && (mem_malloc_end == 0)) {
348098a0:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
    /* not initialized yet */
    return 0;
  }

  if ((long)bytes < 0) return 0;
348098a4:	e3500000 	cmp	r0, #0
348098a8:	b3a00000 	movlt	r0, #0
348098ac:	b8bd8ef0 	poplt	{r4, r5, r6, r7, r9, sl, fp, pc}

  nb = request2size(bytes);  /* padded request size; */
348098b0:	e280400b 	add	r4, r0, #11
348098b4:	e3540016 	cmp	r4, #22
348098b8:	d3a04010 	movle	r4, #16
348098bc:	da000002 	ble	348098cc <malloc+0x4c>
348098c0:	e3c44007 	bic	r4, r4, #7

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
348098c4:	e3540f7e 	cmp	r4, #504	; 0x1f8
348098c8:	2a00000d 	bcs	34809904 <malloc+0x84>
  {
    idx = smallbin_index(nb);

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
348098cc:	e59f3558 	ldr	r3, [pc, #1368]	; 34809e2c <malloc+0x5ac>

  /* Check for exact match in a bin */

  if (is_small_request(nb))  /* Faster version for small requests */
  {
    idx = smallbin_index(nb);
348098d0:	e1a011a4 	lsr	r1, r4, #3

    /* No traversal or size check necessary for small bins.  */

    q = bin_at(idx);
348098d4:	e0833181 	add	r3, r3, r1, lsl #3
    victim = last(q);
348098d8:	e593000c 	ldr	r0, [r3, #12]

    /* Also scan the next one, since it would have a remainder < MINSIZE */
    if (victim == q)
348098dc:	e1500003 	cmp	r0, r3
348098e0:	1a000004 	bne	348098f8 <malloc+0x78>
    {
      q = next_bin(q);
348098e4:	e2803008 	add	r3, r0, #8
      victim = last(q);
348098e8:	e593000c 	ldr	r0, [r3, #12]
    }
    if (victim != q)
348098ec:	e1500003 	cmp	r0, r3
      set_inuse_bit_at_offset(victim, victim_size);
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
    }

    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */
348098f0:	02811002 	addeq	r1, r1, #2
    if (victim == q)
    {
      q = next_bin(q);
      victim = last(q);
    }
    if (victim != q)
348098f4:	0a00002e 	beq	348099b4 <malloc+0x134>
    {
      victim_size = chunksize(victim);
348098f8:	e5903004 	ldr	r3, [r0, #4]
348098fc:	e3c33003 	bic	r3, r3, #3
34809900:	ea000022 	b	34809990 <malloc+0x110>
    idx += 2; /* Set for bin scan below. We've already scanned 2 bins. */

  }
  else
  {
    idx = bin_index(nb);
34809904:	e1b014a4 	lsrs	r1, r4, #9
34809908:	01a011a4 	lsreq	r1, r4, #3
3480990c:	0a000013 	beq	34809960 <malloc+0xe0>
34809910:	e3510004 	cmp	r1, #4
34809914:	91a01324 	lsrls	r1, r4, #6
34809918:	92811038 	addls	r1, r1, #56	; 0x38
3480991c:	9a00000f 	bls	34809960 <malloc+0xe0>
34809920:	e3510014 	cmp	r1, #20
34809924:	9281105b 	addls	r1, r1, #91	; 0x5b
34809928:	9a00000c 	bls	34809960 <malloc+0xe0>
3480992c:	e3510054 	cmp	r1, #84	; 0x54
34809930:	91a01624 	lsrls	r1, r4, #12
34809934:	9281106e 	addls	r1, r1, #110	; 0x6e
34809938:	9a000008 	bls	34809960 <malloc+0xe0>
3480993c:	e3510f55 	cmp	r1, #340	; 0x154
34809940:	91a017a4 	lsrls	r1, r4, #15
34809944:	92811077 	addls	r1, r1, #119	; 0x77
34809948:	9a000004 	bls	34809960 <malloc+0xe0>
3480994c:	e3003554 	movw	r3, #1364	; 0x554
34809950:	e1510003 	cmp	r1, r3
34809954:	91a01924 	lsrls	r1, r4, #18
34809958:	9281107c 	addls	r1, r1, #124	; 0x7c
3480995c:	83a0107e 	movhi	r1, #126	; 0x7e
    bin = bin_at(idx);
34809960:	e59f24c4 	ldr	r2, [pc, #1220]	; 34809e2c <malloc+0x5ac>
34809964:	e0822181 	add	r2, r2, r1, lsl #3

    for (victim = last(bin); victim != bin; victim = victim->bk)
34809968:	e592000c 	ldr	r0, [r2, #12]
3480996c:	ea00000d 	b	348099a8 <malloc+0x128>
    {
      victim_size = chunksize(victim);
34809970:	e5903004 	ldr	r3, [r0, #4]
34809974:	e3c33003 	bic	r3, r3, #3
      remainder_size = victim_size - nb;
34809978:	e064c003 	rsb	ip, r4, r3

      if (remainder_size >= (long)MINSIZE) /* too big */
3480997c:	e35c000f 	cmp	ip, #15
      {
	--idx; /* adjust to rescan below after checking last remainder */
34809980:	c2411001 	subgt	r1, r1, #1
	break;
34809984:	ca000009 	bgt	348099b0 <malloc+0x130>
      }

      else if (remainder_size >= 0) /* exact fit */
34809988:	e35c0000 	cmp	ip, #0
3480998c:	ba000004 	blt	348099a4 <malloc+0x124>
      {
	unlink(victim, bck, fwd);
34809990:	e590200c 	ldr	r2, [r0, #12]
34809994:	e5901008 	ldr	r1, [r0, #8]
34809998:	e581200c 	str	r2, [r1, #12]
3480999c:	e5821008 	str	r1, [r2, #8]
348099a0:	ea00001c 	b	34809a18 <malloc+0x198>
  else
  {
    idx = bin_index(nb);
    bin = bin_at(idx);

    for (victim = last(bin); victim != bin; victim = victim->bk)
348099a4:	e590000c 	ldr	r0, [r0, #12]
348099a8:	e1500002 	cmp	r0, r2
348099ac:	1affffef 	bne	34809970 <malloc+0xf0>
	check_malloced_chunk(victim, nb);
	return chunk2mem(victim);
      }
    }

    ++idx;
348099b0:	e2811001 	add	r1, r1, #1

  }

  /* Try to use the last split-off remainder */

  if ( (victim = last_remainder->fd) != last_remainder)
348099b4:	e59f5470 	ldr	r5, [pc, #1136]	; 34809e2c <malloc+0x5ac>
348099b8:	e2852008 	add	r2, r5, #8
348099bc:	e5920008 	ldr	r0, [r2, #8]
348099c0:	e1500002 	cmp	r0, r2
348099c4:	0a000050 	beq	34809b0c <malloc+0x28c>
  {
    victim_size = chunksize(victim);
348099c8:	e5903004 	ldr	r3, [r0, #4]
348099cc:	e3c33003 	bic	r3, r3, #3
    remainder_size = victim_size - nb;
348099d0:	e064c003 	rsb	ip, r4, r3

    if (remainder_size >= (long)MINSIZE) /* re-split */
348099d4:	e35c000f 	cmp	ip, #15
348099d8:	da00000a 	ble	34809a08 <malloc+0x188>
    {
      remainder = chunk_at_offset(victim, nb);
348099dc:	e0803004 	add	r3, r0, r4
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
348099e0:	e582300c 	str	r3, [r2, #12]
348099e4:	e5823008 	str	r3, [r2, #8]
    remainder_size = victim_size - nb;

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
348099e8:	e3844001 	orr	r4, r4, #1
      link_last_remainder(remainder);
348099ec:	e583200c 	str	r2, [r3, #12]
348099f0:	e5832008 	str	r2, [r3, #8]
      set_head(remainder, remainder_size | PREV_INUSE);
348099f4:	e38c2001 	orr	r2, ip, #1
    remainder_size = victim_size - nb;

    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
348099f8:	e5804004 	str	r4, [r0, #4]
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
      set_foot(remainder, remainder_size);
348099fc:	e783c00c 	str	ip, [r3, ip]
    if (remainder_size >= (long)MINSIZE) /* re-split */
    {
      remainder = chunk_at_offset(victim, nb);
      set_head(victim, nb | PREV_INUSE);
      link_last_remainder(remainder);
      set_head(remainder, remainder_size | PREV_INUSE);
34809a00:	e5832004 	str	r2, [r3, #4]
34809a04:	ea000103 	b	34809e18 <malloc+0x598>
      return chunk2mem(victim);
    }

    clear_last_remainder;

    if (remainder_size >= 0)  /* exhaust */
34809a08:	e35c0000 	cmp	ip, #0
      set_foot(remainder, remainder_size);
      check_malloced_chunk(victim, nb);
      return chunk2mem(victim);
    }

    clear_last_remainder;
34809a0c:	e582200c 	str	r2, [r2, #12]
34809a10:	e5822008 	str	r2, [r2, #8]

    if (remainder_size >= 0)  /* exhaust */
34809a14:	ba000004 	blt	34809a2c <malloc+0x1ac>
    {
      set_inuse_bit_at_offset(victim, victim_size);
34809a18:	e0803003 	add	r3, r0, r3
34809a1c:	e5932004 	ldr	r2, [r3, #4]
34809a20:	e3822001 	orr	r2, r2, #1
34809a24:	e5832004 	str	r2, [r3, #4]
34809a28:	ea0000fa 	b	34809e18 <malloc+0x598>
      return chunk2mem(victim);
    }

    /* Else place in bin */

    frontlink(victim, victim_size, remainder_index, bck, fwd);
34809a2c:	e3530c02 	cmp	r3, #512	; 0x200
34809a30:	2a000008 	bcs	34809a58 <malloc+0x1d8>
34809a34:	e1a031a3 	lsr	r3, r3, #3
34809a38:	e5956004 	ldr	r6, [r5, #4]
34809a3c:	e1a0c143 	asr	ip, r3, #2
34809a40:	e3a07001 	mov	r7, #1
34809a44:	e186cc17 	orr	ip, r6, r7, lsl ip
34809a48:	e0853183 	add	r3, r5, r3, lsl #3
34809a4c:	e585c004 	str	ip, [r5, #4]
34809a50:	e593c008 	ldr	ip, [r3, #8]
34809a54:	ea000028 	b	34809afc <malloc+0x27c>
34809a58:	e1a064a3 	lsr	r6, r3, #9
34809a5c:	e3560004 	cmp	r6, #4
34809a60:	91a06323 	lsrls	r6, r3, #6
34809a64:	92866038 	addls	r6, r6, #56	; 0x38
34809a68:	9a00000f 	bls	34809aac <malloc+0x22c>
34809a6c:	e3560014 	cmp	r6, #20
34809a70:	9286605b 	addls	r6, r6, #91	; 0x5b
34809a74:	9a00000c 	bls	34809aac <malloc+0x22c>
34809a78:	e3560054 	cmp	r6, #84	; 0x54
34809a7c:	91a06623 	lsrls	r6, r3, #12
34809a80:	9286606e 	addls	r6, r6, #110	; 0x6e
34809a84:	9a000008 	bls	34809aac <malloc+0x22c>
34809a88:	e3560f55 	cmp	r6, #340	; 0x154
34809a8c:	91a067a3 	lsrls	r6, r3, #15
34809a90:	92866077 	addls	r6, r6, #119	; 0x77
34809a94:	9a000004 	bls	34809aac <malloc+0x22c>
34809a98:	e300c554 	movw	ip, #1364	; 0x554
34809a9c:	e156000c 	cmp	r6, ip
34809aa0:	91a06923 	lsrls	r6, r3, #18
34809aa4:	9286607c 	addls	r6, r6, #124	; 0x7c
34809aa8:	83a0607e 	movhi	r6, #126	; 0x7e
34809aac:	e0857186 	add	r7, r5, r6, lsl #3
34809ab0:	e597c008 	ldr	ip, [r7, #8]
34809ab4:	e15c0007 	cmp	ip, r7
34809ab8:	1a00000a 	bne	34809ae8 <malloc+0x268>
34809abc:	e59f3368 	ldr	r3, [pc, #872]	; 34809e2c <malloc+0x5ac>
34809ac0:	e1a06146 	asr	r6, r6, #2
34809ac4:	e5937004 	ldr	r7, [r3, #4]
34809ac8:	e3a0a001 	mov	sl, #1
34809acc:	e187661a 	orr	r6, r7, sl, lsl r6
34809ad0:	e5836004 	str	r6, [r3, #4]
34809ad4:	e1a0300c 	mov	r3, ip
34809ad8:	ea000007 	b	34809afc <malloc+0x27c>
34809adc:	e59cc008 	ldr	ip, [ip, #8]
34809ae0:	e15c0007 	cmp	ip, r7
34809ae4:	0a000003 	beq	34809af8 <malloc+0x278>
34809ae8:	e59c6004 	ldr	r6, [ip, #4]
34809aec:	e3c66003 	bic	r6, r6, #3
34809af0:	e1530006 	cmp	r3, r6
34809af4:	3afffff8 	bcc	34809adc <malloc+0x25c>
34809af8:	e59c300c 	ldr	r3, [ip, #12]
34809afc:	e580300c 	str	r3, [r0, #12]
34809b00:	e580c008 	str	ip, [r0, #8]
34809b04:	e5830008 	str	r0, [r3, #8]
34809b08:	e58c000c 	str	r0, [ip, #12]
  /*
     If there are any possibly nonempty big-enough blocks,
     search for best fitting chunk by scanning bins in blockwidth units.
  */

  if ( (block = idx2binblock(idx)) <= binblocks_r)
34809b0c:	e3a00001 	mov	r0, #1
34809b10:	e1a03141 	asr	r3, r1, #2
34809b14:	e1a03310 	lsl	r3, r0, r3
34809b18:	e59f030c 	ldr	r0, [pc, #780]	; 34809e2c <malloc+0x5ac>
34809b1c:	e5900004 	ldr	r0, [r0, #4]
34809b20:	e1530000 	cmp	r3, r0
34809b24:	8a00004a 	bhi	34809c54 <malloc+0x3d4>
  {

    /* Get to the first marked block */

    if ( (block & binblocks_r) == 0)
34809b28:	e1130000 	tst	r3, r0
34809b2c:	1a000004 	bne	34809b44 <malloc+0x2c4>
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
34809b30:	e3c11003 	bic	r1, r1, #3
      block <<= 1;
      while ((block & binblocks_r) == 0)
      {
	idx += BINBLOCKWIDTH;
	block <<= 1;
34809b34:	e1a03083 	lsl	r3, r3, #1
    if ( (block & binblocks_r) == 0)
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks_r) == 0)
34809b38:	e1130000 	tst	r3, r0
      {
	idx += BINBLOCKWIDTH;
34809b3c:	e2811004 	add	r1, r1, #4
    if ( (block & binblocks_r) == 0)
    {
      /* force to an even block boundary */
      idx = (idx & ~(BINBLOCKWIDTH - 1)) + BINBLOCKWIDTH;
      block <<= 1;
      while ((block & binblocks_r) == 0)
34809b40:	0afffffb 	beq	34809b34 <malloc+0x2b4>

      do   /* Possibly backtrack to try to clear a partial block */
      {
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
	{
	  av_[1] = (mbinptr)(binblocks_r & ~block);
34809b44:	e59fa2e0 	ldr	sl, [pc, #736]	; 34809e2c <malloc+0x5ac>

    /* For each possibly nonempty block ... */
    for (;;)
    {
      startidx = idx;          /* (track incomplete blocks) */
      q = bin = bin_at(idx);
34809b48:	e0859181 	add	r9, r5, r1, lsl #3
34809b4c:	e1a07009 	mov	r7, r9
34809b50:	e1a06001 	mov	r6, r1
      /* For each bin in this block ... */
      do
      {
	/* Find and use first big enough chunk ... */

	for (victim = last(bin); victim != bin; victim = victim->bk)
34809b54:	e597000c 	ldr	r0, [r7, #12]
34809b58:	ea000020 	b	34809be0 <malloc+0x360>
	{
	  victim_size = chunksize(victim);
34809b5c:	e590b004 	ldr	fp, [r0, #4]
34809b60:	e3cbb003 	bic	fp, fp, #3
	  remainder_size = victim_size - nb;
34809b64:	e064c00b 	rsb	ip, r4, fp

	  if (remainder_size >= (long)MINSIZE) /* split */
34809b68:	e35c000f 	cmp	ip, #15
34809b6c:	da00000f 	ble	34809bb0 <malloc+0x330>
	  {
	    remainder = chunk_at_offset(victim, nb);
34809b70:	e0803004 	add	r3, r0, r4
	    set_head(victim, nb | PREV_INUSE);
34809b74:	e3844001 	orr	r4, r4, #1
	    unlink(victim, bck, fwd);
34809b78:	e590100c 	ldr	r1, [r0, #12]
	  remainder_size = victim_size - nb;

	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
34809b7c:	e5804004 	str	r4, [r0, #4]
	    unlink(victim, bck, fwd);
34809b80:	e5b04008 	ldr	r4, [r0, #8]!
	    link_last_remainder(remainder);
	    set_head(remainder, remainder_size | PREV_INUSE);
	    set_foot(remainder, remainder_size);
34809b84:	e783c00c 	str	ip, [r3, ip]

	  if (remainder_size >= (long)MINSIZE) /* split */
	  {
	    remainder = chunk_at_offset(victim, nb);
	    set_head(victim, nb | PREV_INUSE);
	    unlink(victim, bck, fwd);
34809b88:	e584100c 	str	r1, [r4, #12]
34809b8c:	e5814008 	str	r4, [r1, #8]
	    link_last_remainder(remainder);
34809b90:	e582300c 	str	r3, [r2, #12]
34809b94:	e5823008 	str	r3, [r2, #8]
34809b98:	e59f2290 	ldr	r2, [pc, #656]	; 34809e30 <malloc+0x5b0>
34809b9c:	e583200c 	str	r2, [r3, #12]
34809ba0:	e5832008 	str	r2, [r3, #8]
	    set_head(remainder, remainder_size | PREV_INUSE);
34809ba4:	e38c2001 	orr	r2, ip, #1
34809ba8:	e5832004 	str	r2, [r3, #4]
	    set_foot(remainder, remainder_size);
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
34809bac:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	  }

	  else if (remainder_size >= 0)  /* take */
34809bb0:	e35c0000 	cmp	ip, #0
34809bb4:	ba000008 	blt	34809bdc <malloc+0x35c>
	  {
	    set_inuse_bit_at_offset(victim, victim_size);
34809bb8:	e080b00b 	add	fp, r0, fp
34809bbc:	e59b3004 	ldr	r3, [fp, #4]
34809bc0:	e3833001 	orr	r3, r3, #1
34809bc4:	e58b3004 	str	r3, [fp, #4]
	    unlink(victim, bck, fwd);
34809bc8:	e590300c 	ldr	r3, [r0, #12]
34809bcc:	e5b02008 	ldr	r2, [r0, #8]!
34809bd0:	e582300c 	str	r3, [r2, #12]
34809bd4:	e5832008 	str	r2, [r3, #8]
	    check_malloced_chunk(victim, nb);
	    return chunk2mem(victim);
34809bd8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
      /* For each bin in this block ... */
      do
      {
	/* Find and use first big enough chunk ... */

	for (victim = last(bin); victim != bin; victim = victim->bk)
34809bdc:	e590000c 	ldr	r0, [r0, #12]
34809be0:	e1500007 	cmp	r0, r7
34809be4:	1affffdc 	bne	34809b5c <malloc+0x2dc>

	}

       bin = next_bin(bin);

      } while ((++idx & (BINBLOCKWIDTH - 1)) != 0);
34809be8:	e2866001 	add	r6, r6, #1
34809bec:	e3160003 	tst	r6, #3
	    return chunk2mem(victim);
	  }

	}

       bin = next_bin(bin);
34809bf0:	12877008 	addne	r7, r7, #8
34809bf4:	1affffd6 	bne	34809b54 <malloc+0x2d4>

      /* Clear out the block bit. */

      do   /* Possibly backtrack to try to clear a partial block */
      {
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
34809bf8:	e3110003 	tst	r1, #3
	{
	  av_[1] = (mbinptr)(binblocks_r & ~block);
34809bfc:	059a1004 	ldreq	r1, [sl, #4]
34809c00:	01c11003 	biceq	r1, r1, r3
34809c04:	058a1004 	streq	r1, [sl, #4]
	  break;
34809c08:	0a000004 	beq	34809c20 <malloc+0x3a0>
	}
	--startidx;
       q = prev_bin(q);
34809c0c:	e1a00009 	mov	r0, r9
      } while (first(q) == q);
34809c10:	e4109008 	ldr	r9, [r0], #-8
34809c14:	e1590000 	cmp	r9, r0
	if ((startidx & (BINBLOCKWIDTH - 1)) == 0)
	{
	  av_[1] = (mbinptr)(binblocks_r & ~block);
	  break;
	}
	--startidx;
34809c18:	02411001 	subeq	r1, r1, #1
34809c1c:	0afffff5 	beq	34809bf8 <malloc+0x378>
       q = prev_bin(q);
      } while (first(q) == q);

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks_r && (block != 0) )
34809c20:	e59a0004 	ldr	r0, [sl, #4]
34809c24:	e1a03083 	lsl	r3, r3, #1
34809c28:	e1530000 	cmp	r3, r0
34809c2c:	8a000008 	bhi	34809c54 <malloc+0x3d4>
34809c30:	e3530000 	cmp	r3, #0
34809c34:	0a000006 	beq	34809c54 <malloc+0x3d4>
34809c38:	e1a01006 	mov	r1, r6
34809c3c:	ea000001 	b	34809c48 <malloc+0x3c8>
      {
	while ((block & binblocks_r) == 0)
	{
	  idx += BINBLOCKWIDTH;
34809c40:	e2811004 	add	r1, r1, #4
	  block <<= 1;
34809c44:	e1a03083 	lsl	r3, r3, #1

      /* Get to the next possibly nonempty block */

      if ( (block <<= 1) <= binblocks_r && (block != 0) )
      {
	while ((block & binblocks_r) == 0)
34809c48:	e1130000 	tst	r3, r0
34809c4c:	1affffbd 	bne	34809b48 <malloc+0x2c8>
34809c50:	eafffffa 	b	34809c40 <malloc+0x3c0>


  /* Try to use top chunk */

  /* Require that there be a remainder, ensuring top always exists  */
  if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
34809c54:	e59f21d0 	ldr	r2, [pc, #464]	; 34809e2c <malloc+0x5ac>
34809c58:	e5927008 	ldr	r7, [r2, #8]
34809c5c:	e5979004 	ldr	r9, [r7, #4]
34809c60:	e3c99003 	bic	r9, r9, #3
34809c64:	e0643009 	rsb	r3, r4, r9
34809c68:	e353000f 	cmp	r3, #15
34809c6c:	ca000061 	bgt	34809df8 <malloc+0x578>
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
34809c70:	e59f31b0 	ldr	r3, [pc, #432]	; 34809e28 <malloc+0x5a8>
34809c74:	e593a034 	ldr	sl, [r3, #52]	; 0x34

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
34809c78:	e5923408 	ldr	r3, [r2, #1032]	; 0x408
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
34809c7c:	e28aa010 	add	sl, sl, #16

  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
34809c80:	e3730001 	cmn	r3, #1
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));

  /* Pad request with top_pad plus minimal overhead */

  INTERNAL_SIZE_T    sbrk_size     = nb + top_pad + MINSIZE;
34809c84:	e08aa004 	add	sl, sl, r4
  /* If not the first time through, round to preserve page boundary */
  /* Otherwise, we need to correct to a page size below anyway. */
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);
34809c88:	128aaeff 	addne	sl, sl, #4080	; 0xff0
34809c8c:	128aa00f 	addne	sl, sl, #15
34809c90:	13caaeff 	bicne	sl, sl, #4080	; 0xff0
34809c94:	13caa00f 	bicne	sl, sl, #15

  brk = (char*)(MORECORE (sbrk_size));
34809c98:	e1a0000a 	mov	r0, sl
34809c9c:	ebfffe1b 	bl	34809510 <sbrk>

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
34809ca0:	e3700001 	cmn	r0, #1
  /* (We also correct below if an intervening foreign sbrk call.) */

  if (sbrk_base != (char*)(-1))
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));
34809ca4:	e1a06000 	mov	r6, r0

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
34809ca8:	0a00004b 	beq	34809ddc <malloc+0x55c>
  char*     new_brk;              /* return of 2nd sbrk call */
  INTERNAL_SIZE_T top_size;       /* new size of top chunk */

  mchunkptr old_top     = top;  /* Record state of old top */
  INTERNAL_SIZE_T old_top_size = chunksize(old_top);
  char*     old_end      = (char*)(chunk_at_offset(old_top, old_top_size));
34809cac:	e0872009 	add	r2, r7, r9
    sbrk_size = (sbrk_size + (pagesz - 1)) & ~(pagesz - 1);

  brk = (char*)(MORECORE (sbrk_size));

  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
34809cb0:	e1500002 	cmp	r0, r2
34809cb4:	2a000001 	bcs	34809cc0 <malloc+0x440>
      (brk < old_end && old_top != initial_top))
34809cb8:	e1570005 	cmp	r7, r5
34809cbc:	1a000046 	bne	34809ddc <malloc+0x55c>
    return;

  sbrked_mem += sbrk_size;
34809cc0:	e59f3160 	ldr	r3, [pc, #352]	; 34809e28 <malloc+0x5a8>

  if (brk == old_end) /* can just add bytes to current top */
34809cc4:	e1560002 	cmp	r6, r2
  /* Fail if sbrk failed or if a foreign sbrk call killed our space */
  if (brk == (char*)(MORECORE_FAILURE) ||
      (brk < old_end && old_top != initial_top))
    return;

  sbrked_mem += sbrk_size;
34809cc8:	e593000c 	ldr	r0, [r3, #12]
34809ccc:	e59f1158 	ldr	r1, [pc, #344]	; 34809e2c <malloc+0x5ac>
34809cd0:	e08a0000 	add	r0, sl, r0
34809cd4:	e583000c 	str	r0, [r3, #12]

  if (brk == old_end) /* can just add bytes to current top */
  {
    top_size = sbrk_size + old_top_size;
    set_head(top, top_size | PREV_INUSE);
34809cd8:	05913008 	ldreq	r3, [r1, #8]

  sbrked_mem += sbrk_size;

  if (brk == old_end) /* can just add bytes to current top */
  {
    top_size = sbrk_size + old_top_size;
34809cdc:	008aa009 	addeq	sl, sl, r9
    set_head(top, top_size | PREV_INUSE);
34809ce0:	038aa001 	orreq	sl, sl, #1
34809ce4:	0583a004 	streq	sl, [r3, #4]
34809ce8:	0a000032 	beq	34809db8 <malloc+0x538>
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
34809cec:	e591c408 	ldr	ip, [r1, #1032]	; 0x408
34809cf0:	e37c0001 	cmn	ip, #1
      sbrk_base = brk;
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
34809cf4:	10860000 	addne	r0, r6, r0
34809cf8:	10622000 	rsbne	r2, r2, r0
    set_head(top, top_size | PREV_INUSE);
  }
  else
  {
    if (sbrk_base == (char*)(-1))  /* First time through. Record base */
      sbrk_base = brk;
34809cfc:	05816408 	streq	r6, [r1, #1032]	; 0x408
    else  /* Someone else called sbrk().  Count those bytes as sbrked_mem. */
      sbrked_mem += brk - (char*)old_end;
34809d00:	1583200c 	strne	r2, [r3, #12]

    /* Guarantee alignment of first new chunk made from this space */
    front_misalign = (unsigned long)chunk2mem(brk) & MALLOC_ALIGN_MASK;
    if (front_misalign > 0)
34809d04:	e2163007 	ands	r3, r6, #7
    {
      correction = (MALLOC_ALIGNMENT) - front_misalign;
34809d08:	12633008 	rsbne	r3, r3, #8
      brk += correction;
34809d0c:	10866003 	addne	r6, r6, r3
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */

    correction += ((((unsigned long)(brk + sbrk_size))+(pagesz-1)) &
34809d10:	e086a00a 	add	sl, r6, sl
		   ~(pagesz - 1)) - ((unsigned long)(brk + sbrk_size));
34809d14:	e06a3003 	rsb	r3, sl, r3
    else
      correction = 0;

    /* Guarantee the next brk will be at a page boundary */

    correction += ((((unsigned long)(brk + sbrk_size))+(pagesz-1)) &
34809d18:	e28aaeff 	add	sl, sl, #4080	; 0xff0
34809d1c:	e28aa00f 	add	sl, sl, #15
34809d20:	e3caaeff 	bic	sl, sl, #4080	; 0xff0
34809d24:	e3caa00f 	bic	sl, sl, #15
34809d28:	e083a00a 	add	sl, r3, sl
		   ~(pagesz - 1)) - ((unsigned long)(brk + sbrk_size));

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
34809d2c:	e1a0000a 	mov	r0, sl
34809d30:	ebfffdf6 	bl	34809510 <sbrk>
    if (new_brk == (char*)(MORECORE_FAILURE)) return;
34809d34:	e3700001 	cmn	r0, #1
34809d38:	0a000027 	beq	34809ddc <malloc+0x55c>

    sbrked_mem += correction;
34809d3c:	e59f30e4 	ldr	r3, [pc, #228]	; 34809e28 <malloc+0x5a8>

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
34809d40:	e0660000 	rsb	r0, r6, r0

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;
34809d44:	e593200c 	ldr	r2, [r3, #12]

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);

    if (old_top != initial_top)
34809d48:	e1570005 	cmp	r7, r5

    /* Allocate correction */
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;
34809d4c:	e08a2002 	add	r2, sl, r2
34809d50:	e583200c 	str	r2, [r3, #12]

    top = (mchunkptr)brk;
    top_size = new_brk - brk + correction;
34809d54:	e08aa000 	add	sl, sl, r0
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;

    top = (mchunkptr)brk;
34809d58:	e59f30cc 	ldr	r3, [pc, #204]	; 34809e2c <malloc+0x5ac>
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
34809d5c:	e38aa001 	orr	sl, sl, #1
    new_brk = (char*)(MORECORE (correction));
    if (new_brk == (char*)(MORECORE_FAILURE)) return;

    sbrked_mem += correction;

    top = (mchunkptr)brk;
34809d60:	e5836008 	str	r6, [r3, #8]
    top_size = new_brk - brk + correction;
    set_head(top, top_size | PREV_INUSE);
34809d64:	e586a004 	str	sl, [r6, #4]

    if (old_top != initial_top)
34809d68:	0a000012 	beq	34809db8 <malloc+0x538>

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE)
34809d6c:	e359000f 	cmp	r9, #15
      {
	set_head(top, PREV_INUSE); /* will force null return from malloc */
34809d70:	95933008 	ldrls	r3, [r3, #8]
34809d74:	93a02001 	movls	r2, #1
34809d78:	95832004 	strls	r2, [r3, #4]

      /* There must have been an intervening foreign sbrk call. */
      /* A double fencepost is necessary to prevent consolidation */

      /* If not enough space to do this, then user did something very wrong */
      if (old_top_size < MINSIZE)
34809d7c:	9a000016 	bls	34809ddc <malloc+0x55c>
	return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
34809d80:	e5973004 	ldr	r3, [r7, #4]
	set_head(top, PREV_INUSE); /* will force null return from malloc */
	return;
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
34809d84:	e249900c 	sub	r9, r9, #12
34809d88:	e3c99007 	bic	r9, r9, #7
      set_head_size(old_top, old_top_size);
34809d8c:	e2033001 	and	r3, r3, #1
34809d90:	e1893003 	orr	r3, r9, r3
34809d94:	e5873004 	str	r3, [r7, #4]
      chunk_at_offset(old_top, old_top_size          )->size =
34809d98:	e3a02005 	mov	r2, #5
34809d9c:	e0873009 	add	r3, r7, r9
	SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
	SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE)
34809da0:	e359000f 	cmp	r9, #15
      }

      /* Also keep size a multiple of MALLOC_ALIGNMENT */
      old_top_size = (old_top_size - 3*SIZE_SZ) & ~MALLOC_ALIGN_MASK;
      set_head_size(old_top, old_top_size);
      chunk_at_offset(old_top, old_top_size          )->size =
34809da4:	e5832004 	str	r2, [r3, #4]
	SIZE_SZ|PREV_INUSE;
      chunk_at_offset(old_top, old_top_size + SIZE_SZ)->size =
34809da8:	e5832008 	str	r2, [r3, #8]
	SIZE_SZ|PREV_INUSE;
      /* If possible, release the rest. */
      if (old_top_size >= MINSIZE)
34809dac:	9a000001 	bls	34809db8 <malloc+0x538>
	fREe(chunk2mem(old_top));
34809db0:	e2870008 	add	r0, r7, #8
34809db4:	ebfffe28 	bl	3480965c <free>
    }
  }

  if ((unsigned long)sbrked_mem > (unsigned long)max_sbrked_mem)
34809db8:	e59f2068 	ldr	r2, [pc, #104]	; 34809e28 <malloc+0x5a8>
34809dbc:	e592300c 	ldr	r3, [r2, #12]
34809dc0:	e5921038 	ldr	r1, [r2, #56]	; 0x38
34809dc4:	e1530001 	cmp	r3, r1
    max_sbrked_mem = sbrked_mem;
34809dc8:	85823038 	strhi	r3, [r2, #56]	; 0x38
  if ((unsigned long)(mmapped_mem + sbrked_mem) > (unsigned long)max_total_mem)
34809dcc:	e59f2054 	ldr	r2, [pc, #84]	; 34809e28 <malloc+0x5a8>
34809dd0:	e592103c 	ldr	r1, [r2, #60]	; 0x3c
34809dd4:	e1530001 	cmp	r3, r1
    max_total_mem = mmapped_mem + sbrked_mem;
34809dd8:	8582303c 	strhi	r3, [r2, #60]	; 0x3c
      return chunk2mem(victim);
#endif

    /* Try to extend */
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
34809ddc:	e59f3048 	ldr	r3, [pc, #72]	; 34809e2c <malloc+0x5ac>
34809de0:	e5933008 	ldr	r3, [r3, #8]
34809de4:	e5933004 	ldr	r3, [r3, #4]
34809de8:	e3c33003 	bic	r3, r3, #3
34809dec:	e0643003 	rsb	r3, r4, r3
34809df0:	e353000f 	cmp	r3, #15
34809df4:	da000009 	ble	34809e20 <malloc+0x5a0>
      return 0; /* propagate failure */
  }

  victim = top;
34809df8:	e59f202c 	ldr	r2, [pc, #44]	; 34809e2c <malloc+0x5ac>
  set_head(victim, nb | PREV_INUSE);
34809dfc:	e3841001 	orr	r1, r4, #1
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return 0; /* propagate failure */
  }

  victim = top;
34809e00:	e5920008 	ldr	r0, [r2, #8]
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
34809e04:	e3833001 	orr	r3, r3, #1
      return 0; /* propagate failure */
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
  top = chunk_at_offset(victim, nb);
34809e08:	e0804004 	add	r4, r0, r4
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return 0; /* propagate failure */
  }

  victim = top;
  set_head(victim, nb | PREV_INUSE);
34809e0c:	e5801004 	str	r1, [r0, #4]
  top = chunk_at_offset(victim, nb);
34809e10:	e5824008 	str	r4, [r2, #8]
  set_head(top, remainder_size | PREV_INUSE);
34809e14:	e5843004 	str	r3, [r4, #4]
  check_malloced_chunk(victim, nb);
  return chunk2mem(victim);
34809e18:	e2800008 	add	r0, r0, #8
34809e1c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
#endif

    /* Try to extend */
    malloc_extend_top(nb);
    if ( (remainder_size = chunksize(top) - nb) < (long)MINSIZE)
      return 0; /* propagate failure */
34809e20:	e3a00000 	mov	r0, #0
  top = chunk_at_offset(victim, nb);
  set_head(top, remainder_size | PREV_INUSE);
  check_malloced_chunk(victim, nb);
  return chunk2mem(victim);

}
34809e24:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34809e28:	34829d80 	.word	0x34829d80
34809e2c:	34828590 	.word	0x34828590
34809e30:	34828598 	.word	0x34828598

34809e34 <calloc>:
#if __STD_C
Void_t* cALLOc(size_t n, size_t elem_size)
#else
Void_t* cALLOc(n, elem_size) size_t n; size_t elem_size;
#endif
{
34809e34:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
  INTERNAL_SIZE_T sz = n * elem_size;


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
34809e38:	e59f30d0 	ldr	r3, [pc, #208]	; 34809f10 <calloc+0xdc>
#if __STD_C
Void_t* cALLOc(size_t n, size_t elem_size)
#else
Void_t* cALLOc(n, elem_size) size_t n; size_t elem_size;
#endif
{
34809e3c:	e1a06000 	mov	r6, r0
  INTERNAL_SIZE_T sz = n * elem_size;


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
34809e40:	e5935008 	ldr	r5, [r3, #8]
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
#endif
  Void_t* mem = mALLOc (sz);
34809e44:	e0000190 	mul	r0, r0, r1


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
34809e48:	e5957004 	ldr	r7, [r5, #4]
#endif
  Void_t* mem = mALLOc (sz);
34809e4c:	ebfffe8b 	bl	34809880 <malloc>

  if ((long)n < 0) return 0;
34809e50:	e3560000 	cmp	r6, #0
  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
#endif
  Void_t* mem = mALLOc (sz);
34809e54:	e1a04000 	mov	r4, r0

  if ((long)n < 0) return 0;
34809e58:	b3a04000 	movlt	r4, #0
34809e5c:	ba000029 	blt	34809f08 <calloc+0xd4>

  if (mem == 0)
34809e60:	e3540000 	cmp	r4, #0
34809e64:	0a000027 	beq	34809f08 <calloc+0xd4>

#if HAVE_MMAP
    if (chunk_is_mmapped(p)) return mem;
#endif

    csz = chunksize(p);
34809e68:	e5142004 	ldr	r2, [r4, #-4]


  /* check if expand_top called, in which case don't need to clear */
#if MORECORE_CLEARS
  mchunkptr oldtop = top;
  INTERNAL_SIZE_T oldtopsize = chunksize(top);
34809e6c:	e3c77003 	bic	r7, r7, #3

#if HAVE_MMAP
    if (chunk_is_mmapped(p)) return mem;
#endif

    csz = chunksize(p);
34809e70:	e3c22003 	bic	r2, r2, #3

  if (mem == 0)
    return 0;
  else
  {
    p = mem2chunk(mem);
34809e74:	e2443008 	sub	r3, r4, #8
#endif

    csz = chunksize(p);

#if MORECORE_CLEARS
    if (p == oldtop && csz > oldtopsize)
34809e78:	e1530005 	cmp	r3, r5
34809e7c:	13a05000 	movne	r5, #0
34809e80:	03a05001 	moveq	r5, #1
34809e84:	e1520007 	cmp	r2, r7
34809e88:	93a05000 	movls	r5, #0
34809e8c:	e3550000 	cmp	r5, #0
34809e90:	11a02007 	movne	r2, r7
      /* clear only the bytes from non-freshly-sbrked memory */
      csz = oldtopsize;
    }
#endif

    MALLOC_ZERO(mem, csz - SIZE_SZ);
34809e94:	e2422004 	sub	r2, r2, #4
34809e98:	e3520024 	cmp	r2, #36	; 0x24
34809e9c:	8a000017 	bhi	34809f00 <calloc+0xcc>
34809ea0:	e3520013 	cmp	r2, #19
34809ea4:	e1a03004 	mov	r3, r4
34809ea8:	9a00000e 	bls	34809ee8 <calloc+0xb4>
34809eac:	e3a01000 	mov	r1, #0
34809eb0:	e1a00004 	mov	r0, r4
34809eb4:	e4801004 	str	r1, [r0], #4
34809eb8:	e352001b 	cmp	r2, #27
34809ebc:	e5841004 	str	r1, [r4, #4]
34809ec0:	e2803004 	add	r3, r0, #4
34809ec4:	9a000007 	bls	34809ee8 <calloc+0xb4>
34809ec8:	e5801004 	str	r1, [r0, #4]
34809ecc:	e2830004 	add	r0, r3, #4
34809ed0:	e5831004 	str	r1, [r3, #4]
34809ed4:	e3520024 	cmp	r2, #36	; 0x24
34809ed8:	e2803004 	add	r3, r0, #4
34809edc:	05801004 	streq	r1, [r0, #4]
34809ee0:	05831004 	streq	r1, [r3, #4]
34809ee4:	02833008 	addeq	r3, r3, #8
34809ee8:	e3a01000 	mov	r1, #0
34809eec:	e1a02003 	mov	r2, r3
34809ef0:	e4821004 	str	r1, [r2], #4
34809ef4:	e5831004 	str	r1, [r3, #4]
34809ef8:	e5821004 	str	r1, [r2, #4]
34809efc:	ea000001 	b	34809f08 <calloc+0xd4>
34809f00:	e3a01000 	mov	r1, #0
34809f04:	eb0047ee 	bl	3481bec4 <memset>
    return mem;
  }
}
34809f08:	e1a00004 	mov	r0, r4
34809f0c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34809f10:	34828590 	.word	0x34828590

34809f14 <memalign>:
#if __STD_C
Void_t* mEMALIGn(size_t alignment, size_t bytes)
#else
Void_t* mEMALIGn(alignment, bytes) size_t alignment; size_t bytes;
#endif
{
34809f14:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34809f18:	e1a04000 	mov	r4, r0
  INTERNAL_SIZE_T  newsize;   /* its size */
  INTERNAL_SIZE_T  leadsize;  /* leading space befor alignment point */
  mchunkptr remainder;        /* spare room at end to split off */
  long      remainder_size;   /* its size */

  if ((long)bytes < 0) return 0;
34809f1c:	e2510000 	subs	r0, r1, #0
34809f20:	b3a00000 	movlt	r0, #0
34809f24:	b8bd84f0 	poplt	{r4, r5, r6, r7, sl, pc}

  /* If need less alignment than we give anyway, just relay to malloc */

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
34809f28:	e3540008 	cmp	r4, #8
34809f2c:	8a000001 	bhi	34809f38 <memalign+0x24>
  }

  check_inuse_chunk(p);
  return chunk2mem(p);

}
34809f30:	e8bd44f0 	pop	{r4, r5, r6, r7, sl, lr}

  if ((long)bytes < 0) return 0;

  /* If need less alignment than we give anyway, just relay to malloc */

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);
34809f34:	eafffe51 	b	34809880 <malloc>

  if (alignment <  MINSIZE) alignment = MINSIZE;

  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
34809f38:	e280700b 	add	r7, r0, #11

  if (alignment <= MALLOC_ALIGNMENT) return mALLOc(bytes);

  /* Otherwise, ensure that it is at least a minimum chunk size */

  if (alignment <  MINSIZE) alignment = MINSIZE;
34809f3c:	e354000f 	cmp	r4, #15
34809f40:	93a04010 	movls	r4, #16

  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
34809f44:	e3570016 	cmp	r7, #22
34809f48:	c3c77007 	bicgt	r7, r7, #7
34809f4c:	d3a07010 	movle	r7, #16
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));
34809f50:	e2840010 	add	r0, r4, #16
34809f54:	e0800007 	add	r0, r0, r7
34809f58:	ebfffe48 	bl	34809880 <malloc>

  if (m == 0) return 0; /* propagate failure */
34809f5c:	e2506000 	subs	r6, r0, #0
34809f60:	0a00002d 	beq	3480a01c <memalign+0x108>

  p = mem2chunk(m);

  if ((((unsigned long)(m)) % alignment) == 0) /* aligned */
34809f64:	e1a01004 	mov	r1, r4
34809f68:	eb005787 	bl	3481fd8c <__aeabi_uidivmod>
34809f6c:	e3510000 	cmp	r1, #0
  nb = request2size(bytes);
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));

  if (m == 0) return 0; /* propagate failure */

  p = mem2chunk(m);
34809f70:	e2465008 	sub	r5, r6, #8

  if ((((unsigned long)(m)) % alignment) == 0) /* aligned */
34809f74:	0a000018 	beq	34809fdc <memalign+0xc8>
      a spot with less than MINSIZE leader, we can move to the
      next aligned spot -- we've allocated enough total room so that
      this is always possible.
    */

    brk = (char*)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment));
34809f78:	e244a001 	sub	sl, r4, #1
34809f7c:	e2643000 	rsb	r3, r4, #0
34809f80:	e086a00a 	add	sl, r6, sl
34809f84:	e00aa003 	and	sl, sl, r3
34809f88:	e24aa008 	sub	sl, sl, #8
    if ((long)(brk - (char*)(p)) < MINSIZE) brk = brk + alignment;
34809f8c:	e065300a 	rsb	r3, r5, sl
34809f90:	e353000f 	cmp	r3, #15

    newp = (mchunkptr)brk;
    leadsize = brk - (char*)(p);
    newsize = chunksize(p) - leadsize;
34809f94:	e5163004 	ldr	r3, [r6, #-4]
      next aligned spot -- we've allocated enough total room so that
      this is always possible.
    */

    brk = (char*)mem2chunk(((unsigned long)(m + alignment - 1)) & -((signed) alignment));
    if ((long)(brk - (char*)(p)) < MINSIZE) brk = brk + alignment;
34809f98:	908aa004 	addls	sl, sl, r4

    newp = (mchunkptr)brk;
    leadsize = brk - (char*)(p);
34809f9c:	e065500a 	rsb	r5, r5, sl
    newsize = chunksize(p) - leadsize;
34809fa0:	e3c33003 	bic	r3, r3, #3
34809fa4:	e0653003 	rsb	r3, r5, r3
    }
#endif

    /* give back leader, use the rest */

    set_head(newp, newsize | PREV_INUSE);
34809fa8:	e3832001 	orr	r2, r3, #1
34809fac:	e58a2004 	str	r2, [sl, #4]
    set_inuse_bit_at_offset(newp, newsize);
34809fb0:	e08a3003 	add	r3, sl, r3
34809fb4:	e5932004 	ldr	r2, [r3, #4]
    set_head_size(p, leadsize);
    fREe(chunk2mem(p));
34809fb8:	e1a00006 	mov	r0, r6
#endif

    /* give back leader, use the rest */

    set_head(newp, newsize | PREV_INUSE);
    set_inuse_bit_at_offset(newp, newsize);
34809fbc:	e3822001 	orr	r2, r2, #1
34809fc0:	e5832004 	str	r2, [r3, #4]
    set_head_size(p, leadsize);
34809fc4:	e5163004 	ldr	r3, [r6, #-4]
34809fc8:	e2033001 	and	r3, r3, #1
34809fcc:	e1855003 	orr	r5, r5, r3
34809fd0:	e5065004 	str	r5, [r6, #-4]
    fREe(chunk2mem(p));
34809fd4:	ebfffda0 	bl	3480965c <free>
34809fd8:	e1a0500a 	mov	r5, sl
    assert (newsize >= nb && (((unsigned long)(chunk2mem(p))) % alignment) == 0);
  }

  /* Also give back spare room at the end */

  remainder_size = chunksize(p) - nb;
34809fdc:	e5953004 	ldr	r3, [r5, #4]
34809fe0:	e3c33003 	bic	r3, r3, #3
34809fe4:	e0673003 	rsb	r3, r7, r3

  if (remainder_size >= (long)MINSIZE)
34809fe8:	e353000f 	cmp	r3, #15
34809fec:	da000008 	ble	3480a014 <memalign+0x100>
  {
    remainder = chunk_at_offset(p, nb);
34809ff0:	e0850007 	add	r0, r5, r7
    set_head(remainder, remainder_size | PREV_INUSE);
34809ff4:	e3833001 	orr	r3, r3, #1
34809ff8:	e5803004 	str	r3, [r0, #4]
    set_head_size(p, nb);
34809ffc:	e5953004 	ldr	r3, [r5, #4]
    fREe(chunk2mem(remainder));
3480a000:	e2800008 	add	r0, r0, #8

  if (remainder_size >= (long)MINSIZE)
  {
    remainder = chunk_at_offset(p, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_head_size(p, nb);
3480a004:	e2033001 	and	r3, r3, #1
3480a008:	e1877003 	orr	r7, r7, r3
3480a00c:	e5857004 	str	r7, [r5, #4]
    fREe(chunk2mem(remainder));
3480a010:	ebfffd91 	bl	3480965c <free>
  }

  check_inuse_chunk(p);
  return chunk2mem(p);
3480a014:	e2850008 	add	r0, r5, #8
3480a018:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
  /* Call malloc with worst case padding to hit alignment. */

  nb = request2size(bytes);
  m  = (char*)(mALLOc(nb + alignment + MINSIZE));

  if (m == 0) return 0; /* propagate failure */
3480a01c:	e1a00006 	mov	r0, r6
  }

  check_inuse_chunk(p);
  return chunk2mem(p);

}
3480a020:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

3480a024 <pvalloc>:
#else
Void_t* pvALLOc(bytes) size_t bytes;
#endif
{
  size_t pagesize = malloc_getpagesize;
  return mEMALIGn (pagesize, (bytes + pagesize - 1) & ~(pagesize - 1));
3480a024:	e2801eff 	add	r1, r0, #4080	; 0xff0
3480a028:	e281100f 	add	r1, r1, #15
3480a02c:	e3c11eff 	bic	r1, r1, #4080	; 0xff0
3480a030:	e3a00a01 	mov	r0, #4096	; 0x1000
3480a034:	e3c1100f 	bic	r1, r1, #15
3480a038:	eaffffb5 	b	34809f14 <memalign>

3480a03c <valloc>:
#if __STD_C
Void_t* vALLOc(size_t bytes)
#else
Void_t* vALLOc(bytes) size_t bytes;
#endif
{
3480a03c:	e1a01000 	mov	r1, r0
  return mEMALIGn (malloc_getpagesize, bytes);
3480a040:	e3a00a01 	mov	r0, #4096	; 0x1000
3480a044:	eaffffb2 	b	34809f14 <memalign>

3480a048 <realloc>:
#if __STD_C
Void_t* rEALLOc(Void_t* oldmem, size_t bytes)
#else
Void_t* rEALLOc(oldmem, bytes) Void_t* oldmem; size_t bytes;
#endif
{
3480a048:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480a04c:	e1a05000 	mov	r5, r0

#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) { fREe(oldmem); return 0; }
#endif

  if ((long)bytes < 0) return 0;
3480a050:	e2510000 	subs	r0, r1, #0
3480a054:	ba00010b 	blt	3480a488 <realloc+0x440>

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);
3480a058:	e3550000 	cmp	r5, #0
3480a05c:	1a000001 	bne	3480a068 <realloc+0x20>
    set_inuse_bit_at_offset(newp, newsize);
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
}
3480a060:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
#endif

  if ((long)bytes < 0) return 0;

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);
3480a064:	eafffe05 	b	34809880 <malloc>

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);


  nb = request2size(bytes);
3480a068:	e280600b 	add	r6, r0, #11

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
3480a06c:	e5151004 	ldr	r1, [r5, #-4]


  nb = request2size(bytes);
3480a070:	e3560016 	cmp	r6, #22

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
  newsize = oldsize = chunksize(oldp);
3480a074:	e3c19003 	bic	r9, r1, #3


  nb = request2size(bytes);
3480a078:	c3c66007 	bicgt	r6, r6, #7
3480a07c:	d3a06010 	movle	r6, #16
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
3480a080:	e1590006 	cmp	r9, r6
  if ((long)bytes < 0) return 0;

  /* realloc of null is supposed to be same as malloc */
  if (oldmem == 0) return mALLOc(bytes);

  newp    = oldp    = mem2chunk(oldmem);
3480a084:	e245b008 	sub	fp, r5, #8
  newsize = oldsize = chunksize(oldp);
3480a088:	a1a0a009 	movge	sl, r9
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
3480a08c:	aa0000e2 	bge	3480a41c <realloc+0x3d4>
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
3480a090:	e59f23fc 	ldr	r2, [pc, #1020]	; 3480a494 <realloc+0x44c>
  if ((long)(oldsize) < (long)(nb))
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
3480a094:	e08b3009 	add	r3, fp, r9
    if (next == top || !inuse(next))
3480a098:	e592c008 	ldr	ip, [r2, #8]
3480a09c:	e153000c 	cmp	r3, ip
3480a0a0:	0a000007 	beq	3480a0c4 <realloc+0x7c>
3480a0a4:	e5932004 	ldr	r2, [r3, #4]
3480a0a8:	e3c22001 	bic	r2, r2, #1
3480a0ac:	e0832002 	add	r2, r3, r2
3480a0b0:	e5922004 	ldr	r2, [r2, #4]
3480a0b4:	e3120001 	tst	r2, #1
      }
    }
    else
    {
      next = 0;
      nextsize = 0;
3480a0b8:	13a02000 	movne	r2, #0
	goto split;
      }
    }
    else
    {
      next = 0;
3480a0bc:	11a03002 	movne	r3, r2
  {

    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
3480a0c0:	1a000019 	bne	3480a12c <realloc+0xe4>
    {
      nextsize = chunksize(next);
3480a0c4:	e5932004 	ldr	r2, [r3, #4]

      /* Forward into top only if a remainder */
      if (next == top)
3480a0c8:	e153000c 	cmp	r3, ip
    /* Try expanding forward */

    next = chunk_at_offset(oldp, oldsize);
    if (next == top || !inuse(next))
    {
      nextsize = chunksize(next);
3480a0cc:	e3c22003 	bic	r2, r2, #3
3480a0d0:	e082a009 	add	sl, r2, r9

      /* Forward into top only if a remainder */
      if (next == top)
3480a0d4:	1a00000e 	bne	3480a114 <realloc+0xcc>
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
3480a0d8:	e2864010 	add	r4, r6, #16
3480a0dc:	e15a0004 	cmp	sl, r4
3480a0e0:	ba000011 	blt	3480a12c <realloc+0xe4>
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
3480a0e4:	e59f33a8 	ldr	r3, [pc, #936]	; 3480a494 <realloc+0x44c>
	  set_head(top, (newsize - nb) | PREV_INUSE);
3480a0e8:	e066a00a 	rsb	sl, r6, sl
      if (next == top)
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
3480a0ec:	e08bb006 	add	fp, fp, r6
	  set_head(top, (newsize - nb) | PREV_INUSE);
3480a0f0:	e38aa001 	orr	sl, sl, #1
      if (next == top)
      {
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
3480a0f4:	e583b008 	str	fp, [r3, #8]
	  set_head(top, (newsize - nb) | PREV_INUSE);
3480a0f8:	e58ba004 	str	sl, [fp, #4]
	  set_head_size(oldp, nb);
3480a0fc:	e5153004 	ldr	r3, [r5, #-4]
	  return chunk2mem(oldp);
3480a100:	e1a07005 	mov	r7, r5
	if ((long)(nextsize + newsize) >= (long)(nb + MINSIZE))
	{
	  newsize += nextsize;
	  top = chunk_at_offset(oldp, nb);
	  set_head(top, (newsize - nb) | PREV_INUSE);
	  set_head_size(oldp, nb);
3480a104:	e2033001 	and	r3, r3, #1
3480a108:	e1866003 	orr	r6, r6, r3
3480a10c:	e5056004 	str	r6, [r5, #-4]
	  return chunk2mem(oldp);
3480a110:	ea0000dd 	b	3480a48c <realloc+0x444>
	}
      }

      /* Forward into next chunk */
      else if (((long)(nextsize + newsize) >= (long)(nb)))
3480a114:	e15a0006 	cmp	sl, r6
      {
	unlink(next, bck, fwd);
3480a118:	a593200c 	ldrge	r2, [r3, #12]
3480a11c:	a5933008 	ldrge	r3, [r3, #8]
3480a120:	a583200c 	strge	r2, [r3, #12]
3480a124:	a5823008 	strge	r3, [r2, #8]
3480a128:	aa0000bb 	bge	3480a41c <realloc+0x3d4>
      nextsize = 0;
    }

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
3480a12c:	e3110001 	tst	r1, #1
3480a130:	1a00007e 	bne	3480a330 <realloc+0x2e8>
    {
      prev = prev_chunk(oldp);
3480a134:	e5154008 	ldr	r4, [r5, #-8]
      prevsize = chunksize(prev);

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
3480a138:	e3530000 	cmp	r3, #0

    /* Try shifting backwards. */

    if (!prev_inuse(oldp))
    {
      prev = prev_chunk(oldp);
3480a13c:	e064400b 	rsb	r4, r4, fp
      prevsize = chunksize(prev);
3480a140:	e5941004 	ldr	r1, [r4, #4]
3480a144:	e3c11003 	bic	r1, r1, #3

      /* try forward + backward first to save a later consolidation */

      if (next != 0)
3480a148:	0a000047 	beq	3480a26c <realloc+0x224>
      {
	/* into top */
	if (next == top)
3480a14c:	e153000c 	cmp	r3, ip
3480a150:	e081a009 	add	sl, r1, r9
3480a154:	1a00003d 	bne	3480a250 <realloc+0x208>
	{
	  if ((long)(nextsize + prevsize + newsize) >= (long)(nb + MINSIZE))
3480a158:	e08aa002 	add	sl, sl, r2
3480a15c:	e2863010 	add	r3, r6, #16
3480a160:	e15a0003 	cmp	sl, r3
3480a164:	ba000040 	blt	3480a26c <realloc+0x224>
	  {
	    unlink(prev, bck, fwd);
3480a168:	e1a07004 	mov	r7, r4
3480a16c:	e5b72008 	ldr	r2, [r7, #8]!
3480a170:	e594300c 	ldr	r3, [r4, #12]
3480a174:	e582300c 	str	r3, [r2, #12]
3480a178:	e5832008 	str	r2, [r3, #8]
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480a17c:	e2492004 	sub	r2, r9, #4
3480a180:	e3520024 	cmp	r2, #36	; 0x24
3480a184:	8a000023 	bhi	3480a218 <realloc+0x1d0>
3480a188:	e3520013 	cmp	r2, #19
3480a18c:	e1a03007 	mov	r3, r7
3480a190:	9a000017 	bls	3480a1f4 <realloc+0x1ac>
3480a194:	e1a01005 	mov	r1, r5
3480a198:	e4913004 	ldr	r3, [r1], #4
3480a19c:	e352001b 	cmp	r2, #27
3480a1a0:	e5843008 	str	r3, [r4, #8]
3480a1a4:	e5953004 	ldr	r3, [r5, #4]
3480a1a8:	e2815004 	add	r5, r1, #4
3480a1ac:	e584300c 	str	r3, [r4, #12]
3480a1b0:	e2843010 	add	r3, r4, #16
3480a1b4:	9a00000e 	bls	3480a1f4 <realloc+0x1ac>
3480a1b8:	e5913004 	ldr	r3, [r1, #4]
3480a1bc:	e3520024 	cmp	r2, #36	; 0x24
3480a1c0:	e5843010 	str	r3, [r4, #16]
3480a1c4:	e5953004 	ldr	r3, [r5, #4]
3480a1c8:	e2851004 	add	r1, r5, #4
3480a1cc:	e5843014 	str	r3, [r4, #20]
3480a1d0:	e2815004 	add	r5, r1, #4
3480a1d4:	e2843018 	add	r3, r4, #24
3480a1d8:	1a000005 	bne	3480a1f4 <realloc+0x1ac>
3480a1dc:	e5913004 	ldr	r3, [r1, #4]
3480a1e0:	e5843018 	str	r3, [r4, #24]
3480a1e4:	e5953004 	ldr	r3, [r5, #4]
3480a1e8:	e2855008 	add	r5, r5, #8
3480a1ec:	e584301c 	str	r3, [r4, #28]
3480a1f0:	e2843020 	add	r3, r4, #32
3480a1f4:	e1a01005 	mov	r1, r5
3480a1f8:	e4910004 	ldr	r0, [r1], #4
3480a1fc:	e1a02003 	mov	r2, r3
3480a200:	e4820004 	str	r0, [r2], #4
3480a204:	e5950004 	ldr	r0, [r5, #4]
3480a208:	e5830004 	str	r0, [r3, #4]
3480a20c:	e5913004 	ldr	r3, [r1, #4]
3480a210:	e5823004 	str	r3, [r2, #4]
3480a214:	ea000002 	b	3480a224 <realloc+0x1dc>
3480a218:	e1a00007 	mov	r0, r7
3480a21c:	e1a01005 	mov	r1, r5
3480a220:	eb00474b 	bl	3481bf54 <memcpy>
	    top = chunk_at_offset(newp, nb);
	    set_head(top, (newsize - nb) | PREV_INUSE);
3480a224:	e066a00a 	rsb	sl, r6, sl
	    unlink(prev, bck, fwd);
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
	    top = chunk_at_offset(newp, nb);
3480a228:	e59f2264 	ldr	r2, [pc, #612]	; 3480a494 <realloc+0x44c>
3480a22c:	e0843006 	add	r3, r4, r6
	    set_head(top, (newsize - nb) | PREV_INUSE);
3480a230:	e38aa001 	orr	sl, sl, #1
	    unlink(prev, bck, fwd);
	    newp = prev;
	    newsize += prevsize + nextsize;
	    newmem = chunk2mem(newp);
	    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
	    top = chunk_at_offset(newp, nb);
3480a234:	e5823008 	str	r3, [r2, #8]
	    set_head(top, (newsize - nb) | PREV_INUSE);
3480a238:	e583a004 	str	sl, [r3, #4]
	    set_head_size(newp, nb);
3480a23c:	e5943004 	ldr	r3, [r4, #4]
3480a240:	e2033001 	and	r3, r3, #1
3480a244:	e1866003 	orr	r6, r6, r3
3480a248:	e5846004 	str	r6, [r4, #4]
	    return newmem;
3480a24c:	ea00008e 	b	3480a48c <realloc+0x444>
	  }
	}

	/* into next chunk */
	else if (((long)(nextsize + prevsize + newsize) >= (long)(nb)))
3480a250:	e08aa002 	add	sl, sl, r2
3480a254:	e15a0006 	cmp	sl, r6
	{
	  unlink(next, bck, fwd);
3480a258:	a593200c 	ldrge	r2, [r3, #12]
3480a25c:	a5933008 	ldrge	r3, [r3, #8]
3480a260:	a583200c 	strge	r2, [r3, #12]
3480a264:	a5823008 	strge	r3, [r2, #8]
3480a268:	aa000002 	bge	3480a278 <realloc+0x230>
	  goto split;
	}
      }

      /* backward only */
      if (prev != 0 && (long)(prevsize + newsize) >= (long)nb)
3480a26c:	e081a009 	add	sl, r1, r9
3480a270:	e15a0006 	cmp	sl, r6
3480a274:	ba00002d 	blt	3480a330 <realloc+0x2e8>
      {
	unlink(prev, bck, fwd);
3480a278:	e1a00004 	mov	r0, r4
3480a27c:	e5b02008 	ldr	r2, [r0, #8]!
3480a280:	e594300c 	ldr	r3, [r4, #12]
3480a284:	e582300c 	str	r3, [r2, #12]
3480a288:	e5832008 	str	r2, [r3, #8]
	newp = prev;
	newsize += prevsize;
	newmem = chunk2mem(newp);
	MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480a28c:	e2492004 	sub	r2, r9, #4
3480a290:	e3520024 	cmp	r2, #36	; 0x24
3480a294:	8a000022 	bhi	3480a324 <realloc+0x2dc>
3480a298:	e3520013 	cmp	r2, #19
3480a29c:	9a000017 	bls	3480a300 <realloc+0x2b8>
3480a2a0:	e1a03005 	mov	r3, r5
3480a2a4:	e4931004 	ldr	r1, [r3], #4
3480a2a8:	e352001b 	cmp	r2, #27
3480a2ac:	e5841008 	str	r1, [r4, #8]
3480a2b0:	e5951004 	ldr	r1, [r5, #4]
3480a2b4:	e2840010 	add	r0, r4, #16
3480a2b8:	e584100c 	str	r1, [r4, #12]
3480a2bc:	e2835004 	add	r5, r3, #4
3480a2c0:	9a00000e 	bls	3480a300 <realloc+0x2b8>
3480a2c4:	e5933004 	ldr	r3, [r3, #4]
3480a2c8:	e3520024 	cmp	r2, #36	; 0x24
3480a2cc:	e5843010 	str	r3, [r4, #16]
3480a2d0:	e5951004 	ldr	r1, [r5, #4]
3480a2d4:	e2853004 	add	r3, r5, #4
3480a2d8:	e5841014 	str	r1, [r4, #20]
3480a2dc:	e2840018 	add	r0, r4, #24
3480a2e0:	e2835004 	add	r5, r3, #4
3480a2e4:	1a000005 	bne	3480a300 <realloc+0x2b8>
3480a2e8:	e5933004 	ldr	r3, [r3, #4]
3480a2ec:	e2840020 	add	r0, r4, #32
3480a2f0:	e5843018 	str	r3, [r4, #24]
3480a2f4:	e5953004 	ldr	r3, [r5, #4]
3480a2f8:	e2855008 	add	r5, r5, #8
3480a2fc:	e584301c 	str	r3, [r4, #28]
3480a300:	e1a02005 	mov	r2, r5
3480a304:	e4921004 	ldr	r1, [r2], #4
3480a308:	e1a03000 	mov	r3, r0
3480a30c:	e4831004 	str	r1, [r3], #4
3480a310:	e5951004 	ldr	r1, [r5, #4]
3480a314:	e5801004 	str	r1, [r0, #4]
3480a318:	e5922004 	ldr	r2, [r2, #4]
3480a31c:	e5832004 	str	r2, [r3, #4]
3480a320:	ea00003e 	b	3480a420 <realloc+0x3d8>
3480a324:	e1a01005 	mov	r1, r5
3480a328:	eb004709 	bl	3481bf54 <memcpy>
3480a32c:	ea00003b 	b	3480a420 <realloc+0x3d8>
      }
    }

    /* Must allocate */

    newmem = mALLOc (bytes);
3480a330:	ebfffd52 	bl	34809880 <malloc>

    if (newmem == 0)  /* propagate failure */
3480a334:	e2507000 	subs	r7, r0, #0
3480a338:	0a000053 	beq	3480a48c <realloc+0x444>
      return 0;

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp))
3480a33c:	e5153004 	ldr	r3, [r5, #-4]
3480a340:	e2472008 	sub	r2, r7, #8
3480a344:	e3c33001 	bic	r3, r3, #1
3480a348:	e08b3003 	add	r3, fp, r3
3480a34c:	e1520003 	cmp	r2, r3
    {
      newsize += chunksize(newp);
3480a350:	0517a004 	ldreq	sl, [r7, #-4]
3480a354:	03caa003 	biceq	sl, sl, #3
3480a358:	008aa009 	addeq	sl, sl, r9
      return 0;

    /* Avoid copy if newp is next chunk after oldp. */
    /* (This can only happen when new chunk is sbrk'ed.) */

    if ( (newp = mem2chunk(newmem)) == next_chunk(oldp))
3480a35c:	0a00002e 	beq	3480a41c <realloc+0x3d4>
      newp = oldp;
      goto split;
    }

    /* Otherwise copy, free, and exit */
    MALLOC_COPY(newmem, oldmem, oldsize - SIZE_SZ);
3480a360:	e2492004 	sub	r2, r9, #4
3480a364:	e3520024 	cmp	r2, #36	; 0x24
3480a368:	8a000026 	bhi	3480a408 <realloc+0x3c0>
3480a36c:	e3520013 	cmp	r2, #19
3480a370:	e1a01005 	mov	r1, r5
3480a374:	e1a03007 	mov	r3, r7
3480a378:	9a000019 	bls	3480a3e4 <realloc+0x39c>
3480a37c:	e1a0c005 	mov	ip, r5
3480a380:	e49c3004 	ldr	r3, [ip], #4
3480a384:	e1a00007 	mov	r0, r7
3480a388:	e4803004 	str	r3, [r0], #4
3480a38c:	e5953004 	ldr	r3, [r5, #4]
3480a390:	e352001b 	cmp	r2, #27
3480a394:	e5873004 	str	r3, [r7, #4]
3480a398:	e28c1004 	add	r1, ip, #4
3480a39c:	e2803004 	add	r3, r0, #4
3480a3a0:	9a00000f 	bls	3480a3e4 <realloc+0x39c>
3480a3a4:	e59cc004 	ldr	ip, [ip, #4]
3480a3a8:	e3520024 	cmp	r2, #36	; 0x24
3480a3ac:	e580c004 	str	ip, [r0, #4]
3480a3b0:	e281c004 	add	ip, r1, #4
3480a3b4:	e5911004 	ldr	r1, [r1, #4]
3480a3b8:	e2830004 	add	r0, r3, #4
3480a3bc:	e5831004 	str	r1, [r3, #4]
3480a3c0:	e2803004 	add	r3, r0, #4
3480a3c4:	e28c1004 	add	r1, ip, #4
3480a3c8:	1a000005 	bne	3480a3e4 <realloc+0x39c>
3480a3cc:	e59c2004 	ldr	r2, [ip, #4]
3480a3d0:	e5802004 	str	r2, [r0, #4]
3480a3d4:	e5912004 	ldr	r2, [r1, #4]
3480a3d8:	e2811008 	add	r1, r1, #8
3480a3dc:	e5832004 	str	r2, [r3, #4]
3480a3e0:	e2833008 	add	r3, r3, #8
3480a3e4:	e1a00001 	mov	r0, r1
3480a3e8:	e490c004 	ldr	ip, [r0], #4
3480a3ec:	e1a02003 	mov	r2, r3
3480a3f0:	e482c004 	str	ip, [r2], #4
3480a3f4:	e5911004 	ldr	r1, [r1, #4]
3480a3f8:	e5831004 	str	r1, [r3, #4]
3480a3fc:	e5903004 	ldr	r3, [r0, #4]
3480a400:	e5823004 	str	r3, [r2, #4]
3480a404:	ea000001 	b	3480a410 <realloc+0x3c8>
3480a408:	e1a01005 	mov	r1, r5
3480a40c:	eb0046d0 	bl	3481bf54 <memcpy>
    fREe(oldmem);
3480a410:	e1a00005 	mov	r0, r5
3480a414:	ebfffc90 	bl	3480965c <free>
    return newmem;
3480a418:	ea00001b 	b	3480a48c <realloc+0x444>
  }
#endif

  check_inuse_chunk(oldp);

  if ((long)(oldsize) < (long)(nb))
3480a41c:	e1a0400b 	mov	r4, fp
  }


 split:  /* split off extra room in old or expanded chunk */

  if (newsize - nb >= MINSIZE) /* split off remainder */
3480a420:	e066300a 	rsb	r3, r6, sl
3480a424:	e353000f 	cmp	r3, #15
3480a428:	e5942004 	ldr	r2, [r4, #4]
3480a42c:	9a00000c 	bls	3480a464 <realloc+0x41c>
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
3480a430:	e2022001 	and	r2, r2, #1

 split:  /* split off extra room in old or expanded chunk */

  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
3480a434:	e0840006 	add	r0, r4, r6
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
3480a438:	e1866002 	orr	r6, r6, r2
    set_head(remainder, remainder_size | PREV_INUSE);
3480a43c:	e3832001 	orr	r2, r3, #1

  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
3480a440:	e5846004 	str	r6, [r4, #4]
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
3480a444:	e0803003 	add	r3, r0, r3
  if (newsize - nb >= MINSIZE) /* split off remainder */
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
3480a448:	e5802004 	str	r2, [r0, #4]
    set_inuse_bit_at_offset(remainder, remainder_size);
3480a44c:	e5932004 	ldr	r2, [r3, #4]
    fREe(chunk2mem(remainder)); /* let free() deal with it */
3480a450:	e2800008 	add	r0, r0, #8
  {
    remainder = chunk_at_offset(newp, nb);
    remainder_size = newsize - nb;
    set_head_size(newp, nb);
    set_head(remainder, remainder_size | PREV_INUSE);
    set_inuse_bit_at_offset(remainder, remainder_size);
3480a454:	e3822001 	orr	r2, r2, #1
3480a458:	e5832004 	str	r2, [r3, #4]
    fREe(chunk2mem(remainder)); /* let free() deal with it */
3480a45c:	ebfffc7e 	bl	3480965c <free>
3480a460:	ea000006 	b	3480a480 <realloc+0x438>
  }
  else
  {
    set_head_size(newp, newsize);
3480a464:	e2022001 	and	r2, r2, #1
3480a468:	e18a2002 	orr	r2, sl, r2
3480a46c:	e5842004 	str	r2, [r4, #4]
    set_inuse_bit_at_offset(newp, newsize);
3480a470:	e084a00a 	add	sl, r4, sl
3480a474:	e59a3004 	ldr	r3, [sl, #4]
3480a478:	e3833001 	orr	r3, r3, #1
3480a47c:	e58a3004 	str	r3, [sl, #4]
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
3480a480:	e2847008 	add	r7, r4, #8
3480a484:	ea000000 	b	3480a48c <realloc+0x444>

#ifdef REALLOC_ZERO_BYTES_FREES
  if (bytes == 0) { fREe(oldmem); return 0; }
#endif

  if ((long)bytes < 0) return 0;
3480a488:	e3a07000 	mov	r7, #0
    set_inuse_bit_at_offset(newp, newsize);
  }

  check_inuse_chunk(newp);
  return chunk2mem(newp);
}
3480a48c:	e1a00007 	mov	r0, r7
3480a490:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480a494:	34828590 	.word	0x34828590

3480a498 <malloc_usable_size>:
#else
size_t malloc_usable_size(mem) Void_t* mem;
#endif
{
  mchunkptr p;
  if (mem == 0)
3480a498:	e3500000 	cmp	r0, #0
3480a49c:	012fff1e 	bxeq	lr
    return 0;
  else
  {
    p = mem2chunk(mem);
    if(!chunk_is_mmapped(p))
3480a4a0:	e5103004 	ldr	r3, [r0, #-4]
  mchunkptr p;
  if (mem == 0)
    return 0;
  else
  {
    p = mem2chunk(mem);
3480a4a4:	e2401008 	sub	r1, r0, #8
    if(!chunk_is_mmapped(p))
3480a4a8:	e3130002 	tst	r3, #2
3480a4ac:	1a000006 	bne	3480a4cc <malloc_usable_size+0x34>
    {
      if (!inuse(p)) return 0;
3480a4b0:	e3c32001 	bic	r2, r3, #1
3480a4b4:	e0812002 	add	r2, r1, r2
3480a4b8:	e5920004 	ldr	r0, [r2, #4]
3480a4bc:	e2100001 	ands	r0, r0, #1
      check_inuse_chunk(p);
      return chunksize(p) - SIZE_SZ;
3480a4c0:	13c30003 	bicne	r0, r3, #3
3480a4c4:	12400004 	subne	r0, r0, #4
3480a4c8:	e12fff1e 	bx	lr
    }
    return chunksize(p) - 2*SIZE_SZ;
3480a4cc:	e3c30003 	bic	r0, r3, #3
3480a4d0:	e2400008 	sub	r0, r0, #8
  }
}
3480a4d4:	e12fff1e 	bx	lr

3480a4d8 <mallopt>:
int mALLOPt(int param_number, int value)
#else
int mALLOPt(param_number, value) int param_number; int value;
#endif
{
  switch(param_number)
3480a4d8:	e2800004 	add	r0, r0, #4
3480a4dc:	e3500003 	cmp	r0, #3
3480a4e0:	979ff100 	ldrls	pc, [pc, r0, lsl #2]
3480a4e4:	ea000012 	b	3480a534 <mallopt+0x5c>
3480a4e8:	3480a51c 	.word	0x3480a51c
3480a4ec:	3480a510 	.word	0x3480a510
3480a4f0:	3480a504 	.word	0x3480a504
3480a4f4:	3480a4f8 	.word	0x3480a4f8
  {
    case M_TRIM_THRESHOLD:
      trim_threshold = value; return 1;
3480a4f8:	e59f3044 	ldr	r3, [pc, #68]	; 3480a544 <mallopt+0x6c>
3480a4fc:	e583140c 	str	r1, [r3, #1036]	; 0x40c
3480a500:	ea000009 	b	3480a52c <mallopt+0x54>
    case M_TOP_PAD:
      top_pad = value; return 1;
3480a504:	e59f303c 	ldr	r3, [pc, #60]	; 3480a548 <mallopt+0x70>
3480a508:	e5831034 	str	r1, [r3, #52]	; 0x34
3480a50c:	ea000006 	b	3480a52c <mallopt+0x54>
    case M_MMAP_THRESHOLD:
      mmap_threshold = value; return 1;
3480a510:	e59f302c 	ldr	r3, [pc, #44]	; 3480a544 <mallopt+0x6c>
3480a514:	e5831410 	str	r1, [r3, #1040]	; 0x410
3480a518:	ea000003 	b	3480a52c <mallopt+0x54>
    case M_MMAP_MAX:
#if HAVE_MMAP
      n_mmaps_max = value; return 1;
#else
      if (value != 0) return 0; else  n_mmaps_max = value; return 1;
3480a51c:	e3510000 	cmp	r1, #0
3480a520:	1a000005 	bne	3480a53c <mallopt+0x64>
3480a524:	e59f301c 	ldr	r3, [pc, #28]	; 3480a548 <mallopt+0x70>
3480a528:	e5831040 	str	r1, [r3, #64]	; 0x40
3480a52c:	e3a00001 	mov	r0, #1
3480a530:	e12fff1e 	bx	lr
#endif

    default:
      return 0;
3480a534:	e3a00000 	mov	r0, #0
3480a538:	e12fff1e 	bx	lr
      mmap_threshold = value; return 1;
    case M_MMAP_MAX:
#if HAVE_MMAP
      n_mmaps_max = value; return 1;
#else
      if (value != 0) return 0; else  n_mmaps_max = value; return 1;
3480a53c:	e3a00000 	mov	r0, #0
#endif

    default:
      return 0;
  }
}
3480a540:	e12fff1e 	bx	lr
3480a544:	34828590 	.word	0x34828590
3480a548:	34829d80 	.word	0x34829d80

3480a54c <env_get_char_spec>:
	.apply = env_check_apply,
};

static uchar __env_get_char_spec(int index)
{
	return *((uchar *)(gd->env_addr + index));
3480a54c:	e5983010 	ldr	r3, [r8, #16]
}
3480a550:	e7d00003 	ldrb	r0, [r0, r3]
3480a554:	e12fff1e 	bx	lr

3480a558 <env_get_addr>:
		return env_get_char_init(index);
}

const uchar *env_get_addr(int index)
{
	if (gd->env_valid)
3480a558:	e5982014 	ldr	r2, [r8, #20]
3480a55c:	e1a03008 	mov	r3, r8
3480a560:	e3520000 	cmp	r2, #0
		return (uchar *)(gd->env_addr + index);
3480a564:	15983010 	ldrne	r3, [r8, #16]
	else
		return &default_environment[index];
3480a568:	059f3008 	ldreq	r3, [pc, #8]	; 3480a578 <env_get_addr+0x20>
}

const uchar *env_get_addr(int index)
{
	if (gd->env_valid)
		return (uchar *)(gd->env_addr + index);
3480a56c:	10800003 	addne	r0, r0, r3
	else
		return &default_environment[index];
3480a570:	00830000 	addeq	r0, r3, r0
}
3480a574:	e12fff1e 	bx	lr
3480a578:	348202b8 	.word	0x348202b8

3480a57c <env_get_char_memory>:
	else
		return default_environment[index];
}

uchar env_get_char_memory(int index)
{
3480a57c:	e92d4008 	push	{r3, lr}
	return *env_get_addr(index);
3480a580:	ebfffff4 	bl	3480a558 <env_get_addr>
}
3480a584:	e5d00000 	ldrb	r0, [r0]
3480a588:	e8bd8008 	pop	{r3, pc}

3480a58c <env_get_char>:

uchar env_get_char(int index)
{
	/* if relocated to RAM */
	if (gd->flags & GD_FLG_RELOC)
3480a58c:	e5981004 	ldr	r1, [r8, #4]
3480a590:	e3110001 	tst	r1, #1
3480a594:	0a000000 	beq	3480a59c <env_get_char+0x10>
		return env_get_char_memory(index);
3480a598:	eafffff7 	b	3480a57c <env_get_char_memory>
	__attribute__((weak, alias("__env_get_char_spec")));

static uchar env_get_char_init(int index)
{
	/* if crc was bad, use the default environment */
	if (gd->env_valid)
3480a59c:	e5983014 	ldr	r3, [r8, #20]
3480a5a0:	e3530000 	cmp	r3, #0
3480a5a4:	0a000000 	beq	3480a5ac <env_get_char+0x20>
		return env_get_char_spec(index);
3480a5a8:	eaffffe7 	b	3480a54c <env_get_char_spec>
	else
		return default_environment[index];
3480a5ac:	e59f3008 	ldr	r3, [pc, #8]	; 3480a5bc <env_get_char+0x30>
3480a5b0:	e0832000 	add	r2, r3, r0
	/* if relocated to RAM */
	if (gd->flags & GD_FLG_RELOC)
		return env_get_char_memory(index);
	else
		return env_get_char_init(index);
}
3480a5b4:	e5d206f9 	ldrb	r0, [r2, #1785]	; 0x6f9
3480a5b8:	e12fff1e 	bx	lr
3480a5bc:	348202b8 	.word	0x348202b8

3480a5c0 <set_default_env>:
	else
		return &default_environment[index];
}

void set_default_env(const char *s)
{
3480a5c0:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	if (sizeof(default_environment) > ENV_SIZE) {
		puts("*** Error - default environment is too large\n\n");
		return;
	}

	if (s) {
3480a5c4:	e2504000 	subs	r4, r0, #0
3480a5c8:	0a00000a 	beq	3480a5f8 <set_default_env+0x38>
		if (*s == '!') {
3480a5cc:	e5d43000 	ldrb	r3, [r4]
3480a5d0:	e3530021 	cmp	r3, #33	; 0x21
3480a5d4:	1a000004 	bne	3480a5ec <set_default_env+0x2c>
			printf("*** Warning - %s, "
3480a5d8:	e2841001 	add	r1, r4, #1
3480a5dc:	e59f0078 	ldr	r0, [pc, #120]	; 3480a65c <set_default_env+0x9c>
3480a5e0:	ebfffadf 	bl	34809164 <printf>
{
	/*
	 * By default, do not apply changes as they will eventually
	 * be applied by someone else
	 */
	int do_apply = 0;
3480a5e4:	e3a04000 	mov	r4, #0
3480a5e8:	ea000004 	b	3480a600 <set_default_env+0x40>
			 * mechanism.  Therefore we check every single
			 * variable and apply changes to the system
			 * right away (e.g. baudrate, console).
			 */
			do_apply = 1;
			puts(s);
3480a5ec:	ebfffad2 	bl	3480913c <puts>
			 * by the user, as opposed to being a recovery
			 * mechanism.  Therefore we check every single
			 * variable and apply changes to the system
			 * right away (e.g. baudrate, console).
			 */
			do_apply = 1;
3480a5f0:	e3a04001 	mov	r4, #1
3480a5f4:	ea000001 	b	3480a600 <set_default_env+0x40>
			puts(s);
		}
	} else {
		puts("Using default environment\n\n");
3480a5f8:	e59f0060 	ldr	r0, [pc, #96]	; 3480a660 <set_default_env+0xa0>
3480a5fc:	ebffface 	bl	3480913c <puts>
	}

	if (himport_r(&env_htab, (char *)default_environment,
3480a600:	e3a03000 	mov	r3, #0
3480a604:	e59f0058 	ldr	r0, [pc, #88]	; 3480a664 <set_default_env+0xa4>
3480a608:	e59f1058 	ldr	r1, [pc, #88]	; 3480a668 <set_default_env+0xa8>
3480a60c:	e30026f9 	movw	r2, #1785	; 0x6f9
3480a610:	e58d3000 	str	r3, [sp]
3480a614:	e58d3004 	str	r3, [sp, #4]
3480a618:	e58d3008 	str	r3, [sp, #8]
3480a61c:	e58d400c 	str	r4, [sp, #12]
3480a620:	eb00428c 	bl	3481b058 <himport_r>
3480a624:	e3500000 	cmp	r0, #0
3480a628:	1a000007 	bne	3480a64c <set_default_env+0x8c>
			sizeof(default_environment), '\0', 0,
			0, NULL, do_apply) == 0)
		error("Environment import failed: errno = %d\n", errno);
3480a62c:	e59f3038 	ldr	r3, [pc, #56]	; 3480a66c <set_default_env+0xac>
3480a630:	e59f0038 	ldr	r0, [pc, #56]	; 3480a670 <set_default_env+0xb0>
3480a634:	e58d3000 	str	r3, [sp]
3480a638:	e59f3034 	ldr	r3, [pc, #52]	; 3480a674 <set_default_env+0xb4>
3480a63c:	e59f2034 	ldr	r2, [pc, #52]	; 3480a678 <set_default_env+0xb8>
3480a640:	e5931000 	ldr	r1, [r3]
3480a644:	e3a030d8 	mov	r3, #216	; 0xd8
3480a648:	ebfffac5 	bl	34809164 <printf>

	gd->flags |= GD_FLG_ENV_READY;
3480a64c:	e5982004 	ldr	r2, [r8, #4]
3480a650:	e3822080 	orr	r2, r2, #128	; 0x80
3480a654:	e5882004 	str	r2, [r8, #4]
}
3480a658:	e8bd801f 	pop	{r0, r1, r2, r3, r4, pc}
3480a65c:	34826061 	.word	0x34826061
3480a660:	3482608f 	.word	0x3482608f
3480a664:	348289a4 	.word	0x348289a4
3480a668:	348202b8 	.word	0x348202b8
3480a66c:	348210ac 	.word	0x348210ac
3480a670:	3482510e 	.word	0x3482510e
3480a674:	3482bc40 	.word	0x3482bc40
3480a678:	348260ab 	.word	0x348260ab

3480a67c <set_default_vars>:


/* [re]set individual variables to their value in the default environment */
int set_default_vars(int nvars, char * const vars[])
{
3480a67c:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	/*
	 * Special use-case: import from default environment
	 * (and use \0 as a separator)
	 */
	return himport_r(&env_htab, (const char *)default_environment,
3480a680:	e3a03001 	mov	r3, #1
3480a684:	e58d3000 	str	r3, [sp]
3480a688:	e98d000b 	stmib	sp, {r0, r1, r3}
3480a68c:	e59f1014 	ldr	r1, [pc, #20]	; 3480a6a8 <set_default_vars+0x2c>
3480a690:	e30026f9 	movw	r2, #1785	; 0x6f9
3480a694:	e3a03000 	mov	r3, #0
3480a698:	e59f000c 	ldr	r0, [pc, #12]	; 3480a6ac <set_default_vars+0x30>
3480a69c:	eb00426d 	bl	3481b058 <himport_r>
				sizeof(default_environment), '\0', H_NOCLEAR,
				nvars, vars, 1 /* do_apply */);
}
3480a6a0:	e28dd014 	add	sp, sp, #20
3480a6a4:	e8bd8000 	pop	{pc}
3480a6a8:	348202b8 	.word	0x348202b8
3480a6ac:	348289a4 	.word	0x348289a4

3480a6b0 <env_import>:
/*
 * Check if CRC is valid and (if yes) import the environment.
 * Note that "buf" may or may not be aligned.
 */
int env_import(const char *buf, int check)
{
3480a6b0:	e92d4010 	push	{r4, lr}
	env_t *ep = (env_t *)buf;

	if (check) {
3480a6b4:	e3510000 	cmp	r1, #0
/*
 * Check if CRC is valid and (if yes) import the environment.
 * Note that "buf" may or may not be aligned.
 */
int env_import(const char *buf, int check)
{
3480a6b8:	e24dd018 	sub	sp, sp, #24
3480a6bc:	e1a04000 	mov	r4, r0
	env_t *ep = (env_t *)buf;

	if (check) {
3480a6c0:	0a00000e 	beq	3480a700 <env_import+0x50>
		uint32_t crc;

		memcpy(&crc, &ep->crc, sizeof(crc));
3480a6c4:	e1a01004 	mov	r1, r4
3480a6c8:	e3a02004 	mov	r2, #4
3480a6cc:	e28d0014 	add	r0, sp, #20
3480a6d0:	eb00461f 	bl	3481bf54 <memcpy>

		if (crc32(0, ep->data, ENV_SIZE) != crc) {
3480a6d4:	e3a00000 	mov	r0, #0
3480a6d8:	e2841004 	add	r1, r4, #4
3480a6dc:	e59f208c 	ldr	r2, [pc, #140]	; 3480a770 <env_import+0xc0>
3480a6e0:	eb003e99 	bl	3481a14c <crc32>
3480a6e4:	e59d3014 	ldr	r3, [sp, #20]
3480a6e8:	e1500003 	cmp	r0, r3
3480a6ec:	0a000003 	beq	3480a700 <env_import+0x50>
			set_default_env("!bad CRC");
3480a6f0:	e59f007c 	ldr	r0, [pc, #124]	; 3480a774 <env_import+0xc4>
3480a6f4:	ebffffb1 	bl	3480a5c0 <set_default_env>
			return 0;
3480a6f8:	e3a00000 	mov	r0, #0
3480a6fc:	ea000019 	b	3480a768 <env_import+0xb8>
		}
	}

	if (himport_r(&env_htab, (char *)ep->data, ENV_SIZE, '\0', 0,
3480a700:	e3a03000 	mov	r3, #0
3480a704:	e2841004 	add	r1, r4, #4
3480a708:	e59f0068 	ldr	r0, [pc, #104]	; 3480a778 <env_import+0xc8>
3480a70c:	e59f205c 	ldr	r2, [pc, #92]	; 3480a770 <env_import+0xc0>
3480a710:	e58d3000 	str	r3, [sp]
3480a714:	e58d3004 	str	r3, [sp, #4]
3480a718:	e58d3008 	str	r3, [sp, #8]
3480a71c:	e58d300c 	str	r3, [sp, #12]
3480a720:	eb00424c 	bl	3481b058 <himport_r>
3480a724:	e2504000 	subs	r4, r0, #0
			0, NULL, 0 /* do_apply */)) {
		gd->flags |= GD_FLG_ENV_READY;
3480a728:	15982004 	ldrne	r2, [r8, #4]
		return 1;
3480a72c:	13a00001 	movne	r0, #1
		}
	}

	if (himport_r(&env_htab, (char *)ep->data, ENV_SIZE, '\0', 0,
			0, NULL, 0 /* do_apply */)) {
		gd->flags |= GD_FLG_ENV_READY;
3480a730:	13822080 	orrne	r2, r2, #128	; 0x80
3480a734:	15882004 	strne	r2, [r8, #4]
		return 1;
3480a738:	1a00000a 	bne	3480a768 <env_import+0xb8>
	}

	error("Cannot import environment: errno = %d\n", errno);
3480a73c:	e59f3038 	ldr	r3, [pc, #56]	; 3480a77c <env_import+0xcc>
3480a740:	e59f2038 	ldr	r2, [pc, #56]	; 3480a780 <env_import+0xd0>
3480a744:	e58d3000 	str	r3, [sp]
3480a748:	e59f3034 	ldr	r3, [pc, #52]	; 3480a784 <env_import+0xd4>
3480a74c:	e59f0034 	ldr	r0, [pc, #52]	; 3480a788 <env_import+0xd8>
3480a750:	e5931000 	ldr	r1, [r3]
3480a754:	e3a03f41 	mov	r3, #260	; 0x104
3480a758:	ebfffa81 	bl	34809164 <printf>

	set_default_env("!import failed");
3480a75c:	e59f0028 	ldr	r0, [pc, #40]	; 3480a78c <env_import+0xdc>
3480a760:	ebffff96 	bl	3480a5c0 <set_default_env>

	return 0;
3480a764:	e1a00004 	mov	r0, r4
}
3480a768:	e28dd018 	add	sp, sp, #24
3480a76c:	e8bd8010 	pop	{r4, pc}
3480a770:	0003fffc 	.word	0x0003fffc
3480a774:	348260b8 	.word	0x348260b8
3480a778:	348289a4 	.word	0x348289a4
3480a77c:	348210bc 	.word	0x348210bc
3480a780:	348260ab 	.word	0x348260ab
3480a784:	3482bc40 	.word	0x3482bc40
3480a788:	348260c1 	.word	0x348260c1
3480a78c:	348260fe 	.word	0x348260fe

3480a790 <env_relocate>:
void env_relocate(void)
{
#if defined(CONFIG_NEEDS_MANUAL_RELOC)
	env_reloc();
#endif
	if (gd->env_valid == 0) {
3480a790:	e5983014 	ldr	r3, [r8, #20]
	return 0;
}
#endif

void env_relocate(void)
{
3480a794:	e92d4010 	push	{r4, lr}
#if defined(CONFIG_NEEDS_MANUAL_RELOC)
	env_reloc();
#endif
	if (gd->env_valid == 0) {
3480a798:	e3530000 	cmp	r3, #0
3480a79c:	1a000004 	bne	3480a7b4 <env_relocate+0x24>
3480a7a0:	e3e0003b 	mvn	r0, #59	; 0x3b
3480a7a4:	eb000b69 	bl	3480d550 <__show_boot_progress>
#if defined(CONFIG_ENV_IS_NOWHERE) || defined(CONFIG_SPL_BUILD)
		/* Environment not changable */
		set_default_env(NULL);
#else
		bootstage_error(BOOTSTAGE_ID_NET_CHECKSUM);
		set_default_env("!bad CRC");
3480a7a8:	e59f000c 	ldr	r0, [pc, #12]	; 3480a7bc <env_relocate+0x2c>
#endif
	} else {
		env_relocate_spec();
	}
}
3480a7ac:	e8bd4010 	pop	{r4, lr}
#if defined(CONFIG_ENV_IS_NOWHERE) || defined(CONFIG_SPL_BUILD)
		/* Environment not changable */
		set_default_env(NULL);
#else
		bootstage_error(BOOTSTAGE_ID_NET_CHECKSUM);
		set_default_env("!bad CRC");
3480a7b0:	eaffff82 	b	3480a5c0 <set_default_env>
#endif
	} else {
		env_relocate_spec();
	}
}
3480a7b4:	e8bd4010 	pop	{r4, lr}
#else
		bootstage_error(BOOTSTAGE_ID_NET_CHECKSUM);
		set_default_env("!bad CRC");
#endif
	} else {
		env_relocate_spec();
3480a7b8:	ea000000 	b	3480a7c0 <env_relocate_spec>
3480a7bc:	348260b8 	.word	0x348260b8

3480a7c0 <env_relocate_spec>:
#define ONENAND_ENV_SIZE(mtd)	(ONENAND_MAX_ENV_SIZE - ENV_HEADER_SIZE)

DECLARE_GLOBAL_DATA_PTR;

void env_relocate_spec(void)
{
3480a7c0:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
# ifdef CONFIG_ENV_ADDR_FLEX
	if (FLEXONENAND(this))
		env_addr = CONFIG_ENV_ADDR_FLEX;
# endif
	/* Check OneNAND exist */
	if (mtd->writesize)
3480a7c4:	e59f006c 	ldr	r0, [pc, #108]	; 3480a838 <env_relocate_spec+0x78>
#define ONENAND_ENV_SIZE(mtd)	(ONENAND_MAX_ENV_SIZE - ENV_HEADER_SIZE)

DECLARE_GLOBAL_DATA_PTR;

void env_relocate_spec(void)
{
3480a7c8:	e24dd701 	sub	sp, sp, #262144	; 0x40000
# ifdef CONFIG_ENV_ADDR_FLEX
	if (FLEXONENAND(this))
		env_addr = CONFIG_ENV_ADDR_FLEX;
# endif
	/* Check OneNAND exist */
	if (mtd->writesize)
3480a7cc:	e5903014 	ldr	r3, [r0, #20]
#define ONENAND_ENV_SIZE(mtd)	(ONENAND_MAX_ENV_SIZE - ENV_HEADER_SIZE)

DECLARE_GLOBAL_DATA_PTR;

void env_relocate_spec(void)
{
3480a7d0:	e24dd01c 	sub	sp, sp, #28
# ifdef CONFIG_ENV_ADDR_FLEX
	if (FLEXONENAND(this))
		env_addr = CONFIG_ENV_ADDR_FLEX;
# endif
	/* Check OneNAND exist */
	if (mtd->writesize)
3480a7d4:	e3530000 	cmp	r3, #0
		/* Ignore read fail */
		mtd->read(mtd, env_addr, ONENAND_MAX_ENV_SIZE,
				&retlen, (u_char *)buf);
	else
		mtd->writesize = MAX_ONENAND_PAGESIZE;
3480a7d8:	03a03d42 	moveq	r3, #4224	; 0x1080
3480a7dc:	05803014 	streq	r3, [r0, #20]
# ifdef CONFIG_ENV_ADDR_FLEX
	if (FLEXONENAND(this))
		env_addr = CONFIG_ENV_ADDR_FLEX;
# endif
	/* Check OneNAND exist */
	if (mtd->writesize)
3480a7e0:	0a00000a 	beq	3480a810 <env_relocate_spec+0x50>
		/* Ignore read fail */
		mtd->read(mtd, env_addr, ONENAND_MAX_ENV_SIZE,
3480a7e4:	e3a03701 	mov	r3, #262144	; 0x40000
3480a7e8:	e58d3000 	str	r3, [sp]
3480a7ec:	e28d3701 	add	r3, sp, #262144	; 0x40000
3480a7f0:	e2833014 	add	r3, r3, #20
3480a7f4:	e58d3004 	str	r3, [sp, #4]
#ifdef ENV_IS_EMBEDDED
	char *buf = (char *)&environment;
#else
	loff_t env_addr = CONFIG_ENV_ADDR;
	char onenand_env[ONENAND_MAX_ENV_SIZE];
	char *buf = (char *)&onenand_env[0];
3480a7f8:	e28d3014 	add	r3, sp, #20
		env_addr = CONFIG_ENV_ADDR_FLEX;
# endif
	/* Check OneNAND exist */
	if (mtd->writesize)
		/* Ignore read fail */
		mtd->read(mtd, env_addr, ONENAND_MAX_ENV_SIZE,
3480a7fc:	e58d3008 	str	r3, [sp, #8]
3480a800:	e5901040 	ldr	r1, [r0, #64]	; 0x40
3480a804:	e3a02601 	mov	r2, #1048576	; 0x100000
3480a808:	e3a03000 	mov	r3, #0
3480a80c:	e12fff31 	blx	r1
				&retlen, (u_char *)buf);
	else
		mtd->writesize = MAX_ONENAND_PAGESIZE;
#endif /* !ENV_IS_EMBEDDED */

	rc = env_import(buf, 1);
3480a810:	e28d0014 	add	r0, sp, #20
3480a814:	e3a01001 	mov	r1, #1
3480a818:	ebffffa4 	bl	3480a6b0 <env_import>
	if (rc)
3480a81c:	e3500000 	cmp	r0, #0
		gd->env_valid = 1;
3480a820:	11a03008 	movne	r3, r8
3480a824:	13a02001 	movne	r2, #1
3480a828:	15832014 	strne	r2, [r3, #20]
}
3480a82c:	e28dd01c 	add	sp, sp, #28
3480a830:	e28dd701 	add	sp, sp, #262144	; 0x40000
3480a834:	e8bd8000 	pop	{pc}
3480a838:	3482bac0 	.word	0x3482bac0

3480a83c <saveenv>:

int saveenv(void)
{
3480a83c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3480a840:	e24dd701 	sub	sp, sp, #262144	; 0x40000
3480a844:	e24dd060 	sub	sp, sp, #96	; 0x60
#ifdef CONFIG_ENV_ADDR_FLEX
	struct onenand_chip *this = &onenand_chip;
#endif
	loff_t	env_addr = CONFIG_ENV_ADDR;
	size_t	retlen;
	struct erase_info instr = {
3480a848:	e28d6701 	add	r6, sp, #262144	; 0x40000
3480a84c:	e2866010 	add	r6, r6, #16
3480a850:	e3a01000 	mov	r1, #0
3480a854:	e3a02048 	mov	r2, #72	; 0x48
3480a858:	e1a00006 	mov	r0, r6
3480a85c:	eb004598 	bl	3481bec4 <memset>
		.callback	= NULL,
	};

	res = (char *)&env_new.data;
3480a860:	e28d7010 	add	r7, sp, #16
3480a864:	e28d2701 	add	r2, sp, #262144	; 0x40000
	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, 0, NULL);
3480a868:	e3a04000 	mov	r4, #0
	size_t	retlen;
	struct erase_info instr = {
		.callback	= NULL,
	};

	res = (char *)&env_new.data;
3480a86c:	e2822060 	add	r2, r2, #96	; 0x60
3480a870:	e2875004 	add	r5, r7, #4
3480a874:	e5225004 	str	r5, [r2, #-4]!
	len = hexport_r(&env_htab, '\0', &res, ENV_SIZE, 0, NULL);
3480a878:	e59f010c 	ldr	r0, [pc, #268]	; 3480a98c <saveenv+0x150>
3480a87c:	e1a01004 	mov	r1, r4
3480a880:	e59f3108 	ldr	r3, [pc, #264]	; 3480a990 <saveenv+0x154>
3480a884:	e58d4000 	str	r4, [sp]
3480a888:	e58d4004 	str	r4, [sp, #4]
3480a88c:	eb004146 	bl	3481adac <hexport_r>
	if (len < 0) {
3480a890:	e1500004 	cmp	r0, r4
3480a894:	aa000008 	bge	3480a8bc <saveenv+0x80>
		error("Cannot export environment: errno = %d\n", errno);
3480a898:	e59f30f4 	ldr	r3, [pc, #244]	; 3480a994 <saveenv+0x158>
3480a89c:	e59f20f4 	ldr	r2, [pc, #244]	; 3480a998 <saveenv+0x15c>
3480a8a0:	e58d3000 	str	r3, [sp]
3480a8a4:	e59f30f0 	ldr	r3, [pc, #240]	; 3480a99c <saveenv+0x160>
3480a8a8:	e59f00f0 	ldr	r0, [pc, #240]	; 3480a9a0 <saveenv+0x164>
3480a8ac:	e5931000 	ldr	r1, [r3]
3480a8b0:	e3a03064 	mov	r3, #100	; 0x64
3480a8b4:	ebfffa2a 	bl	34809164 <printf>
3480a8b8:	ea00001c 	b	3480a930 <saveenv+0xf4>
		return 1;
	}
	env_new.crc = crc32(0, env_new.data, ENV_SIZE);
3480a8bc:	e1a01005 	mov	r1, r5
3480a8c0:	e1a00004 	mov	r0, r4
3480a8c4:	e59f20c4 	ldr	r2, [pc, #196]	; 3480a990 <saveenv+0x154>
3480a8c8:	eb003e1f 	bl	3481a14c <crc32>
3480a8cc:	e59f30d0 	ldr	r3, [pc, #208]	; 3480a9a4 <saveenv+0x168>
3480a8d0:	e28d1701 	add	r1, sp, #262144	; 0x40000
3480a8d4:	e2811060 	add	r1, r1, #96	; 0x60
3480a8d8:	e7810003 	str	r0, [r1, r3]

	instr.len = CONFIG_ENV_SIZE;
3480a8dc:	e28d1701 	add	r1, sp, #262144	; 0x40000
3480a8e0:	e2811020 	add	r1, r1, #32
		instr.len <<= onenand_mtd.eraseregions[0].numblocks == 1 ?
				1 : 0;
	}
#endif
	instr.addr = env_addr;
	instr.mtd = mtd;
3480a8e4:	e59fa0bc 	ldr	sl, [pc, #188]	; 3480a9a8 <saveenv+0x16c>
		error("Cannot export environment: errno = %d\n", errno);
		return 1;
	}
	env_new.crc = crc32(0, env_new.data, ENV_SIZE);

	instr.len = CONFIG_ENV_SIZE;
3480a8e8:	e3a02701 	mov	r2, #262144	; 0x40000
3480a8ec:	e3a03000 	mov	r3, #0
3480a8f0:	e1c120f0 	strd	r2, [r1]
		instr.len = CONFIG_ENV_SIZE_FLEX;
		instr.len <<= onenand_mtd.eraseregions[0].numblocks == 1 ?
				1 : 0;
	}
#endif
	instr.addr = env_addr;
3480a8f4:	e3a04601 	mov	r4, #1048576	; 0x100000
	instr.mtd = mtd;
3480a8f8:	e28d2701 	add	r2, sp, #262144	; 0x40000
		instr.len = CONFIG_ENV_SIZE_FLEX;
		instr.len <<= onenand_mtd.eraseregions[0].numblocks == 1 ?
				1 : 0;
	}
#endif
	instr.addr = env_addr;
3480a8fc:	e3a05000 	mov	r5, #0
3480a900:	e14140f8 	strd	r4, [r1, #-8]
	instr.mtd = mtd;
3480a904:	e582a010 	str	sl, [r2, #16]
	if (mtd->erase(mtd, &instr)) {
3480a908:	e59a3034 	ldr	r3, [sl, #52]	; 0x34
3480a90c:	e1a0000a 	mov	r0, sl
3480a910:	e1a01006 	mov	r1, r6
3480a914:	e12fff33 	blx	r3
3480a918:	e3500000 	cmp	r0, #0
3480a91c:	0a000005 	beq	3480a938 <saveenv+0xfc>
		printf("OneNAND: erase failed at 0x%08llx\n", env_addr);
3480a920:	e59f0084 	ldr	r0, [pc, #132]	; 3480a9ac <saveenv+0x170>
3480a924:	e1a02004 	mov	r2, r4
3480a928:	e1a03005 	mov	r3, r5
3480a92c:	ebfffa0c 	bl	34809164 <printf>
		return 1;
3480a930:	e3a00001 	mov	r0, #1
3480a934:	ea000011 	b	3480a980 <saveenv+0x144>
	}

	if (mtd->write(mtd, env_addr, ONENAND_MAX_ENV_SIZE, &retlen,
3480a938:	e3a03701 	mov	r3, #262144	; 0x40000
3480a93c:	e58d3000 	str	r3, [sp]
3480a940:	e28d3701 	add	r3, sp, #262144	; 0x40000
3480a944:	e2833058 	add	r3, r3, #88	; 0x58
3480a948:	e98d0088 	stmib	sp, {r3, r7}
3480a94c:	e59a1044 	ldr	r1, [sl, #68]	; 0x44
3480a950:	e1a0000a 	mov	r0, sl
3480a954:	e1a02004 	mov	r2, r4
3480a958:	e1a03005 	mov	r3, r5
3480a95c:	e12fff31 	blx	r1
3480a960:	e3500000 	cmp	r0, #0
3480a964:	0a000005 	beq	3480a980 <saveenv+0x144>
			(u_char *)&env_new)) {
		printf("OneNAND: write failed at 0x%llx\n", instr.addr);
3480a968:	e28d1701 	add	r1, sp, #262144	; 0x40000
3480a96c:	e2811020 	add	r1, r1, #32
3480a970:	e59f0038 	ldr	r0, [pc, #56]	; 3480a9b0 <saveenv+0x174>
3480a974:	e14120d8 	ldrd	r2, [r1, #-8]
3480a978:	ebfff9f9 	bl	34809164 <printf>
		return 2;
3480a97c:	e3a00002 	mov	r0, #2
	}

	return 0;
}
3480a980:	e28dd060 	add	sp, sp, #96	; 0x60
3480a984:	e28dd701 	add	sp, sp, #262144	; 0x40000
3480a988:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3480a98c:	348289a4 	.word	0x348289a4
3480a990:	0003fffc 	.word	0x0003fffc
3480a994:	348210c8 	.word	0x348210c8
3480a998:	3482610d 	.word	0x3482610d
3480a99c:	3482bc40 	.word	0x3482bc40
3480a9a0:	3482530a 	.word	0x3482530a
3480a9a4:	fffbffb0 	.word	0xfffbffb0
3480a9a8:	3482bac0 	.word	0x3482bac0
3480a9ac:	3482611b 	.word	0x3482611b
3480a9b0:	3482613e 	.word	0x3482613e

3480a9b4 <env_init>:

int env_init(void)
{
	/* use default */
	gd->env_addr = (ulong)&default_environment[0];
3480a9b4:	e59f2010 	ldr	r2, [pc, #16]	; 3480a9cc <env_init+0x18>
	gd->env_valid = 1;

	return 0;
}
3480a9b8:	e3a00000 	mov	r0, #0
}

int env_init(void)
{
	/* use default */
	gd->env_addr = (ulong)&default_environment[0];
3480a9bc:	e5882010 	str	r2, [r8, #16]
	gd->env_valid = 1;
3480a9c0:	e3a02001 	mov	r2, #1
3480a9c4:	e5882014 	str	r2, [r8, #20]

	return 0;
}
3480a9c8:	e12fff1e 	bx	lr
3480a9cc:	348202b8 	.word	0x348202b8

3480a9d0 <dummy>:

DECLARE_GLOBAL_DATA_PTR;

__attribute__((unused)) static void dummy(void)
{
}
3480a9d0:	e12fff1e 	bx	lr

3480a9d4 <get_version>:

unsigned long get_version(void)
{
	return XF_VERSION;
}
3480a9d4:	e3a00006 	mov	r0, #6
3480a9d8:	e12fff1e 	bx	lr

3480a9dc <jumptable_init>:
# define spi_release_bus   dummy
# define spi_xfer          dummy
#endif

void jumptable_init(void)
{
3480a9dc:	e92d4010 	push	{r4, lr}
	gd->jt = malloc(XF_MAX * sizeof(void *));
3480a9e0:	e3a00070 	mov	r0, #112	; 0x70
3480a9e4:	e1a04008 	mov	r4, r8
3480a9e8:	ebfffba4 	bl	34809880 <malloc>
3480a9ec:	e5840054 	str	r0, [r4, #84]	; 0x54
/*
 * You do not need to use #ifdef around functions that may not exist
 * in the final configuration (such as i2c).
 */
EXPORT_FUNC(get_version)
3480a9f0:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480a9f4:	e59f1124 	ldr	r1, [pc, #292]	; 3480ab20 <jumptable_init+0x144>
EXPORT_FUNC(putc)
EXPORT_FUNC(puts)
EXPORT_FUNC(printf)
EXPORT_FUNC(install_hdlr)
EXPORT_FUNC(free_hdlr)
EXPORT_FUNC(malloc)
3480a9f8:	e59f0124 	ldr	r0, [pc, #292]	; 3480ab24 <jumptable_init+0x148>
/*
 * You do not need to use #ifdef around functions that may not exist
 * in the final configuration (such as i2c).
 */
EXPORT_FUNC(get_version)
3480a9fc:	e5821000 	str	r1, [r2]
EXPORT_FUNC(getc)
3480aa00:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480aa04:	e59f111c 	ldr	r1, [pc, #284]	; 3480ab28 <jumptable_init+0x14c>
3480aa08:	e5821004 	str	r1, [r2, #4]
EXPORT_FUNC(tstc)
3480aa0c:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480aa10:	e59f1114 	ldr	r1, [pc, #276]	; 3480ab2c <jumptable_init+0x150>
3480aa14:	e5821008 	str	r1, [r2, #8]
EXPORT_FUNC(putc)
3480aa18:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480aa1c:	e59f110c 	ldr	r1, [pc, #268]	; 3480ab30 <jumptable_init+0x154>
3480aa20:	e582100c 	str	r1, [r2, #12]
EXPORT_FUNC(puts)
3480aa24:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480aa28:	e59f1104 	ldr	r1, [pc, #260]	; 3480ab34 <jumptable_init+0x158>
3480aa2c:	e5821010 	str	r1, [r2, #16]
EXPORT_FUNC(printf)
3480aa30:	e5982054 	ldr	r2, [r8, #84]	; 0x54
3480aa34:	e59f10fc 	ldr	r1, [pc, #252]	; 3480ab38 <jumptable_init+0x15c>
3480aa38:	e5821014 	str	r1, [r2, #20]
EXPORT_FUNC(install_hdlr)
3480aa3c:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aa40:	e59f20f4 	ldr	r2, [pc, #244]	; 3480ab3c <jumptable_init+0x160>
3480aa44:	e5812018 	str	r2, [r1, #24]
EXPORT_FUNC(free_hdlr)
3480aa48:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aa4c:	e581201c 	str	r2, [r1, #28]
EXPORT_FUNC(malloc)
3480aa50:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aa54:	e5810020 	str	r0, [r1, #32]
EXPORT_FUNC(free)
3480aa58:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aa5c:	e59f00dc 	ldr	r0, [pc, #220]	; 3480ab40 <jumptable_init+0x164>
3480aa60:	e5810024 	str	r0, [r1, #36]	; 0x24
EXPORT_FUNC(udelay)
3480aa64:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aa68:	e59f00d4 	ldr	r0, [pc, #212]	; 3480ab44 <jumptable_init+0x168>
3480aa6c:	e5810028 	str	r0, [r1, #40]	; 0x28
EXPORT_FUNC(get_timer)
3480aa70:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aa74:	e59f00cc 	ldr	r0, [pc, #204]	; 3480ab48 <jumptable_init+0x16c>
3480aa78:	e581002c 	str	r0, [r1, #44]	; 0x2c
EXPORT_FUNC(vprintf)
3480aa7c:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aa80:	e59f00c4 	ldr	r0, [pc, #196]	; 3480ab4c <jumptable_init+0x170>
3480aa84:	e5810030 	str	r0, [r1, #48]	; 0x30
EXPORT_FUNC(do_reset)
3480aa88:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aa8c:	e59f00bc 	ldr	r0, [pc, #188]	; 3480ab50 <jumptable_init+0x174>
3480aa90:	e5810034 	str	r0, [r1, #52]	; 0x34
EXPORT_FUNC(getenv)
3480aa94:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aa98:	e59f00b4 	ldr	r0, [pc, #180]	; 3480ab54 <jumptable_init+0x178>
3480aa9c:	e5810038 	str	r0, [r1, #56]	; 0x38
EXPORT_FUNC(setenv)
3480aaa0:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aaa4:	e59f00ac 	ldr	r0, [pc, #172]	; 3480ab58 <jumptable_init+0x17c>
3480aaa8:	e581003c 	str	r0, [r1, #60]	; 0x3c
EXPORT_FUNC(simple_strtoul)
3480aaac:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aab0:	e59f00a4 	ldr	r0, [pc, #164]	; 3480ab5c <jumptable_init+0x180>
3480aab4:	e5810040 	str	r0, [r1, #64]	; 0x40
EXPORT_FUNC(strict_strtoul)
3480aab8:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aabc:	e59f009c 	ldr	r0, [pc, #156]	; 3480ab60 <jumptable_init+0x184>
3480aac0:	e5810044 	str	r0, [r1, #68]	; 0x44
EXPORT_FUNC(simple_strtol)
3480aac4:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aac8:	e59f0094 	ldr	r0, [pc, #148]	; 3480ab64 <jumptable_init+0x188>
3480aacc:	e5810048 	str	r0, [r1, #72]	; 0x48
EXPORT_FUNC(strcmp)
3480aad0:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aad4:	e59f008c 	ldr	r0, [pc, #140]	; 3480ab68 <jumptable_init+0x18c>
3480aad8:	e581004c 	str	r0, [r1, #76]	; 0x4c
EXPORT_FUNC(i2c_write)
3480aadc:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aae0:	e5812050 	str	r2, [r1, #80]	; 0x50
EXPORT_FUNC(i2c_read)
3480aae4:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aae8:	e5812054 	str	r2, [r1, #84]	; 0x54
EXPORT_FUNC(spi_init)
3480aaec:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aaf0:	e5812058 	str	r2, [r1, #88]	; 0x58
EXPORT_FUNC(spi_setup_slave)
3480aaf4:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480aaf8:	e581205c 	str	r2, [r1, #92]	; 0x5c
EXPORT_FUNC(spi_free_slave)
3480aafc:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480ab00:	e5812060 	str	r2, [r1, #96]	; 0x60
EXPORT_FUNC(spi_claim_bus)
3480ab04:	e5981054 	ldr	r1, [r8, #84]	; 0x54
3480ab08:	e5812064 	str	r2, [r1, #100]	; 0x64
EXPORT_FUNC(spi_release_bus)
3480ab0c:	e5981054 	ldr	r1, [r8, #84]	; 0x54
EXPORT_FUNC(spi_xfer)
3480ab10:	e5983054 	ldr	r3, [r8, #84]	; 0x54
EXPORT_FUNC(i2c_read)
EXPORT_FUNC(spi_init)
EXPORT_FUNC(spi_setup_slave)
EXPORT_FUNC(spi_free_slave)
EXPORT_FUNC(spi_claim_bus)
EXPORT_FUNC(spi_release_bus)
3480ab14:	e5812068 	str	r2, [r1, #104]	; 0x68
EXPORT_FUNC(spi_xfer)
3480ab18:	e583206c 	str	r2, [r3, #108]	; 0x6c
#include <_exports.h>
}
3480ab1c:	e8bd8010 	pop	{r4, pc}
3480ab20:	3480a9d4 	.word	0x3480a9d4
3480ab24:	34809880 	.word	0x34809880
3480ab28:	348090cc 	.word	0x348090cc
3480ab2c:	348090f0 	.word	0x348090f0
3480ab30:	34809114 	.word	0x34809114
3480ab34:	3480913c 	.word	0x3480913c
3480ab38:	34809164 	.word	0x34809164
3480ab3c:	3480a9d0 	.word	0x3480a9d0
3480ab40:	3480965c 	.word	0x3480965c
3480ab44:	3481c180 	.word	0x3481c180
3480ab48:	34800924 	.word	0x34800924
3480ab4c:	348091b4 	.word	0x348091b4
3480ab50:	348017bc 	.word	0x348017bc
3480ab54:	348075ac 	.word	0x348075ac
3480ab58:	3480718c 	.word	0x3480718c
3480ab5c:	3481ca90 	.word	0x3481ca90
3480ab60:	3481cb3c 	.word	0x3481cb3c
3480ab64:	3481cbb4 	.word	0x3481cbb4
3480ab68:	3481bb74 	.word	0x3481bb74

3480ab6c <static_get>:
}
#endif

static int static_get(struct in_str *i)
{
	int ch = *i->p++;
3480ab6c:	e5903000 	ldr	r3, [r0]
3480ab70:	e4d32001 	ldrb	r2, [r3], #1
	if (ch=='\0') return EOF;
3480ab74:	e3520000 	cmp	r2, #0
}
#endif

static int static_get(struct in_str *i)
{
	int ch = *i->p++;
3480ab78:	e5803000 	str	r3, [r0]
	if (ch=='\0') return EOF;
	return ch;
}
3480ab7c:	11a00002 	movne	r0, r2
3480ab80:	03e00000 	mvneq	r0, #0
3480ab84:	e12fff1e 	bx	lr

3480ab88 <static_peek>:

static int static_peek(struct in_str *i)
{
	return *i->p;
3480ab88:	e5903000 	ldr	r3, [r0]
}
3480ab8c:	e5d30000 	ldrb	r0, [r3]
3480ab90:	e12fff1e 	bx	lr

3480ab94 <file_peek>:
static int file_peek(struct in_str *i)
{
#ifndef __U_BOOT__
	if (i->p && *i->p) {
#endif
		return *i->p;
3480ab94:	e5903000 	ldr	r3, [r0]
		i->p = i->peek_buf;
		debug_printf("b_peek: got a %d\n", *i->p);
		return *i->p;
	}
#endif
}
3480ab98:	e5d30000 	ldrb	r0, [r3]
3480ab9c:	e12fff1e 	bx	lr

3480aba0 <is_assignment>:
	}
}

static int is_assignment(const char *s)
{
	if (s == NULL)
3480aba0:	e3500000 	cmp	r0, #0
3480aba4:	012fff1e 	bxeq	lr
		return 0;

	if (!isalpha(*s)) return 0;
3480aba8:	e59f3040 	ldr	r3, [pc, #64]	; 3480abf0 <is_assignment+0x50>
3480abac:	e5d02000 	ldrb	r2, [r0]
3480abb0:	e7d32002 	ldrb	r2, [r3, r2]
3480abb4:	e2122003 	ands	r2, r2, #3
3480abb8:	0a00000a 	beq	3480abe8 <is_assignment+0x48>
	++s;
	while(isalnum(*s) || *s=='_') ++s;
3480abbc:	e1a02003 	mov	r2, r3
3480abc0:	e5f03001 	ldrb	r3, [r0, #1]!
3480abc4:	e7d21003 	ldrb	r1, [r2, r3]
3480abc8:	e3110007 	tst	r1, #7
3480abcc:	1afffffb 	bne	3480abc0 <is_assignment+0x20>
3480abd0:	e353005f 	cmp	r3, #95	; 0x5f
3480abd4:	0afffff9 	beq	3480abc0 <is_assignment+0x20>
	return *s=='=';
3480abd8:	e353003d 	cmp	r3, #61	; 0x3d
3480abdc:	13a00000 	movne	r0, #0
3480abe0:	03a00001 	moveq	r0, #1
3480abe4:	e12fff1e 	bx	lr
static int is_assignment(const char *s)
{
	if (s == NULL)
		return 0;

	if (!isalpha(*s)) return 0;
3480abe8:	e1a00002 	mov	r0, r2
	++s;
	while(isalnum(*s) || *s=='_') ++s;
	return *s=='=';
}
3480abec:	e12fff1e 	bx	lr
3480abf0:	34821cd4 	.word	0x34821cd4

3480abf4 <syntax_err>:
#endif
#define final_printf debug_printf

#ifdef __U_BOOT__
static void syntax_err(void) {
	 printf("syntax error\n");
3480abf4:	e59f0000 	ldr	r0, [pc, #0]	; 3480abfc <syntax_err+0x8>
3480abf8:	eafff959 	b	34809164 <printf>
3480abfc:	34826167 	.word	0x34826167

3480ac00 <do_showvar>:
	return str;
}

#ifdef __U_BOOT__
int do_showvar (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480ac00:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
3480ac04:	e3520001 	cmp	r2, #1
		for (cur = top_vars; cur; cur = cur->next) {
3480ac08:	059f30d0 	ldreq	r3, [pc, #208]	; 3480ace0 <do_showvar+0xe0>
	return str;
}

#ifdef __U_BOOT__
int do_showvar (cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
3480ac0c:	e58d2004 	str	r2, [sp, #4]
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
3480ac10:	11a09003 	movne	r9, r3
3480ac14:	13a04000 	movne	r4, #0
3480ac18:	13a06001 	movne	r6, #1
		for (cur = top_vars; cur; cur = cur->next) {
3480ac1c:	05934000 	ldreq	r4, [r3]
{
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
3480ac20:	1a000029 	bne	3480accc <do_showvar+0xcc>
3480ac24:	ea000006 	b	3480ac44 <do_showvar+0x44>
		for (cur = top_vars; cur; cur = cur->next) {
			printf ("%s=%s\n", cur->name, cur->value);
3480ac28:	e8940006 	ldm	r4, {r1, r2}
3480ac2c:	e59f00b0 	ldr	r0, [pc, #176]	; 3480ace4 <do_showvar+0xe4>
3480ac30:	ebfff94b 	bl	34809164 <printf>
			if (ctrlc ()) {
3480ac34:	ebfff96f 	bl	348091f8 <ctrlc>
3480ac38:	e3500000 	cmp	r0, #0
3480ac3c:	1a000014 	bne	3480ac94 <do_showvar+0x94>
	int i, k;
	int rcode = 0;
	struct variables *cur;

	if (argc == 1) {		/* Print all env variables	*/
		for (cur = top_vars; cur; cur = cur->next) {
3480ac40:	e5944010 	ldr	r4, [r4, #16]
3480ac44:	e3540000 	cmp	r4, #0
3480ac48:	1afffff6 	bne	3480ac28 <do_showvar+0x28>
3480ac4c:	ea000021 	b	3480acd8 <do_showvar+0xd8>
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
3480ac50:	e59f2088 	ldr	r2, [pc, #136]	; 3480ace0 <do_showvar+0xe0>
			}
		}
		return 0;
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];
3480ac54:	e5b97004 	ldr	r7, [r9, #4]!

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
3480ac58:	e5925000 	ldr	r5, [r2]
		return 0;
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
3480ac5c:	e3e0b000 	mvn	fp, #0
		for (cur = top_vars; cur; cur = cur->next) {
3480ac60:	ea000010 	b	3480aca8 <do_showvar+0xa8>
			if(strcmp (cur->name, name) == 0) {
3480ac64:	e5950000 	ldr	r0, [r5]
3480ac68:	e1a01007 	mov	r1, r7
3480ac6c:	eb0043c0 	bl	3481bb74 <strcmp>
3480ac70:	e250a000 	subs	sl, r0, #0
3480ac74:	1a000003 	bne	3480ac88 <do_showvar+0x88>
				k = 0;
				printf ("%s=%s\n", cur->name, cur->value);
3480ac78:	e59f0064 	ldr	r0, [pc, #100]	; 3480ace4 <do_showvar+0xe4>
3480ac7c:	e8950006 	ldm	r5, {r1, r2}
3480ac80:	ebfff937 	bl	34809164 <printf>
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
			if(strcmp (cur->name, name) == 0) {
				k = 0;
3480ac84:	e1a0b00a 	mov	fp, sl
				printf ("%s=%s\n", cur->name, cur->value);
			}
			if (ctrlc ()) {
3480ac88:	ebfff95a 	bl	348091f8 <ctrlc>
3480ac8c:	e3500000 	cmp	r0, #0
3480ac90:	0a000003 	beq	3480aca4 <do_showvar+0xa4>
				puts ("\n ** Abort\n");
3480ac94:	e59f004c 	ldr	r0, [pc, #76]	; 3480ace8 <do_showvar+0xe8>
3480ac98:	ebfff927 	bl	3480913c <puts>
				return 1;
3480ac9c:	e3a04001 	mov	r4, #1
3480aca0:	ea00000c 	b	3480acd8 <do_showvar+0xd8>
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
		char *name = argv[i];

		k = -1;
		for (cur = top_vars; cur; cur = cur->next) {
3480aca4:	e5955010 	ldr	r5, [r5, #16]
3480aca8:	e3550000 	cmp	r5, #0
3480acac:	1affffec 	bne	3480ac64 <do_showvar+0x64>
			if (ctrlc ()) {
				puts ("\n ** Abort\n");
				return 1;
			}
		}
		if (k < 0) {
3480acb0:	e37b0001 	cmn	fp, #1
3480acb4:	1a000003 	bne	3480acc8 <do_showvar+0xc8>
			printf ("## Error: \"%s\" not defined\n", name);
3480acb8:	e59f002c 	ldr	r0, [pc, #44]	; 3480acec <do_showvar+0xec>
3480acbc:	e1a01007 	mov	r1, r7
3480acc0:	ebfff927 	bl	34809164 <printf>
			rcode ++;
3480acc4:	e2844001 	add	r4, r4, #1
				return 1;
			}
		}
		return 0;
	}
	for (i = 1; i < argc; ++i) {	/* print single env variables	*/
3480acc8:	e2866001 	add	r6, r6, #1
3480accc:	e59d3004 	ldr	r3, [sp, #4]
3480acd0:	e1560003 	cmp	r6, r3
3480acd4:	baffffdd 	blt	3480ac50 <do_showvar+0x50>
			printf ("## Error: \"%s\" not defined\n", name);
			rcode ++;
		}
	}
	return rcode;
}
3480acd8:	e1a00004 	mov	r0, r4
3480acdc:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3480ace0:	34829dc4 	.word	0x34829dc4
3480ace4:	348251c9 	.word	0x348251c9
3480ace8:	34826175 	.word	0x34826175
3480acec:	348251f1 	.word	0x348251f1

3480acf0 <xmalloc>:
	}
	return 0;
}

static void *xmalloc(size_t size)
{
3480acf0:	e92d4008 	push	{r3, lr}
	void *p = NULL;

	if (!(p = malloc(size))) {
3480acf4:	ebfffae1 	bl	34809880 <malloc>
3480acf8:	e3500000 	cmp	r0, #0
3480acfc:	18bd8008 	popne	{r3, pc}
	    printf("ERROR : memory not allocated\n");
3480ad00:	e59f0004 	ldr	r0, [pc, #4]	; 3480ad0c <xmalloc+0x1c>
3480ad04:	ebfff916 	bl	34809164 <printf>
3480ad08:	eafffffe 	b	3480ad08 <xmalloc+0x18>
3480ad0c:	34826181 	.word	0x34826181

3480ad10 <file_get>:
{
	int ch;

	ch = 0;
	/* If there is data waiting, eat it up */
	if (i->p && *i->p) {
3480ad10:	e5903000 	ldr	r3, [r0]
}

/* This is the magic location that prints prompts
 * and gets data back from the user */
static int file_get(struct in_str *i)
{
3480ad14:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int ch;

	ch = 0;
	/* If there is data waiting, eat it up */
	if (i->p && *i->p) {
3480ad18:	e3530000 	cmp	r3, #0
}

/* This is the magic location that prints prompts
 * and gets data back from the user */
static int file_get(struct in_str *i)
{
3480ad1c:	e1a04000 	mov	r4, r0
	int ch;

	ch = 0;
	/* If there is data waiting, eat it up */
	if (i->p && *i->p) {
3480ad20:	0a000047 	beq	3480ae44 <file_get+0x134>
3480ad24:	e5d30000 	ldrb	r0, [r3]
3480ad28:	e3500000 	cmp	r0, #0
3480ad2c:	0a000044 	beq	3480ae44 <file_get+0x134>
3480ad30:	ea000056 	b	3480ae90 <file_get+0x180>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	reset_cmd_timeout();
#endif
	i->__promptme = 1;
	if (i->promptmode == 1) {
3480ad34:	e5943008 	ldr	r3, [r4, #8]
#  ifndef CONFIG_RESET_TO_RETRY
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	reset_cmd_timeout();
#endif
	i->__promptme = 1;
3480ad38:	e3a02001 	mov	r2, #1
	if (i->promptmode == 1) {
3480ad3c:	e1530002 	cmp	r3, r2
#  ifndef CONFIG_RESET_TO_RETRY
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	reset_cmd_timeout();
#endif
	i->__promptme = 1;
3480ad40:	e5842004 	str	r2, [r4, #4]
	if (i->promptmode == 1) {
		n = readline(CONFIG_SYS_PROMPT);
3480ad44:	059f0158 	ldreq	r0, [pc, #344]	; 3480aea4 <file_get+0x194>
	} else {
		n = readline(CONFIG_SYS_PROMPT_HUSH_PS2);
3480ad48:	159f0158 	ldrne	r0, [pc, #344]	; 3480aea8 <file_get+0x198>
3480ad4c:	eb000c3d 	bl	3480de48 <readline>
#  else
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
3480ad50:	e3700001 	cmn	r0, #1
		flag_repeat = 0;
		i->__promptme = 0;
3480ad54:	05846004 	streq	r6, [r4, #4]
	}
	n = strlen(console_buffer);
3480ad58:	e59f014c 	ldr	r0, [pc, #332]	; 3480aeac <file_get+0x19c>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
		flag_repeat = 0;
3480ad5c:	05856004 	streq	r6, [r5, #4]
		i->__promptme = 0;
	}
	n = strlen(console_buffer);
3480ad60:	eb0043b7 	bl	3481bc44 <strlen>
	console_buffer[n] = '\n';
3480ad64:	e1a03007 	mov	r3, r7
3480ad68:	e7e3a000 	strb	sl, [r3, r0]!
	console_buffer[n+1]= '\0';
3480ad6c:	e5c36001 	strb	r6, [r3, #1]
	if (had_ctrlc()) flag_repeat = 0;
3480ad70:	ebfff939 	bl	3480925c <had_ctrlc>
3480ad74:	e3500000 	cmp	r0, #0
3480ad78:	15856004 	strne	r6, [r5, #4]
	clear_ctrlc();
3480ad7c:	ebfff93a 	bl	3480926c <clear_ctrlc>
	do_repeat = 0;
	if (i->promptmode == 1) {
3480ad80:	e5949008 	ldr	r9, [r4, #8]
	n = strlen(console_buffer);
	console_buffer[n] = '\n';
	console_buffer[n+1]= '\0';
	if (had_ctrlc()) flag_repeat = 0;
	clear_ctrlc();
	do_repeat = 0;
3480ad84:	e5856008 	str	r6, [r5, #8]
	if (i->promptmode == 1) {
3480ad88:	e3590001 	cmp	r9, #1
3480ad8c:	1a000010 	bne	3480add4 <file_get+0xc4>
		if (console_buffer[0] == '\n'&& flag_repeat == 0) {
3480ad90:	e5d73000 	ldrb	r3, [r7]
3480ad94:	e353000a 	cmp	r3, #10
3480ad98:	1a000007 	bne	3480adbc <file_get+0xac>
3480ad9c:	e5953004 	ldr	r3, [r5, #4]
3480ada0:	e3530000 	cmp	r3, #0
			if (console_buffer[0] != '\n') {
				strcpy(the_command,console_buffer);
				flag_repeat = 1;
			}
			else {
				do_repeat = 1;
3480ada4:	15859008 	strne	r9, [r5, #8]
	console_buffer[n+1]= '\0';
	if (had_ctrlc()) flag_repeat = 0;
	clear_ctrlc();
	do_repeat = 0;
	if (i->promptmode == 1) {
		if (console_buffer[0] == '\n'&& flag_repeat == 0) {
3480ada8:	1a000007 	bne	3480adcc <file_get+0xbc>
			strcpy(the_command,console_buffer);
3480adac:	e59f10f8 	ldr	r1, [pc, #248]	; 3480aeac <file_get+0x19c>
3480adb0:	e59f00f8 	ldr	r0, [pc, #248]	; 3480aeb0 <file_get+0x1a0>
3480adb4:	eb00433d 	bl	3481bab0 <strcpy>
3480adb8:	ea000003 	b	3480adcc <file_get+0xbc>
		}
		else {
			if (console_buffer[0] != '\n') {
				strcpy(the_command,console_buffer);
3480adbc:	e59f00ec 	ldr	r0, [pc, #236]	; 3480aeb0 <file_get+0x1a0>
3480adc0:	e59f10e4 	ldr	r1, [pc, #228]	; 3480aeac <file_get+0x19c>
3480adc4:	eb004339 	bl	3481bab0 <strcpy>
				flag_repeat = 1;
3480adc8:	e5859004 	str	r9, [r5, #4]
			}
			else {
				do_repeat = 1;
			}
		}
		i->p = the_command;
3480adcc:	e584b000 	str	fp, [r4]
3480add0:	ea000020 	b	3480ae58 <file_get+0x148>
	}
	else {
		if (console_buffer[0] != '\n') {
3480add4:	e5d73000 	ldrb	r3, [r7]
3480add8:	e353000a 	cmp	r3, #10
3480addc:	0a000012 	beq	3480ae2c <file_get+0x11c>
			if (strlen(the_command) + strlen(console_buffer)
3480ade0:	e59f00c8 	ldr	r0, [pc, #200]	; 3480aeb0 <file_get+0x1a0>
3480ade4:	eb004396 	bl	3481bc44 <strlen>
3480ade8:	e1a09000 	mov	r9, r0
3480adec:	e59f00b8 	ldr	r0, [pc, #184]	; 3480aeac <file_get+0x19c>
3480adf0:	eb004393 	bl	3481bc44 <strlen>
3480adf4:	e0800009 	add	r0, r0, r9
3480adf8:	e35000ff 	cmp	r0, #255	; 0xff
				n = strlen(the_command);
				the_command[n-1] = ' ';
				strcpy(&the_command[n],console_buffer);
			}
			else {
				the_command[0] = '\n';
3480adfc:	85c5a00c 	strbhi	sl, [r5, #12]
				the_command[1] = '\0';
3480ae00:	85c5600d 	strbhi	r6, [r5, #13]
				flag_repeat = 0;
3480ae04:	85856004 	strhi	r6, [r5, #4]
		}
		i->p = the_command;
	}
	else {
		if (console_buffer[0] != '\n') {
			if (strlen(the_command) + strlen(console_buffer)
3480ae08:	8a000007 	bhi	3480ae2c <file_get+0x11c>
			    < CONFIG_SYS_CBSIZE) {
				n = strlen(the_command);
3480ae0c:	e59f009c 	ldr	r0, [pc, #156]	; 3480aeb0 <file_get+0x1a0>
3480ae10:	eb00438b 	bl	3481bc44 <strlen>
				the_command[n-1] = ' ';
3480ae14:	e3a02020 	mov	r2, #32
3480ae18:	e0853000 	add	r3, r5, r0
3480ae1c:	e5c3200b 	strb	r2, [r3, #11]
				strcpy(&the_command[n],console_buffer);
3480ae20:	e08b0000 	add	r0, fp, r0
3480ae24:	e59f1080 	ldr	r1, [pc, #128]	; 3480aeac <file_get+0x19c>
3480ae28:	eb004320 	bl	3481bab0 <strcpy>
				the_command[0] = '\n';
				the_command[1] = '\0';
				flag_repeat = 0;
			}
		}
		if (i->__promptme == 0) {
3480ae2c:	e5943004 	ldr	r3, [r4, #4]
3480ae30:	e3530000 	cmp	r3, #0
			the_command[0] = '\n';
3480ae34:	05c5a00c 	strbeq	sl, [r5, #12]
			the_command[1] = '\0';
3480ae38:	05c5300d 	strbeq	r3, [r5, #13]
		}
		i->p = console_buffer;
3480ae3c:	e5847000 	str	r7, [r4]
3480ae40:	ea000004 	b	3480ae58 <file_get+0x148>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
		flag_repeat = 0;
3480ae44:	e59f5068 	ldr	r5, [pc, #104]	; 3480aeb4 <file_get+0x1a4>
		i->__promptme = 0;
	}
	n = strlen(console_buffer);
3480ae48:	e59f705c 	ldr	r7, [pc, #92]	; 3480aeac <file_get+0x19c>
#	error "This currently only works with CONFIG_RESET_TO_RETRY enabled"
#  endif
	}
#endif
	if (n == -1 ) {
		flag_repeat = 0;
3480ae4c:	e3a06000 	mov	r6, #0
		i->__promptme = 0;
	}
	n = strlen(console_buffer);
	console_buffer[n] = '\n';
3480ae50:	e3a0a00a 	mov	sl, #10
		}
		i->p = the_command;
	}
	else {
		if (console_buffer[0] != '\n') {
			if (strlen(the_command) + strlen(console_buffer)
3480ae54:	e285b00c 	add	fp, r5, #12
		 * more complicated by now, like sourcing or substituting. */
#ifndef __U_BOOT__
		if (i->__promptme && interactive && i->file == stdin) {
			while(! i->p || (interactive && strlen(i->p)==0) ) {
#else
			while(! i->p  || strlen(i->p)==0 ) {
3480ae58:	e5940000 	ldr	r0, [r4]
3480ae5c:	e3500000 	cmp	r0, #0
3480ae60:	0affffb3 	beq	3480ad34 <file_get+0x24>
3480ae64:	eb004376 	bl	3481bc44 <strlen>
3480ae68:	e3500000 	cmp	r0, #0
3480ae6c:	0affffb0 	beq	3480ad34 <file_get+0x24>
#endif
				get_user_input(i);
			}
			i->promptmode=2;
3480ae70:	e3a03002 	mov	r3, #2
3480ae74:	e5843008 	str	r3, [r4, #8]
#ifndef __U_BOOT__
			i->__promptme = 0;
#endif
			if (i->p && *i->p) {
3480ae78:	e5943000 	ldr	r3, [r4]
3480ae7c:	e3530000 	cmp	r3, #0
3480ae80:	0a000005 	beq	3480ae9c <file_get+0x18c>
3480ae84:	e5d30000 	ldrb	r0, [r3]
3480ae88:	e3500000 	cmp	r0, #0
3480ae8c:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
				ch = *i->p++;
3480ae90:	e2833001 	add	r3, r3, #1
3480ae94:	e5843000 	str	r3, [r4]
3480ae98:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
 * and gets data back from the user */
static int file_get(struct in_str *i)
{
	int ch;

	ch = 0;
3480ae9c:	e1a00003 	mov	r0, r3
	}
#ifndef __U_BOOT__
	if (ch == '\n') i->__promptme=1;
#endif
	return ch;
}
3480aea0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480aea4:	3482619f 	.word	0x3482619f
3480aea8:	348261a7 	.word	0x348261a7
3480aeac:	3482b478 	.word	0x3482b478
3480aeb0:	34829dd0 	.word	0x34829dd0
3480aeb4:	34829dc4 	.word	0x34829dc4

3480aeb8 <free_pipe_list>:
	pi->progs=NULL;
	return ret_code;
}

static int free_pipe_list(struct pipe *head, int indent)
{
3480aeb8:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	int rcode=0;   /* if list has no members */
3480aebc:	e3a05000 	mov	r5, #0
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
3480aec0:	e1a04000 	mov	r4, r0
3480aec4:	e1a06005 	mov	r6, r5
			child->argv=NULL;
		} else if (child->group) {
#ifndef __U_BOOT__
			final_printf("%s   begin group (subshell:%d)\n",ind, child->subshell);
#endif
			ret_code = free_pipe_list(child->group,indent+3);
3480aec8:	e2819003 	add	r9, r1, #3
static int free_pipe_list(struct pipe *head, int indent)
{
	int rcode=0;   /* if list has no members */
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
3480aecc:	ea000029 	b	3480af78 <free_pipe_list+0xc0>
	if (pi->stopped_progs > 0)
		return ret_code;
	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
#endif
	for (i=0; i<pi->num_progs; i++) {
		child = &pi->progs[i];
3480aed0:	e5943004 	ldr	r3, [r4, #4]
		final_printf("%s  command %d:\n",ind,i);
		if (child->argv) {
3480aed4:	e7932007 	ldr	r2, [r3, r7]
	if (pi->stopped_progs > 0)
		return ret_code;
	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
#endif
	for (i=0; i<pi->num_progs; i++) {
		child = &pi->progs[i];
3480aed8:	e083b007 	add	fp, r3, r7
		final_printf("%s  command %d:\n",ind,i);
		if (child->argv) {
3480aedc:	e3520000 	cmp	r2, #0
3480aee0:	0a000011 	beq	3480af2c <free_pipe_list+0x74>
			for (a=0,p=child->argv; *p; a++,p++) {
3480aee4:	e4923004 	ldr	r3, [r2], #4
3480aee8:	e3530000 	cmp	r3, #0
3480aeec:	1afffffc 	bne	3480aee4 <free_pipe_list+0x2c>
3480aef0:	ea000005 	b	3480af0c <free_pipe_list+0x54>
			}
#ifndef __U_BOOT__
			globfree(&child->glob_result);
#else
			for (a = 0; a < child->argc; a++) {
				free(child->argv[a]);
3480aef4:	e59b2000 	ldr	r2, [fp]
3480aef8:	e7920103 	ldr	r0, [r2, r3, lsl #2]
3480aefc:	e58d3004 	str	r3, [sp, #4]
3480af00:	ebfff9d5 	bl	3480965c <free>
				final_printf("%s   argv[%d] = %s\n",ind,a,*p);
			}
#ifndef __U_BOOT__
			globfree(&child->glob_result);
#else
			for (a = 0; a < child->argc; a++) {
3480af04:	e59d3004 	ldr	r3, [sp, #4]
3480af08:	e2833001 	add	r3, r3, #1
3480af0c:	e59b2004 	ldr	r2, [fp, #4]
3480af10:	e1530002 	cmp	r3, r2
3480af14:	bafffff6 	blt	3480aef4 <free_pipe_list+0x3c>
				free(child->argv[a]);
			}
					free(child->argv);
3480af18:	e59b0000 	ldr	r0, [fp]
3480af1c:	ebfff9ce 	bl	3480965c <free>
			child->argc = 0;
3480af20:	e58b6004 	str	r6, [fp, #4]
#endif
			child->argv=NULL;
3480af24:	e58b6000 	str	r6, [fp]
3480af28:	ea000005 	b	3480af44 <free_pipe_list+0x8c>
		} else if (child->group) {
3480af2c:	e59b0008 	ldr	r0, [fp, #8]
3480af30:	e3500000 	cmp	r0, #0
3480af34:	0a000002 	beq	3480af44 <free_pipe_list+0x8c>
#ifndef __U_BOOT__
			final_printf("%s   begin group (subshell:%d)\n",ind, child->subshell);
#endif
			ret_code = free_pipe_list(child->group,indent+3);
3480af38:	e1a01009 	mov	r1, r9
3480af3c:	ebffffdd 	bl	3480aeb8 <free_pipe_list>
3480af40:	e1a05000 	mov	r5, r0
#ifndef __U_BOOT__
	if (pi->stopped_progs > 0)
		return ret_code;
	final_printf("%s run pipe: (pid %d)\n",ind,getpid());
#endif
	for (i=0; i<pi->num_progs; i++) {
3480af44:	e28aa001 	add	sl, sl, #1
3480af48:	e2877014 	add	r7, r7, #20
3480af4c:	e5943000 	ldr	r3, [r4]
3480af50:	e15a0003 	cmp	sl, r3
3480af54:	baffffdd 	blt	3480aed0 <free_pipe_list+0x18>
			free(r);
		}
		child->redirects=NULL;
#endif
	}
	free(pi->progs);   /* children are an array, they get freed all at once */
3480af58:	e5940004 	ldr	r0, [r4, #4]
3480af5c:	ebfff9be 	bl	3480965c <free>
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
		final_printf("%s pipe reserved mode %d\n", ind, pi->r_mode);
		rcode = free_pipe(pi, indent);
		final_printf("%s pipe followup code %d\n", ind, pi->followup);
		next=pi->next;
3480af60:	e5947008 	ldr	r7, [r4, #8]
		}
		child->redirects=NULL;
#endif
	}
	free(pi->progs);   /* children are an array, they get freed all at once */
	pi->progs=NULL;
3480af64:	e5846004 	str	r6, [r4, #4]
	for (pi=head; pi; pi=next) {
		final_printf("%s pipe reserved mode %d\n", ind, pi->r_mode);
		rcode = free_pipe(pi, indent);
		final_printf("%s pipe followup code %d\n", ind, pi->followup);
		next=pi->next;
		pi->next=NULL;
3480af68:	e5846008 	str	r6, [r4, #8]
		free(pi);
3480af6c:	e1a00004 	mov	r0, r4
3480af70:	ebfff9b9 	bl	3480965c <free>
static int free_pipe_list(struct pipe *head, int indent)
{
	int rcode=0;   /* if list has no members */
	struct pipe *pi, *next;
	char *ind = indenter(indent);
	for (pi=head; pi; pi=next) {
3480af74:	e1a04007 	mov	r4, r7
3480af78:	e3540000 	cmp	r4, #0
3480af7c:	13a05000 	movne	r5, #0
3480af80:	11a07005 	movne	r7, r5
3480af84:	11a0a005 	movne	sl, r5
3480af88:	1affffef 	bne	3480af4c <free_pipe_list+0x94>
		next=pi->next;
		pi->next=NULL;
		free(pi);
	}
	return rcode;
}
3480af8c:	e1a00005 	mov	r0, r5
3480af90:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

3480af94 <xrealloc>:
	}
	return p;
}

static void *xrealloc(void *ptr, size_t size)
{
3480af94:	e92d4008 	push	{r3, lr}
	void *p = NULL;

	if (!(p = realloc(ptr, size))) {
3480af98:	ebfffc2a 	bl	3480a048 <realloc>
3480af9c:	e3500000 	cmp	r0, #0
3480afa0:	18bd8008 	popne	{r3, pc}
	    printf("ERROR : memory not allocated\n");
3480afa4:	e59f0004 	ldr	r0, [pc, #4]	; 3480afb0 <xrealloc+0x1c>
3480afa8:	ebfff86d 	bl	34809164 <printf>
3480afac:	eafffffe 	b	3480afac <xrealloc+0x18>
3480afb0:	34826181 	.word	0x34826181

3480afb4 <done_command>:
	 * advance the pipe counter and make a new, null child.
	 * Only real trickiness here is that the uncommitted
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. */
	struct pipe *pi=ctx->pipe;
	struct child_prog *prog=ctx->child;
3480afb4:	e5903000 	ldr	r3, [r0]
}

/* The only possible error here is out of memory, in which case
 * xmalloc exits. */
static int done_command(struct p_context *ctx)
{
3480afb8:	e92d4070 	push	{r4, r5, r6, lr}
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. */
	struct pipe *pi=ctx->pipe;
	struct child_prog *prog=ctx->child;

	if (prog && prog->group == NULL
3480afbc:	e3530000 	cmp	r3, #0
}

/* The only possible error here is out of memory, in which case
 * xmalloc exits. */
static int done_command(struct p_context *ctx)
{
3480afc0:	e1a05000 	mov	r5, r0
	/* The child is really already in the pipe structure, so
	 * advance the pipe counter and make a new, null child.
	 * Only real trickiness here is that the uncommitted
	 * child structure, to which ctx->child points, is not
	 * counted in pi->num_progs. */
	struct pipe *pi=ctx->pipe;
3480afc4:	e5904008 	ldr	r4, [r0, #8]
	struct child_prog *prog=ctx->child;

	if (prog && prog->group == NULL
3480afc8:	0a000008 	beq	3480aff0 <done_command+0x3c>
3480afcc:	e5932008 	ldr	r2, [r3, #8]
3480afd0:	e3520000 	cmp	r2, #0
3480afd4:	1a000002 	bne	3480afe4 <done_command+0x30>
		 && prog->argv == NULL
3480afd8:	e5933000 	ldr	r3, [r3]
3480afdc:	e3530000 	cmp	r3, #0
3480afe0:	0a000013 	beq	3480b034 <done_command+0x80>
										) {
#endif
		debug_printf("done_command: skipping null command\n");
		return 0;
	} else if (prog) {
		pi->num_progs++;
3480afe4:	e5943000 	ldr	r3, [r4]
3480afe8:	e2833001 	add	r3, r3, #1
3480afec:	e5843000 	str	r3, [r4]
		debug_printf("done_command: num_progs incremented to %d\n",pi->num_progs);
	} else {
		debug_printf("done_command: initializing\n");
	}
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));
3480aff0:	e5941000 	ldr	r1, [r4]
3480aff4:	e3a06014 	mov	r6, #20
3480aff8:	e2811001 	add	r1, r1, #1
3480affc:	e0010196 	mul	r1, r6, r1
3480b000:	e5940004 	ldr	r0, [r4, #4]
3480b004:	ebffffe2 	bl	3480af94 <xrealloc>

	prog = pi->progs + pi->num_progs;
3480b008:	e5943000 	ldr	r3, [r4]
#ifndef __U_BOOT__
	prog->redirects = NULL;
#endif
	prog->argv = NULL;
3480b00c:	e3a02000 	mov	r2, #0
	} else {
		debug_printf("done_command: initializing\n");
	}
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));

	prog = pi->progs + pi->num_progs;
3480b010:	e0060396 	mul	r6, r6, r3
3480b014:	e0803006 	add	r3, r0, r6
		pi->num_progs++;
		debug_printf("done_command: num_progs incremented to %d\n",pi->num_progs);
	} else {
		debug_printf("done_command: initializing\n");
	}
	pi->progs = xrealloc(pi->progs, sizeof(*pi->progs) * (pi->num_progs+1));
3480b018:	e5840004 	str	r0, [r4, #4]

	prog = pi->progs + pi->num_progs;
#ifndef __U_BOOT__
	prog->redirects = NULL;
#endif
	prog->argv = NULL;
3480b01c:	e7802006 	str	r2, [r0, r6]
#ifndef __U_BOOT__
	prog->is_stopped = 0;
#endif
	prog->group = NULL;
3480b020:	e5832008 	str	r2, [r3, #8]
#ifndef __U_BOOT__
	prog->glob_result.gl_pathv = NULL;
	prog->family = pi;
#endif
	prog->sp = 0;
3480b024:	e583200c 	str	r2, [r3, #12]
	ctx->child = prog;
	prog->type = ctx->type;
3480b028:	e5952018 	ldr	r2, [r5, #24]
#ifndef __U_BOOT__
	prog->glob_result.gl_pathv = NULL;
	prog->family = pi;
#endif
	prog->sp = 0;
	ctx->child = prog;
3480b02c:	e5853000 	str	r3, [r5]
	prog->type = ctx->type;
3480b030:	e5832010 	str	r2, [r3, #16]

	/* but ctx->pipe and ctx->list_head remain unchanged */
	return 0;
}
3480b034:	e3a00000 	mov	r0, #0
3480b038:	e8bd8070 	pop	{r4, r5, r6, pc}

3480b03c <b_addchr>:
	}
	return o->data == NULL;
}

static int b_addchr(o_string *o, int ch)
{
3480b03c:	e92d4070 	push	{r4, r5, r6, lr}

static int b_check_space(o_string *o, int len)
{
	/* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
3480b040:	e5903004 	ldr	r3, [r0, #4]
	}
	return o->data == NULL;
}

static int b_addchr(o_string *o, int ch)
{
3480b044:	e1a06001 	mov	r6, r1

static int b_check_space(o_string *o, int len)
{
	/* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
3480b048:	e5901008 	ldr	r1, [r0, #8]
	}
	return o->data == NULL;
}

static int b_addchr(o_string *o, int ch)
{
3480b04c:	e1a04000 	mov	r4, r0

static int b_check_space(o_string *o, int len)
{
	/* It would be easy to drop a more restrictive policy
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
3480b050:	e1530001 	cmp	r3, r1
3480b054:	ba00000a 	blt	3480b084 <b_addchr+0x48>
		char *old_data = o->data;
3480b058:	e5905000 	ldr	r5, [r0]
		/* assert (data == NULL || o->maxlen != 0); */
		o->maxlen += max(2*len, B_CHUNK);
3480b05c:	e2813064 	add	r3, r1, #100	; 0x64
3480b060:	e5803008 	str	r3, [r0, #8]
		o->data = realloc(o->data, 1 + o->maxlen);
3480b064:	e2811065 	add	r1, r1, #101	; 0x65
3480b068:	e1a00005 	mov	r0, r5
3480b06c:	ebfffbf5 	bl	3480a048 <realloc>
		if (o->data == NULL) {
3480b070:	e3500000 	cmp	r0, #0
	 * in here, such as setting a maximum string length */
	if (o->length + len > o->maxlen) {
		char *old_data = o->data;
		/* assert (data == NULL || o->maxlen != 0); */
		o->maxlen += max(2*len, B_CHUNK);
		o->data = realloc(o->data, 1 + o->maxlen);
3480b074:	e5840000 	str	r0, [r4]
		if (o->data == NULL) {
3480b078:	1a000001 	bne	3480b084 <b_addchr+0x48>
			free(old_data);
3480b07c:	e1a00005 	mov	r0, r5
3480b080:	ebfff975 	bl	3480965c <free>
		}
	}
	return o->data == NULL;
3480b084:	e5943000 	ldr	r3, [r4]
}

static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
3480b088:	e3530000 	cmp	r3, #0
	o->data[o->length] = ch;
3480b08c:	15942004 	ldrne	r2, [r4, #4]
	o->length++;
	o->data[o->length] = '\0';
3480b090:	13a00000 	movne	r0, #0

static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
	o->data[o->length] = ch;
3480b094:	17c36002 	strbne	r6, [r3, r2]
	o->length++;
3480b098:	15943004 	ldrne	r3, [r4, #4]
	o->data[o->length] = '\0';
3480b09c:	15942000 	ldrne	r2, [r4]
static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
	o->data[o->length] = ch;
	o->length++;
3480b0a0:	12833001 	addne	r3, r3, #1
3480b0a4:	15843004 	strne	r3, [r4, #4]
}

static int b_addchr(o_string *o, int ch)
{
	debug_printf("b_addchr: %c %d %p\n", ch, o->length, o);
	if (b_check_space(o, 1)) return B_NOSPAC;
3480b0a8:	03a00001 	moveq	r0, #1
	o->data[o->length] = ch;
	o->length++;
	o->data[o->length] = '\0';
3480b0ac:	17c20003 	strbne	r0, [r2, r3]
	return 0;
}
3480b0b0:	e8bd8070 	pop	{r4, r5, r6, pc}

3480b0b4 <b_addqchr>:
/* My analysis of quoting semantics tells me that state information
 * is associated with a destination, not a source.
 */
static int b_addqchr(o_string *o, int ch, int quote)
{
	if (quote && strchr("*?[\\",ch)) {
3480b0b4:	e3520000 	cmp	r2, #0

/* My analysis of quoting semantics tells me that state information
 * is associated with a destination, not a source.
 */
static int b_addqchr(o_string *o, int ch, int quote)
{
3480b0b8:	e92d4070 	push	{r4, r5, r6, lr}
3480b0bc:	e1a04000 	mov	r4, r0
3480b0c0:	e1a05001 	mov	r5, r1
	if (quote && strchr("*?[\\",ch)) {
3480b0c4:	0a000008 	beq	3480b0ec <b_addqchr+0x38>
3480b0c8:	e59f002c 	ldr	r0, [pc, #44]	; 3480b0fc <b_addqchr+0x48>
3480b0cc:	eb0042c6 	bl	3481bbec <strchr>
3480b0d0:	e3500000 	cmp	r0, #0
3480b0d4:	0a000004 	beq	3480b0ec <b_addqchr+0x38>
		int rc;
		rc = b_addchr(o, '\\');
3480b0d8:	e1a00004 	mov	r0, r4
3480b0dc:	e3a0105c 	mov	r1, #92	; 0x5c
3480b0e0:	ebffffd5 	bl	3480b03c <b_addchr>
		if (rc) return rc;
3480b0e4:	e3500000 	cmp	r0, #0
3480b0e8:	18bd8070 	popne	{r4, r5, r6, pc}
	}
	return b_addchr(o, ch);
3480b0ec:	e1a00004 	mov	r0, r4
3480b0f0:	e1a01005 	mov	r1, r5
}
3480b0f4:	e8bd4070 	pop	{r4, r5, r6, lr}
	if (quote && strchr("*?[\\",ch)) {
		int rc;
		rc = b_addchr(o, '\\');
		if (rc) return rc;
	}
	return b_addchr(o, ch);
3480b0f8:	eaffffcf 	b	3480b03c <b_addchr>
3480b0fc:	348261aa 	.word	0x348261aa

3480b100 <get_local_var>:
static char *get_dollar_var(char ch);
#endif

/* This is used to get/check local shell variables */
char *get_local_var(const char *s)
{
3480b100:	e92d4038 	push	{r3, r4, r5, lr}
	struct variables *cur;

	if (!s)
3480b104:	e2505000 	subs	r5, r0, #0
3480b108:	0a00001c 	beq	3480b180 <get_local_var+0x80>
		return NULL;

#ifdef __U_BOOT__
	if (*s == '$')
3480b10c:	e5d53000 	ldrb	r3, [r5]
3480b110:	e59f4070 	ldr	r4, [pc, #112]	; 3480b188 <get_local_var+0x88>
3480b114:	e3530024 	cmp	r3, #36	; 0x24
3480b118:	1a00000a 	bne	3480b148 <get_local_var+0x48>
		return get_dollar_var(s[1]);
3480b11c:	e5d53001 	ldrb	r3, [r5, #1]
#ifdef __U_BOOT__
static char *get_dollar_var(char ch)
{
	static char buf[40];

	buf[0] = '\0';
3480b120:	e3a00000 	mov	r0, #0
	switch (ch) {
3480b124:	e353003f 	cmp	r3, #63	; 0x3f
#ifdef __U_BOOT__
static char *get_dollar_var(char ch)
{
	static char buf[40];

	buf[0] = '\0';
3480b128:	e5c4010c 	strb	r0, [r4, #268]	; 0x10c
	switch (ch) {
3480b12c:	18bd8038 	popne	{r3, r4, r5, pc}
		case '?':
			sprintf(buf, "%u", (unsigned int)last_return_code);
3480b130:	e2840f43 	add	r0, r4, #268	; 0x10c
3480b134:	e59f1050 	ldr	r1, [pc, #80]	; 3480b18c <get_local_var+0x8c>
3480b138:	e5942134 	ldr	r2, [r4, #308]	; 0x134
3480b13c:	eb0046f9 	bl	3481cd28 <sprintf>
			break;
		default:
			return NULL;
	}
	return buf;
3480b140:	e2840f43 	add	r0, r4, #268	; 0x10c
3480b144:	e8bd8038 	pop	{r3, r4, r5, pc}
#ifdef __U_BOOT__
	if (*s == '$')
		return get_dollar_var(s[1]);
#endif

	for (cur = top_vars; cur; cur=cur->next)
3480b148:	e5944000 	ldr	r4, [r4]
3480b14c:	ea000007 	b	3480b170 <get_local_var+0x70>
		if(strcmp(cur->name, s)==0)
3480b150:	e5940000 	ldr	r0, [r4]
3480b154:	e1a01005 	mov	r1, r5
3480b158:	eb004285 	bl	3481bb74 <strcmp>
3480b15c:	e3500000 	cmp	r0, #0
3480b160:	1a000001 	bne	3480b16c <get_local_var+0x6c>
			return cur->value;
3480b164:	e5940004 	ldr	r0, [r4, #4]
3480b168:	e8bd8038 	pop	{r3, r4, r5, pc}
#ifdef __U_BOOT__
	if (*s == '$')
		return get_dollar_var(s[1]);
#endif

	for (cur = top_vars; cur; cur=cur->next)
3480b16c:	e5944010 	ldr	r4, [r4, #16]
3480b170:	e3540000 	cmp	r4, #0
3480b174:	1afffff5 	bne	3480b150 <get_local_var+0x50>
		if(strcmp(cur->name, s)==0)
			return cur->value;
	return NULL;
3480b178:	e1a00004 	mov	r0, r4
3480b17c:	e8bd8038 	pop	{r3, r4, r5, pc}
char *get_local_var(const char *s)
{
	struct variables *cur;

	if (!s)
		return NULL;
3480b180:	e1a00005 	mov	r0, r5

	for (cur = top_vars; cur; cur=cur->next)
		if(strcmp(cur->name, s)==0)
			return cur->value;
	return NULL;
}
3480b184:	e8bd8038 	pop	{r3, r4, r5, pc}
3480b188:	34829dc4 	.word	0x34829dc4
3480b18c:	348243da 	.word	0x348243da

3480b190 <set_local_var>:
/* This is used to set local shell variables
   flg_export==0 if only local (not exporting) variable
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
3480b190:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	int result=0;
	struct variables *cur;

#ifdef __U_BOOT__
	/* might be possible! */
	if (!isalpha(*s))
3480b194:	e59f219c 	ldr	r2, [pc, #412]	; 3480b338 <set_local_var+0x1a8>
3480b198:	e5d03000 	ldrb	r3, [r0]
/* This is used to set local shell variables
   flg_export==0 if only local (not exporting) variable
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
3480b19c:	e1a07001 	mov	r7, r1
	int result=0;
	struct variables *cur;

#ifdef __U_BOOT__
	/* might be possible! */
	if (!isalpha(*s))
3480b1a0:	e7d23003 	ldrb	r3, [r2, r3]
3480b1a4:	e3130003 	tst	r3, #3
3480b1a8:	0a00005a 	beq	3480b318 <set_local_var+0x188>
		return -1;
#endif

	name=strdup(s);
3480b1ac:	eb0042d9 	bl	3481bd18 <strdup>
3480b1b0:	e1a05000 	mov	r5, r0

#ifdef __U_BOOT__
	if (getenv(name) != NULL) {
3480b1b4:	ebfff0fc 	bl	348075ac <getenv>
3480b1b8:	e2504000 	subs	r4, r0, #0
3480b1bc:	0a000004 	beq	3480b1d4 <set_local_var+0x44>
		printf ("ERROR: "
3480b1c0:	e59f0174 	ldr	r0, [pc, #372]	; 3480b33c <set_local_var+0x1ac>
3480b1c4:	ebfff7e6 	bl	34809164 <printf>
				"There is a global environment variable with the same name.\n");
		free(name);
3480b1c8:	e1a00005 	mov	r0, r5
3480b1cc:	ebfff922 	bl	3480965c <free>
3480b1d0:	ea000050 	b	3480b318 <set_local_var+0x188>
	}
#endif
	/* Assume when we enter this function that we are already in
	 * NAME=VALUE format.  So the first order of business is to
	 * split 's' on the '=' into 'name' and 'value' */
	value = strchr(name, '=');
3480b1d4:	e1a00005 	mov	r0, r5
3480b1d8:	e3a0103d 	mov	r1, #61	; 0x3d
3480b1dc:	eb004282 	bl	3481bbec <strchr>
	if (value==0 && ++value==0) {
		free(name);
		return -1;
	}
	*value++ = 0;
3480b1e0:	e3500000 	cmp	r0, #0
3480b1e4:	11a06000 	movne	r6, r0
3480b1e8:	03a06001 	moveq	r6, #1

	for(cur = top_vars; cur; cur = cur->next) {
3480b1ec:	e59f314c 	ldr	r3, [pc, #332]	; 3480b340 <set_local_var+0x1b0>
	value = strchr(name, '=');
	if (value==0 && ++value==0) {
		free(name);
		return -1;
	}
	*value++ = 0;
3480b1f0:	e4c64001 	strb	r4, [r6], #1

	for(cur = top_vars; cur; cur = cur->next) {
3480b1f4:	e5934000 	ldr	r4, [r3]
3480b1f8:	ea000005 	b	3480b214 <set_local_var+0x84>
		if(strcmp(cur->name, name)==0)
3480b1fc:	e5940000 	ldr	r0, [r4]
3480b200:	e1a01005 	mov	r1, r5
3480b204:	eb00425a 	bl	3481bb74 <strcmp>
3480b208:	e3500000 	cmp	r0, #0
3480b20c:	0a000003 	beq	3480b220 <set_local_var+0x90>
		free(name);
		return -1;
	}
	*value++ = 0;

	for(cur = top_vars; cur; cur = cur->next) {
3480b210:	e5944010 	ldr	r4, [r4, #16]
3480b214:	e3540000 	cmp	r4, #0
3480b218:	1afffff7 	bne	3480b1fc <set_local_var+0x6c>
3480b21c:	ea000040 	b	3480b324 <set_local_var+0x194>
		if(strcmp(cur->name, name)==0)
			break;
	}

	if(cur) {
		if(strcmp(cur->value, value)==0) {
3480b220:	e5940004 	ldr	r0, [r4, #4]
3480b224:	e1a01006 	mov	r1, r6
3480b228:	eb004251 	bl	3481bb74 <strcmp>
3480b22c:	e3500000 	cmp	r0, #0
3480b230:	1a000007 	bne	3480b254 <set_local_var+0xc4>
			if(flg_export>0 && cur->flg_export==0)
3480b234:	e3570000 	cmp	r7, #0
3480b238:	da000030 	ble	3480b300 <set_local_var+0x170>
3480b23c:	e5943008 	ldr	r3, [r4, #8]
3480b240:	e3530000 	cmp	r3, #0
				cur->flg_export=flg_export;
3480b244:	05847008 	streq	r7, [r4, #8]
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
	char *name, *value;
	int result=0;
3480b248:	01a04003 	moveq	r4, r3
			break;
	}

	if(cur) {
		if(strcmp(cur->value, value)==0) {
			if(flg_export>0 && cur->flg_export==0)
3480b24c:	0a00002e 	beq	3480b30c <set_local_var+0x17c>
3480b250:	ea00002a 	b	3480b300 <set_local_var+0x170>
				cur->flg_export=flg_export;
			else
				result++;
		} else {
			if(cur->flg_read_only) {
3480b254:	e594300c 	ldr	r3, [r4, #12]
3480b258:	e3530000 	cmp	r3, #0
3480b25c:	0a000003 	beq	3480b270 <set_local_var+0xe0>
				error_msg("%s: readonly variable", name);
3480b260:	e1a01005 	mov	r1, r5
3480b264:	e59f00d8 	ldr	r0, [pc, #216]	; 3480b344 <set_local_var+0x1b4>
3480b268:	ebfff7bd 	bl	34809164 <printf>
3480b26c:	ea000025 	b	3480b308 <set_local_var+0x178>
				result = -1;
			} else {
				if(flg_export>0 || cur->flg_export>1)
3480b270:	e3570000 	cmp	r7, #0
3480b274:	ca000002 	bgt	3480b284 <set_local_var+0xf4>
3480b278:	e5943008 	ldr	r3, [r4, #8]
3480b27c:	e3530001 	cmp	r3, #1
3480b280:	da000001 	ble	3480b28c <set_local_var+0xfc>
					cur->flg_export=1;
3480b284:	e3a03001 	mov	r3, #1
3480b288:	e5843008 	str	r3, [r4, #8]
				free(cur->value);
3480b28c:	e5940004 	ldr	r0, [r4, #4]
3480b290:	ebfff8f1 	bl	3480965c <free>

				cur->value = strdup(value);
3480b294:	e1a00006 	mov	r0, r6
3480b298:	eb00429e 	bl	3481bd18 <strdup>
3480b29c:	e5840004 	str	r0, [r4, #4]
   flg_export==1 if "new" exporting environ
   flg_export>1  if current startup environ (not call putenv()) */
int set_local_var(const char *s, int flg_export)
{
	char *name, *value;
	int result=0;
3480b2a0:	e3a04000 	mov	r4, #0
3480b2a4:	ea000018 	b	3480b30c <set_local_var+0x17c>
	} else {
		cur = malloc(sizeof(struct variables));
		if(!cur) {
			result = -1;
		} else {
			cur->name = strdup(name);
3480b2a8:	e1a00005 	mov	r0, r5
3480b2ac:	eb004299 	bl	3481bd18 <strdup>
			if(cur->name == 0) {
3480b2b0:	e3500000 	cmp	r0, #0
	} else {
		cur = malloc(sizeof(struct variables));
		if(!cur) {
			result = -1;
		} else {
			cur->name = strdup(name);
3480b2b4:	e58a0000 	str	r0, [sl]
			if(cur->name == 0) {
3480b2b8:	1a000002 	bne	3480b2c8 <set_local_var+0x138>
				free(cur);
3480b2bc:	e1a0000a 	mov	r0, sl
3480b2c0:	ebfff8e5 	bl	3480965c <free>
3480b2c4:	ea00000f 	b	3480b308 <set_local_var+0x178>
				result = -1;
			} else {
				struct variables *bottom = top_vars;
3480b2c8:	e59f3070 	ldr	r3, [pc, #112]	; 3480b340 <set_local_var+0x1b0>
				cur->value = strdup(value);
3480b2cc:	e1a00006 	mov	r0, r6
			cur->name = strdup(name);
			if(cur->name == 0) {
				free(cur);
				result = -1;
			} else {
				struct variables *bottom = top_vars;
3480b2d0:	e5939000 	ldr	r9, [r3]
				cur->value = strdup(value);
3480b2d4:	eb00428f 	bl	3481bd18 <strdup>
				cur->next = 0;
3480b2d8:	e58a4010 	str	r4, [sl, #16]
			if(cur->name == 0) {
				free(cur);
				result = -1;
			} else {
				struct variables *bottom = top_vars;
				cur->value = strdup(value);
3480b2dc:	e98a0081 	stmib	sl, {r0, r7}
				cur->next = 0;
				cur->flg_export = flg_export;
				cur->flg_read_only = 0;
3480b2e0:	e58a400c 	str	r4, [sl, #12]
				while(bottom->next) bottom=bottom->next;
3480b2e4:	ea000000 	b	3480b2ec <set_local_var+0x15c>
3480b2e8:	e1a09004 	mov	r9, r4
3480b2ec:	e5994010 	ldr	r4, [r9, #16]
3480b2f0:	e3540000 	cmp	r4, #0
3480b2f4:	1afffffb 	bne	3480b2e8 <set_local_var+0x158>
				bottom->next = cur;
3480b2f8:	e589a010 	str	sl, [r9, #16]
3480b2fc:	ea000002 	b	3480b30c <set_local_var+0x17c>
	if(cur) {
		if(strcmp(cur->value, value)==0) {
			if(flg_export>0 && cur->flg_export==0)
				cur->flg_export=flg_export;
			else
				result++;
3480b300:	e3a04001 	mov	r4, #1
3480b304:	ea000000 	b	3480b30c <set_local_var+0x17c>
			}
		}
	} else {
		cur = malloc(sizeof(struct variables));
		if(!cur) {
			result = -1;
3480b308:	e3e04000 	mvn	r4, #0
	if(result==0 && cur->flg_export==1) {
		*(value-1) = '=';
		result = putenv(name);
	} else {
#endif
		free(name);
3480b30c:	e1a00005 	mov	r0, r5
3480b310:	ebfff8d1 	bl	3480965c <free>
#ifndef __U_BOOT__
		if(result>0)            /* equivalent to previous set */
			result = 0;
	}
#endif
	return result;
3480b314:	ea000000 	b	3480b31c <set_local_var+0x18c>
	struct variables *cur;

#ifdef __U_BOOT__
	/* might be possible! */
	if (!isalpha(*s))
		return -1;
3480b318:	e3e04000 	mvn	r4, #0
		if(result>0)            /* equivalent to previous set */
			result = 0;
	}
#endif
	return result;
}
3480b31c:	e1a00004 	mov	r0, r4
3480b320:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

				cur->value = strdup(value);
			}
		}
	} else {
		cur = malloc(sizeof(struct variables));
3480b324:	e3a00014 	mov	r0, #20
3480b328:	ebfff954 	bl	34809880 <malloc>
		if(!cur) {
3480b32c:	e250a000 	subs	sl, r0, #0
3480b330:	1affffdc 	bne	3480b2a8 <set_local_var+0x118>
3480b334:	eafffff3 	b	3480b308 <set_local_var+0x178>
3480b338:	34821cd4 	.word	0x34821cd4
3480b33c:	348261af 	.word	0x348261af
3480b340:	34829dc4 	.word	0x34829dc4
3480b344:	348261f2 	.word	0x348261f2

3480b348 <insert_var_value_sub>:
{
	return insert_var_value_sub(inp, 0);
}

static char *insert_var_value_sub(char *inp, int tag_subst)
{
3480b348:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	int res_str_len = 0;
	int len;
	int done = 0;
	char *p, *p1, *res_str = NULL;
3480b34c:	e3a04000 	mov	r4, #0
{
	return insert_var_value_sub(inp, 0);
}

static char *insert_var_value_sub(char *inp, int tag_subst)
{
3480b350:	e1a09000 	mov	r9, r0
3480b354:	e58d100c 	str	r1, [sp, #12]
	int res_str_len = 0;
	int len;
	int done = 0;
3480b358:	e1a05004 	mov	r5, r4
	return insert_var_value_sub(inp, 0);
}

static char *insert_var_value_sub(char *inp, int tag_subst)
{
	int res_str_len = 0;
3480b35c:	e1a07004 	mov	r7, r4
3480b360:	e1a06004 	mov	r6, r4
	int len;
	int done = 0;
	char *p, *p1, *res_str = NULL;

	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
3480b364:	ea00008a 	b	3480b594 <insert_var_value_sub+0x24c>
		/* check the beginning of the string for normal charachters */
		if (p != inp) {
3480b368:	e15b0009 	cmp	fp, r9
3480b36c:	0a00000a 	beq	3480b39c <insert_var_value_sub+0x54>
			/* copy any charachters to the result string */
			len = p - inp;
3480b370:	e069500b 	rsb	r5, r9, fp
			res_str = xrealloc(res_str, (res_str_len + len));
3480b374:	e0854007 	add	r4, r5, r7
3480b378:	e1a00006 	mov	r0, r6
3480b37c:	e1a01004 	mov	r1, r4
3480b380:	ebffff03 	bl	3480af94 <xrealloc>
			strncpy((res_str + res_str_len), inp, len);
3480b384:	e1a01009 	mov	r1, r9
	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
		/* check the beginning of the string for normal charachters */
		if (p != inp) {
			/* copy any charachters to the result string */
			len = p - inp;
			res_str = xrealloc(res_str, (res_str_len + len));
3480b388:	e1a06000 	mov	r6, r0
			strncpy((res_str + res_str_len), inp, len);
3480b38c:	e1a02005 	mov	r2, r5
3480b390:	e0800007 	add	r0, r0, r7
3480b394:	eb0041cc 	bl	3481bacc <strncpy>
			res_str_len += len;
3480b398:	e1a07004 	mov	r7, r4
		}
		inp = ++p;
3480b39c:	e28bb001 	add	fp, fp, #1
		/* find the ending marker */
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
3480b3a0:	e1a0000b 	mov	r0, fp
3480b3a4:	e3a01003 	mov	r1, #3
3480b3a8:	eb00420f 	bl	3481bbec <strchr>
		*p = '\0';
3480b3ac:	e3a03000 	mov	r3, #0
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;

	if (!src)
3480b3b0:	e35b0000 	cmp	fp, #0
			strncpy((res_str + res_str_len), inp, len);
			res_str_len += len;
		}
		inp = ++p;
		/* find the ending marker */
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
3480b3b4:	e1a09000 	mov	r9, r0
		*p = '\0';
3480b3b8:	e5c03000 	strb	r3, [r0]
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;

	if (!src)
3480b3bc:	0a000071 	beq	3480b588 <insert_var_value_sub+0x240>
		return NULL;

	sep = strchr(src, ':');
3480b3c0:	e1a0000b 	mov	r0, fp
3480b3c4:	e3a0103a 	mov	r1, #58	; 0x3a
3480b3c8:	eb004207 	bl	3481bbec <strchr>

	if (sep) {
3480b3cc:	e250a000 	subs	sl, r0, #0
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480b3d0:	01a0500a 	moveq	r5, sl
static char *lookup_param(char *src)
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
3480b3d4:	01a0200a 	moveq	r2, sl
 * see the bash man page under "Parameter Expansion" */
static char *lookup_param(char *src)
{
	char *p;
	char *sep;
	char *default_val = NULL;
3480b3d8:	01a0400a 	moveq	r4, sl
	if (!src)
		return NULL;

	sep = strchr(src, ':');

	if (sep) {
3480b3dc:	0a000013 	beq	3480b430 <insert_var_value_sub+0xe8>
		*sep = '\0';
3480b3e0:	e3a03000 	mov	r3, #0
3480b3e4:	e5ca3000 	strb	r3, [sl]
		if (*(sep + 1) == '-')
3480b3e8:	e5da3001 	ldrb	r3, [sl, #1]
3480b3ec:	e353002d 	cmp	r3, #45	; 0x2d
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480b3f0:	03a05000 	moveq	r5, #0
	sep = strchr(src, ':');

	if (sep) {
		*sep = '\0';
		if (*(sep + 1) == '-')
			default_val = sep+2;
3480b3f4:	028a4002 	addeq	r4, sl, #2
3480b3f8:	01a02005 	moveq	r2, r5

	sep = strchr(src, ':');

	if (sep) {
		*sep = '\0';
		if (*(sep + 1) == '-')
3480b3fc:	0a00000b 	beq	3480b430 <insert_var_value_sub+0xe8>
			default_val = sep+2;
		if (*(sep + 1) == '=') {
3480b400:	e353003d 	cmp	r3, #61	; 0x3d
			default_val = sep+2;
3480b404:	028a4002 	addeq	r4, sl, #2
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480b408:	03a05000 	moveq	r5, #0
		*sep = '\0';
		if (*(sep + 1) == '-')
			default_val = sep+2;
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
3480b40c:	03a02001 	moveq	r2, #1

	if (sep) {
		*sep = '\0';
		if (*(sep + 1) == '-')
			default_val = sep+2;
		if (*(sep + 1) == '=') {
3480b410:	0a000006 	beq	3480b430 <insert_var_value_sub+0xe8>
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
3480b414:	e353002b 	cmp	r3, #43	; 0x2b
{
	char *p;
	char *sep;
	char *default_val = NULL;
	int assign = 0;
	int expand_empty = 0;
3480b418:	13a05000 	movne	r5, #0
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
			default_val = sep+2;
3480b41c:	028a4002 	addeq	r4, sl, #2
			expand_empty = 1;
3480b420:	03a05001 	moveq	r5, #1
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
			default_val = sep+2;
3480b424:	03a02000 	moveq	r2, #0
			default_val = sep+2;
		if (*(sep + 1) == '=') {
			default_val = sep+2;
			assign = 1;
		}
		if (*(sep + 1) == '+') {
3480b428:	11a02005 	movne	r2, r5
 * see the bash man page under "Parameter Expansion" */
static char *lookup_param(char *src)
{
	char *p;
	char *sep;
	char *default_val = NULL;
3480b42c:	11a04005 	movne	r4, r5
			default_val = sep+2;
			expand_empty = 1;
		}
	}

	p = getenv(src);
3480b430:	e1a0000b 	mov	r0, fp
3480b434:	e58d2004 	str	r2, [sp, #4]
3480b438:	ebfff05b 	bl	348075ac <getenv>
	if (!p)
3480b43c:	e2503000 	subs	r3, r0, #0
3480b440:	e59d2004 	ldr	r2, [sp, #4]
3480b444:	1a000004 	bne	3480b45c <insert_var_value_sub+0x114>
		p = get_local_var(src);
3480b448:	e1a0000b 	mov	r0, fp
3480b44c:	ebffff2b 	bl	3480b100 <get_local_var>

	if (!p || strlen(p) == 0) {
3480b450:	e2503000 	subs	r3, r0, #0
3480b454:	e59d2004 	ldr	r2, [sp, #4]
3480b458:	0a000005 	beq	3480b474 <insert_var_value_sub+0x12c>
3480b45c:	e1a00003 	mov	r0, r3
3480b460:	e98d000c 	stmib	sp, {r2, r3}
3480b464:	eb0041f6 	bl	3481bc44 <strlen>
3480b468:	e3500000 	cmp	r0, #0
3480b46c:	e99d000c 	ldmib	sp, {r2, r3}
3480b470:	1a000015 	bne	3480b4cc <insert_var_value_sub+0x184>
		p = default_val;
		if (assign) {
3480b474:	e3520000 	cmp	r2, #0
3480b478:	0a00001b 	beq	3480b4ec <insert_var_value_sub+0x1a4>
			char *var = malloc(strlen(src)+strlen(default_val)+2);
3480b47c:	e1a0000b 	mov	r0, fp
3480b480:	eb0041ef 	bl	3481bc44 <strlen>
3480b484:	e1a05000 	mov	r5, r0
3480b488:	e1a00004 	mov	r0, r4
3480b48c:	eb0041ec 	bl	3481bc44 <strlen>
3480b490:	e0850000 	add	r0, r5, r0
3480b494:	e2800002 	add	r0, r0, #2
3480b498:	ebfff8f8 	bl	34809880 <malloc>
			if (var) {
3480b49c:	e2505000 	subs	r5, r0, #0
3480b4a0:	0a000006 	beq	3480b4c0 <insert_var_value_sub+0x178>
				sprintf(var, "%s=%s", src, default_val);
3480b4a4:	e59f1164 	ldr	r1, [pc, #356]	; 3480b610 <insert_var_value_sub+0x2c8>
3480b4a8:	e1a0200b 	mov	r2, fp
3480b4ac:	e1a03004 	mov	r3, r4
3480b4b0:	eb00461c 	bl	3481cd28 <sprintf>
				set_local_var(var, 0);
3480b4b4:	e1a00005 	mov	r0, r5
3480b4b8:	e3a01000 	mov	r1, #0
3480b4bc:	ebffff33 	bl	3480b190 <set_local_var>
			}
			free(var);
3480b4c0:	e1a00005 	mov	r0, r5
3480b4c4:	ebfff864 	bl	3480965c <free>
3480b4c8:	ea000007 	b	3480b4ec <insert_var_value_sub+0x1a4>
		}
	} else if (expand_empty) {
3480b4cc:	e3550000 	cmp	r5, #0
3480b4d0:	01a04003 	moveq	r4, r3
3480b4d4:	0a000004 	beq	3480b4ec <insert_var_value_sub+0x1a4>
		p += strlen(p);
3480b4d8:	e1a00003 	mov	r0, r3
3480b4dc:	e58d3008 	str	r3, [sp, #8]
3480b4e0:	eb0041d7 	bl	3481bc44 <strlen>
3480b4e4:	e59d3008 	ldr	r3, [sp, #8]
3480b4e8:	e0834000 	add	r4, r3, r0
	}

	if (sep)
3480b4ec:	e35a0000 	cmp	sl, #0
		*sep = ':';
3480b4f0:	13a0303a 	movne	r3, #58	; 0x3a
3480b4f4:	15ca3000 	strbne	r3, [sl]
		inp = ++p;
		/* find the ending marker */
		p = strchr(inp, SPECIAL_VAR_SYMBOL);
		*p = '\0';
		/* look up the value to substitute */
		if ((p1 = lookup_param(inp))) {
3480b4f8:	e3540000 	cmp	r4, #0
3480b4fc:	0a000021 	beq	3480b588 <insert_var_value_sub+0x240>
			if (tag_subst)
3480b500:	e59d300c 	ldr	r3, [sp, #12]
3480b504:	e3530000 	cmp	r3, #0
3480b508:	0a000004 	beq	3480b520 <insert_var_value_sub+0x1d8>
				len = res_str_len + strlen(p1) + 2;
3480b50c:	e1a00004 	mov	r0, r4
3480b510:	eb0041cb 	bl	3481bc44 <strlen>
3480b514:	e2875002 	add	r5, r7, #2
3480b518:	e0855000 	add	r5, r5, r0
3480b51c:	ea000002 	b	3480b52c <insert_var_value_sub+0x1e4>
			else
				len = res_str_len + strlen(p1);
3480b520:	e1a00004 	mov	r0, r4
3480b524:	eb0041c6 	bl	3481bc44 <strlen>
3480b528:	e0805007 	add	r5, r0, r7
			res_str = xrealloc(res_str, (1 + len));
3480b52c:	e1a00006 	mov	r0, r6
3480b530:	e2851001 	add	r1, r5, #1
3480b534:	ebfffe96 	bl	3480af94 <xrealloc>
			if (tag_subst) {
3480b538:	e59d300c 	ldr	r3, [sp, #12]
		if ((p1 = lookup_param(inp))) {
			if (tag_subst)
				len = res_str_len + strlen(p1) + 2;
			else
				len = res_str_len + strlen(p1);
			res_str = xrealloc(res_str, (1 + len));
3480b53c:	e1a06000 	mov	r6, r0
			if (tag_subst) {
3480b540:	e3530000 	cmp	r3, #0
3480b544:	0a00000b 	beq	3480b578 <insert_var_value_sub+0x230>
				/*
				 * copy the variable value to the result
				 * string
				 */
				strcpy((res_str + res_str_len + 1), p1);
3480b548:	e287a001 	add	sl, r7, #1
3480b54c:	e080a00a 	add	sl, r0, sl
3480b550:	e1a01004 	mov	r1, r4
3480b554:	e1a0000a 	mov	r0, sl
3480b558:	eb004154 	bl	3481bab0 <strcpy>

				/*
				 * mark the replaced text to be accepted as
				 * is
				 */
				res_str[res_str_len] = SUBSTED_VAR_SYMBOL;
3480b55c:	e3a03004 	mov	r3, #4
3480b560:	e7c63007 	strb	r3, [r6, r7]
				res_str[res_str_len + 1 + strlen(p1)] =
3480b564:	e1a00004 	mov	r0, r4
3480b568:	eb0041b5 	bl	3481bc44 <strlen>
3480b56c:	e3a03004 	mov	r3, #4
3480b570:	e7ca3000 	strb	r3, [sl, r0]
3480b574:	ea000002 	b	3480b584 <insert_var_value_sub+0x23c>
			} else
				/*
				 * copy the variable value to the result
				 * string
				 */
				strcpy((res_str + res_str_len), p1);
3480b578:	e0800007 	add	r0, r0, r7
3480b57c:	e1a01004 	mov	r1, r4
3480b580:	eb00414a 	bl	3481bab0 <strcpy>

			res_str_len = len;
3480b584:	e1a07005 	mov	r7, r5
		}
		*p = SPECIAL_VAR_SYMBOL;
3480b588:	e3a03003 	mov	r3, #3
3480b58c:	e4c93001 	strb	r3, [r9], #1
		inp = ++p;
		done = 1;
3480b590:	e3a05001 	mov	r5, #1
	int res_str_len = 0;
	int len;
	int done = 0;
	char *p, *p1, *res_str = NULL;

	while ((p = strchr(inp, SPECIAL_VAR_SYMBOL))) {
3480b594:	e1a00009 	mov	r0, r9
3480b598:	e3a01003 	mov	r1, #3
3480b59c:	eb004192 	bl	3481bbec <strchr>
3480b5a0:	e250b000 	subs	fp, r0, #0
3480b5a4:	1affff6f 	bne	3480b368 <insert_var_value_sub+0x20>
		}
		*p = SPECIAL_VAR_SYMBOL;
		inp = ++p;
		done = 1;
	}
	if (done) {
3480b5a8:	e3550000 	cmp	r5, #0
3480b5ac:	e1a04006 	mov	r4, r6
3480b5b0:	0a000011 	beq	3480b5fc <insert_var_value_sub+0x2b4>
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
3480b5b4:	e1a00009 	mov	r0, r9
3480b5b8:	eb0041a1 	bl	3481bc44 <strlen>
3480b5bc:	e2871001 	add	r1, r7, #1
3480b5c0:	e0811000 	add	r1, r1, r0
3480b5c4:	e1a00006 	mov	r0, r6
3480b5c8:	ebfffe71 	bl	3480af94 <xrealloc>
		strcpy((res_str + res_str_len), inp);
3480b5cc:	e1a01009 	mov	r1, r9
		*p = SPECIAL_VAR_SYMBOL;
		inp = ++p;
		done = 1;
	}
	if (done) {
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
3480b5d0:	e1a04000 	mov	r4, r0
		strcpy((res_str + res_str_len), inp);
3480b5d4:	e0800007 	add	r0, r0, r7
3480b5d8:	eb004134 	bl	3481bab0 <strcpy>
		while ((p = strchr(res_str, '\n'))) {
			*p = ' ';
3480b5dc:	e3a05020 	mov	r5, #32
		done = 1;
	}
	if (done) {
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
		strcpy((res_str + res_str_len), inp);
		while ((p = strchr(res_str, '\n'))) {
3480b5e0:	ea000000 	b	3480b5e8 <insert_var_value_sub+0x2a0>
			*p = ' ';
3480b5e4:	e5c05000 	strb	r5, [r0]
		done = 1;
	}
	if (done) {
		res_str = xrealloc(res_str, (1 + res_str_len + strlen(inp)));
		strcpy((res_str + res_str_len), inp);
		while ((p = strchr(res_str, '\n'))) {
3480b5e8:	e1a00004 	mov	r0, r4
3480b5ec:	e3a0100a 	mov	r1, #10
3480b5f0:	eb00417d 	bl	3481bbec <strchr>
3480b5f4:	e3500000 	cmp	r0, #0
3480b5f8:	1afffff9 	bne	3480b5e4 <insert_var_value_sub+0x29c>
			*p = ' ';
		}
	}
	return (res_str == NULL) ? inp : res_str;
}
3480b5fc:	e3540000 	cmp	r4, #0
3480b600:	11a00004 	movne	r0, r4
3480b604:	01a00009 	moveq	r0, r9
3480b608:	e28dd010 	add	sp, sp, #16
3480b60c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480b610:	34826208 	.word	0x34826208

3480b614 <unset_local_var>:
#endif
	return result;
}

void unset_local_var(const char *name)
{
3480b614:	e92d4070 	push	{r4, r5, r6, lr}
	struct variables *cur;

	if (name) {
3480b618:	e2505000 	subs	r5, r0, #0
		for (cur = top_vars; cur; cur=cur->next) {
3480b61c:	159f3088 	ldrne	r3, [pc, #136]	; 3480b6ac <unset_local_var+0x98>
3480b620:	15934000 	ldrne	r4, [r3]

void unset_local_var(const char *name)
{
	struct variables *cur;

	if (name) {
3480b624:	1a000006 	bne	3480b644 <unset_local_var+0x30>
3480b628:	e8bd8070 	pop	{r4, r5, r6, pc}
		for (cur = top_vars; cur; cur=cur->next) {
			if(strcmp(cur->name, name)==0)
3480b62c:	e5940000 	ldr	r0, [r4]
3480b630:	e1a01005 	mov	r1, r5
3480b634:	eb00414e 	bl	3481bb74 <strcmp>
3480b638:	e3500000 	cmp	r0, #0
3480b63c:	0a000003 	beq	3480b650 <unset_local_var+0x3c>
void unset_local_var(const char *name)
{
	struct variables *cur;

	if (name) {
		for (cur = top_vars; cur; cur=cur->next) {
3480b640:	e5944010 	ldr	r4, [r4, #16]
3480b644:	e3540000 	cmp	r4, #0
3480b648:	1afffff7 	bne	3480b62c <unset_local_var+0x18>
3480b64c:	e8bd8070 	pop	{r4, r5, r6, pc}
			if(strcmp(cur->name, name)==0)
				break;
		}
		if(cur!=0) {
			struct variables *next = top_vars;
3480b650:	e59f3054 	ldr	r3, [pc, #84]	; 3480b6ac <unset_local_var+0x98>
3480b654:	e5936000 	ldr	r6, [r3]
			if(cur->flg_read_only) {
3480b658:	e594300c 	ldr	r3, [r4, #12]
3480b65c:	e3530000 	cmp	r3, #0
3480b660:	0a000003 	beq	3480b674 <unset_local_var+0x60>
				error_msg("%s: readonly variable", name);
3480b664:	e59f0044 	ldr	r0, [pc, #68]	; 3480b6b0 <unset_local_var+0x9c>
3480b668:	e1a01005 	mov	r1, r5
				next->next = cur->next;
			}
			free(cur);
		}
	}
}
3480b66c:	e8bd4070 	pop	{r4, r5, r6, lr}
				break;
		}
		if(cur!=0) {
			struct variables *next = top_vars;
			if(cur->flg_read_only) {
				error_msg("%s: readonly variable", name);
3480b670:	eafff6bb 	b	34809164 <printf>
			} else {
#ifndef __U_BOOT__
				if(cur->flg_export)
					unsetenv(cur->name);
#endif
				free(cur->name);
3480b674:	e5940000 	ldr	r0, [r4]
3480b678:	ebfff7f7 	bl	3480965c <free>
				free(cur->value);
3480b67c:	e5940004 	ldr	r0, [r4, #4]
3480b680:	ebfff7f5 	bl	3480965c <free>
				while (next->next != cur)
3480b684:	ea000000 	b	3480b68c <unset_local_var+0x78>
3480b688:	e1a06003 	mov	r6, r3
3480b68c:	e5963010 	ldr	r3, [r6, #16]
3480b690:	e1530004 	cmp	r3, r4
3480b694:	1afffffb 	bne	3480b688 <unset_local_var+0x74>
					next = next->next;
				next->next = cur->next;
3480b698:	e5943010 	ldr	r3, [r4, #16]
			}
			free(cur);
3480b69c:	e1a00004 	mov	r0, r4
#endif
				free(cur->name);
				free(cur->value);
				while (next->next != cur)
					next = next->next;
				next->next = cur->next;
3480b6a0:	e5863010 	str	r3, [r6, #16]
			}
			free(cur);
		}
	}
}
3480b6a4:	e8bd4070 	pop	{r4, r5, r6, lr}
				free(cur->value);
				while (next->next != cur)
					next = next->next;
				next->next = cur->next;
			}
			free(cur);
3480b6a8:	eafff7eb 	b	3480965c <free>
3480b6ac:	34829dc4 	.word	0x34829dc4
3480b6b0:	348261f2 	.word	0x348261f2

3480b6b4 <new_pipe>:
	}
	return 0;
}
#endif

struct pipe *new_pipe(void) {
3480b6b4:	e92d4008 	push	{r3, lr}
	struct pipe *pi;
	pi = xmalloc(sizeof(struct pipe));
3480b6b8:	e3a00014 	mov	r0, #20
3480b6bc:	ebfffd8b 	bl	3480acf0 <xmalloc>
	pi->num_progs = 0;
3480b6c0:	e3a02000 	mov	r2, #0
3480b6c4:	e5802000 	str	r2, [r0]
	pi->progs = NULL;
3480b6c8:	e5802004 	str	r2, [r0, #4]
	pi->next = NULL;
3480b6cc:	e5802008 	str	r2, [r0, #8]
	pi->followup = 0;  /* invalid */
3480b6d0:	e580200c 	str	r2, [r0, #12]
	pi->r_mode = RES_NONE;
3480b6d4:	e5802010 	str	r2, [r0, #16]
	return pi;
}
3480b6d8:	e8bd8008 	pop	{r3, pc}

3480b6dc <done_pipe>:
	/* but ctx->pipe and ctx->list_head remain unchanged */
	return 0;
}

static int done_pipe(struct p_context *ctx, pipe_style type)
{
3480b6dc:	e92d4038 	push	{r3, r4, r5, lr}
3480b6e0:	e1a04000 	mov	r4, r0
3480b6e4:	e1a05001 	mov	r5, r1
	struct pipe *new_p;
	done_command(ctx);  /* implicit closure of previous command */
3480b6e8:	ebfffe31 	bl	3480afb4 <done_command>
	debug_printf("done_pipe, type %d\n", type);
	ctx->pipe->followup = type;
3480b6ec:	e5943008 	ldr	r3, [r4, #8]
	ctx->pipe->r_mode = ctx->w;
3480b6f0:	e594200c 	ldr	r2, [r4, #12]
static int done_pipe(struct p_context *ctx, pipe_style type)
{
	struct pipe *new_p;
	done_command(ctx);  /* implicit closure of previous command */
	debug_printf("done_pipe, type %d\n", type);
	ctx->pipe->followup = type;
3480b6f4:	e583500c 	str	r5, [r3, #12]
	ctx->pipe->r_mode = ctx->w;
3480b6f8:	e5832010 	str	r2, [r3, #16]
	new_p=new_pipe();
3480b6fc:	ebffffec 	bl	3480b6b4 <new_pipe>
	ctx->pipe->next = new_p;
3480b700:	e5943008 	ldr	r3, [r4, #8]
	ctx->pipe = new_p;
	ctx->child = NULL;
3480b704:	e3a05000 	mov	r5, #0
	done_command(ctx);  /* implicit closure of previous command */
	debug_printf("done_pipe, type %d\n", type);
	ctx->pipe->followup = type;
	ctx->pipe->r_mode = ctx->w;
	new_p=new_pipe();
	ctx->pipe->next = new_p;
3480b708:	e5830008 	str	r0, [r3, #8]
	ctx->pipe = new_p;
3480b70c:	e5840008 	str	r0, [r4, #8]
	ctx->child = NULL;
3480b710:	e5845000 	str	r5, [r4]
	done_command(ctx);  /* set up new pipe to accept commands */
3480b714:	e1a00004 	mov	r0, r4
3480b718:	ebfffe25 	bl	3480afb4 <done_command>
	return 0;
}
3480b71c:	e1a00005 	mov	r0, r5
3480b720:	e8bd8038 	pop	{r3, r4, r5, pc}

3480b724 <reserved_word>:
	{ "done",  RES_DONE,  FLAG_END  }
};
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
{
3480b724:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	{ "do",    RES_DO,    FLAG_DONE },
	{ "done",  RES_DONE,  FLAG_END  }
};
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
3480b728:	e59f719c 	ldr	r7, [pc, #412]	; 3480b8cc <reserved_word+0x1a8>
{
	struct reserved_combo *r;
	for (r=reserved_list;
3480b72c:	e59f619c 	ldr	r6, [pc, #412]	; 3480b8d0 <reserved_word+0x1ac>
	{ "done",  RES_DONE,  FLAG_END  }
};
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
{
3480b730:	e1a05000 	mov	r5, r0
3480b734:	e1a04001 	mov	r4, r1
	struct reserved_combo *r;
	for (r=reserved_list;
		r<reserved_list+NRES; r++) {
		if (strcmp(dest->data, r->literal) == 0) {
3480b738:	e5950000 	ldr	r0, [r5]
3480b73c:	e5961000 	ldr	r1, [r6]
3480b740:	eb00410b 	bl	3481bb74 <strcmp>
3480b744:	e2509000 	subs	r9, r0, #0
3480b748:	1a000056 	bne	3480b8a8 <reserved_word+0x184>
			debug_printf("found reserved word %s, code %d\n",r->literal,r->code);
			if (r->flag & FLAG_START) {
3480b74c:	e5963008 	ldr	r3, [r6, #8]
3480b750:	e3130b02 	tst	r3, #2048	; 0x800
3480b754:	0a000025 	beq	3480b7f0 <reserved_word+0xcc>
				struct p_context *new = xmalloc(sizeof(struct p_context));
3480b758:	e280001c 	add	r0, r0, #28
3480b75c:	ebfffd63 	bl	3480acf0 <xmalloc>
				debug_printf("push stack\n");
				if (ctx->w == RES_IN || ctx->w == RES_FOR) {
3480b760:	e594700c 	ldr	r7, [r4, #12]
	for (r=reserved_list;
		r<reserved_list+NRES; r++) {
		if (strcmp(dest->data, r->literal) == 0) {
			debug_printf("found reserved word %s, code %d\n",r->literal,r->code);
			if (r->flag & FLAG_START) {
				struct p_context *new = xmalloc(sizeof(struct p_context));
3480b764:	e1a0a000 	mov	sl, r0
				debug_printf("push stack\n");
				if (ctx->w == RES_IN || ctx->w == RES_FOR) {
3480b768:	e357000c 	cmp	r7, #12
3480b76c:	13570006 	cmpne	r7, #6
3480b770:	13a07000 	movne	r7, #0
3480b774:	03a07001 	moveq	r7, #1
3480b778:	1a00000a 	bne	3480b7a8 <reserved_word+0x84>
					syntax();
3480b77c:	ebfffd1c 	bl	3480abf4 <syntax_err>
					free(new);
3480b780:	e1a0000a 	mov	r0, sl
3480b784:	ebfff7b4 	bl	3480965c <free>
					ctx->w = RES_SNTX;
3480b788:	e3a0300d 	mov	r3, #13
3480b78c:	e584300c 	str	r3, [r4, #12]

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b790:	e5953000 	ldr	r3, [r5]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480b794:	e5859004 	str	r9, [r5, #4]
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b798:	e3530000 	cmp	r3, #0
}

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
3480b79c:	e5859010 	str	r9, [r5, #16]
	if (o->data != NULL) *o->data = '\0';
3480b7a0:	15c39000 	strbne	r9, [r3]
3480b7a4:	ea000044 	b	3480b8bc <reserved_word+0x198>
					free(new);
					ctx->w = RES_SNTX;
					b_reset(dest);
					return 1;
				}
				*new = *ctx;   /* physical copy */
3480b7a8:	e1a0c004 	mov	ip, r4
3480b7ac:	e1a0e00a 	mov	lr, sl
3480b7b0:	e8bc000f 	ldm	ip!, {r0, r1, r2, r3}
3480b7b4:	e8ae000f 	stmia	lr!, {r0, r1, r2, r3}
3480b7b8:	e89c0007 	ldm	ip, {r0, r1, r2}
3480b7bc:	e88e0007 	stm	lr, {r0, r1, r2}
	return pi;
}

static void initialize_context(struct p_context *ctx)
{
	ctx->pipe=NULL;
3480b7c0:	e5847008 	str	r7, [r4, #8]
#ifndef __U_BOOT__
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
3480b7c4:	e5847000 	str	r7, [r4]
	ctx->list_head=new_pipe();
3480b7c8:	ebffffb9 	bl	3480b6b4 <new_pipe>
	ctx->pipe=ctx->list_head;
	ctx->w=RES_NONE;
3480b7cc:	e584700c 	str	r7, [r4, #12]
	ctx->pipe=NULL;
#ifndef __U_BOOT__
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
	ctx->list_head=new_pipe();
3480b7d0:	e5840004 	str	r0, [r4, #4]
	ctx->pipe=ctx->list_head;
3480b7d4:	e5840008 	str	r0, [r4, #8]
	ctx->w=RES_NONE;
	ctx->stack=NULL;
3480b7d8:	e5847014 	str	r7, [r4, #20]
#ifdef __U_BOOT__
	ctx->old_flag=0;
3480b7dc:	e5847010 	str	r7, [r4, #16]
#endif
	done_command(ctx);   /* creates the memory for working child */
3480b7e0:	e1a00004 	mov	r0, r4
3480b7e4:	ebfffdf2 	bl	3480afb4 <done_command>
					b_reset(dest);
					return 1;
				}
				*new = *ctx;   /* physical copy */
				initialize_context(ctx);
				ctx->stack=new;
3480b7e8:	e584a014 	str	sl, [r4, #20]
3480b7ec:	ea000011 	b	3480b838 <reserved_word+0x114>
			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
3480b7f0:	e594300c 	ldr	r3, [r4, #12]
3480b7f4:	e3530000 	cmp	r3, #0
3480b7f8:	0a000004 	beq	3480b810 <reserved_word+0xec>
3480b7fc:	e5942010 	ldr	r2, [r4, #16]
3480b800:	e5963004 	ldr	r3, [r6, #4]
3480b804:	e1a03352 	asr	r3, r2, r3
3480b808:	e3130001 	tst	r3, #1
3480b80c:	1a000009 	bne	3480b838 <reserved_word+0x114>
				syntax();
3480b810:	ebfffcf7 	bl	3480abf4 <syntax_err>
				ctx->w = RES_SNTX;
3480b814:	e3a0300d 	mov	r3, #13

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b818:	e5952000 	ldr	r2, [r5]
				*new = *ctx;   /* physical copy */
				initialize_context(ctx);
				ctx->stack=new;
			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
				syntax();
				ctx->w = RES_SNTX;
3480b81c:	e584300c 	str	r3, [r4, #12]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480b820:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b824:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480b828:	e5853004 	str	r3, [r5, #4]
	o->nonnull = 0;
3480b82c:	e5853010 	str	r3, [r5, #16]
	if (o->data != NULL) *o->data = '\0';
3480b830:	1a00001a 	bne	3480b8a0 <reserved_word+0x17c>
3480b834:	ea000020 	b	3480b8bc <reserved_word+0x198>
				syntax();
				ctx->w = RES_SNTX;
				b_reset(dest);
				return 1;
			}
			ctx->w=r->code;
3480b838:	e5963004 	ldr	r3, [r6, #4]
3480b83c:	e584300c 	str	r3, [r4, #12]
			ctx->old_flag = r->flag;
3480b840:	e5963008 	ldr	r3, [r6, #8]
			if (ctx->old_flag & FLAG_END) {
3480b844:	e3130001 	tst	r3, #1
				ctx->w = RES_SNTX;
				b_reset(dest);
				return 1;
			}
			ctx->w=r->code;
			ctx->old_flag = r->flag;
3480b848:	e5843010 	str	r3, [r4, #16]
			if (ctx->old_flag & FLAG_END) {
3480b84c:	0a00000d 	beq	3480b888 <reserved_word+0x164>
				struct p_context *old;
				debug_printf("pop stack\n");
				done_pipe(ctx,PIPE_SEQ);
3480b850:	e1a00004 	mov	r0, r4
3480b854:	e3a01001 	mov	r1, #1
3480b858:	ebffff9f 	bl	3480b6dc <done_pipe>
				old = ctx->stack;
3480b85c:	e594c014 	ldr	ip, [r4, #20]
				old->child->group = ctx->list_head;
3480b860:	e5942004 	ldr	r2, [r4, #4]
3480b864:	e59c3000 	ldr	r3, [ip]
#ifndef __U_BOOT__
				old->child->subshell = 0;
#endif
				*ctx = *old;   /* physical copy */
3480b868:	e1a0e00c 	mov	lr, ip
			if (ctx->old_flag & FLAG_END) {
				struct p_context *old;
				debug_printf("pop stack\n");
				done_pipe(ctx,PIPE_SEQ);
				old = ctx->stack;
				old->child->group = ctx->list_head;
3480b86c:	e5832008 	str	r2, [r3, #8]
#ifndef __U_BOOT__
				old->child->subshell = 0;
#endif
				*ctx = *old;   /* physical copy */
3480b870:	e8be000f 	ldm	lr!, {r0, r1, r2, r3}
3480b874:	e8a4000f 	stmia	r4!, {r0, r1, r2, r3}
3480b878:	e89e0007 	ldm	lr, {r0, r1, r2}
3480b87c:	e8840007 	stm	r4, {r0, r1, r2}
				free(old);
3480b880:	e1a0000c 	mov	r0, ip
3480b884:	ebfff774 	bl	3480965c <free>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b888:	e5952000 	ldr	r2, [r5]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480b88c:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b890:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480b894:	e5853004 	str	r3, [r5, #4]
	o->nonnull = 0;
3480b898:	e5853010 	str	r3, [r5, #16]
	if (o->data != NULL) *o->data = '\0';
3480b89c:	0a000008 	beq	3480b8c4 <reserved_word+0x1a0>
3480b8a0:	e5c23000 	strb	r3, [r2]
3480b8a4:	ea000004 	b	3480b8bc <reserved_word+0x198>

int reserved_word(o_string *dest, struct p_context *ctx)
{
	struct reserved_combo *r;
	for (r=reserved_list;
		r<reserved_list+NRES; r++) {
3480b8a8:	e286600c 	add	r6, r6, #12
#define NRES (sizeof(reserved_list)/sizeof(struct reserved_combo))

int reserved_word(o_string *dest, struct p_context *ctx)
{
	struct reserved_combo *r;
	for (r=reserved_list;
3480b8ac:	e1560007 	cmp	r6, r7
3480b8b0:	1affffa0 	bne	3480b738 <reserved_word+0x14>
			}
			b_reset (dest);
			return 1;
		}
	}
	return 0;
3480b8b4:	e3a00000 	mov	r0, #0
3480b8b8:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
				ctx->stack=new;
			} else if ( ctx->w == RES_NONE || ! (ctx->old_flag & (1<<r->code))) {
				syntax();
				ctx->w = RES_SNTX;
				b_reset(dest);
				return 1;
3480b8bc:	e3a00001 	mov	r0, #1
3480b8c0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
#endif
				*ctx = *old;   /* physical copy */
				free(old);
			}
			b_reset (dest);
			return 1;
3480b8c4:	e3a00001 	mov	r0, #1
		}
	}
	return 0;
}
3480b8c8:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3480b8cc:	34828a3c 	.word	0x34828a3c
3480b8d0:	348289b8 	.word	0x348289b8

3480b8d4 <done_word>:

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
{
3480b8d4:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	char *str, *s;
	int argc, cnt;
#endif

	debug_printf("done_word: %s %p\n", dest->data, child);
	if (dest->length == 0 && !dest->nonnull) {
3480b8d8:	e5903004 	ldr	r3, [r0, #4]
}

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
{
3480b8dc:	e1a04000 	mov	r4, r0
	char *str, *s;
	int argc, cnt;
#endif

	debug_printf("done_word: %s %p\n", dest->data, child);
	if (dest->length == 0 && !dest->nonnull) {
3480b8e0:	e3530000 	cmp	r3, #0
}

/* normal return is 0.
 * Syntax or xglob errors return 1. */
static int done_word(o_string *dest, struct p_context *ctx)
{
3480b8e4:	e1a05001 	mov	r5, r1
	struct child_prog *child=ctx->child;
3480b8e8:	e5916000 	ldr	r6, [r1]
	char *str, *s;
	int argc, cnt;
#endif

	debug_printf("done_word: %s %p\n", dest->data, child);
	if (dest->length == 0 && !dest->nonnull) {
3480b8ec:	1a000002 	bne	3480b8fc <done_word+0x28>
3480b8f0:	e5900010 	ldr	r0, [r0, #16]
3480b8f4:	e3500000 	cmp	r0, #0
3480b8f8:	08bd86f8 	popeq	{r3, r4, r5, r6, r7, r9, sl, pc}
#ifndef __U_BOOT__
	if (ctx->pending_redirect) {
		glob_target = &ctx->pending_redirect->word;
	} else {
#endif
		if (child->group) {
3480b8fc:	e5963008 	ldr	r3, [r6, #8]
3480b900:	e3530000 	cmp	r3, #0
3480b904:	0a000001 	beq	3480b910 <done_word+0x3c>
			syntax();
3480b908:	ebfffcb9 	bl	3480abf4 <syntax_err>
3480b90c:	ea00004a 	b	3480ba3c <done_word+0x168>
			return 1;  /* syntax error, groups and arglists don't mix */
		}
		if (!child->argv && (ctx->type & FLAG_PARSE_SEMICOLON)) {
3480b910:	e5963000 	ldr	r3, [r6]
3480b914:	e3530000 	cmp	r3, #0
3480b918:	1a00000c 	bne	3480b950 <done_word+0x7c>
3480b91c:	e5953018 	ldr	r3, [r5, #24]
3480b920:	e3130002 	tst	r3, #2
3480b924:	0a000009 	beq	3480b950 <done_word+0x7c>
			debug_printf("checking %s for reserved-ness\n",dest->data);
			if (reserved_word(dest,ctx)) return ctx->w==RES_SNTX;
3480b928:	e1a00004 	mov	r0, r4
3480b92c:	e1a01005 	mov	r1, r5
3480b930:	ebffff7b 	bl	3480b724 <reserved_word>
3480b934:	e3500000 	cmp	r0, #0
3480b938:	0a000004 	beq	3480b950 <done_word+0x7c>
3480b93c:	e595000c 	ldr	r0, [r5, #12]
3480b940:	e350000d 	cmp	r0, #13
3480b944:	13a00000 	movne	r0, #0
3480b948:	03a00001 	moveq	r0, #1
3480b94c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		}
#ifndef __U_BOOT__
		glob_target = &child->glob_result;
		if (child->argv) flags |= GLOB_APPEND;
#else
		for (cnt = 1, s = dest->data; s && *s; s++) {
3480b950:	e5943000 	ldr	r3, [r4]
3480b954:	e3a00001 	mov	r0, #1
3480b958:	ea000003 	b	3480b96c <done_word+0x98>
			if (*s == '\\') s++;
3480b95c:	e352005c 	cmp	r2, #92	; 0x5c
3480b960:	02833001 	addeq	r3, r3, #1
			cnt++;
3480b964:	e2800001 	add	r0, r0, #1
		}
#ifndef __U_BOOT__
		glob_target = &child->glob_result;
		if (child->argv) flags |= GLOB_APPEND;
#else
		for (cnt = 1, s = dest->data; s && *s; s++) {
3480b968:	e2833001 	add	r3, r3, #1
3480b96c:	e3530000 	cmp	r3, #0
3480b970:	0a000002 	beq	3480b980 <done_word+0xac>
3480b974:	e5d32000 	ldrb	r2, [r3]
3480b978:	e3520000 	cmp	r2, #0
3480b97c:	1afffff6 	bne	3480b95c <done_word+0x88>
			if (*s == '\\') s++;
			cnt++;
		}
		str = malloc(cnt);
3480b980:	ebfff7be 	bl	34809880 <malloc>
		if (!str) return 1;
3480b984:	e2507000 	subs	r7, r0, #0
3480b988:	0a00002b 	beq	3480ba3c <done_word+0x168>
		if ( child->argv == NULL) {
3480b98c:	e5960000 	ldr	r0, [r6]
3480b990:	e3500000 	cmp	r0, #0
			child->argc=0;
3480b994:	05860004 	streq	r0, [r6, #4]
		}
		argc = ++child->argc;
3480b998:	e5969004 	ldr	r9, [r6, #4]
3480b99c:	e289a001 	add	sl, r9, #1
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
3480b9a0:	e28a1001 	add	r1, sl, #1
		str = malloc(cnt);
		if (!str) return 1;
		if ( child->argv == NULL) {
			child->argc=0;
		}
		argc = ++child->argc;
3480b9a4:	e586a004 	str	sl, [r6, #4]
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
3480b9a8:	e1a01101 	lsl	r1, r1, #2
3480b9ac:	ebfff9a5 	bl	3480a048 <realloc>
		if (child->argv == NULL) return 1;
3480b9b0:	e3500000 	cmp	r0, #0
		if (!str) return 1;
		if ( child->argv == NULL) {
			child->argc=0;
		}
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
3480b9b4:	e5860000 	str	r0, [r6]
		if (child->argv == NULL) return 1;
3480b9b8:	0a00001f 	beq	3480ba3c <done_word+0x168>
		child->argv[argc-1]=str;
		child->argv[argc]=NULL;
3480b9bc:	e3a03000 	mov	r3, #0
			child->argc=0;
		}
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
		if (child->argv == NULL) return 1;
		child->argv[argc-1]=str;
3480b9c0:	e7807109 	str	r7, [r0, r9, lsl #2]
		child->argv[argc]=NULL;
3480b9c4:	e780310a 	str	r3, [r0, sl, lsl #2]
		for (s = dest->data; s && *s; s++,str++) {
3480b9c8:	e5943000 	ldr	r3, [r4]
3480b9cc:	ea000003 	b	3480b9e0 <done_word+0x10c>
			if (*s == '\\') s++;
3480b9d0:	e352005c 	cmp	r2, #92	; 0x5c
3480b9d4:	02833001 	addeq	r3, r3, #1
			*str = *s;
3480b9d8:	e4d32001 	ldrb	r2, [r3], #1
3480b9dc:	e4c72001 	strb	r2, [r7], #1
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
		if (child->argv == NULL) return 1;
		child->argv[argc-1]=str;
		child->argv[argc]=NULL;
		for (s = dest->data; s && *s; s++,str++) {
3480b9e0:	e3530000 	cmp	r3, #0
3480b9e4:	0a000002 	beq	3480b9f4 <done_word+0x120>
3480b9e8:	e5d32000 	ldrb	r2, [r3]
3480b9ec:	e3520000 	cmp	r2, #0
3480b9f0:	1afffff6 	bne	3480b9d0 <done_word+0xfc>
			if (*s == '\\') s++;
			*str = *s;
		}
		*str = '\0';
3480b9f4:	e3a03000 	mov	r3, #0
3480b9f8:	e5c73000 	strb	r3, [r7]

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480b9fc:	e5942000 	ldr	r2, [r4]
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480ba00:	e5843004 	str	r3, [r4, #4]
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480ba04:	e1520003 	cmp	r2, r3
}

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
3480ba08:	e5843010 	str	r3, [r4, #16]
	if (o->data != NULL) *o->data = '\0';
3480ba0c:	15c23000 	strbne	r3, [r2]
		}
	} else {
		child->argv = glob_target->gl_pathv;
	}
#endif
	if (ctx->w == RES_FOR) {
3480ba10:	e595300c 	ldr	r3, [r5, #12]
3480ba14:	e3530006 	cmp	r3, #6
3480ba18:	1a000009 	bne	3480ba44 <done_word+0x170>
		done_word(dest,ctx);
3480ba1c:	e1a01005 	mov	r1, r5
3480ba20:	e1a00004 	mov	r0, r4
3480ba24:	ebffffaa 	bl	3480b8d4 <done_word>
		done_pipe(ctx,PIPE_SEQ);
3480ba28:	e1a00005 	mov	r0, r5
3480ba2c:	e3a01001 	mov	r1, #1
3480ba30:	ebffff29 	bl	3480b6dc <done_pipe>
	}
	return 0;
3480ba34:	e3a00000 	mov	r0, #0
3480ba38:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		if ( child->argv == NULL) {
			child->argc=0;
		}
		argc = ++child->argc;
		child->argv = realloc(child->argv, (argc+1)*sizeof(*child->argv));
		if (child->argv == NULL) return 1;
3480ba3c:	e3a00001 	mov	r0, #1
3480ba40:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
#endif
	if (ctx->w == RES_FOR) {
		done_word(dest,ctx);
		done_pipe(ctx,PIPE_SEQ);
	}
	return 0;
3480ba44:	e3a00000 	mov	r0, #0
}
3480ba48:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

3480ba4c <mapset>:
}

void mapset(const unsigned char *set, int code)
{
	const unsigned char *s;
	for (s=set; *s; s++) map[*s] = code;
3480ba4c:	e59f2018 	ldr	r2, [pc, #24]	; 3480ba6c <mapset+0x20>
3480ba50:	ea000001 	b	3480ba5c <mapset+0x10>
3480ba54:	e0823003 	add	r3, r2, r3
3480ba58:	e5c31138 	strb	r1, [r3, #312]	; 0x138
3480ba5c:	e4d03001 	ldrb	r3, [r0], #1
3480ba60:	e3530000 	cmp	r3, #0
3480ba64:	1afffffa 	bne	3480ba54 <mapset+0x8>
}
3480ba68:	e12fff1e 	bx	lr
3480ba6c:	34829dc4 	.word	0x34829dc4

3480ba70 <update_ifs_map>:

void update_ifs_map(void)
{
3480ba70:	e92d4013 	push	{r0, r1, r4, lr}
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
3480ba74:	e59f006c 	ldr	r0, [pc, #108]	; 3480bae8 <update_ifs_map+0x78>
3480ba78:	ebffeecb 	bl	348075ac <getenv>
	if (ifs == NULL) ifs=(uchar *)" \t\n";
3480ba7c:	e3500000 	cmp	r0, #0
3480ba80:	059f2064 	ldreq	r2, [pc, #100]	; 3480baec <update_ifs_map+0x7c>
}

void update_ifs_map(void)
{
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
3480ba84:	e59f3064 	ldr	r3, [pc, #100]	; 3480baf0 <update_ifs_map+0x80>
	 * quickly up front.  Computation is necessary because of IFS.
	 * Special case handling of IFS == " \t\n" is not implemented.
	 * The map[] array only really needs two bits each, and on most machines
	 * that would be faster because of the reduced L1 cache footprint.
	 */
	memset(map,0,sizeof(map)); /* most characters flow through always */
3480ba88:	e59f4060 	ldr	r4, [pc, #96]	; 3480baf0 <update_ifs_map+0x80>
}

void update_ifs_map(void)
{
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
3480ba8c:	e5830238 	str	r0, [r3, #568]	; 0x238
	 * quickly up front.  Computation is necessary because of IFS.
	 * Special case handling of IFS == " \t\n" is not implemented.
	 * The map[] array only really needs two bits each, and on most machines
	 * that would be faster because of the reduced L1 cache footprint.
	 */
	memset(map,0,sizeof(map)); /* most characters flow through always */
3480ba90:	e3a01000 	mov	r1, #0

void update_ifs_map(void)
{
	/* char *ifs and char map[256] are both globals. */
	ifs = (uchar *)getenv("IFS");
	if (ifs == NULL) ifs=(uchar *)" \t\n";
3480ba94:	05832238 	streq	r2, [r3, #568]	; 0x238
	 * quickly up front.  Computation is necessary because of IFS.
	 * Special case handling of IFS == " \t\n" is not implemented.
	 * The map[] array only really needs two bits each, and on most machines
	 * that would be faster because of the reduced L1 cache footprint.
	 */
	memset(map,0,sizeof(map)); /* most characters flow through always */
3480ba98:	e2840f4e 	add	r0, r4, #312	; 0x138
3480ba9c:	e3a02c01 	mov	r2, #256	; 0x100
3480baa0:	eb004107 	bl	3481bec4 <memset>
#ifndef __U_BOOT__
	mapset((uchar *)"\\$'\"`", 3);      /* never flow through */
	mapset((uchar *)"<>;&|(){}#", 1);   /* flow through if quoted */
#else
	{
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
3480baa4:	e3a03004 	mov	r3, #4
3480baa8:	e5cd3004 	strb	r3, [sp, #4]
		mapset(subst, 3);       /* never flow through */
3480baac:	e28d0004 	add	r0, sp, #4
#ifndef __U_BOOT__
	mapset((uchar *)"\\$'\"`", 3);      /* never flow through */
	mapset((uchar *)"<>;&|(){}#", 1);   /* flow through if quoted */
#else
	{
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
3480bab0:	e3a03000 	mov	r3, #0
		mapset(subst, 3);       /* never flow through */
3480bab4:	e3a01003 	mov	r1, #3
#ifndef __U_BOOT__
	mapset((uchar *)"\\$'\"`", 3);      /* never flow through */
	mapset((uchar *)"<>;&|(){}#", 1);   /* flow through if quoted */
#else
	{
		uchar subst[2] = {SUBSTED_VAR_SYMBOL, 0};
3480bab8:	e5cd3005 	strb	r3, [sp, #5]
		mapset(subst, 3);       /* never flow through */
3480babc:	ebffffe2 	bl	3480ba4c <mapset>
	}
	mapset((uchar *)"\\$'\"", 3);       /* never flow through */
3480bac0:	e59f002c 	ldr	r0, [pc, #44]	; 3480baf4 <update_ifs_map+0x84>
3480bac4:	e3a01003 	mov	r1, #3
3480bac8:	ebffffdf 	bl	3480ba4c <mapset>
	mapset((uchar *)";&|#", 1);         /* flow through if quoted */
3480bacc:	e59f0024 	ldr	r0, [pc, #36]	; 3480baf8 <update_ifs_map+0x88>
3480bad0:	e3a01001 	mov	r1, #1
3480bad4:	ebffffdc 	bl	3480ba4c <mapset>
#endif
	mapset(ifs, 2);            /* also flow through if quoted */
3480bad8:	e5940238 	ldr	r0, [r4, #568]	; 0x238
3480badc:	e3a01002 	mov	r1, #2
3480bae0:	ebffffd9 	bl	3480ba4c <mapset>
}
3480bae4:	e8bd801c 	pop	{r2, r3, r4, pc}
3480bae8:	3482620e 	.word	0x3482620e
3480baec:	34826212 	.word	0x34826212
3480baf0:	34829dc4 	.word	0x34829dc4
3480baf4:	34826216 	.word	0x34826216
3480baf8:	3482621b 	.word	0x3482621b

3480bafc <parse_string_outer>:
#ifndef __U_BOOT__
static int parse_string_outer(const char *s, int flag)
#else
int parse_string_outer(const char *s, int flag)
#endif	/* __U_BOOT__ */
{
3480bafc:	e92d4070 	push	{r4, r5, r6, lr}
	struct in_str input;
#ifdef __U_BOOT__
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
3480bb00:	e2504000 	subs	r4, r0, #0
#ifndef __U_BOOT__
static int parse_string_outer(const char *s, int flag)
#else
int parse_string_outer(const char *s, int flag)
#endif	/* __U_BOOT__ */
{
3480bb04:	e24dd018 	sub	sp, sp, #24
3480bb08:	e1a06001 	mov	r6, r1
	struct in_str input;
#ifdef __U_BOOT__
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
3480bb0c:	0a00002f 	beq	3480bbd0 <parse_string_outer+0xd4>
3480bb10:	e5d43000 	ldrb	r3, [r4]
3480bb14:	e3530000 	cmp	r3, #0
3480bb18:	0a00002c 	beq	3480bbd0 <parse_string_outer+0xd4>
		return 1;
	if (!(p = strchr(s, '\n')) || *++p) {
3480bb1c:	e3a0100a 	mov	r1, #10
3480bb20:	eb004031 	bl	3481bbec <strchr>
3480bb24:	e3500000 	cmp	r0, #0
3480bb28:	0a000002 	beq	3480bb38 <parse_string_outer+0x3c>
3480bb2c:	e5d03001 	ldrb	r3, [r0, #1]
3480bb30:	e3530000 	cmp	r3, #0
3480bb34:	0a000018 	beq	3480bb9c <parse_string_outer+0xa0>
		p = xmalloc(strlen(s) + 2);
3480bb38:	e1a00004 	mov	r0, r4
3480bb3c:	eb004040 	bl	3481bc44 <strlen>
3480bb40:	e2800002 	add	r0, r0, #2
3480bb44:	ebfffc69 	bl	3480acf0 <xmalloc>
		strcpy(p, s);
3480bb48:	e1a01004 	mov	r1, r4
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
		return 1;
	if (!(p = strchr(s, '\n')) || *++p) {
		p = xmalloc(strlen(s) + 2);
3480bb4c:	e1a05000 	mov	r5, r0
		strcpy(p, s);
3480bb50:	eb003fd6 	bl	3481bab0 <strcpy>
		strcat(p, "\n");
3480bb54:	e1a00005 	mov	r0, r5
3480bb58:	e59f1080 	ldr	r1, [pc, #128]	; 3480bbe0 <parse_string_outer+0xe4>
3480bb5c:	eb003fe4 	bl	3481baf4 <strcat>
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480bb60:	e59f307c 	ldr	r3, [pc, #124]	; 3480bbe4 <parse_string_outer+0xe8>
	i->get = static_get;
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480bb64:	e28d0018 	add	r0, sp, #24
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480bb68:	e58d3014 	str	r3, [sp, #20]
	i->get = static_get;
3480bb6c:	e59f3074 	ldr	r3, [pc, #116]	; 3480bbe8 <parse_string_outer+0xec>
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480bb70:	e5205014 	str	r5, [r0, #-20]!
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
3480bb74:	e58d3010 	str	r3, [sp, #16]
	if (!(p = strchr(s, '\n')) || *++p) {
		p = xmalloc(strlen(s) + 2);
		strcpy(p, s);
		strcat(p, "\n");
		setup_string_in_str(&input, p);
		rcode = parse_stream_outer(&input, flag);
3480bb78:	e1a01006 	mov	r1, r6

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
	i->__promptme=1;
3480bb7c:	e3a03001 	mov	r3, #1
3480bb80:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
3480bb84:	e58d300c 	str	r3, [sp, #12]
	if (!(p = strchr(s, '\n')) || *++p) {
		p = xmalloc(strlen(s) + 2);
		strcpy(p, s);
		strcat(p, "\n");
		setup_string_in_str(&input, p);
		rcode = parse_stream_outer(&input, flag);
3480bb88:	eb000210 	bl	3480c3d0 <parse_stream_outer>
3480bb8c:	e1a04000 	mov	r4, r0
		free(p);
3480bb90:	e1a00005 	mov	r0, r5
3480bb94:	ebfff6b0 	bl	3480965c <free>
		return rcode;
3480bb98:	ea00000d 	b	3480bbd4 <parse_string_outer+0xd8>
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480bb9c:	e59f3040 	ldr	r3, [pc, #64]	; 3480bbe4 <parse_string_outer+0xe8>
	i->get = static_get;
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480bba0:	e28d0018 	add	r0, sp, #24
	i->p = NULL;
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
3480bba4:	e58d3014 	str	r3, [sp, #20]
	i->get = static_get;
3480bba8:	e59f3038 	ldr	r3, [pc, #56]	; 3480bbe8 <parse_string_outer+0xec>
	i->__promptme=1;
	i->promptmode=1;
	i->p = s;
3480bbac:	e5204014 	str	r4, [r0, #-20]!
}

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
3480bbb0:	e58d3010 	str	r3, [sp, #16]
		free(p);
		return rcode;
	} else {
#endif
	setup_string_in_str(&input, s);
	return parse_stream_outer(&input, flag);
3480bbb4:	e1a01006 	mov	r1, r6

static void setup_string_in_str(struct in_str *i, const char *s)
{
	i->peek = static_peek;
	i->get = static_get;
	i->__promptme=1;
3480bbb8:	e3a03001 	mov	r3, #1
3480bbbc:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
3480bbc0:	e58d300c 	str	r3, [sp, #12]
		free(p);
		return rcode;
	} else {
#endif
	setup_string_in_str(&input, s);
	return parse_stream_outer(&input, flag);
3480bbc4:	eb000201 	bl	3480c3d0 <parse_stream_outer>
3480bbc8:	e1a04000 	mov	r4, r0
3480bbcc:	ea000000 	b	3480bbd4 <parse_string_outer+0xd8>
	struct in_str input;
#ifdef __U_BOOT__
	char *p = NULL;
	int rcode;
	if ( !s || !*s)
		return 1;
3480bbd0:	e3a04001 	mov	r4, #1
	setup_string_in_str(&input, s);
	return parse_stream_outer(&input, flag);
#ifdef __U_BOOT__
	}
#endif
}
3480bbd4:	e1a00004 	mov	r0, r4
3480bbd8:	e28dd018 	add	sp, sp, #24
3480bbdc:	e8bd8070 	pop	{r4, r5, r6, pc}
3480bbe0:	34826214 	.word	0x34826214
3480bbe4:	3480ab88 	.word	0x3480ab88
3480bbe8:	3480ab6c 	.word	0x3480ab6c

3480bbec <run_list_real>:
#endif
	return -1;
}

static int run_list_real(struct pipe *pi)
{
3480bbec:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480bbf0:	e1a04000 	mov	r4, r0
3480bbf4:	e24dd038 	sub	sp, sp, #56	; 0x38
	int rcode=0, flag_skip=1;
	int flag_restore = 0;
	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
	/* check syntax for "for" */
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
3480bbf8:	e1a05000 	mov	r5, r0
3480bbfc:	ea000023 	b	3480bc90 <run_list_real+0xa4>
		if ((rpipe->r_mode == RES_IN ||
3480bc00:	e5953010 	ldr	r3, [r5, #16]
3480bc04:	e353000c 	cmp	r3, #12
3480bc08:	13a02000 	movne	r2, #0
3480bc0c:	03a02001 	moveq	r2, #1
3480bc10:	e3530006 	cmp	r3, #6
3480bc14:	13a03000 	movne	r3, #0
3480bc18:	03a03001 	moveq	r3, #1
3480bc1c:	e1930002 	orrs	r0, r3, r2
3480bc20:	0a000019 	beq	3480bc8c <run_list_real+0xa0>
		    rpipe->r_mode == RES_FOR) &&
		    (rpipe->next == NULL)) {
3480bc24:	e5956008 	ldr	r6, [r5, #8]
	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
	/* check syntax for "for" */
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
		if ((rpipe->r_mode == RES_IN ||
		    rpipe->r_mode == RES_FOR) &&
3480bc28:	e3560000 	cmp	r6, #0
3480bc2c:	1a000003 	bne	3480bc40 <run_list_real+0x54>
		    (rpipe->next == NULL)) {
				syntax();
3480bc30:	ebfffbef 	bl	3480abf4 <syntax_err>
#ifdef __U_BOOT__
				flag_repeat = 0;
3480bc34:	e59f377c 	ldr	r3, [pc, #1916]	; 3480c3b8 <run_list_real+0x7cc>
3480bc38:	e5836004 	str	r6, [r3, #4]
3480bc3c:	ea0001d7 	b	3480c3a0 <run_list_real+0x7b4>
#endif
				return 1;
		}
		if ((rpipe->r_mode == RES_IN &&
3480bc40:	e3520000 	cmp	r2, #0
3480bc44:	0a000006 	beq	3480bc64 <run_list_real+0x78>
3480bc48:	e5963010 	ldr	r3, [r6, #16]
3480bc4c:	e353000c 	cmp	r3, #12
3480bc50:	1a00000d 	bne	3480bc8c <run_list_real+0xa0>
			(rpipe->next->r_mode == RES_IN &&
			rpipe->next->progs->argv != NULL))||
3480bc54:	e5963004 	ldr	r3, [r6, #4]
				flag_repeat = 0;
#endif
				return 1;
		}
		if ((rpipe->r_mode == RES_IN &&
			(rpipe->next->r_mode == RES_IN &&
3480bc58:	e5933000 	ldr	r3, [r3]
3480bc5c:	e3530000 	cmp	r3, #0
3480bc60:	ea000003 	b	3480bc74 <run_list_real+0x88>
			rpipe->next->progs->argv != NULL))||
3480bc64:	e3530000 	cmp	r3, #0
3480bc68:	0a000007 	beq	3480bc8c <run_list_real+0xa0>
			(rpipe->r_mode == RES_FOR &&
3480bc6c:	e5963010 	ldr	r3, [r6, #16]
3480bc70:	e353000c 	cmp	r3, #12
3480bc74:	0a000004 	beq	3480bc8c <run_list_real+0xa0>
			rpipe->next->r_mode != RES_IN)) {
				syntax();
3480bc78:	ebfffbdd 	bl	3480abf4 <syntax_err>
#ifdef __U_BOOT__
				flag_repeat = 0;
3480bc7c:	e59f3734 	ldr	r3, [pc, #1844]	; 3480c3b8 <run_list_real+0x7cc>
3480bc80:	e3a02000 	mov	r2, #0
3480bc84:	e5832004 	str	r2, [r3, #4]
3480bc88:	ea0001c4 	b	3480c3a0 <run_list_real+0x7b4>
	int rcode=0, flag_skip=1;
	int flag_restore = 0;
	int if_code=0, next_if_code=0;  /* need double-buffer to handle elif */
	reserved_style rmode, skip_more_in_this_rmode=RES_XXXX;
	/* check syntax for "for" */
	for (rpipe = pi; rpipe; rpipe = rpipe->next) {
3480bc8c:	e5955008 	ldr	r5, [r5, #8]
3480bc90:	e3550000 	cmp	r5, #0
3480bc94:	1affffd9 	bne	3480bc00 <run_list_real+0x14>
3480bc98:	e3a09001 	mov	r9, #1
3480bc9c:	e1a07009 	mov	r7, r9
3480bca0:	e3a0300b 	mov	r3, #11
3480bca4:	e58d5028 	str	r5, [sp, #40]	; 0x28
3480bca8:	e58d5018 	str	r5, [sp, #24]
3480bcac:	e58d5014 	str	r5, [sp, #20]
3480bcb0:	e1a0a005 	mov	sl, r5
3480bcb4:	e1a0b005 	mov	fp, r5
3480bcb8:	e58d5020 	str	r5, [sp, #32]
3480bcbc:	e1a06005 	mov	r6, r5
3480bcc0:	e58d501c 	str	r5, [sp, #28]
3480bcc4:	e1a09005 	mov	r9, r5
3480bcc8:	ea0001b1 	b	3480c394 <run_list_real+0x7a8>
#endif
				return 1;
		}
	}
	for (; pi; pi = (flag_restore != 0) ? rpipe : pi->next) {
		if (pi->r_mode == RES_WHILE || pi->r_mode == RES_UNTIL ||
3480bccc:	e5942010 	ldr	r2, [r4, #16]
3480bcd0:	e2422006 	sub	r2, r2, #6
3480bcd4:	e3520002 	cmp	r2, #2
3480bcd8:	8a00000a 	bhi	3480bd08 <run_list_real+0x11c>
			pi->r_mode == RES_FOR) {
#ifdef __U_BOOT__
				/* check Ctrl-C */
				ctrlc();
3480bcdc:	e58d3008 	str	r3, [sp, #8]
3480bce0:	ebfff544 	bl	348091f8 <ctrlc>
				if ((had_ctrlc())) {
3480bce4:	ebfff55c 	bl	3480925c <had_ctrlc>
3480bce8:	e3500000 	cmp	r0, #0
3480bcec:	e59d3008 	ldr	r3, [sp, #8]
3480bcf0:	1a0001aa 	bne	3480c3a0 <run_list_real+0x7b4>
					return 1;
				}
#endif
				flag_restore = 0;
				if (!rpipe) {
3480bcf4:	e3590000 	cmp	r9, #0
				ctrlc();
				if ((had_ctrlc())) {
					return 1;
				}
#endif
				flag_restore = 0;
3480bcf8:	158d0014 	strne	r0, [sp, #20]
				if (!rpipe) {
3480bcfc:	01a09004 	moveq	r9, r4
				ctrlc();
				if ((had_ctrlc())) {
					return 1;
				}
#endif
				flag_restore = 0;
3480bd00:	058d0014 	streq	r0, [sp, #20]
				if (!rpipe) {
					flag_rep = 0;
3480bd04:	01a0b000 	moveq	fp, r0
					rpipe = pi;
				}
		}
		rmode = pi->r_mode;
3480bd08:	e5945010 	ldr	r5, [r4, #16]
		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
		if (rmode == skip_more_in_this_rmode && flag_skip) {
3480bd0c:	e1550003 	cmp	r5, r3
3480bd10:	13a07000 	movne	r7, #0
3480bd14:	02077001 	andeq	r7, r7, #1
3480bd18:	e3570000 	cmp	r7, #0
3480bd1c:	0a000003 	beq	3480bd30 <run_list_real+0x144>
			if (pi->followup == PIPE_SEQ) flag_skip=0;
3480bd20:	e594700c 	ldr	r7, [r4, #12]
3480bd24:	e2577001 	subs	r7, r7, #1
3480bd28:	13a07001 	movne	r7, #1
3480bd2c:	ea000194 	b	3480c384 <run_list_real+0x798>
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
3480bd30:	e3550002 	cmp	r5, #2
3480bd34:	13a02000 	movne	r2, #0
3480bd38:	03a02001 	moveq	r2, #1
3480bd3c:	e3550004 	cmp	r5, #4
3480bd40:	13a03000 	movne	r3, #0
3480bd44:	03a03001 	moveq	r3, #1
3480bd48:	e1931002 	orrs	r1, r3, r2
3480bd4c:	e59d0018 	ldr	r0, [sp, #24]
3480bd50:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3480bd54:	11a00001 	movne	r0, r1
		if (rmode == RES_THEN &&  if_code) continue;
3480bd58:	e3500000 	cmp	r0, #0
3480bd5c:	03a02000 	moveq	r2, #0
3480bd60:	12022001 	andne	r2, r2, #1
3480bd64:	e3520000 	cmp	r2, #0
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
3480bd68:	e58d0018 	str	r0, [sp, #24]
		if (rmode == RES_THEN &&  if_code) continue;
3480bd6c:	1a000182 	bne	3480c37c <run_list_real+0x790>
		if (rmode == RES_ELSE && !if_code) continue;
3480bd70:	e2707001 	rsbs	r7, r0, #1
3480bd74:	33a07000 	movcc	r7, #0
3480bd78:	e1170003 	tst	r7, r3
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
3480bd7c:	13a0300b 	movne	r3, #11
		if (rmode == RES_THEN || rmode == RES_ELSE) if_code = next_if_code;
		if (rmode == RES_THEN &&  if_code) continue;
		if (rmode == RES_ELSE && !if_code) continue;
3480bd80:	158d2018 	strne	r2, [sp, #24]
3480bd84:	1a00017d 	bne	3480c380 <run_list_real+0x794>
		if (rmode == RES_ELIF && !if_code) break;
3480bd88:	e3550003 	cmp	r5, #3
3480bd8c:	13a02000 	movne	r2, #0
3480bd90:	03a02001 	moveq	r2, #1
3480bd94:	e0177002 	ands	r7, r7, r2
3480bd98:	e58d202c 	str	r2, [sp, #44]	; 0x2c
3480bd9c:	1a000180 	bne	3480c3a4 <run_list_real+0x7b8>
		if (rmode == RES_FOR && pi->num_progs) {
3480bda0:	e3550006 	cmp	r5, #6
3480bda4:	1a000082 	bne	3480bfb4 <run_list_real+0x3c8>
3480bda8:	e5943000 	ldr	r3, [r4]
3480bdac:	e3530000 	cmp	r3, #0
3480bdb0:	0a00008d 	beq	3480bfec <run_list_real+0x400>
			if (!list) {
3480bdb4:	e3560000 	cmp	r6, #0
3480bdb8:	1a00005f 	bne	3480bf3c <run_list_real+0x350>
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
3480bdbc:	e5943008 	ldr	r3, [r4, #8]
3480bdc0:	e5933004 	ldr	r3, [r3, #4]
3480bdc4:	e5933000 	ldr	r3, [r3]
3480bdc8:	e3530000 	cmp	r3, #0
3480bdcc:	0a00016a 	beq	3480c37c <run_list_real+0x790>
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
3480bdd0:	e5942004 	ldr	r2, [r4, #4]
		if (rmode == RES_FOR && pi->num_progs) {
			if (!list) {
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
3480bdd4:	e5922000 	ldr	r2, [r2]
3480bdd8:	e5922000 	ldr	r2, [r2]
}

static char **make_list_in(char **inp, char *name)
{
	int len, i;
	int name_len = strlen(name);
3480bddc:	e58d3008 	str	r3, [sp, #8]
3480bde0:	e1a00002 	mov	r0, r2
		if (rmode == RES_FOR && pi->num_progs) {
			if (!list) {
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
3480bde4:	e58d2010 	str	r2, [sp, #16]
}

static char **make_list_in(char **inp, char *name)
{
	int len, i;
	int name_len = strlen(name);
3480bde8:	eb003f95 	bl	3481bc44 <strlen>
3480bdec:	e58d001c 	str	r0, [sp, #28]
	int n = 0;
	char **list;
	char *p1, *p2, *p3;

	/* create list of variable values */
	list = xmalloc(sizeof(*list));
3480bdf0:	e3a00004 	mov	r0, #4
3480bdf4:	ebfffbbd 	bl	3480acf0 <xmalloc>
3480bdf8:	e59d3008 	ldr	r3, [sp, #8]
3480bdfc:	e58d9024 	str	r9, [sp, #36]	; 0x24
3480be00:	e58d300c 	str	r3, [sp, #12]
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
			list[n] = xmalloc(2 + name_len + len);
3480be04:	e59d301c 	ldr	r3, [sp, #28]
	int n = 0;
	char **list;
	char *p1, *p2, *p3;

	/* create list of variable values */
	list = xmalloc(sizeof(*list));
3480be08:	e1a06000 	mov	r6, r0
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
			list[n] = xmalloc(2 + name_len + len);
3480be0c:	e2833002 	add	r3, r3, #2
3480be10:	e58d3020 	str	r3, [sp, #32]
3480be14:	e58da030 	str	sl, [sp, #48]	; 0x30
3480be18:	e58d5034 	str	r5, [sp, #52]	; 0x34
3480be1c:	e1a09004 	mov	r9, r4
3480be20:	ea000034 	b	3480bef8 <run_list_real+0x30c>
}
#endif

static char *insert_var_value(char *inp)
{
	return insert_var_value_sub(inp, 0);
3480be24:	e3a01000 	mov	r1, #0
3480be28:	ebfffd46 	bl	3480b348 <insert_var_value_sub>
3480be2c:	e1a0b000 	mov	fp, r0
3480be30:	e1a0a000 	mov	sl, r0
3480be34:	ea000026 	b	3480bed4 <run_list_real+0x2e8>
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
		p3 = insert_var_value(inp[i]);
		p1 = p3;
		while (*p1) {
			if ((*p1 == ' ')) {
3480be38:	e3530020 	cmp	r3, #32
				p1++;
3480be3c:	028bb001 	addeq	fp, fp, #1
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
		p3 = insert_var_value(inp[i]);
		p1 = p3;
		while (*p1) {
			if ((*p1 == ' ')) {
3480be40:	0a000023 	beq	3480bed4 <run_list_real+0x2e8>
				p1++;
				continue;
			}
			if ((p2 = strchr(p1, ' '))) {
3480be44:	e1a0000b 	mov	r0, fp
3480be48:	e3a01020 	mov	r1, #32
3480be4c:	eb003f66 	bl	3481bbec <strchr>
3480be50:	e2505000 	subs	r5, r0, #0
				len = p2 - p1;
3480be54:	106b4005 	rsbne	r4, fp, r5
		while (*p1) {
			if ((*p1 == ' ')) {
				p1++;
				continue;
			}
			if ((p2 = strchr(p1, ' '))) {
3480be58:	1a000003 	bne	3480be6c <run_list_real+0x280>
				len = p2 - p1;
			} else {
				len = strlen(p1);
3480be5c:	e1a0000b 	mov	r0, fp
3480be60:	eb003f77 	bl	3481bc44 <strlen>
3480be64:	e1a04000 	mov	r4, r0
				p2 = p1 + len;
3480be68:	e08b5000 	add	r5, fp, r0
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
3480be6c:	e2871002 	add	r1, r7, #2
3480be70:	e1a00006 	mov	r0, r6
3480be74:	e1a01101 	lsl	r1, r1, #2
3480be78:	ebfffc45 	bl	3480af94 <xrealloc>
			list[n] = xmalloc(2 + name_len + len);
3480be7c:	e59d1020 	ldr	r1, [sp, #32]
				len = strlen(p1);
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
3480be80:	e1a06000 	mov	r6, r0
			list[n] = xmalloc(2 + name_len + len);
3480be84:	e0810004 	add	r0, r1, r4
3480be88:	ebfffb98 	bl	3480acf0 <xmalloc>
			strcpy(list[n], name);
3480be8c:	e59d1010 	ldr	r1, [sp, #16]
				p2 = p1 + len;
			}
			/* we use n + 2 in realloc for list,because we add
			 * new element and then we will add NULL element */
			list = xrealloc(list, sizeof(*list) * (n + 2));
			list[n] = xmalloc(2 + name_len + len);
3480be90:	e7860107 	str	r0, [r6, r7, lsl #2]
			strcpy(list[n], name);
3480be94:	eb003f05 	bl	3481bab0 <strcpy>
			strcat(list[n], "=");
3480be98:	e7960107 	ldr	r0, [r6, r7, lsl #2]
3480be9c:	e59f1518 	ldr	r1, [pc, #1304]	; 3480c3bc <run_list_real+0x7d0>
3480bea0:	eb003f13 	bl	3481baf4 <strcat>
			strncat(list[n], p1, len);
3480bea4:	e1a02004 	mov	r2, r4
3480bea8:	e7960107 	ldr	r0, [r6, r7, lsl #2]
3480beac:	e1a0100b 	mov	r1, fp
3480beb0:	eb003f1b 	bl	3481bb24 <strncat>
			list[n++][name_len + len + 1] = '\0';
3480beb4:	e7963107 	ldr	r3, [r6, r7, lsl #2]
3480beb8:	e59d201c 	ldr	r2, [sp, #28]
3480bebc:	e2877001 	add	r7, r7, #1
3480bec0:	e0833002 	add	r3, r3, r2
3480bec4:	e0834004 	add	r4, r3, r4
3480bec8:	e3a03000 	mov	r3, #0
3480becc:	e5c43001 	strb	r3, [r4, #1]
			p1 = p2;
3480bed0:	e1a0b005 	mov	fp, r5
	/* create list of variable values */
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
		p3 = insert_var_value(inp[i]);
		p1 = p3;
		while (*p1) {
3480bed4:	e5db3000 	ldrb	r3, [fp]
3480bed8:	e3530000 	cmp	r3, #0
3480bedc:	1affffd5 	bne	3480be38 <run_list_real+0x24c>
			strcat(list[n], "=");
			strncat(list[n], p1, len);
			list[n++][name_len + len + 1] = '\0';
			p1 = p2;
		}
		if (p3 != inp[i]) free(p3);
3480bee0:	e59d000c 	ldr	r0, [sp, #12]
3480bee4:	e5103004 	ldr	r3, [r0, #-4]
3480bee8:	e15a0003 	cmp	sl, r3
3480beec:	0a000001 	beq	3480bef8 <run_list_real+0x30c>
3480bef0:	e1a0000a 	mov	r0, sl
3480bef4:	ebfff5d8 	bl	3480965c <free>
	char **list;
	char *p1, *p2, *p3;

	/* create list of variable values */
	list = xmalloc(sizeof(*list));
	for (i = 0; inp[i]; i++) {
3480bef8:	e59d100c 	ldr	r1, [sp, #12]
3480befc:	e4910004 	ldr	r0, [r1], #4
3480bf00:	e3500000 	cmp	r0, #0
3480bf04:	e58d100c 	str	r1, [sp, #12]
3480bf08:	1affffc5 	bne	3480be24 <run_list_real+0x238>
3480bf0c:	e1a04009 	mov	r4, r9
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
				save_name = pi->progs->argv[0];
3480bf10:	e5943004 	ldr	r3, [r4, #4]
3480bf14:	e59da030 	ldr	sl, [sp, #48]	; 0x30
3480bf18:	e5933000 	ldr	r3, [r3]
3480bf1c:	e59d5034 	ldr	r5, [sp, #52]	; 0x34
3480bf20:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
			list[n++][name_len + len + 1] = '\0';
			p1 = p2;
		}
		if (p3 != inp[i]) free(p3);
	}
	list[n] = NULL;
3480bf24:	e7860107 	str	r0, [r6, r7, lsl #2]
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
				save_name = pi->progs->argv[0];
3480bf28:	e5932000 	ldr	r2, [r3]
				pi->progs->argv[0] = NULL;
				flag_rep = 1;
3480bf2c:	e3a0b001 	mov	fp, #1
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
				save_name = pi->progs->argv[0];
3480bf30:	e58d201c 	str	r2, [sp, #28]
				pi->progs->argv[0] = NULL;
3480bf34:	e5830000 	str	r0, [r3]
				/* if no variable values after "in" we skip "for" */
				if (!pi->next->progs->argv) continue;
				/* create list of variable values */
				list = make_list_in(pi->next->progs->argv,
					pi->progs->argv[0]);
				save_list = list;
3480bf38:	e58d6020 	str	r6, [sp, #32]
				save_name = pi->progs->argv[0];
				pi->progs->argv[0] = NULL;
				flag_rep = 1;
			}
			if (!(*list)) {
3480bf3c:	e5962000 	ldr	r2, [r6]
3480bf40:	e5943004 	ldr	r3, [r4, #4]
3480bf44:	e3520000 	cmp	r2, #0
3480bf48:	1a00000f 	bne	3480bf8c <run_list_real+0x3a0>
				free(pi->progs->argv[0]);
3480bf4c:	e5933000 	ldr	r3, [r3]
		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
3480bf50:	e3a07001 	mov	r7, #1
				save_name = pi->progs->argv[0];
				pi->progs->argv[0] = NULL;
				flag_rep = 1;
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
3480bf54:	e5930000 	ldr	r0, [r3]
3480bf58:	e58d2008 	str	r2, [sp, #8]
3480bf5c:	ebfff5be 	bl	3480965c <free>
				free(save_list);
3480bf60:	e59d0020 	ldr	r0, [sp, #32]
3480bf64:	ebfff5bc 	bl	3480965c <free>
				list = NULL;
				flag_rep = 0;
				pi->progs->argv[0] = save_name;
3480bf68:	e5943004 	ldr	r3, [r4, #4]
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
				free(save_list);
				list = NULL;
				flag_rep = 0;
3480bf6c:	e59d2008 	ldr	r2, [sp, #8]
				pi->progs->argv[0] = save_name;
3480bf70:	e5933000 	ldr	r3, [r3]
3480bf74:	e59d001c 	ldr	r0, [sp, #28]
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
				free(save_list);
				list = NULL;
				flag_rep = 0;
3480bf78:	e1a0b002 	mov	fp, r2
				pi->progs->argv[0] = save_name;
3480bf7c:	e5830000 	str	r0, [r3]
				flag_rep = 1;
			}
			if (!(*list)) {
				free(pi->progs->argv[0]);
				free(save_list);
				list = NULL;
3480bf80:	e1a06002 	mov	r6, r2
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
3480bf84:	e3a0300b 	mov	r3, #11
				pi->progs->argv[0] = save_name;
#ifndef __U_BOOT__
				pi->progs->glob_result.gl_pathv[0] =
					pi->progs->argv[0];
#endif
				continue;
3480bf88:	ea0000fd 	b	3480c384 <run_list_real+0x798>
			} else {
				/* insert new value from list for variable */
				if (pi->progs->argv[0])
3480bf8c:	e5933000 	ldr	r3, [r3]
3480bf90:	e5930000 	ldr	r0, [r3]
3480bf94:	e3500000 	cmp	r0, #0
3480bf98:	0a000000 	beq	3480bfa0 <run_list_real+0x3b4>
					free(pi->progs->argv[0]);
3480bf9c:	ebfff5ae 	bl	3480965c <free>
				pi->progs->argv[0] = *list++;
3480bfa0:	e5943004 	ldr	r3, [r4, #4]
3480bfa4:	e4962004 	ldr	r2, [r6], #4
3480bfa8:	e5933000 	ldr	r3, [r3]
3480bfac:	e5832000 	str	r2, [r3]
3480bfb0:	ea00000d 	b	3480bfec <run_list_real+0x400>
				pi->progs->glob_result.gl_pathv[0] =
					pi->progs->argv[0];
#endif
			}
		}
		if (rmode == RES_IN) continue;
3480bfb4:	e355000c 	cmp	r5, #12
3480bfb8:	0a0000ef 	beq	3480c37c <run_list_real+0x790>
		if (rmode == RES_DO) {
3480bfbc:	e3550009 	cmp	r5, #9
3480bfc0:	1a000002 	bne	3480bfd0 <run_list_real+0x3e4>
			if (!flag_rep) continue;
3480bfc4:	e35b0000 	cmp	fp, #0
3480bfc8:	0a0000eb 	beq	3480c37c <run_list_real+0x790>
3480bfcc:	ea000006 	b	3480bfec <run_list_real+0x400>
		}
		if ((rmode == RES_DONE)) {
3480bfd0:	e355000a 	cmp	r5, #10
3480bfd4:	1a000004 	bne	3480bfec <run_list_real+0x400>
			if (flag_rep) {
				flag_restore = 1;
3480bfd8:	e59d1014 	ldr	r1, [sp, #20]
3480bfdc:	e35b0000 	cmp	fp, #0
3480bfe0:	13a01001 	movne	r1, #1
3480bfe4:	e58d1014 	str	r1, [sp, #20]
3480bfe8:	03a09000 	moveq	r9, #0
			} else {
				rpipe = NULL;
			}
		}
		if (pi->num_progs == 0) continue;
3480bfec:	e5943000 	ldr	r3, [r4]
3480bff0:	e3530000 	cmp	r3, #0
3480bff4:	0a0000e0 	beq	3480c37c <run_list_real+0x790>
	(void) &nextout;
	(void) &child;
# endif
#else
	int nextin;
	int flag = do_repeat ? CMD_FLAG_REPEAT : 0;
3480bff8:	e59f23b8 	ldr	r2, [pc, #952]	; 3480c3b8 <run_list_real+0x7cc>

	/* Check if this is a simple builtin (not part of a pipe).
	 * Builtins within pipes have to fork anyway, and are handled in
	 * pseudo_exec.  "echo foo | read bar" doesn't work on bash, either.
	 */
	if (pi->num_progs == 1) child = & (pi->progs[0]);
3480bffc:	e3530001 	cmp	r3, #1
	(void) &nextout;
	(void) &child;
# endif
#else
	int nextin;
	int flag = do_repeat ? CMD_FLAG_REPEAT : 0;
3480c000:	e5922008 	ldr	r2, [r2, #8]
3480c004:	e58d2010 	str	r2, [sp, #16]

	/* Check if this is a simple builtin (not part of a pipe).
	 * Builtins within pipes have to fork anyway, and are handled in
	 * pseudo_exec.  "echo foo | read bar" doesn't work on bash, either.
	 */
	if (pi->num_progs == 1) child = & (pi->progs[0]);
3480c008:	1a0000e8 	bne	3480c3b0 <run_list_real+0x7c4>
3480c00c:	e5947004 	ldr	r7, [r4, #4]
		/* XXX could we merge code with following builtin case,
		 * by creating a pseudo builtin that calls run_list_real? */
		rcode = run_list_real(child->group);
		restore_redirects(squirrel);
#else
		if (pi->num_progs == 1 && child->group) {
3480c010:	e5970008 	ldr	r0, [r7, #8]
3480c014:	e3500000 	cmp	r0, #0
3480c018:	0a000001 	beq	3480c024 <run_list_real+0x438>
		int rcode;
		debug_printf("non-subshell grouping\n");
		rcode = run_list_real(child->group);
3480c01c:	ebfffef2 	bl	3480bbec <run_list_real>
3480c020:	ea0000b3 	b	3480c2f4 <run_list_real+0x708>
#endif
		return rcode;
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
3480c024:	e5972000 	ldr	r2, [r7]
3480c028:	e3520000 	cmp	r2, #0
3480c02c:	0a0000df 	beq	3480c3b0 <run_list_real+0x7c4>
3480c030:	e1a01007 	mov	r1, r7
3480c034:	e1a0c004 	mov	ip, r4
3480c038:	e1a0a000 	mov	sl, r0
3480c03c:	e1a07005 	mov	r7, r5
3480c040:	e1a04002 	mov	r4, r2
3480c044:	ea000000 	b	3480c04c <run_list_real+0x460>
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
3480c048:	e28aa001 	add	sl, sl, #1
3480c04c:	e4945004 	ldr	r5, [r4], #4
3480c050:	e58d1008 	str	r1, [sp, #8]
3480c054:	e1a00005 	mov	r0, r5
3480c058:	e58dc004 	str	ip, [sp, #4]
3480c05c:	ebfffacf 	bl	3480aba0 <is_assignment>
3480c060:	e3500000 	cmp	r0, #0
3480c064:	e59d1008 	ldr	r1, [sp, #8]
3480c068:	e59dc004 	ldr	ip, [sp, #4]
3480c06c:	1afffff5 	bne	3480c048 <run_list_real+0x45c>
		if (i!=0 && child->argv[i]==NULL) {
3480c070:	e35a0000 	cmp	sl, #0
3480c074:	e1a03005 	mov	r3, r5
3480c078:	e1a0400c 	mov	r4, ip
3480c07c:	e1a05007 	mov	r5, r7
3480c080:	e1a07001 	mov	r7, r1
3480c084:	0a000035 	beq	3480c160 <run_list_real+0x574>
3480c088:	e3530000 	cmp	r3, #0
3480c08c:	01a0a003 	moveq	sl, r3
3480c090:	1a000031 	bne	3480c15c <run_list_real+0x570>
3480c094:	ea000018 	b	3480c0fc <run_list_real+0x510>
				 * not exported, we need only set this as a local variable.
				 * This junk is all to decide whether or not to export this
				 * variable. */
				int export_me=0;
				char *name, *value;
				name = xstrdup(child->argv[i]);
3480c098:	eb003f1e 	bl	3481bd18 <strdup>
				debug_printf("Local environment set: %s\n", name);
				value = strchr(name, '=');
3480c09c:	e3a0103d 	mov	r1, #61	; 0x3d
3480c0a0:	e58d0008 	str	r0, [sp, #8]
3480c0a4:	eb003ed0 	bl	3481bbec <strchr>
				if (value)
3480c0a8:	e59d3008 	ldr	r3, [sp, #8]
3480c0ac:	e3500000 	cmp	r0, #0
					*value=0;
3480c0b0:	13a01000 	movne	r1, #0
3480c0b4:	15c01000 	strbne	r1, [r0]
#ifndef __U_BOOT__
				if ( get_local_var(name)) {
					export_me=1;
				}
#endif
				free(name);
3480c0b8:	e1a00003 	mov	r0, r3
3480c0bc:	ebfff566 	bl	3480965c <free>
				p = insert_var_value(child->argv[i]);
3480c0c0:	e5973000 	ldr	r3, [r7]
}
#endif

static char *insert_var_value(char *inp)
{
	return insert_var_value_sub(inp, 0);
3480c0c4:	e3a01000 	mov	r1, #0
3480c0c8:	e793000a 	ldr	r0, [r3, sl]
3480c0cc:	ebfffc9d 	bl	3480b348 <insert_var_value_sub>
					export_me=1;
				}
#endif
				free(name);
				p = insert_var_value(child->argv[i]);
				set_local_var(p, export_me);
3480c0d0:	e3a01000 	mov	r1, #0
3480c0d4:	e58d0008 	str	r0, [sp, #8]
3480c0d8:	ebfffc2c 	bl	3480b190 <set_local_var>
				if (p != child->argv[i]) free(p);
3480c0dc:	e5972000 	ldr	r2, [r7]
3480c0e0:	e59d3008 	ldr	r3, [sp, #8]
3480c0e4:	e792200a 	ldr	r2, [r2, sl]
3480c0e8:	e1530002 	cmp	r3, r2
3480c0ec:	0a000001 	beq	3480c0f8 <run_list_real+0x50c>
3480c0f0:	e1a00003 	mov	r0, r3
3480c0f4:	ebfff558 	bl	3480965c <free>
3480c0f8:	e28aa004 	add	sl, sl, #4
		return rcode;
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
		if (i!=0 && child->argv[i]==NULL) {
			/* assignments, but no command: set the local environment */
			for (i=0; child->argv[i]!=NULL; i++) {
3480c0fc:	e5973000 	ldr	r3, [r7]
3480c100:	e793000a 	ldr	r0, [r3, sl]
3480c104:	e3500000 	cmp	r0, #0
3480c108:	1affffe2 	bne	3480c098 <run_list_real+0x4ac>
				free(name);
				p = insert_var_value(child->argv[i]);
				set_local_var(p, export_me);
				if (p != child->argv[i]) free(p);
			}
			return EXIT_SUCCESS;   /* don't worry about errors in set_local_var() yet */
3480c10c:	e1a0a000 	mov	sl, r0
3480c110:	ea000080 	b	3480c318 <run_list_real+0x72c>
}
#endif

static char *insert_var_value(char *inp)
{
	return insert_var_value_sub(inp, 0);
3480c114:	e1a00003 	mov	r0, r3
3480c118:	e3a01000 	mov	r1, #0
3480c11c:	ebfffc89 	bl	3480b348 <insert_var_value_sub>
		for (i = 0; is_assignment(child->argv[i]); i++) {
			p = insert_var_value(child->argv[i]);
#ifndef __U_BOOT__
			putenv(strdup(p));
#else
			set_local_var(p, 0);
3480c120:	e3a01000 	mov	r1, #0
3480c124:	e58d0008 	str	r0, [sp, #8]
3480c128:	ebfffc18 	bl	3480b190 <set_local_var>
#endif
			if (p != child->argv[i]) {
3480c12c:	e5972000 	ldr	r2, [r7]
3480c130:	e59d3008 	ldr	r3, [sp, #8]
3480c134:	e792200a 	ldr	r2, [r2, sl]
3480c138:	e1530002 	cmp	r3, r2
3480c13c:	0a000004 	beq	3480c154 <run_list_real+0x568>
				child->sp--;
3480c140:	e597200c 	ldr	r2, [r7, #12]
				free(p);
3480c144:	e1a00003 	mov	r0, r3
			putenv(strdup(p));
#else
			set_local_var(p, 0);
#endif
			if (p != child->argv[i]) {
				child->sp--;
3480c148:	e2422001 	sub	r2, r2, #1
3480c14c:	e587200c 	str	r2, [r7, #12]
				free(p);
3480c150:	ebfff541 	bl	3480965c <free>
3480c154:	e28aa004 	add	sl, sl, #4
3480c158:	ea000000 	b	3480c160 <run_list_real+0x574>
		rcode = run_list_real(child->group);
#endif
		return rcode;
	} else if (pi->num_progs == 1 && pi->progs[0].argv != NULL) {
		for (i=0; is_assignment(child->argv[i]); i++) { /* nothing */ }
		if (i!=0 && child->argv[i]==NULL) {
3480c15c:	e1a0a000 	mov	sl, r0
				set_local_var(p, export_me);
				if (p != child->argv[i]) free(p);
			}
			return EXIT_SUCCESS;   /* don't worry about errors in set_local_var() yet */
		}
		for (i = 0; is_assignment(child->argv[i]); i++) {
3480c160:	e5973000 	ldr	r3, [r7]
3480c164:	e083200a 	add	r2, r3, sl
3480c168:	e793300a 	ldr	r3, [r3, sl]
3480c16c:	e58d200c 	str	r2, [sp, #12]
3480c170:	e1a00003 	mov	r0, r3
3480c174:	e58d3008 	str	r3, [sp, #8]
3480c178:	ebfffa88 	bl	3480aba0 <is_assignment>
3480c17c:	e2502000 	subs	r2, r0, #0
3480c180:	e59d3008 	ldr	r3, [sp, #8]
3480c184:	1affffe2 	bne	3480c114 <run_list_real+0x528>
			if (p != child->argv[i]) {
				child->sp--;
				free(p);
			}
		}
		if (child->sp) {
3480c188:	e597100c 	ldr	r1, [r7, #12]
3480c18c:	e3510000 	cmp	r1, #0
3480c190:	0a000046 	beq	3480c2b0 <run_list_real+0x6c4>
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;

	noeval_str = get_local_var("HUSH_NO_EVAL");
3480c194:	e59f0224 	ldr	r0, [pc, #548]	; 3480c3c0 <run_list_real+0x7d4>
3480c198:	e58d2008 	str	r2, [sp, #8]
3480c19c:	ebfffbd7 	bl	3480b100 <get_local_var>
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
3480c1a0:	e3500000 	cmp	r0, #0
3480c1a4:	e59d2008 	ldr	r2, [sp, #8]
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;
3480c1a8:	058d0010 	streq	r0, [sp, #16]

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
3480c1ac:	0a000006 	beq	3480c1cc <run_list_real+0x5e0>
3480c1b0:	e5d03000 	ldrb	r3, [r0]
3480c1b4:	e3530030 	cmp	r3, #48	; 0x30
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;
3480c1b8:	058d2010 	streq	r2, [sp, #16]

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
3480c1bc:	0a000002 	beq	3480c1cc <run_list_real+0x5e0>
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
	char *noeval_str;
	int noeval = 0;
3480c1c0:	e2533000 	subs	r3, r3, #0
3480c1c4:	13a03001 	movne	r3, #1
3480c1c8:	e58d3010 	str	r3, [sp, #16]
static char * make_string(char ** inp)
{
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
3480c1cc:	e3a03002 	mov	r3, #2
	int noeval = 0;

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
3480c1d0:	e3a0a000 	mov	sl, #0
static char * make_string(char ** inp)
{
	char *p;
	char *str = NULL;
	int n;
	int len = 2;
3480c1d4:	e58d3024 	str	r3, [sp, #36]	; 0x24

/* Make new string for parser */
static char * make_string(char ** inp)
{
	char *p;
	char *str = NULL;
3480c1d8:	e1a0700a 	mov	r7, sl
3480c1dc:	e58d6030 	str	r6, [sp, #48]	; 0x30
3480c1e0:	ea00001c 	b	3480c258 <run_list_real+0x66c>

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
		p = insert_var_value_sub(inp[n], noeval);
3480c1e4:	e1a00003 	mov	r0, r3
3480c1e8:	e59d1010 	ldr	r1, [sp, #16]
3480c1ec:	ebfffc55 	bl	3480b348 <insert_var_value_sub>
3480c1f0:	e1a06000 	mov	r6, r0
		str = xrealloc(str, (len + strlen(p)));
3480c1f4:	eb003e92 	bl	3481bc44 <strlen>
3480c1f8:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
3480c1fc:	e0801002 	add	r1, r0, r2
3480c200:	e1a00007 	mov	r0, r7
3480c204:	ebfffb62 	bl	3480af94 <xrealloc>
		if (n) {
3480c208:	e35a0000 	cmp	sl, #0
	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
		p = insert_var_value_sub(inp[n], noeval);
		str = xrealloc(str, (len + strlen(p)));
3480c20c:	e1a07000 	mov	r7, r0
		if (n) {
			strcat(str, " ");
		} else {
			*str = '\0';
3480c210:	05c0a000 	strbeq	sl, [r0]
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
		p = insert_var_value_sub(inp[n], noeval);
		str = xrealloc(str, (len + strlen(p)));
		if (n) {
3480c214:	0a000001 	beq	3480c220 <run_list_real+0x634>
			strcat(str, " ");
3480c218:	e59f11a4 	ldr	r1, [pc, #420]	; 3480c3c4 <run_list_real+0x7d8>
3480c21c:	eb003e34 	bl	3481baf4 <strcat>
		} else {
			*str = '\0';
		}
		strcat(str, p);
3480c220:	e1a01006 	mov	r1, r6
3480c224:	e1a00007 	mov	r0, r7
3480c228:	eb003e31 	bl	3481baf4 <strcat>
		len = strlen(str) + 3;
3480c22c:	e1a00007 	mov	r0, r7
3480c230:	eb003e83 	bl	3481bc44 <strlen>
3480c234:	e2800003 	add	r0, r0, #3
3480c238:	e58d0024 	str	r0, [sp, #36]	; 0x24
		if (p != inp[n]) free(p);
3480c23c:	e59d000c 	ldr	r0, [sp, #12]
3480c240:	e5103004 	ldr	r3, [r0, #-4]
3480c244:	e1560003 	cmp	r6, r3
3480c248:	0a000001 	beq	3480c254 <run_list_real+0x668>
3480c24c:	e1a00006 	mov	r0, r6
3480c250:	ebfff501 	bl	3480965c <free>
	int noeval = 0;

	noeval_str = get_local_var("HUSH_NO_EVAL");
	if (noeval_str != NULL && *noeval_str != '0' && *noeval_str != '\0')
		noeval = 1;
	for (n = 0; inp[n]; n++) {
3480c254:	e28aa001 	add	sl, sl, #1
3480c258:	e59d100c 	ldr	r1, [sp, #12]
3480c25c:	e4913004 	ldr	r3, [r1], #4
3480c260:	e3530000 	cmp	r3, #0
3480c264:	e58d100c 	str	r1, [sp, #12]
3480c268:	1affffdd 	bne	3480c1e4 <run_list_real+0x5f8>
		}
		strcat(str, p);
		len = strlen(str) + 3;
		if (p != inp[n]) free(p);
	}
	len = strlen(str);
3480c26c:	e1a00007 	mov	r0, r7
3480c270:	e58d3008 	str	r3, [sp, #8]
3480c274:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
3480c278:	eb003e71 	bl	3481bc44 <strlen>
	*(str + len) = '\n';
3480c27c:	e1a02007 	mov	r2, r7
3480c280:	e3a0100a 	mov	r1, #10
3480c284:	e7e21000 	strb	r1, [r2, r0]!
	*(str + len + 1) = '\0';
3480c288:	e59d3008 	ldr	r3, [sp, #8]
		}
		if (child->sp) {
			char * str = NULL;

			str = make_string((child->argv + i));
			parse_string_outer(str, FLAG_EXIT_FROM_LOOP | FLAG_REPARSING);
3480c28c:	e3a01005 	mov	r1, #5
		len = strlen(str) + 3;
		if (p != inp[n]) free(p);
	}
	len = strlen(str);
	*(str + len) = '\n';
	*(str + len + 1) = '\0';
3480c290:	e5c23001 	strb	r3, [r2, #1]
		}
		if (child->sp) {
			char * str = NULL;

			str = make_string((child->argv + i));
			parse_string_outer(str, FLAG_EXIT_FROM_LOOP | FLAG_REPARSING);
3480c294:	e1a00007 	mov	r0, r7
3480c298:	ebfffe17 	bl	3480bafc <parse_string_outer>
			free(str);
3480c29c:	e1a00007 	mov	r0, r7
3480c2a0:	ebfff4ed 	bl	3480965c <free>
			return last_return_code;
3480c2a4:	e59f210c 	ldr	r2, [pc, #268]	; 3480c3b8 <run_list_real+0x7cc>
3480c2a8:	e592a134 	ldr	sl, [r2, #308]	; 0x134
3480c2ac:	ea000011 	b	3480c2f8 <run_list_real+0x70c>
		}
#else
		/* check ";", because ,example , argv consist from
		 * "help;flinfo" must not execute
		 */
		if (strchr(child->argv[i], ';')) {
3480c2b0:	e1a00003 	mov	r0, r3
3480c2b4:	e3a0103b 	mov	r1, #59	; 0x3b
3480c2b8:	eb003e4b 	bl	3481bbec <strchr>
3480c2bc:	e3500000 	cmp	r0, #0
3480c2c0:	0a000004 	beq	3480c2d8 <run_list_real+0x6ec>
			printf("Unknown command '%s' - try 'help' or use "
3480c2c4:	e5973000 	ldr	r3, [r7]
3480c2c8:	e59f00f8 	ldr	r0, [pc, #248]	; 3480c3c8 <run_list_real+0x7dc>
3480c2cc:	e793100a 	ldr	r1, [r3, sl]
3480c2d0:	ebfff3a3 	bl	34809164 <printf>
3480c2d4:	ea000035 	b	3480c3b0 <run_list_real+0x7c4>
					"'run' command\n", child->argv[i]);
			return -1;
		}
		/* Process the command */
		return cmd_process(flag, child->argc, child->argv,
3480c2d8:	e59d3010 	ldr	r3, [sp, #16]
3480c2dc:	e5971004 	ldr	r1, [r7, #4]
3480c2e0:	e2530000 	subs	r0, r3, #0
3480c2e4:	13a00001 	movne	r0, #1
3480c2e8:	e5972000 	ldr	r2, [r7]
3480c2ec:	e59f30d8 	ldr	r3, [pc, #216]	; 3480c3cc <run_list_real+0x7e0>
3480c2f0:	ebfff2d1 	bl	34808e3c <cmd_process>
3480c2f4:	e1a0a000 	mov	sl, r0
			}
			debug_printf("checkjobs returned %d\n",rcode);
		}
		last_return_code=rcode;
#else
		if (rcode < -1) {
3480c2f8:	e37a0001 	cmn	sl, #1
3480c2fc:	aa000005 	bge	3480c318 <run_list_real+0x72c>
			last_return_code = -rcode - 2;
3480c300:	e3e03001 	mvn	r3, #1
3480c304:	e59f20ac 	ldr	r2, [pc, #172]	; 3480c3b8 <run_list_real+0x7cc>
3480c308:	e06a3003 	rsb	r3, sl, r3
3480c30c:	e5823134 	str	r3, [r2, #308]	; 0x134
			return -2;	/* exit */
3480c310:	e3e0a001 	mvn	sl, #1
3480c314:	ea000022 	b	3480c3a4 <run_list_real+0x7b8>
		last_return_code=(rcode == 0) ? 0 : 1;
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480c318:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
#else
		if (rcode < -1) {
			last_return_code = -rcode - 2;
			return -2;	/* exit */
		}
		last_return_code=(rcode == 0) ? 0 : 1;
3480c31c:	e25a3000 	subs	r3, sl, #0
3480c320:	13a03001 	movne	r3, #1
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480c324:	e3550001 	cmp	r5, #1
3480c328:	03822001 	orreq	r2, r2, #1
3480c32c:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3480c330:	e3520000 	cmp	r2, #0
#else
		if (rcode < -1) {
			last_return_code = -rcode - 2;
			return -2;	/* exit */
		}
		last_return_code=(rcode == 0) ? 0 : 1;
3480c334:	e59f007c 	ldr	r0, [pc, #124]	; 3480c3b8 <run_list_real+0x7cc>
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480c338:	11a0100a 	movne	r1, sl
			next_if_code=rcode;  /* can be overwritten a number of times */
		if (rmode == RES_WHILE)
3480c33c:	e3550007 	cmp	r5, #7
#else
		if (rcode < -1) {
			last_return_code = -rcode - 2;
			return -2;	/* exit */
		}
		last_return_code=(rcode == 0) ? 0 : 1;
3480c340:	e5803134 	str	r3, [r0, #308]	; 0x134
#endif
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
3480c344:	e58d1028 	str	r1, [sp, #40]	; 0x28
			next_if_code=rcode;  /* can be overwritten a number of times */
		if (rmode == RES_WHILE)
			flag_rep = !last_return_code;
3480c348:	0223b001 	eoreq	fp, r3, #1
#ifndef __U_BOOT__
		pi->num_progs = save_num_progs; /* restore number of programs */
#endif
		if ( rmode == RES_IF || rmode == RES_ELIF )
			next_if_code=rcode;  /* can be overwritten a number of times */
		if (rmode == RES_WHILE)
3480c34c:	0a000001 	beq	3480c358 <run_list_real+0x76c>
			flag_rep = !last_return_code;
		if (rmode == RES_UNTIL)
			flag_rep = last_return_code;
3480c350:	e3550008 	cmp	r5, #8
3480c354:	01a0b003 	moveq	fp, r3
		if ( (rcode==EXIT_SUCCESS && pi->followup==PIPE_OR) ||
3480c358:	e35a0000 	cmp	sl, #0
3480c35c:	e594300c 	ldr	r3, [r4, #12]
3480c360:	1a000001 	bne	3480c36c <run_list_real+0x780>
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
		skip_more_in_this_rmode = RES_XXXX;
3480c364:	e3530003 	cmp	r3, #3
3480c368:	ea000000 	b	3480c370 <run_list_real+0x784>
3480c36c:	e3530002 	cmp	r3, #2
3480c370:	01a03005 	moveq	r3, r5
3480c374:	13a0300b 	movne	r3, #11
3480c378:	ea000000 	b	3480c380 <run_list_real+0x794>
3480c37c:	e3a0300b 	mov	r3, #11
		debug_printf("rmode=%d  if_code=%d  next_if_code=%d skip_more=%d\n", rmode, if_code, next_if_code, skip_more_in_this_rmode);
		if (rmode == skip_more_in_this_rmode && flag_skip) {
			if (pi->followup == PIPE_SEQ) flag_skip=0;
			continue;
		}
		flag_skip = 1;
3480c380:	e3a07001 	mov	r7, #1
				flag_repeat = 0;
#endif
				return 1;
		}
	}
	for (; pi; pi = (flag_restore != 0) ? rpipe : pi->next) {
3480c384:	e59d2014 	ldr	r2, [sp, #20]
3480c388:	e3520000 	cmp	r2, #0
3480c38c:	05944008 	ldreq	r4, [r4, #8]
3480c390:	11a04009 	movne	r4, r9
3480c394:	e3540000 	cmp	r4, #0
3480c398:	1afffe4b 	bne	3480bccc <run_list_real+0xe0>
3480c39c:	ea000000 	b	3480c3a4 <run_list_real+0x7b8>
			pi->r_mode == RES_FOR) {
#ifdef __U_BOOT__
				/* check Ctrl-C */
				ctrlc();
				if ((had_ctrlc())) {
					return 1;
3480c3a0:	e3a0a001 	mov	sl, #1
#ifndef __U_BOOT__
		checkjobs(NULL);
#endif
	}
	return rcode;
}
3480c3a4:	e1a0000a 	mov	r0, sl
3480c3a8:	e28dd038 	add	sp, sp, #56	; 0x38
3480c3ac:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		/* If there isn't another process, nextin is garbage
		   but it doesn't matter */
		nextin = pipefds[0];
	}
#endif
	return -1;
3480c3b0:	e3e0a000 	mvn	sl, #0
3480c3b4:	eaffffd7 	b	3480c318 <run_list_real+0x72c>
3480c3b8:	34829dc4 	.word	0x34829dc4
3480c3bc:	348238f5 	.word	0x348238f5
3480c3c0:	34826220 	.word	0x34826220
3480c3c4:	34826429 	.word	0x34826429
3480c3c8:	3482622d 	.word	0x3482622d
3480c3cc:	34829dc8 	.word	0x34829dc8

3480c3d0 <parse_stream_outer>:
}

/* most recursion does not come through here, the exeception is
 * from builtin_source() */
int parse_stream_outer(struct in_str *inp, int flag)
{
3480c3d0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480c3d4:	e24dd038 	sub	sp, sp, #56	; 0x38

	struct p_context ctx;
	o_string temp=NULL_O_STRING;
3480c3d8:	e28d5024 	add	r5, sp, #36	; 0x24
}

/* most recursion does not come through here, the exeception is
 * from builtin_source() */
int parse_stream_outer(struct in_str *inp, int flag)
{
3480c3dc:	e58d1004 	str	r1, [sp, #4]
3480c3e0:	e1a04000 	mov	r4, r0

	struct p_context ctx;
	o_string temp=NULL_O_STRING;
3480c3e4:	e3a01000 	mov	r1, #0
3480c3e8:	e1a00005 	mov	r0, r5
3480c3ec:	e3a02014 	mov	r2, #20
3480c3f0:	eb003eb3 	bl	3481bec4 <memset>
	int rcode;
#ifdef __U_BOOT__
	int code = 0;
3480c3f4:	e3a07000 	mov	r7, #0
#endif
	do {
		ctx.type = flag;
		initialize_context(&ctx);
3480c3f8:	e28d6008 	add	r6, sp, #8
	int rcode;
#ifdef __U_BOOT__
	int code = 0;
#endif
	do {
		ctx.type = flag;
3480c3fc:	e59d2004 	ldr	r2, [sp, #4]
	return pi;
}

static void initialize_context(struct p_context *ctx)
{
	ctx->pipe=NULL;
3480c400:	e3a0a000 	mov	sl, #0
	int rcode;
#ifdef __U_BOOT__
	int code = 0;
#endif
	do {
		ctx.type = flag;
3480c404:	e58d2020 	str	r2, [sp, #32]
	return pi;
}

static void initialize_context(struct p_context *ctx)
{
	ctx->pipe=NULL;
3480c408:	e58da010 	str	sl, [sp, #16]
#ifndef __U_BOOT__
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
3480c40c:	e58da008 	str	sl, [sp, #8]
	ctx->list_head=new_pipe();
3480c410:	ebfffca7 	bl	3480b6b4 <new_pipe>
3480c414:	e58d000c 	str	r0, [sp, #12]
	ctx->pipe=ctx->list_head;
3480c418:	e58d0010 	str	r0, [sp, #16]
	ctx->w=RES_NONE;
	ctx->stack=NULL;
#ifdef __U_BOOT__
	ctx->old_flag=0;
#endif
	done_command(ctx);   /* creates the memory for working child */
3480c41c:	e1a00006 	mov	r0, r6
	ctx->pending_redirect=NULL;
#endif
	ctx->child=NULL;
	ctx->list_head=new_pipe();
	ctx->pipe=ctx->list_head;
	ctx->w=RES_NONE;
3480c420:	e58da014 	str	sl, [sp, #20]
	ctx->stack=NULL;
3480c424:	e58da01c 	str	sl, [sp, #28]
#ifdef __U_BOOT__
	ctx->old_flag=0;
3480c428:	e58da018 	str	sl, [sp, #24]
#endif
	done_command(ctx);   /* creates the memory for working child */
3480c42c:	ebfffae0 	bl	3480afb4 <done_command>
	int code = 0;
#endif
	do {
		ctx.type = flag;
		initialize_context(&ctx);
		update_ifs_map();
3480c430:	ebfffd8e 	bl	3480ba70 <update_ifs_map>
		if (!(flag & FLAG_PARSE_SEMICOLON) || (flag & FLAG_REPARSING)) mapset((uchar *)";$&|", 0);
3480c434:	e59d2004 	ldr	r2, [sp, #4]
3480c438:	e2023006 	and	r3, r2, #6
3480c43c:	e3530002 	cmp	r3, #2
3480c440:	0a000002 	beq	3480c450 <parse_stream_outer+0x80>
3480c444:	e59f05e0 	ldr	r0, [pc, #1504]	; 3480ca2c <parse_stream_outer+0x65c>
3480c448:	e1a0100a 	mov	r1, sl
3480c44c:	ebfffd7e 	bl	3480ba4c <mapset>
		inp->promptmode=1;
3480c450:	e3a03001 	mov	r3, #1
3480c454:	e5843008 	str	r3, [r4, #8]
3480c458:	ea00010a 	b	3480c888 <parse_stream_outer+0x4b8>
	 * A single-quote triggers a bypass of the main loop until its mate is
	 * found.  When recursing, quote state is passed in via dest->quote. */

	debug_printf("parse_stream, end_trigger=%d\n",end_trigger);
	while ((ch=b_getch(input))!=EOF) {
		m = map[ch];
3480c45c:	e59f25cc 	ldr	r2, [pc, #1484]	; 3480ca30 <parse_stream_outer+0x660>
3480c460:	e082300a 	add	r3, r2, sl
3480c464:	e5d3b138 	ldrb	fp, [r3, #312]	; 0x138
#ifdef __U_BOOT__
		if (input->__promptme == 0) return 1;
3480c468:	e5943004 	ldr	r3, [r4, #4]
3480c46c:	e3530000 	cmp	r3, #0
3480c470:	0a00010b 	beq	3480c8a4 <parse_stream_outer+0x4d4>
#endif
		next = (ch == '\n') ? 0 : b_peek(input);
3480c474:	e35a000a 	cmp	sl, #10
3480c478:	03a09000 	moveq	r9, #0
3480c47c:	0a000003 	beq	3480c490 <parse_stream_outer+0xc0>
3480c480:	e5943010 	ldr	r3, [r4, #16]
3480c484:	e1a00004 	mov	r0, r4
3480c488:	e12fff33 	blx	r3
3480c48c:	e1a09000 	mov	r9, r0

		debug_printf("parse_stream: ch=%c (%d) m=%d quote=%d - %c\n",
			ch >= ' ' ? ch : '.', ch, m,
			dest->quote, ctx->stack == NULL ? '*' : '.');

		if (m==0 || ((m==1 || m==2) && dest->quote)) {
3480c490:	e35b0000 	cmp	fp, #0
3480c494:	0a000005 	beq	3480c4b0 <parse_stream_outer+0xe0>
3480c498:	e24b3001 	sub	r3, fp, #1
3480c49c:	e3530001 	cmp	r3, #1
3480c4a0:	8a000012 	bhi	3480c4f0 <parse_stream_outer+0x120>
3480c4a4:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480c4a8:	e3530000 	cmp	r3, #0
3480c4ac:	0a000002 	beq	3480c4bc <parse_stream_outer+0xec>
			b_addqchr(dest, ch, dest->quote);
3480c4b0:	e1a00005 	mov	r0, r5
3480c4b4:	e1a0100a 	mov	r1, sl
3480c4b8:	ea000042 	b	3480c5c8 <parse_stream_outer+0x1f8>
		} else {
			if (m==2) {  /* unquoted IFS */
3480c4bc:	e35b0002 	cmp	fp, #2
3480c4c0:	1a00000a 	bne	3480c4f0 <parse_stream_outer+0x120>
				if (done_word(dest, ctx)) {
3480c4c4:	e1a00005 	mov	r0, r5
3480c4c8:	e1a01006 	mov	r1, r6
3480c4cc:	ebfffd00 	bl	3480b8d4 <done_word>
3480c4d0:	e3500000 	cmp	r0, #0
3480c4d4:	1a0000f2 	bne	3480c8a4 <parse_stream_outer+0x4d4>
					return 1;
				}
				/* If we aren't performing a substitution, treat a newline as a
				 * command separator.  */
				if (end_trigger != '\0' && ch=='\n')
3480c4d8:	e35a000a 	cmp	sl, #10
3480c4dc:	1a0000e9 	bne	3480c888 <parse_stream_outer+0x4b8>
					done_pipe(ctx,PIPE_SEQ);
3480c4e0:	e1a00006 	mov	r0, r6
3480c4e4:	e3a01001 	mov	r1, #1
3480c4e8:	ebfffc7b 	bl	3480b6dc <done_pipe>
3480c4ec:	ea000001 	b	3480c4f8 <parse_stream_outer+0x128>
			}
			if (ch == end_trigger && !dest->quote && ctx->w==RES_NONE) {
3480c4f0:	e35a000a 	cmp	sl, #10
3480c4f4:	1a000005 	bne	3480c510 <parse_stream_outer+0x140>
3480c4f8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480c4fc:	e3530000 	cmp	r3, #0
3480c500:	1a000002 	bne	3480c510 <parse_stream_outer+0x140>
3480c504:	e59d3014 	ldr	r3, [sp, #20]
3480c508:	e3530000 	cmp	r3, #0
3480c50c:	0a000141 	beq	3480ca18 <parse_stream_outer+0x648>
				done_pipe(ctx,PIPE_SEQ);
				run_list(ctx->list_head);
				initialize_context(ctx);
			}
#endif
			if (m!=2) switch (ch) {
3480c510:	e35b0002 	cmp	fp, #2
3480c514:	0a0000db 	beq	3480c888 <parse_stream_outer+0x4b8>
3480c518:	e35a0026 	cmp	sl, #38	; 0x26
3480c51c:	0a0000af 	beq	3480c7e0 <parse_stream_outer+0x410>
3480c520:	8a00000a 	bhi	3480c550 <parse_stream_outer+0x180>
3480c524:	e35a0022 	cmp	sl, #34	; 0x22
3480c528:	0a00009f 	beq	3480c7ac <parse_stream_outer+0x3dc>
3480c52c:	8a000002 	bhi	3480c53c <parse_stream_outer+0x16c>
3480c530:	e35a0004 	cmp	sl, #4
3480c534:	1a0000d1 	bne	3480c880 <parse_stream_outer+0x4b0>
3480c538:	ea0000bf 	b	3480c83c <parse_stream_outer+0x46c>
3480c53c:	e35a0023 	cmp	sl, #35	; 0x23
3480c540:	0a00000d 	beq	3480c57c <parse_stream_outer+0x1ac>
3480c544:	e35a0024 	cmp	sl, #36	; 0x24
3480c548:	1a0000cc 	bne	3480c880 <parse_stream_outer+0x4b0>
3480c54c:	ea00002c 	b	3480c604 <parse_stream_outer+0x234>
3480c550:	e35a003b 	cmp	sl, #59	; 0x3b
3480c554:	0a00009b 	beq	3480c7c8 <parse_stream_outer+0x3f8>
3480c558:	8a000002 	bhi	3480c568 <parse_stream_outer+0x198>
3480c55c:	e35a0027 	cmp	sl, #39	; 0x27
3480c560:	1a0000c6 	bne	3480c880 <parse_stream_outer+0x4b0>
3480c564:	ea000080 	b	3480c76c <parse_stream_outer+0x39c>
3480c568:	e35a005c 	cmp	sl, #92	; 0x5c
3480c56c:	0a000018 	beq	3480c5d4 <parse_stream_outer+0x204>
3480c570:	e35a007c 	cmp	sl, #124	; 0x7c
3480c574:	1a0000c1 	bne	3480c880 <parse_stream_outer+0x4b0>
3480c578:	ea0000a3 	b	3480c80c <parse_stream_outer+0x43c>
		case '#':
			if (dest->length == 0 && !dest->quote) {
3480c57c:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3480c580:	e3530000 	cmp	r3, #0
3480c584:	1a00000d 	bne	3480c5c0 <parse_stream_outer+0x1f0>
3480c588:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480c58c:	e3530000 	cmp	r3, #0
3480c590:	0a000003 	beq	3480c5a4 <parse_stream_outer+0x1d4>
3480c594:	ea000009 	b	3480c5c0 <parse_stream_outer+0x1f0>
				while(ch=b_peek(input),ch!=EOF && ch!='\n') { b_getch(input); }
3480c598:	e594300c 	ldr	r3, [r4, #12]
3480c59c:	e1a00004 	mov	r0, r4
3480c5a0:	e12fff33 	blx	r3
3480c5a4:	e5943010 	ldr	r3, [r4, #16]
3480c5a8:	e1a00004 	mov	r0, r4
3480c5ac:	e12fff33 	blx	r3
3480c5b0:	e350000a 	cmp	r0, #10
3480c5b4:	13700001 	cmnne	r0, #1
3480c5b8:	1afffff6 	bne	3480c598 <parse_stream_outer+0x1c8>
3480c5bc:	ea0000b1 	b	3480c888 <parse_stream_outer+0x4b8>
			} else {
				b_addqchr(dest, ch, dest->quote);
3480c5c0:	e1a00005 	mov	r0, r5
3480c5c4:	e3a01023 	mov	r1, #35	; 0x23
3480c5c8:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3480c5cc:	ebfffab8 	bl	3480b0b4 <b_addqchr>
3480c5d0:	ea0000ac 	b	3480c888 <parse_stream_outer+0x4b8>
			}
			break;
		case '\\':
			if (next == EOF) {
3480c5d4:	e3790001 	cmn	r9, #1
3480c5d8:	0a0000a8 	beq	3480c880 <parse_stream_outer+0x4b0>
				syntax();
				return 1;
			}
			b_addqchr(dest, '\\', dest->quote);
3480c5dc:	e1a0100a 	mov	r1, sl
3480c5e0:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3480c5e4:	e1a00005 	mov	r0, r5
3480c5e8:	ebfffab1 	bl	3480b0b4 <b_addqchr>
			b_addqchr(dest, b_getch(input), dest->quote);
3480c5ec:	e594300c 	ldr	r3, [r4, #12]
3480c5f0:	e1a00004 	mov	r0, r4
3480c5f4:	e12fff33 	blx	r3
3480c5f8:	e1a01000 	mov	r1, r0
3480c5fc:	e1a00005 	mov	r0, r5
3480c600:	eafffff0 	b	3480c5c8 <parse_stream_outer+0x1f8>
	int advance=0;
#endif
#ifndef __U_BOOT__
	char sep[]=" ";
#endif
	int ch = input->peek(input);  /* first character after the $ */
3480c604:	e5943010 	ldr	r3, [r4, #16]
3480c608:	e1a00004 	mov	r0, r4
3480c60c:	e12fff33 	blx	r3
	debug_printf("handle_dollar: ch=%c\n",ch);
	if (isalpha(ch)) {
3480c610:	e59f241c 	ldr	r2, [pc, #1052]	; 3480ca34 <parse_stream_outer+0x664>
3480c614:	e6ef3070 	uxtb	r3, r0
3480c618:	e7d23003 	ldrb	r3, [r2, r3]
	int advance=0;
#endif
#ifndef __U_BOOT__
	char sep[]=" ";
#endif
	int ch = input->peek(input);  /* first character after the $ */
3480c61c:	e1a09000 	mov	r9, r0
	debug_printf("handle_dollar: ch=%c\n",ch);
	if (isalpha(ch)) {
3480c620:	e3130003 	tst	r3, #3
3480c624:	0a00001b 	beq	3480c698 <parse_stream_outer+0x2c8>
		b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480c628:	e1a00005 	mov	r0, r5
3480c62c:	e3a01003 	mov	r1, #3
3480c630:	ebfffa81 	bl	3480b03c <b_addchr>
		ctx->child->sp++;
3480c634:	e59d3008 	ldr	r3, [sp, #8]
3480c638:	e593200c 	ldr	r2, [r3, #12]
3480c63c:	e2822001 	add	r2, r2, #1
3480c640:	e583200c 	str	r2, [r3, #12]
3480c644:	ea000005 	b	3480c660 <parse_stream_outer+0x290>
		while(ch=b_peek(input),isalnum(ch) || ch=='_') {
			b_getch(input);
3480c648:	e594300c 	ldr	r3, [r4, #12]
3480c64c:	e1a00004 	mov	r0, r4
3480c650:	e12fff33 	blx	r3
			b_addchr(dest,ch);
3480c654:	e1a00005 	mov	r0, r5
3480c658:	e1a0100a 	mov	r1, sl
3480c65c:	ebfffa76 	bl	3480b03c <b_addchr>
	int ch = input->peek(input);  /* first character after the $ */
	debug_printf("handle_dollar: ch=%c\n",ch);
	if (isalpha(ch)) {
		b_addchr(dest, SPECIAL_VAR_SYMBOL);
		ctx->child->sp++;
		while(ch=b_peek(input),isalnum(ch) || ch=='_') {
3480c660:	e5943010 	ldr	r3, [r4, #16]
3480c664:	e1a00004 	mov	r0, r4
3480c668:	e12fff33 	blx	r3
3480c66c:	e59f23c0 	ldr	r2, [pc, #960]	; 3480ca34 <parse_stream_outer+0x664>
3480c670:	e6ef3070 	uxtb	r3, r0
3480c674:	e7d23003 	ldrb	r3, [r2, r3]
3480c678:	e1a0a000 	mov	sl, r0
3480c67c:	e2133007 	ands	r3, r3, #7
3480c680:	13a03001 	movne	r3, #1
3480c684:	e350005f 	cmp	r0, #95	; 0x5f
3480c688:	03833001 	orreq	r3, r3, #1
3480c68c:	e3530000 	cmp	r3, #0
3480c690:	1affffec 	bne	3480c648 <parse_stream_outer+0x278>
3480c694:	ea000030 	b	3480c75c <parse_stream_outer+0x38c>
		if (i<global_argc) {
			parse_string(dest, ctx, global_argv[i]); /* recursion */
		}
		advance = 1;
#endif
	} else switch (ch) {
3480c698:	e350003f 	cmp	r0, #63	; 0x3f
3480c69c:	0a000004 	beq	3480c6b4 <parse_stream_outer+0x2e4>
3480c6a0:	e350007b 	cmp	r0, #123	; 0x7b
			error_msg("unhandled syntax: $%c",ch);
			return 1;
			break;
#endif
		default:
			b_addqchr(dest,'$',dest->quote);
3480c6a4:	11a00005 	movne	r0, r5
3480c6a8:	13a01024 	movne	r1, #36	; 0x24
		if (i<global_argc) {
			parse_string(dest, ctx, global_argv[i]); /* recursion */
		}
		advance = 1;
#endif
	} else switch (ch) {
3480c6ac:	1affffc5 	bne	3480c5c8 <parse_stream_outer+0x1f8>
3480c6b0:	ea000013 	b	3480c704 <parse_stream_outer+0x334>
#endif
		case '?':
#ifndef __U_BOOT__
			b_adduint(dest,last_return_code);
#else
			ctx->child->sp++;
3480c6b4:	e59d3008 	ldr	r3, [sp, #8]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480c6b8:	e1a00005 	mov	r0, r5
#endif
		case '?':
#ifndef __U_BOOT__
			b_adduint(dest,last_return_code);
#else
			ctx->child->sp++;
3480c6bc:	e593200c 	ldr	r2, [r3, #12]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480c6c0:	e3a01003 	mov	r1, #3
#endif
		case '?':
#ifndef __U_BOOT__
			b_adduint(dest,last_return_code);
#else
			ctx->child->sp++;
3480c6c4:	e2822001 	add	r2, r2, #1
3480c6c8:	e583200c 	str	r2, [r3, #12]
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480c6cc:	ebfffa5a 	bl	3480b03c <b_addchr>
			b_addchr(dest, '$');
3480c6d0:	e1a0100a 	mov	r1, sl
3480c6d4:	e1a00005 	mov	r0, r5
3480c6d8:	ebfffa57 	bl	3480b03c <b_addchr>
			b_addchr(dest, '?');
3480c6dc:	e1a01009 	mov	r1, r9
3480c6e0:	e1a00005 	mov	r0, r5
3480c6e4:	ebfffa54 	bl	3480b03c <b_addchr>
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480c6e8:	e1a00005 	mov	r0, r5
3480c6ec:	e3a01003 	mov	r1, #3
3480c6f0:	ebfffa51 	bl	3480b03c <b_addchr>
	/* Eat the character if the flag was set.  If the compiler
	 * is smart enough, we could substitute "b_getch(input);"
	 * for all the "advance = 1;" above, and also end up with
	 * a nice size-optimized program.  Hah!  That'll be the day.
	 */
	if (advance) b_getch(input);
3480c6f4:	e594300c 	ldr	r3, [r4, #12]
3480c6f8:	e1a00004 	mov	r0, r4
3480c6fc:	e12fff33 	blx	r3
3480c700:	ea000060 	b	3480c888 <parse_stream_outer+0x4b8>
			b_adduint(dest,global_argc ? global_argc-1 : 0);
			advance = 1;
			break;
#endif
		case '{':
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480c704:	e1a00005 	mov	r0, r5
3480c708:	e3a01003 	mov	r1, #3
3480c70c:	ebfffa4a 	bl	3480b03c <b_addchr>
			ctx->child->sp++;
3480c710:	e59d3008 	ldr	r3, [sp, #8]
			b_getch(input);
3480c714:	e1a00004 	mov	r0, r4
			advance = 1;
			break;
#endif
		case '{':
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
			ctx->child->sp++;
3480c718:	e593200c 	ldr	r2, [r3, #12]
3480c71c:	e2822001 	add	r2, r2, #1
3480c720:	e583200c 	str	r2, [r3, #12]
			b_getch(input);
3480c724:	e594300c 	ldr	r3, [r4, #12]
3480c728:	e12fff33 	blx	r3
3480c72c:	ea000001 	b	3480c738 <parse_stream_outer+0x368>
			/* XXX maybe someone will try to escape the '}' */
			while(ch=b_getch(input),ch!=EOF && ch!='}') {
				b_addchr(dest,ch);
3480c730:	e1a00005 	mov	r0, r5
3480c734:	ebfffa40 	bl	3480b03c <b_addchr>
		case '{':
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
			ctx->child->sp++;
			b_getch(input);
			/* XXX maybe someone will try to escape the '}' */
			while(ch=b_getch(input),ch!=EOF && ch!='}') {
3480c738:	e594300c 	ldr	r3, [r4, #12]
3480c73c:	e1a00004 	mov	r0, r4
3480c740:	e12fff33 	blx	r3
3480c744:	e350007d 	cmp	r0, #125	; 0x7d
3480c748:	13700001 	cmnne	r0, #1
3480c74c:	e1a01000 	mov	r1, r0
3480c750:	1afffff6 	bne	3480c730 <parse_stream_outer+0x360>
				b_addchr(dest,ch);
			}
			if (ch != '}') {
3480c754:	e350007d 	cmp	r0, #125	; 0x7d
3480c758:	1a000048 	bne	3480c880 <parse_stream_outer+0x4b0>
				syntax();
				return 1;
			}
			b_addchr(dest, SPECIAL_VAR_SYMBOL);
3480c75c:	e1a00005 	mov	r0, r5
3480c760:	e3a01003 	mov	r1, #3
3480c764:	ebfffa34 	bl	3480b03c <b_addchr>
3480c768:	ea000046 	b	3480c888 <parse_stream_outer+0x4b8>
			break;
		case '$':
			if (handle_dollar(dest, ctx, input)!=0) return 1;
			break;
		case '\'':
			dest->nonnull = 1;
3480c76c:	e3a03001 	mov	r3, #1
3480c770:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480c774:	ea000004 	b	3480c78c <parse_stream_outer+0x3bc>
			while(ch=b_getch(input),ch!=EOF && ch!='\'') {
#ifdef __U_BOOT__
				if(input->__promptme == 0) return 1;
3480c778:	e5943004 	ldr	r3, [r4, #4]
3480c77c:	e3530000 	cmp	r3, #0
3480c780:	0a000047 	beq	3480c8a4 <parse_stream_outer+0x4d4>
#endif
				b_addchr(dest,ch);
3480c784:	e1a00005 	mov	r0, r5
3480c788:	ebfffa2b 	bl	3480b03c <b_addchr>
		case '$':
			if (handle_dollar(dest, ctx, input)!=0) return 1;
			break;
		case '\'':
			dest->nonnull = 1;
			while(ch=b_getch(input),ch!=EOF && ch!='\'') {
3480c78c:	e594300c 	ldr	r3, [r4, #12]
3480c790:	e1a00004 	mov	r0, r4
3480c794:	e12fff33 	blx	r3
3480c798:	e3500027 	cmp	r0, #39	; 0x27
3480c79c:	13700001 	cmnne	r0, #1
3480c7a0:	e1a01000 	mov	r1, r0
3480c7a4:	1afffff3 	bne	3480c778 <parse_stream_outer+0x3a8>
3480c7a8:	ea000032 	b	3480c878 <parse_stream_outer+0x4a8>
				return 1;
			}
			break;
		case '"':
			dest->nonnull = 1;
			dest->quote = !dest->quote;
3480c7ac:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
				syntax();
				return 1;
			}
			break;
		case '"':
			dest->nonnull = 1;
3480c7b0:	e3a02001 	mov	r2, #1
			dest->quote = !dest->quote;
3480c7b4:	e2733001 	rsbs	r3, r3, #1
3480c7b8:	33a03000 	movcc	r3, #0
				syntax();
				return 1;
			}
			break;
		case '"':
			dest->nonnull = 1;
3480c7bc:	e58d2034 	str	r2, [sp, #52]	; 0x34
			dest->quote = !dest->quote;
3480c7c0:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480c7c4:	ea00002f 	b	3480c888 <parse_stream_outer+0x4b8>
			}
			setup_redirect(ctx, redir_fd, redir_style, input);
			break;
#endif
		case ';':
			done_word(dest, ctx);
3480c7c8:	e1a01006 	mov	r1, r6
3480c7cc:	e1a00005 	mov	r0, r5
3480c7d0:	ebfffc3f 	bl	3480b8d4 <done_word>
			done_pipe(ctx,PIPE_SEQ);
3480c7d4:	e1a00006 	mov	r0, r6
3480c7d8:	e3a01001 	mov	r1, #1
3480c7dc:	ea000014 	b	3480c834 <parse_stream_outer+0x464>
			break;
		case '&':
			done_word(dest, ctx);
3480c7e0:	e1a00005 	mov	r0, r5
3480c7e4:	e1a01006 	mov	r1, r6
3480c7e8:	ebfffc39 	bl	3480b8d4 <done_word>
			if (next=='&') {
3480c7ec:	e3590026 	cmp	r9, #38	; 0x26
3480c7f0:	1a000022 	bne	3480c880 <parse_stream_outer+0x4b0>
				b_getch(input);
3480c7f4:	e594300c 	ldr	r3, [r4, #12]
3480c7f8:	e1a00004 	mov	r0, r4
3480c7fc:	e12fff33 	blx	r3
				done_pipe(ctx,PIPE_AND);
3480c800:	e1a00006 	mov	r0, r6
3480c804:	e3a01002 	mov	r1, #2
3480c808:	ea000009 	b	3480c834 <parse_stream_outer+0x464>
				return 1;
#endif
			}
			break;
		case '|':
			done_word(dest, ctx);
3480c80c:	e1a00005 	mov	r0, r5
3480c810:	e1a01006 	mov	r1, r6
3480c814:	ebfffc2e 	bl	3480b8d4 <done_word>
			if (next=='|') {
3480c818:	e359007c 	cmp	r9, #124	; 0x7c
3480c81c:	1a000017 	bne	3480c880 <parse_stream_outer+0x4b0>
				b_getch(input);
3480c820:	e594300c 	ldr	r3, [r4, #12]
3480c824:	e1a00004 	mov	r0, r4
3480c828:	e12fff33 	blx	r3
				done_pipe(ctx,PIPE_OR);
3480c82c:	e1a00006 	mov	r0, r6
3480c830:	e3a01003 	mov	r1, #3
3480c834:	ebfffba8 	bl	3480b6dc <done_pipe>
3480c838:	ea000012 	b	3480c888 <parse_stream_outer+0x4b8>
			syntax();   /* Proper use of this character caught by end_trigger */
			return 1;
			break;
#endif
		case SUBSTED_VAR_SYMBOL:
			dest->nonnull = 1;
3480c83c:	e3a03001 	mov	r3, #1
3480c840:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480c844:	ea000004 	b	3480c85c <parse_stream_outer+0x48c>
			while (ch = b_getch(input), ch != EOF &&
			    ch != SUBSTED_VAR_SYMBOL) {
				debug_printf("subst, pass=%d\n", ch);
				if (input->__promptme == 0)
3480c848:	e5943004 	ldr	r3, [r4, #4]
3480c84c:	e3530000 	cmp	r3, #0
3480c850:	0a000013 	beq	3480c8a4 <parse_stream_outer+0x4d4>
					return 1;
				b_addchr(dest, ch);
3480c854:	e1a00005 	mov	r0, r5
3480c858:	ebfff9f7 	bl	3480b03c <b_addchr>
			return 1;
			break;
#endif
		case SUBSTED_VAR_SYMBOL:
			dest->nonnull = 1;
			while (ch = b_getch(input), ch != EOF &&
3480c85c:	e594300c 	ldr	r3, [r4, #12]
3480c860:	e1a00004 	mov	r0, r4
3480c864:	e12fff33 	blx	r3
3480c868:	e3500004 	cmp	r0, #4
3480c86c:	13700001 	cmnne	r0, #1
3480c870:	e1a01000 	mov	r1, r0
3480c874:	1afffff3 	bne	3480c848 <parse_stream_outer+0x478>
				if (input->__promptme == 0)
					return 1;
				b_addchr(dest, ch);
			}
			debug_printf("subst, term=%d\n", ch);
			if (ch == EOF) {
3480c878:	e3710001 	cmn	r1, #1
3480c87c:	1a000001 	bne	3480c888 <parse_stream_outer+0x4b8>
				syntax();
				return 1;
			}
			break;
		default:
			syntax();   /* this is really an internal logic error */
3480c880:	ebfff8db 	bl	3480abf4 <syntax_err>
3480c884:	ea000006 	b	3480c8a4 <parse_stream_outer+0x4d4>
	/* Only double-quote state is handled in the state variable dest->quote.
	 * A single-quote triggers a bypass of the main loop until its mate is
	 * found.  When recursing, quote state is passed in via dest->quote. */

	debug_printf("parse_stream, end_trigger=%d\n",end_trigger);
	while ((ch=b_getch(input))!=EOF) {
3480c888:	e594300c 	ldr	r3, [r4, #12]
3480c88c:	e1a00004 	mov	r0, r4
3480c890:	e12fff33 	blx	r3
3480c894:	e3700001 	cmn	r0, #1
3480c898:	e1a0a000 	mov	sl, r0
3480c89c:	1afffeee 	bne	3480c45c <parse_stream_outer+0x8c>
3480c8a0:	ea00005d 	b	3480ca1c <parse_stream_outer+0x64c>
		update_ifs_map();
		if (!(flag & FLAG_PARSE_SEMICOLON) || (flag & FLAG_REPARSING)) mapset((uchar *)";$&|", 0);
		inp->promptmode=1;
		rcode = parse_stream(&temp, &ctx, inp, '\n');
#ifdef __U_BOOT__
		if (rcode == 1) flag_repeat = 0;
3480c8a4:	e59f2184 	ldr	r2, [pc, #388]	; 3480ca30 <parse_stream_outer+0x660>
3480c8a8:	e3a03000 	mov	r3, #0
3480c8ac:	e5823004 	str	r3, [r2, #4]
3480c8b0:	e3a0a001 	mov	sl, #1
3480c8b4:	ea000028 	b	3480c95c <parse_stream_outer+0x58c>
#endif
		if (rcode != 1 && ctx.old_flag != 0) {
			syntax();
3480c8b8:	ebfff8cd 	bl	3480abf4 <syntax_err>
#ifdef __U_BOOT__
			flag_repeat = 0;
3480c8bc:	e59f216c 	ldr	r2, [pc, #364]	; 3480ca30 <parse_stream_outer+0x660>
3480c8c0:	e3a03000 	mov	r3, #0
3480c8c4:	e5823004 	str	r3, [r2, #4]
3480c8c8:	ea00004e 	b	3480ca08 <parse_stream_outer+0x638>
#endif
		}
		if (rcode != 1 && ctx.old_flag == 0) {
			done_word(&temp, &ctx);
3480c8cc:	e1a01006 	mov	r1, r6
3480c8d0:	e1a00005 	mov	r0, r5
3480c8d4:	ebfffbfe 	bl	3480b8d4 <done_word>
			done_pipe(&ctx,PIPE_SEQ);
3480c8d8:	e3a01001 	mov	r1, #1
3480c8dc:	e1a00006 	mov	r0, r6
3480c8e0:	ebfffb7d 	bl	3480b6dc <done_pipe>
#ifndef __U_BOOT__
			run_list(ctx.list_head);
#else
			code = run_list(ctx.list_head);
3480c8e4:	e59db00c 	ldr	fp, [sp, #12]
{
	int rcode=0;
#ifndef __U_BOOT__
	if (fake_mode==0) {
#endif
		rcode = run_list_real(pi);
3480c8e8:	e1a0000b 	mov	r0, fp
3480c8ec:	ebfffcbe 	bl	3480bbec <run_list_real>
	}
#endif
	/* free_pipe_list has the side effect of clearing memory
	 * In the long run that function can be merged with run_list_real,
	 * but doing that now would hobble the debugging effort. */
	free_pipe_list(pi,0);
3480c8f0:	e1a01009 	mov	r1, r9
{
	int rcode=0;
#ifndef __U_BOOT__
	if (fake_mode==0) {
#endif
		rcode = run_list_real(pi);
3480c8f4:	e1a07000 	mov	r7, r0
	}
#endif
	/* free_pipe_list has the side effect of clearing memory
	 * In the long run that function can be merged with run_list_real,
	 * but doing that now would hobble the debugging effort. */
	free_pipe_list(pi,0);
3480c8f8:	e1a0000b 	mov	r0, fp
3480c8fc:	ebfff96d 	bl	3480aeb8 <free_pipe_list>
			done_pipe(&ctx,PIPE_SEQ);
#ifndef __U_BOOT__
			run_list(ctx.list_head);
#else
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
3480c900:	e3770002 	cmn	r7, #2
3480c904:	1a000010 	bne	3480c94c <parse_stream_outer+0x57c>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c908:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c90c:	e58d9028 	str	r9, [sp, #40]	; 0x28
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c910:	e3530000 	cmp	r3, #0
}

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
3480c914:	e58d9034 	str	r9, [sp, #52]	; 0x34
	if (o->data != NULL) *o->data = '\0';
3480c918:	15c39000 	strbne	r9, [r3]
}

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
3480c91c:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3480c920:	ebfff34d 	bl	3480965c <free>
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
3480c924:	e5943010 	ldr	r3, [r4, #16]
3480c928:	e59f2108 	ldr	r2, [pc, #264]	; 3480ca38 <parse_stream_outer+0x668>

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
	o->data = NULL;
3480c92c:	e3a07000 	mov	r7, #0
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
3480c930:	e1530002 	cmp	r3, r2

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
	o->data = NULL;
3480c934:	e58d7024 	str	r7, [sp, #36]	; 0x24
	o->maxlen = 0;
3480c938:	e58d702c 	str	r7, [sp, #44]	; 0x2c
			code = run_list(ctx.list_head);
			if (code == -2) {	/* exit */
				b_free(&temp);
				code = 0;
				/* XXX hackish way to not allow exit from main loop */
				if (inp->peek == file_peek) {
3480c93c:	1a00002d 	bne	3480c9f8 <parse_stream_outer+0x628>
					printf("exit not allowed from main input shell.\n");
3480c940:	e59f00f4 	ldr	r0, [pc, #244]	; 3480ca3c <parse_stream_outer+0x66c>
3480c944:	ebfff206 	bl	34809164 <printf>
					continue;
3480c948:	ea000025 	b	3480c9e4 <parse_stream_outer+0x614>
				}
				break;
			}
			if (code == -1)
3480c94c:	e3770001 	cmn	r7, #1
			    flag_repeat = 0;
3480c950:	059f30d8 	ldreq	r3, [pc, #216]	; 3480ca30 <parse_stream_outer+0x660>
3480c954:	05839004 	streq	r9, [r3, #4]
3480c958:	ea000016 	b	3480c9b8 <parse_stream_outer+0x5e8>
#endif
		} else {
			if (ctx.old_flag != 0) {
3480c95c:	e59d3018 	ldr	r3, [sp, #24]
3480c960:	e3530000 	cmp	r3, #0
3480c964:	0a000007 	beq	3480c988 <parse_stream_outer+0x5b8>
				free(ctx.stack);
3480c968:	e59d001c 	ldr	r0, [sp, #28]
3480c96c:	ebfff33a 	bl	3480965c <free>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c970:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c974:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c978:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c97c:	e58d3028 	str	r3, [sp, #40]	; 0x28
	o->nonnull = 0;
3480c980:	e58d3034 	str	r3, [sp, #52]	; 0x34
	if (o->data != NULL) *o->data = '\0';
3480c984:	15c23000 	strbne	r3, [r2]
			if (ctx.old_flag != 0) {
				free(ctx.stack);
				b_reset(&temp);
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
3480c988:	e5943004 	ldr	r3, [r4, #4]
3480c98c:	e3530000 	cmp	r3, #0
3480c990:	1a000001 	bne	3480c99c <parse_stream_outer+0x5cc>
3480c994:	e59f00a4 	ldr	r0, [pc, #164]	; 3480ca40 <parse_stream_outer+0x670>
3480c998:	ebfff1f1 	bl	34809164 <printf>
			inp->__promptme = 1;
#endif
			temp.nonnull = 0;
3480c99c:	e3a01000 	mov	r1, #0
				free(ctx.stack);
				b_reset(&temp);
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
			inp->__promptme = 1;
3480c9a0:	e3a03001 	mov	r3, #1
3480c9a4:	e884000a 	stm	r4, {r1, r3}
#endif
			temp.nonnull = 0;
			temp.quote = 0;
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
3480c9a8:	e59d000c 	ldr	r0, [sp, #12]
			}
#ifdef __U_BOOT__
			if (inp->__promptme == 0) printf("<INTERRUPT>\n");
			inp->__promptme = 1;
#endif
			temp.nonnull = 0;
3480c9ac:	e58d1034 	str	r1, [sp, #52]	; 0x34
			temp.quote = 0;
3480c9b0:	e58d1030 	str	r1, [sp, #48]	; 0x30
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
3480c9b4:	ebfff93f 	bl	3480aeb8 <free_pipe_list>

static void b_reset(o_string *o)
{
	o->length = 0;
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c9b8:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c9bc:	e3a03000 	mov	r3, #0
	o->nonnull = 0;
	if (o->data != NULL) *o->data = '\0';
3480c9c0:	e1520003 	cmp	r2, r3
	return 0;
}

static void b_reset(o_string *o)
{
	o->length = 0;
3480c9c4:	e58d3028 	str	r3, [sp, #40]	; 0x28
	o->nonnull = 0;
3480c9c8:	e58d3034 	str	r3, [sp, #52]	; 0x34
	if (o->data != NULL) *o->data = '\0';
3480c9cc:	15c23000 	strbne	r3, [r2]
}

static void b_free(o_string *o)
{
	b_reset(o);
	free(o->data);
3480c9d0:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3480c9d4:	ebfff320 	bl	3480965c <free>
	o->data = NULL;
3480c9d8:	e3a03000 	mov	r3, #0
3480c9dc:	e58d3024 	str	r3, [sp, #36]	; 0x24
	o->maxlen = 0;
3480c9e0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
			temp.quote = 0;
			inp->p = NULL;
			free_pipe_list(ctx.list_head,0);
		}
		b_free(&temp);
	} while (rcode != -1 && !(flag & FLAG_EXIT_FROM_LOOP));   /* loop on syntax errors, return on EOF */
3480c9e4:	e37a0001 	cmn	sl, #1
3480c9e8:	0a000002 	beq	3480c9f8 <parse_stream_outer+0x628>
3480c9ec:	e59d2004 	ldr	r2, [sp, #4]
3480c9f0:	e3120001 	tst	r2, #1
3480c9f4:	0afffe80 	beq	3480c3fc <parse_stream_outer+0x2c>
#ifndef __U_BOOT__
	return 0;
#else
	return (code != 0) ? 1 : 0;
#endif /* __U_BOOT__ */
}
3480c9f8:	e2570000 	subs	r0, r7, #0
3480c9fc:	13a00001 	movne	r0, #1
3480ca00:	e28dd038 	add	sp, sp, #56	; 0x38
3480ca04:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			syntax();
#ifdef __U_BOOT__
			flag_repeat = 0;
#endif
		}
		if (rcode != 1 && ctx.old_flag == 0) {
3480ca08:	e59d9018 	ldr	r9, [sp, #24]
3480ca0c:	e3590000 	cmp	r9, #0
3480ca10:	1affffd1 	bne	3480c95c <parse_stream_outer+0x58c>
3480ca14:	eaffffac 	b	3480c8cc <parse_stream_outer+0x4fc>
				if (end_trigger != '\0' && ch=='\n')
					done_pipe(ctx,PIPE_SEQ);
			}
			if (ch == end_trigger && !dest->quote && ctx->w==RES_NONE) {
				debug_printf("leaving parse_stream (triggered)\n");
				return 0;
3480ca18:	e1a0a003 	mov	sl, r3
		inp->promptmode=1;
		rcode = parse_stream(&temp, &ctx, inp, '\n');
#ifdef __U_BOOT__
		if (rcode == 1) flag_repeat = 0;
#endif
		if (rcode != 1 && ctx.old_flag != 0) {
3480ca1c:	e59d3018 	ldr	r3, [sp, #24]
3480ca20:	e3530000 	cmp	r3, #0
3480ca24:	0afffff7 	beq	3480ca08 <parse_stream_outer+0x638>
3480ca28:	eaffffa2 	b	3480c8b8 <parse_stream_outer+0x4e8>
3480ca2c:	34826265 	.word	0x34826265
3480ca30:	34829dc4 	.word	0x34829dc4
3480ca34:	34821cd4 	.word	0x34821cd4
3480ca38:	3480ab94 	.word	0x3480ab94
3480ca3c:	3482626a 	.word	0x3482626a
3480ca40:	34826293 	.word	0x34826293

3480ca44 <parse_file_outer>:
#ifndef __U_BOOT__
static int parse_file_outer(FILE *f)
#else
int parse_file_outer(void)
#endif
{
3480ca44:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
static void setup_file_in_str(struct in_str *i, FILE *f)
#else
static void setup_file_in_str(struct in_str *i)
#endif
{
	i->peek = file_peek;
3480ca48:	e59f3030 	ldr	r3, [pc, #48]	; 3480ca80 <parse_file_outer+0x3c>
	i->__promptme=1;
	i->promptmode=1;
#ifndef __U_BOOT__
	i->file = f;
#endif
	i->p = NULL;
3480ca4c:	e28d0018 	add	r0, sp, #24
static void setup_file_in_str(struct in_str *i, FILE *f)
#else
static void setup_file_in_str(struct in_str *i)
#endif
{
	i->peek = file_peek;
3480ca50:	e58d3014 	str	r3, [sp, #20]
	i->get = file_get;
3480ca54:	e59f3028 	ldr	r3, [pc, #40]	; 3480ca84 <parse_file_outer+0x40>
#ifndef __U_BOOT__
	setup_file_in_str(&input, f);
#else
	setup_file_in_str(&input);
#endif
	rcode = parse_stream_outer(&input, FLAG_PARSE_SEMICOLON);
3480ca58:	e3a01002 	mov	r1, #2
#else
static void setup_file_in_str(struct in_str *i)
#endif
{
	i->peek = file_peek;
	i->get = file_get;
3480ca5c:	e58d3010 	str	r3, [sp, #16]
	i->__promptme=1;
3480ca60:	e3a03001 	mov	r3, #1
3480ca64:	e58d3008 	str	r3, [sp, #8]
	i->promptmode=1;
3480ca68:	e58d300c 	str	r3, [sp, #12]
#ifndef __U_BOOT__
	i->file = f;
#endif
	i->p = NULL;
3480ca6c:	e3a03000 	mov	r3, #0
3480ca70:	e5203014 	str	r3, [r0, #-20]!
#ifndef __U_BOOT__
	setup_file_in_str(&input, f);
#else
	setup_file_in_str(&input);
#endif
	rcode = parse_stream_outer(&input, FLAG_PARSE_SEMICOLON);
3480ca74:	ebfffe55 	bl	3480c3d0 <parse_stream_outer>
	return rcode;
}
3480ca78:	e28dd01c 	add	sp, sp, #28
3480ca7c:	e8bd8000 	pop	{pc}
3480ca80:	3480ab94 	.word	0x3480ab94
3480ca84:	3480ad10 	.word	0x3480ad10

3480ca88 <u_boot_hush_start>:
	}
}
#endif

int u_boot_hush_start(void)
{
3480ca88:	e92d4038 	push	{r3, r4, r5, lr}
	if (top_vars == NULL) {
3480ca8c:	e59f503c 	ldr	r5, [pc, #60]	; 3480cad0 <u_boot_hush_start+0x48>
3480ca90:	e5954000 	ldr	r4, [r5]
3480ca94:	e3540000 	cmp	r4, #0
3480ca98:	1a00000a 	bne	3480cac8 <u_boot_hush_start+0x40>
		top_vars = malloc(sizeof(struct variables));
3480ca9c:	e3a00014 	mov	r0, #20
3480caa0:	ebfff376 	bl	34809880 <malloc>
		top_vars->name = "HUSH_VERSION";
3480caa4:	e59f3028 	ldr	r3, [pc, #40]	; 3480cad4 <u_boot_hush_start+0x4c>
#endif

int u_boot_hush_start(void)
{
	if (top_vars == NULL) {
		top_vars = malloc(sizeof(struct variables));
3480caa8:	e5850000 	str	r0, [r5]
		top_vars->name = "HUSH_VERSION";
3480caac:	e5803000 	str	r3, [r0]
		top_vars->value = "0.01";
3480cab0:	e59f3020 	ldr	r3, [pc, #32]	; 3480cad8 <u_boot_hush_start+0x50>
		top_vars->next = 0;
3480cab4:	e5804010 	str	r4, [r0, #16]
int u_boot_hush_start(void)
{
	if (top_vars == NULL) {
		top_vars = malloc(sizeof(struct variables));
		top_vars->name = "HUSH_VERSION";
		top_vars->value = "0.01";
3480cab8:	e5803004 	str	r3, [r0, #4]
		top_vars->next = 0;
		top_vars->flg_export = 0;
		top_vars->flg_read_only = 1;
3480cabc:	e3a03001 	mov	r3, #1
	if (top_vars == NULL) {
		top_vars = malloc(sizeof(struct variables));
		top_vars->name = "HUSH_VERSION";
		top_vars->value = "0.01";
		top_vars->next = 0;
		top_vars->flg_export = 0;
3480cac0:	e5804008 	str	r4, [r0, #8]
		top_vars->flg_read_only = 1;
3480cac4:	e580300c 	str	r3, [r0, #12]
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		u_boot_hush_reloc();
#endif
	}
	return 0;
}
3480cac8:	e3a00000 	mov	r0, #0
3480cacc:	e8bd8038 	pop	{r3, r4, r5, pc}
3480cad0:	34829dc4 	.word	0x34829dc4
3480cad4:	348262a0 	.word	0x348262a0
3480cad8:	348262ad 	.word	0x348262ad

3480cadc <__fswab32>:
3480cadc:	e6bf0f30 	rev	r0, r0
3480cae0:	e12fff1e 	bx	lr

3480cae4 <image_check_magic.clone.8>:
phys_size_t getenv_bootm_size(void);
phys_size_t getenv_bootm_mapsize(void);
void memmove_wd(void *to, void *from, size_t len, ulong chunksz);
#endif

static inline int image_check_magic(const image_header_t *hdr)
3480cae4:	e92d4008 	push	{r3, lr}
#define image_get_hdr_l(f) \
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
3480cae8:	ebfffffb 	bl	3480cadc <__fswab32>
#endif

static inline int image_check_magic(const image_header_t *hdr)
{
	return (image_get_magic(hdr) == IH_MAGIC);
}
3480caec:	e59f300c 	ldr	r3, [pc, #12]	; 3480cb00 <image_check_magic.clone.8+0x1c>
3480caf0:	e1500003 	cmp	r0, r3
3480caf4:	13a00000 	movne	r0, #0
3480caf8:	03a00001 	moveq	r0, #1
3480cafc:	e8bd8008 	pop	{r3, pc}
3480cb00:	27051956 	.word	0x27051956

3480cb04 <image_get_data_size.clone.10>:
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
3480cb04:	eafffff4 	b	3480cadc <__fswab32>

3480cb08 <image_check_hcrc>:

/*****************************************************************************/
/* Legacy format routines */
/*****************************************************************************/
int image_check_hcrc(const image_header_t *hdr)
{
3480cb08:	e92d4030 	push	{r4, r5, lr}
3480cb0c:	e1a04000 	mov	r4, r0
3480cb10:	e24dd044 	sub	sp, sp, #68	; 0x44
	ulong hcrc;
	ulong len = image_get_header_size();
	image_header_t header;

	/* Copy header so we can blank CRC field for re-calculation */
	memmove(&header, (char *)hdr, image_get_header_size());
3480cb14:	e1a01004 	mov	r1, r4
3480cb18:	e1a0000d 	mov	r0, sp
3480cb1c:	e3a02040 	mov	r2, #64	; 0x40
3480cb20:	eb003d28 	bl	3481bfc8 <memmove>
	image_set_hcrc(&header, 0);

	hcrc = crc32(0, (unsigned char *)&header, len);
3480cb24:	e1a0100d 	mov	r1, sp
3480cb28:	e3a02040 	mov	r2, #64	; 0x40
	static inline void image_set_##f(image_header_t *hdr, uint32_t val) \
	{ \
		hdr->ih_##f = cpu_to_uimage(val); \
	}
image_set_hdr_l(magic)		/* image_set_magic */
image_set_hdr_l(hcrc)		/* image_set_hcrc */
3480cb2c:	e3a00000 	mov	r0, #0
3480cb30:	e58d0004 	str	r0, [sp, #4]
3480cb34:	eb003584 	bl	3481a14c <crc32>
3480cb38:	e1a05000 	mov	r5, r0
	static inline uint32_t image_get_##f(const image_header_t *hdr) \
	{ \
		return uimage_to_cpu(hdr->ih_##f); \
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
3480cb3c:	e5940004 	ldr	r0, [r4, #4]
3480cb40:	ebffffe5 	bl	3480cadc <__fswab32>

	return (hcrc == image_get_hcrc(hdr));
}
3480cb44:	e1550000 	cmp	r5, r0
3480cb48:	13a00000 	movne	r0, #0
3480cb4c:	03a00001 	moveq	r0, #1
3480cb50:	e28dd044 	add	sp, sp, #68	; 0x44
3480cb54:	e8bd8030 	pop	{r4, r5, pc}

3480cb58 <image_check_dcrc>:

int image_check_dcrc(const image_header_t *hdr)
{
3480cb58:	e92d4038 	push	{r3, r4, r5, lr}
3480cb5c:	e1a04000 	mov	r4, r0
	ulong data = image_get_data(hdr);
	ulong len = image_get_data_size(hdr);
3480cb60:	e590000c 	ldr	r0, [r0, #12]
3480cb64:	ebffffe6 	bl	3480cb04 <image_get_data_size.clone.10>
	ulong dcrc = crc32_wd(0, (unsigned char *)data, len, CHUNKSZ_CRC32);
3480cb68:	e2841040 	add	r1, r4, #64	; 0x40
}

int image_check_dcrc(const image_header_t *hdr)
{
	ulong data = image_get_data(hdr);
	ulong len = image_get_data_size(hdr);
3480cb6c:	e1a02000 	mov	r2, r0
	ulong dcrc = crc32_wd(0, (unsigned char *)data, len, CHUNKSZ_CRC32);
3480cb70:	e3a03801 	mov	r3, #65536	; 0x10000
3480cb74:	e3a00000 	mov	r0, #0
3480cb78:	eb003578 	bl	3481a160 <crc32_wd>
3480cb7c:	e1a05000 	mov	r5, r0
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
image_get_hdr_l(load)		/* image_get_load */
image_get_hdr_l(ep)		/* image_get_ep */
image_get_hdr_l(dcrc)		/* image_get_dcrc */
3480cb80:	e5940018 	ldr	r0, [r4, #24]
3480cb84:	ebffffd4 	bl	3480cadc <__fswab32>

	return (dcrc == image_get_dcrc(hdr));
}
3480cb88:	e1550000 	cmp	r5, r0
3480cb8c:	13a00000 	movne	r0, #0
3480cb90:	03a00001 	moveq	r0, #1
3480cb94:	e8bd8038 	pop	{r3, r4, r5, pc}

3480cb98 <image_multi_count>:
	/* get start of the image payload, which in case of multi
	 * component images that points to a table of component sizes */
	size = (uint32_t *)image_get_data(hdr);

	/* count non empty slots */
	for (i = 0; size[i]; ++i)
3480cb98:	e280303c 	add	r3, r0, #60	; 0x3c
3480cb9c:	e3a00000 	mov	r0, #0
3480cba0:	ea000000 	b	3480cba8 <image_multi_count+0x10>
3480cba4:	e2800001 	add	r0, r0, #1
3480cba8:	e5b32004 	ldr	r2, [r3, #4]!
3480cbac:	e3520000 	cmp	r2, #0
3480cbb0:	1afffffb 	bne	3480cba4 <image_multi_count+0xc>
		count++;

	return count;
}
3480cbb4:	e12fff1e 	bx	lr

3480cbb8 <image_multi_getimg>:
 *     data address and size of the component, if idx is valid
 *     0 in data and len, if idx is out of range
 */
void image_multi_getimg(const image_header_t *hdr, ulong idx,
			ulong *data, ulong *len)
{
3480cbb8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480cbbc:	e1a0a003 	mov	sl, r3
3480cbc0:	e1a05001 	mov	r5, r1
3480cbc4:	e1a06002 	mov	r6, r2
3480cbc8:	e1a04000 	mov	r4, r0
	int i;
	uint32_t *size;
	ulong offset, count, img_data;

	/* get number of component */
	count = image_multi_count(hdr);
3480cbcc:	ebfffff1 	bl	3480cb98 <image_multi_count>

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
3480cbd0:	e1550000 	cmp	r5, r0
		}

		/* calculate idx-th component data address */
		*data = img_data + offset;
	} else {
		*len = 0;
3480cbd4:	23a03000 	movcs	r3, #0
3480cbd8:	258a3000 	strcs	r3, [sl]
	int i;
	uint32_t *size;
	ulong offset, count, img_data;

	/* get number of component */
	count = image_multi_count(hdr);
3480cbdc:	e1a0b000 	mov	fp, r0

		/* calculate idx-th component data address */
		*data = img_data + offset;
	} else {
		*len = 0;
		*data = 0;
3480cbe0:	25863000 	strcs	r3, [r6]

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
3480cbe4:	28bd8ef0 	popcs	{r4, r5, r6, r7, r9, sl, fp, pc}
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
3480cbe8:	e2849040 	add	r9, r4, #64	; 0x40
		*len = uimage_to_cpu(size[idx]);
3480cbec:	e7990105 	ldr	r0, [r9, r5, lsl #2]
3480cbf0:	ebffffb9 	bl	3480cadc <__fswab32>
		offset = 0;
3480cbf4:	e3a07000 	mov	r7, #0
	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);

	if (idx < count) {
		*len = uimage_to_cpu(size[idx]);
3480cbf8:	e58a0000 	str	r0, [sl]
3480cbfc:	e284403c 	add	r4, r4, #60	; 0x3c
		offset = 0;

		/* go over all indices preceding requested component idx */
		for (i = 0; i < idx; i++) {
3480cc00:	e1a0a007 	mov	sl, r7
3480cc04:	ea000005 	b	3480cc20 <image_multi_getimg+0x68>
			/* add up i-th component size, rounding up to 4 bytes */
			offset += (uimage_to_cpu(size[i]) + 3) & ~3 ;
3480cc08:	e5b40004 	ldr	r0, [r4, #4]!
3480cc0c:	ebffffb2 	bl	3480cadc <__fswab32>
3480cc10:	e2800003 	add	r0, r0, #3
3480cc14:	e3c00003 	bic	r0, r0, #3
3480cc18:	e0877000 	add	r7, r7, r0
	if (idx < count) {
		*len = uimage_to_cpu(size[idx]);
		offset = 0;

		/* go over all indices preceding requested component idx */
		for (i = 0; i < idx; i++) {
3480cc1c:	e28aa001 	add	sl, sl, #1
3480cc20:	e15a0005 	cmp	sl, r5
3480cc24:	1afffff7 	bne	3480cc08 <image_multi_getimg+0x50>
	 * component images that points to a table of component sizes */
	size = (uint32_t *)image_get_data(hdr);

	/* get address of the proper component data start, which means
	 * skipping sizes table (add 1 for last, null entry) */
	img_data = image_get_data(hdr) + (count + 1) * sizeof(uint32_t);
3480cc28:	e28bb001 	add	fp, fp, #1
3480cc2c:	e089910b 	add	r9, r9, fp, lsl #2
			/* add up i-th component size, rounding up to 4 bytes */
			offset += (uimage_to_cpu(size[i]) + 3) & ~3 ;
		}

		/* calculate idx-th component data address */
		*data = img_data + offset;
3480cc30:	e0897007 	add	r7, r9, r7
3480cc34:	e5867000 	str	r7, [r6]
3480cc38:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3480cc3c <getenv_yesno>:
/*****************************************************************************/
/* Shared dual-format routines */
/*****************************************************************************/
#ifndef USE_HOSTCC
int getenv_yesno(char *var)
{
3480cc3c:	e92d4008 	push	{r3, lr}
	char *s = getenv(var);
3480cc40:	ebffea59 	bl	348075ac <getenv>
	return (s && (*s == 'n')) ? 0 : 1;
3480cc44:	e3500000 	cmp	r0, #0
3480cc48:	0a000003 	beq	3480cc5c <getenv_yesno+0x20>
3480cc4c:	e5d00000 	ldrb	r0, [r0]
3480cc50:	e250006e 	subs	r0, r0, #110	; 0x6e
3480cc54:	13a00001 	movne	r0, #1
3480cc58:	e8bd8008 	pop	{r3, pc}
3480cc5c:	e3a00001 	mov	r0, #1
}
3480cc60:	e8bd8008 	pop	{r3, pc}

3480cc64 <getenv_bootm_low>:

ulong getenv_bootm_low(void)
{
3480cc64:	e92d4010 	push	{r4, lr}
	char *s = getenv("bootm_low");
3480cc68:	e59f0020 	ldr	r0, [pc, #32]	; 3480cc90 <getenv_bootm_low+0x2c>
3480cc6c:	ebffea4e 	bl	348075ac <getenv>
	if (s) {
3480cc70:	e3500000 	cmp	r0, #0
3480cc74:	0a000003 	beq	3480cc88 <getenv_bootm_low+0x24>
		ulong tmp = simple_strtoul(s, NULL, 16);
3480cc78:	e3a01000 	mov	r1, #0
3480cc7c:	e3a02010 	mov	r2, #16
#elif defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].start;
#else
	return 0;
#endif
}
3480cc80:	e8bd4010 	pop	{r4, lr}

ulong getenv_bootm_low(void)
{
	char *s = getenv("bootm_low");
	if (s) {
		ulong tmp = simple_strtoul(s, NULL, 16);
3480cc84:	ea003f81 	b	3481ca90 <simple_strtoul>
#elif defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].start;
#else
	return 0;
#endif
}
3480cc88:	e3a00203 	mov	r0, #805306368	; 0x30000000
3480cc8c:	e8bd8010 	pop	{r4, pc}
3480cc90:	34826373 	.word	0x34826373

3480cc94 <getenv_bootm_size>:

phys_size_t getenv_bootm_size(void)
{
3480cc94:	e92d4010 	push	{r4, lr}
	phys_size_t tmp;
	char *s = getenv("bootm_size");
3480cc98:	e59f0048 	ldr	r0, [pc, #72]	; 3480cce8 <getenv_bootm_size+0x54>
3480cc9c:	ebffea42 	bl	348075ac <getenv>
	if (s) {
3480cca0:	e2504000 	subs	r4, r0, #0
3480cca4:	0a000003 	beq	3480ccb8 <getenv_bootm_size+0x24>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
3480cca8:	e3a02010 	mov	r2, #16
3480ccac:	e3a01000 	mov	r1, #0
3480ccb0:	eb003fe6 	bl	3481cc50 <simple_strtoull>
		return tmp;
3480ccb4:	e8bd8010 	pop	{r4, pc}
	}
	s = getenv("bootm_low");
3480ccb8:	e59f002c 	ldr	r0, [pc, #44]	; 3480ccec <getenv_bootm_size+0x58>
3480ccbc:	ebffea3a 	bl	348075ac <getenv>
	if (s)
3480ccc0:	e2503000 	subs	r3, r0, #0
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
	else
		tmp = 0;
3480ccc4:	01a00003 	moveq	r0, r3
	if (s) {
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
		return tmp;
	}
	s = getenv("bootm_low");
	if (s)
3480ccc8:	0a000002 	beq	3480ccd8 <getenv_bootm_size+0x44>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
3480cccc:	e1a01004 	mov	r1, r4
3480ccd0:	e3a02010 	mov	r2, #16
3480ccd4:	eb003fdd 	bl	3481cc50 <simple_strtoull>
	else
		tmp = 0;


#if defined(CONFIG_ARM)
	return gd->bd->bi_dram[0].size - tmp;
3480ccd8:	e5983000 	ldr	r3, [r8]
3480ccdc:	e593301c 	ldr	r3, [r3, #28]
3480cce0:	e0600003 	rsb	r0, r0, r3
#else
	return gd->bd->bi_memsize - tmp;
#endif
}
3480cce4:	e8bd8010 	pop	{r4, pc}
3480cce8:	3482637d 	.word	0x3482637d
3480ccec:	34826373 	.word	0x34826373

3480ccf0 <getenv_bootm_mapsize>:

phys_size_t getenv_bootm_mapsize(void)
{
3480ccf0:	e92d4010 	push	{r4, lr}
	phys_size_t tmp;
	char *s = getenv("bootm_mapsize");
3480ccf4:	e59f0020 	ldr	r0, [pc, #32]	; 3480cd1c <getenv_bootm_mapsize+0x2c>
3480ccf8:	ebffea2b 	bl	348075ac <getenv>
	if (s) {
3480ccfc:	e3500000 	cmp	r0, #0
3480cd00:	0a000003 	beq	3480cd14 <getenv_bootm_mapsize+0x24>
		tmp = (phys_size_t)simple_strtoull(s, NULL, 16);
3480cd04:	e3a02010 	mov	r2, #16
3480cd08:	e3a01000 	mov	r1, #0
3480cd0c:	eb003fcf 	bl	3481cc50 <simple_strtoull>
#if defined(CONFIG_SYS_BOOTMAPSZ)
	return CONFIG_SYS_BOOTMAPSZ;
#else
	return getenv_bootm_size();
#endif
}
3480cd10:	e8bd8010 	pop	{r4, pc}
3480cd14:	e8bd4010 	pop	{r4, lr}
	}

#if defined(CONFIG_SYS_BOOTMAPSZ)
	return CONFIG_SYS_BOOTMAPSZ;
#else
	return getenv_bootm_size();
3480cd18:	eaffffdd 	b	3480cc94 <getenv_bootm_size>
3480cd1c:	34826388 	.word	0x34826388

3480cd20 <memmove_wd>:
#endif
}

void memmove_wd(void *to, void *from, size_t len, ulong chunksz)
{
	if (to == from)
3480cd20:	e1510000 	cmp	r1, r0
3480cd24:	012fff1e 	bxeq	lr
		to += tail;
		from += tail;
		len -= tail;
	}
#else	/* !(CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG) */
	memmove(to, from, len);
3480cd28:	ea003ca6 	b	3481bfc8 <memmove>

3480cd2c <genimg_print_size>:
#endif	/* CONFIG_HW_WATCHDOG || CONFIG_WATCHDOG */
}
#endif /* !USE_HOSTCC */

void genimg_print_size(uint32_t size)
{
3480cd2c:	e92d4010 	push	{r4, lr}
3480cd30:	e1a04000 	mov	r4, r0
#ifndef USE_HOSTCC
	printf("%d Bytes = ", size);
3480cd34:	e1a01004 	mov	r1, r4
3480cd38:	e59f0014 	ldr	r0, [pc, #20]	; 3480cd54 <genimg_print_size+0x28>
3480cd3c:	ebfff108 	bl	34809164 <printf>
	print_size(size, "\n");
3480cd40:	e59f2010 	ldr	r2, [pc, #16]	; 3480cd58 <genimg_print_size+0x2c>
3480cd44:	e1a00004 	mov	r0, r4
3480cd48:	e3a01000 	mov	r1, #0
#else
	printf("%d Bytes = %.2f kB = %.2f MB\n",
			size, (double)size / 1.024e3,
			(double)size / 1.048576e6);
#endif
}
3480cd4c:	e8bd4010 	pop	{r4, lr}

void genimg_print_size(uint32_t size)
{
#ifndef USE_HOSTCC
	printf("%d Bytes = ", size);
	print_size(size, "\n");
3480cd50:	ea003515 	b	3481a1ac <print_size>
3480cd54:	34826396 	.word	0x34826396
3480cd58:	34826214 	.word	0x34826214

3480cd5c <get_table_entry_name>:
 * returns:
 *     long entry name if translation succeeds
 *     msg otherwise
 */
char *get_table_entry_name(const table_entry_t *table, char *msg, int id)
{
3480cd5c:	e1a03000 	mov	r3, r0
	for (; table->id >= 0; ++table) {
3480cd60:	ea000003 	b	3480cd74 <get_table_entry_name+0x18>
		if (table->id == id)
3480cd64:	e1500002 	cmp	r0, r2
#if defined(USE_HOSTCC) || !defined(CONFIG_NEEDS_MANUAL_RELOC)
			return table->lname;
3480cd68:	05931008 	ldreq	r1, [r3, #8]
3480cd6c:	0a000003 	beq	3480cd80 <get_table_entry_name+0x24>
 *     long entry name if translation succeeds
 *     msg otherwise
 */
char *get_table_entry_name(const table_entry_t *table, char *msg, int id)
{
	for (; table->id >= 0; ++table) {
3480cd70:	e283300c 	add	r3, r3, #12
3480cd74:	e5930000 	ldr	r0, [r3]
3480cd78:	e3500000 	cmp	r0, #0
3480cd7c:	aafffff8 	bge	3480cd64 <get_table_entry_name+0x8>
#else
			return table->lname + gd->reloc_off;
#endif
	}
	return (msg);
}
3480cd80:	e1a00001 	mov	r0, r1
3480cd84:	e12fff1e 	bx	lr

3480cd88 <genimg_get_os_name>:

const char *genimg_get_os_name(uint8_t os)
{
3480cd88:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_os, "Unknown OS", os));
3480cd8c:	e59f1004 	ldr	r1, [pc, #4]	; 3480cd98 <genimg_get_os_name+0x10>
3480cd90:	e59f0004 	ldr	r0, [pc, #4]	; 3480cd9c <genimg_get_os_name+0x14>
3480cd94:	eafffff0 	b	3480cd5c <get_table_entry_name>
3480cd98:	348263a2 	.word	0x348263a2
3480cd9c:	348210d0 	.word	0x348210d0

3480cda0 <genimg_get_arch_name>:
}

const char *genimg_get_arch_name(uint8_t arch)
{
3480cda0:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_arch, "Unknown Architecture",
3480cda4:	e59f1004 	ldr	r1, [pc, #4]	; 3480cdb0 <genimg_get_arch_name+0x10>
3480cda8:	e59f0004 	ldr	r0, [pc, #4]	; 3480cdb4 <genimg_get_arch_name+0x14>
3480cdac:	eaffffea 	b	3480cd5c <get_table_entry_name>
3480cdb0:	348263ad 	.word	0x348263ad
3480cdb4:	34821124 	.word	0x34821124

3480cdb8 <genimg_get_type_name>:
					arch));
}

const char *genimg_get_type_name(uint8_t type)
{
3480cdb8:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_type, "Unknown Image", type));
3480cdbc:	e59f1004 	ldr	r1, [pc, #4]	; 3480cdc8 <genimg_get_type_name+0x10>
3480cdc0:	e59f0004 	ldr	r0, [pc, #4]	; 3480cdcc <genimg_get_type_name+0x14>
3480cdc4:	eaffffe4 	b	3480cd5c <get_table_entry_name>
3480cdc8:	348263c2 	.word	0x348263c2
3480cdcc:	34821220 	.word	0x34821220

3480cdd0 <genimg_get_comp_name>:
}

const char *genimg_get_comp_name(uint8_t comp)
{
3480cdd0:	e1a02000 	mov	r2, r0
	return (get_table_entry_name(uimage_comp, "Unknown Compression",
3480cdd4:	e59f1004 	ldr	r1, [pc, #4]	; 3480cde0 <genimg_get_comp_name+0x10>
3480cdd8:	e59f0004 	ldr	r0, [pc, #4]	; 3480cde4 <genimg_get_comp_name+0x14>
3480cddc:	eaffffde 	b	3480cd5c <get_table_entry_name>
3480cde0:	348263d0 	.word	0x348263d0
3480cde4:	348212ec 	.word	0x348212ec

3480cde8 <image_print_contents>:
 *
 * returns:
 *     no returned results
 */
void image_print_contents(const void *ptr)
{
3480cde8:	e92d44ff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, sl, lr}
3480cdec:	e1a04000 	mov	r4, r0
	p = "";
#else
	p = "   ";
#endif

	printf("%sImage Name:   %.*s\n", p, IH_NMLEN, image_get_name(hdr));
3480cdf0:	e3a02020 	mov	r2, #32
3480cdf4:	e0843002 	add	r3, r4, r2
3480cdf8:	e59f1138 	ldr	r1, [pc, #312]	; 3480cf38 <image_print_contents+0x150>
3480cdfc:	e59f0138 	ldr	r0, [pc, #312]	; 3480cf3c <image_print_contents+0x154>
3480ce00:	ebfff0d7 	bl	34809164 <printf>
#if defined(CONFIG_TIMESTAMP) || defined(CONFIG_CMD_DATE) || defined(USE_HOSTCC)
	printf("%sCreated:      ", p);
	genimg_print_time((time_t)image_get_time(hdr));
#endif
	printf("%sImage Type:   ", p);
3480ce04:	e59f112c 	ldr	r1, [pc, #300]	; 3480cf38 <image_print_contents+0x150>
3480ce08:	e59f0130 	ldr	r0, [pc, #304]	; 3480cf40 <image_print_contents+0x158>
3480ce0c:	ebfff0d4 	bl	34809164 <printf>

static void image_print_type(const image_header_t *hdr)
{
	const char *os, *arch, *type, *comp;

	os = genimg_get_os_name(image_get_os(hdr));
3480ce10:	e5d4001c 	ldrb	r0, [r4, #28]
3480ce14:	ebffffdb 	bl	3480cd88 <genimg_get_os_name>
3480ce18:	e1a06000 	mov	r6, r0
	arch = genimg_get_arch_name(image_get_arch(hdr));
3480ce1c:	e5d4001d 	ldrb	r0, [r4, #29]
3480ce20:	ebffffde 	bl	3480cda0 <genimg_get_arch_name>
3480ce24:	e1a07000 	mov	r7, r0
	type = genimg_get_type_name(image_get_type(hdr));
3480ce28:	e5d4001e 	ldrb	r0, [r4, #30]
3480ce2c:	ebffffe1 	bl	3480cdb8 <genimg_get_type_name>
3480ce30:	e1a05000 	mov	r5, r0
	comp = genimg_get_comp_name(image_get_comp(hdr));
3480ce34:	e5d4001f 	ldrb	r0, [r4, #31]
3480ce38:	ebffffe4 	bl	3480cdd0 <genimg_get_comp_name>

	printf("%s %s %s (%s)\n", arch, os, type, comp);
3480ce3c:	e1a03005 	mov	r3, r5
3480ce40:	e1a02006 	mov	r2, r6
3480ce44:	e58d0000 	str	r0, [sp]
3480ce48:	e1a01007 	mov	r1, r7
3480ce4c:	e59f00f0 	ldr	r0, [pc, #240]	; 3480cf44 <image_print_contents+0x15c>
3480ce50:	ebfff0c3 	bl	34809164 <printf>
	printf("%sCreated:      ", p);
	genimg_print_time((time_t)image_get_time(hdr));
#endif
	printf("%sImage Type:   ", p);
	image_print_type(hdr);
	printf("%sData Size:    ", p);
3480ce54:	e59f10dc 	ldr	r1, [pc, #220]	; 3480cf38 <image_print_contents+0x150>
3480ce58:	e59f00e8 	ldr	r0, [pc, #232]	; 3480cf48 <image_print_contents+0x160>
3480ce5c:	ebfff0c0 	bl	34809164 <printf>
	genimg_print_size(image_get_data_size(hdr));
3480ce60:	e594000c 	ldr	r0, [r4, #12]
3480ce64:	ebffff26 	bl	3480cb04 <image_get_data_size.clone.10>
3480ce68:	ebffffaf 	bl	3480cd2c <genimg_print_size>
	}
image_get_hdr_l(magic)		/* image_get_magic */
image_get_hdr_l(hcrc)		/* image_get_hcrc */
image_get_hdr_l(time)		/* image_get_time */
image_get_hdr_l(size)		/* image_get_size */
image_get_hdr_l(load)		/* image_get_load */
3480ce6c:	e5940010 	ldr	r0, [r4, #16]
3480ce70:	ebffff19 	bl	3480cadc <__fswab32>
	printf("%sLoad Address: %08x\n", p, image_get_load(hdr));
3480ce74:	e59f10bc 	ldr	r1, [pc, #188]	; 3480cf38 <image_print_contents+0x150>
3480ce78:	e1a02000 	mov	r2, r0
3480ce7c:	e59f00c8 	ldr	r0, [pc, #200]	; 3480cf4c <image_print_contents+0x164>
3480ce80:	ebfff0b7 	bl	34809164 <printf>
image_get_hdr_l(ep)		/* image_get_ep */
3480ce84:	e5940014 	ldr	r0, [r4, #20]
3480ce88:	ebffff13 	bl	3480cadc <__fswab32>
	printf("%sEntry Point:  %08x\n", p, image_get_ep(hdr));
3480ce8c:	e59f10a4 	ldr	r1, [pc, #164]	; 3480cf38 <image_print_contents+0x150>
3480ce90:	e1a02000 	mov	r2, r0
3480ce94:	e59f00b4 	ldr	r0, [pc, #180]	; 3480cf50 <image_print_contents+0x168>
3480ce98:	ebfff0b1 	bl	34809164 <printf>

	return 0;

error:
	return -1;
}
3480ce9c:	e5d4301e 	ldrb	r3, [r4, #30]
	printf("%sData Size:    ", p);
	genimg_print_size(image_get_data_size(hdr));
	printf("%sLoad Address: %08x\n", p, image_get_load(hdr));
	printf("%sEntry Point:  %08x\n", p, image_get_ep(hdr));

	if (image_check_type(hdr, IH_TYPE_MULTI) ||
3480cea0:	e3530004 	cmp	r3, #4
3480cea4:	0a000001 	beq	3480ceb0 <image_print_contents+0xc8>
3480cea8:	e3530006 	cmp	r3, #6
3480ceac:	1a000020 	bne	3480cf34 <image_print_contents+0x14c>
			image_check_type(hdr, IH_TYPE_SCRIPT)) {
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);
3480ceb0:	e1a00004 	mov	r0, r4
3480ceb4:	ebffff37 	bl	3480cb98 <image_multi_count>

		printf("%sContents:\n", p);
3480ceb8:	e59f1078 	ldr	r1, [pc, #120]	; 3480cf38 <image_print_contents+0x150>

	if (image_check_type(hdr, IH_TYPE_MULTI) ||
			image_check_type(hdr, IH_TYPE_SCRIPT)) {
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);
3480cebc:	e1a06000 	mov	r6, r0

		printf("%sContents:\n", p);
3480cec0:	e59f008c 	ldr	r0, [pc, #140]	; 3480cf54 <image_print_contents+0x16c>
3480cec4:	ebfff0a6 	bl	34809164 <printf>
		for (i = 0; i < count; i++) {
3480cec8:	e3a05000 	mov	r5, #0
			image_multi_getimg(hdr, i, &data, &len);
3480cecc:	e28d700c 	add	r7, sp, #12
3480ced0:	e28da008 	add	sl, sp, #8
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);

		printf("%sContents:\n", p);
		for (i = 0; i < count; i++) {
3480ced4:	ea000014 	b	3480cf2c <image_print_contents+0x144>
			image_multi_getimg(hdr, i, &data, &len);
3480ced8:	e1a0300a 	mov	r3, sl
3480cedc:	e1a00004 	mov	r0, r4
3480cee0:	e1a01005 	mov	r1, r5
3480cee4:	e1a02007 	mov	r2, r7
3480cee8:	ebffff32 	bl	3480cbb8 <image_multi_getimg>

			printf("%s   Image %d: ", p, i);
3480ceec:	e59f1044 	ldr	r1, [pc, #68]	; 3480cf38 <image_print_contents+0x150>
3480cef0:	e1a02005 	mov	r2, r5
3480cef4:	e59f005c 	ldr	r0, [pc, #92]	; 3480cf58 <image_print_contents+0x170>
3480cef8:	ebfff099 	bl	34809164 <printf>
			genimg_print_size(len);
3480cefc:	e59d0008 	ldr	r0, [sp, #8]
3480cf00:	ebffff89 	bl	3480cd2c <genimg_print_size>

			if (image_check_type(hdr, IH_TYPE_SCRIPT) && i > 0) {
3480cf04:	e5d4301e 	ldrb	r3, [r4, #30]
3480cf08:	e3530006 	cmp	r3, #6
3480cf0c:	1a000005 	bne	3480cf28 <image_print_contents+0x140>
3480cf10:	e3550000 	cmp	r5, #0
3480cf14:	0a000003 	beq	3480cf28 <image_print_contents+0x140>
				/*
				 * the user may need to know offsets
				 * if planning to do something with
				 * multiple files
				 */
				printf("%s    Offset = 0x%08lx\n", p, data);
3480cf18:	e59f003c 	ldr	r0, [pc, #60]	; 3480cf5c <image_print_contents+0x174>
3480cf1c:	e59f1014 	ldr	r1, [pc, #20]	; 3480cf38 <image_print_contents+0x150>
3480cf20:	e59d200c 	ldr	r2, [sp, #12]
3480cf24:	ebfff08e 	bl	34809164 <printf>
		int i;
		ulong data, len;
		ulong count = image_multi_count(hdr);

		printf("%sContents:\n", p);
		for (i = 0; i < count; i++) {
3480cf28:	e2855001 	add	r5, r5, #1
3480cf2c:	e1550006 	cmp	r5, r6
3480cf30:	3affffe8 	bcc	3480ced8 <image_print_contents+0xf0>
				 */
				printf("%s    Offset = 0x%08lx\n", p, data);
			}
		}
	}
}
3480cf34:	e8bd84ff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, sl, pc}
3480cf38:	34826427 	.word	0x34826427
3480cf3c:	348263e4 	.word	0x348263e4
3480cf40:	348263fa 	.word	0x348263fa
3480cf44:	3482640b 	.word	0x3482640b
3480cf48:	3482641a 	.word	0x3482641a
3480cf4c:	3482642b 	.word	0x3482642b
3480cf50:	34826441 	.word	0x34826441
3480cf54:	34826457 	.word	0x34826457
3480cf58:	34826464 	.word	0x34826464
3480cf5c:	34826474 	.word	0x34826474

3480cf60 <get_table_entry_id>:
 *     entry id if translation succeeds
 *     -1 otherwise
 */
int get_table_entry_id(const table_entry_t *table,
		const char *table_name, const char *name)
{
3480cf60:	e92d4038 	push	{r3, r4, r5, lr}
3480cf64:	e1a05002 	mov	r5, r2
		fprintf(stderr, "%c %s", (first) ? ':' : ',', t->sname);
		first = 0;
	}
	fprintf(stderr, "\n");
#else
	for (t = table; t->id >= 0; ++t) {
3480cf68:	e1a04000 	mov	r4, r0
3480cf6c:	ea000009 	b	3480cf98 <get_table_entry_id+0x38>
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		if (t->sname && strcmp(t->sname + gd->reloc_off, name) == 0)
#else
		if (t->sname && strcmp(t->sname, name) == 0)
3480cf70:	e5940004 	ldr	r0, [r4, #4]
3480cf74:	e3500000 	cmp	r0, #0
3480cf78:	0a000005 	beq	3480cf94 <get_table_entry_id+0x34>
3480cf7c:	e1a01005 	mov	r1, r5
3480cf80:	eb003afb 	bl	3481bb74 <strcmp>
3480cf84:	e3500000 	cmp	r0, #0
3480cf88:	1a000001 	bne	3480cf94 <get_table_entry_id+0x34>
#endif
			return (t->id);
3480cf8c:	e5940000 	ldr	r0, [r4]
3480cf90:	e8bd8038 	pop	{r3, r4, r5, pc}
		fprintf(stderr, "%c %s", (first) ? ':' : ',', t->sname);
		first = 0;
	}
	fprintf(stderr, "\n");
#else
	for (t = table; t->id >= 0; ++t) {
3480cf94:	e284400c 	add	r4, r4, #12
3480cf98:	e5943000 	ldr	r3, [r4]
3480cf9c:	e3530000 	cmp	r3, #0
3480cfa0:	aafffff2 	bge	3480cf70 <get_table_entry_id+0x10>
#endif
			return (t->id);
	}
	debug("Invalid %s Type: %s\n", table_name, name);
#endif /* USE_HOSTCC */
	return (-1);
3480cfa4:	e3e00000 	mvn	r0, #0
}
3480cfa8:	e8bd8038 	pop	{r3, r4, r5, pc}

3480cfac <genimg_get_os_id>:

int genimg_get_os_id(const char *name)
{
3480cfac:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_os, "OS", name));
3480cfb0:	e59f1004 	ldr	r1, [pc, #4]	; 3480cfbc <genimg_get_os_id+0x10>
3480cfb4:	e59f0004 	ldr	r0, [pc, #4]	; 3480cfc0 <genimg_get_os_id+0x14>
3480cfb8:	eaffffe8 	b	3480cf60 <get_table_entry_id>
3480cfbc:	348268a5 	.word	0x348268a5
3480cfc0:	348210d0 	.word	0x348210d0

3480cfc4 <genimg_get_arch_id>:
}

int genimg_get_arch_id(const char *name)
{
3480cfc4:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_arch, "CPU", name));
3480cfc8:	e59f1004 	ldr	r1, [pc, #4]	; 3480cfd4 <genimg_get_arch_id+0x10>
3480cfcc:	e59f0004 	ldr	r0, [pc, #4]	; 3480cfd8 <genimg_get_arch_id+0x14>
3480cfd0:	eaffffe2 	b	3480cf60 <get_table_entry_id>
3480cfd4:	34822d44 	.word	0x34822d44
3480cfd8:	34821124 	.word	0x34821124

3480cfdc <genimg_get_type_id>:
}

int genimg_get_type_id(const char *name)
{
3480cfdc:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_type, "Image", name));
3480cfe0:	e59f1004 	ldr	r1, [pc, #4]	; 3480cfec <genimg_get_type_id+0x10>
3480cfe4:	e59f0004 	ldr	r0, [pc, #4]	; 3480cff0 <genimg_get_type_id+0x14>
3480cfe8:	eaffffdc 	b	3480cf60 <get_table_entry_id>
3480cfec:	348266e8 	.word	0x348266e8
3480cff0:	34821220 	.word	0x34821220

3480cff4 <genimg_get_comp_id>:
}

int genimg_get_comp_id(const char *name)
{
3480cff4:	e1a02000 	mov	r2, r0
	return (get_table_entry_id(uimage_comp, "Compression", name));
3480cff8:	e59f1004 	ldr	r1, [pc, #4]	; 3480d004 <genimg_get_comp_id+0x10>
3480cffc:	e59f0004 	ldr	r0, [pc, #4]	; 3480d008 <genimg_get_comp_id+0x14>
3480d000:	eaffffd6 	b	3480cf60 <get_table_entry_id>
3480d004:	348263d8 	.word	0x348263d8
3480d008:	348212ec 	.word	0x348212ec

3480d00c <genimg_get_format>:
 *
 * returns:
 *     image format type or IMAGE_FORMAT_INVALID if no image is present
 */
int genimg_get_format(void *img_addr)
{
3480d00c:	e92d4008 	push	{r3, lr}
#if defined(CONFIG_FIT) || defined(CONFIG_OF_LIBFDT)
	char *fit_hdr;
#endif

	hdr = (const image_header_t *)img_addr;
	if (image_check_magic(hdr))
3480d010:	e5900000 	ldr	r0, [r0]
3480d014:	ebfffeb2 	bl	3480cae4 <image_check_magic.clone.8>
			format = IMAGE_FORMAT_FIT;
	}
#endif

	return format;
}
3480d018:	e2500000 	subs	r0, r0, #0
3480d01c:	13a00001 	movne	r0, #1
3480d020:	e8bd8008 	pop	{r3, pc}

3480d024 <genimg_get_image>:

	}
#endif /* CONFIG_HAS_DATAFLASH */

	return ram_addr;
}
3480d024:	e12fff1e 	bx	lr

3480d028 <genimg_has_config>:
#if defined(CONFIG_FIT)
	if (images->fit_uname_cfg)
		return 1;
#endif
	return 0;
}
3480d028:	e3a00000 	mov	r0, #0
3480d02c:	e12fff1e 	bx	lr

3480d030 <boot_get_ramdisk>:
 *     1, if ramdisk image is found but corrupted, or invalid
 *     rd_start and rd_end are set to 0 if no ramdisk exists
 */
int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
		uint8_t arch, ulong *rd_start, ulong *rd_end)
{
3480d030:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
3480d034:	e59d7028 	ldr	r7, [sp, #40]	; 0x28
3480d038:	e59d502c 	ldr	r5, [sp, #44]	; 0x2c
	int		cfg_noffset;
	const void	*data;
	size_t		size;
#endif

	*rd_start = 0;
3480d03c:	e3a09000 	mov	r9, #0

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
3480d040:	e3500002 	cmp	r0, #2
	int		cfg_noffset;
	const void	*data;
	size_t		size;
#endif

	*rd_start = 0;
3480d044:	e5879000 	str	r9, [r7]
 *     1, if ramdisk image is found but corrupted, or invalid
 *     rd_start and rd_end are set to 0 if no ramdisk exists
 */
int boot_get_ramdisk(int argc, char * const argv[], bootm_headers_t *images,
		uint8_t arch, ulong *rd_start, ulong *rd_end)
{
3480d048:	e1a06001 	mov	r6, r1
3480d04c:	e1a04002 	mov	r4, r2
3480d050:	e1a0a003 	mov	sl, r3
	const void	*data;
	size_t		size;
#endif

	*rd_start = 0;
	*rd_end = 0;
3480d054:	e5859000 	str	r9, [r5]

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
3480d058:	da000006 	ble	3480d078 <boot_get_ramdisk+0x48>
3480d05c:	e5910008 	ldr	r0, [r1, #8]
3480d060:	e59f11d0 	ldr	r1, [pc, #464]	; 3480d238 <boot_get_ramdisk+0x208>
3480d064:	eb003ac2 	bl	3481bb74 <strcmp>
3480d068:	e3500000 	cmp	r0, #0
		debug("## Skipping init Ramdisk\n");
		rd_len = rd_data = 0;
3480d06c:	058d0004 	streq	r0, [sp, #4]

	/*
	 * Look for a '-' which indicates to ignore the
	 * ramdisk argument
	 */
	if ((argc >= 3) && (strcmp(argv[2], "-") ==  0)) {
3480d070:	0a000044 	beq	3480d188 <boot_get_ramdisk+0x158>
3480d074:	ea000065 	b	3480d210 <boot_get_ramdisk+0x1e0>
				puts("Wrong Ramdisk Image Format\n");
				rd_data = rd_len = rd_load = 0;
				return 1;
			}
		}
	} else if (images->legacy_hdr_valid &&
3480d078:	e5923044 	ldr	r3, [r2, #68]	; 0x44
3480d07c:	e3530000 	cmp	r3, #0
3480d080:	1a000046 	bne	3480d1a0 <boot_get_ramdisk+0x170>
3480d084:	ea000053 	b	3480d1d8 <boot_get_ramdisk+0x1a8>
		 * address provided in the second bootm argument
		 * check image type, for FIT images get FIT node.
		 */
		switch (genimg_get_format((void *)rd_addr)) {
		case IMAGE_FORMAT_LEGACY:
			printf("## Loading init Ramdisk from Legacy "
3480d088:	e1a01006 	mov	r1, r6
3480d08c:	e59f01a8 	ldr	r0, [pc, #424]	; 3480d23c <boot_get_ramdisk+0x20c>
3480d090:	ebfff033 	bl	34809164 <printf>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480d094:	e3a00009 	mov	r0, #9
3480d098:	eb00012c 	bl	3480d550 <__show_boot_progress>
static const image_header_t *image_get_ramdisk(ulong rd_addr, uint8_t arch,
						int verify)
{
	const image_header_t *rd_hdr = (const image_header_t *)rd_addr;

	if (!image_check_magic(rd_hdr)) {
3480d09c:	e5960000 	ldr	r0, [r6]
3480d0a0:	ebfffe8f 	bl	3480cae4 <image_check_magic.clone.8>
3480d0a4:	e3500000 	cmp	r0, #0
		case IMAGE_FORMAT_LEGACY:
			printf("## Loading init Ramdisk from Legacy "
					"Image at %08lx ...\n", rd_addr);

			bootstage_mark(BOOTSTAGE_ID_CHECK_RAMDISK);
			rd_hdr = image_get_ramdisk(rd_addr, arch,
3480d0a8:	e5944084 	ldr	r4, [r4, #132]	; 0x84
static const image_header_t *image_get_ramdisk(ulong rd_addr, uint8_t arch,
						int verify)
{
	const image_header_t *rd_hdr = (const image_header_t *)rd_addr;

	if (!image_check_magic(rd_hdr)) {
3480d0ac:	1a000003 	bne	3480d0c0 <boot_get_ramdisk+0x90>
		puts("Bad Magic Number\n");
3480d0b0:	e59f0188 	ldr	r0, [pc, #392]	; 3480d240 <boot_get_ramdisk+0x210>
3480d0b4:	ebfff020 	bl	3480913c <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3480d0b8:	e3e00009 	mvn	r0, #9
3480d0bc:	ea000006 	b	3480d0dc <boot_get_ramdisk+0xac>
		bootstage_error(BOOTSTAGE_ID_RD_MAGIC);
		return NULL;
	}

	if (!image_check_hcrc(rd_hdr)) {
3480d0c0:	e1a00006 	mov	r0, r6
3480d0c4:	ebfffe8f 	bl	3480cb08 <image_check_hcrc>
3480d0c8:	e3500000 	cmp	r0, #0
3480d0cc:	1a000004 	bne	3480d0e4 <boot_get_ramdisk+0xb4>
		puts("Bad Header Checksum\n");
3480d0d0:	e59f016c 	ldr	r0, [pc, #364]	; 3480d244 <boot_get_ramdisk+0x214>
3480d0d4:	ebfff018 	bl	3480913c <puts>
3480d0d8:	e3e0000a 	mvn	r0, #10
3480d0dc:	eb00011b 	bl	3480d550 <__show_boot_progress>
3480d0e0:	ea000048 	b	3480d208 <boot_get_ramdisk+0x1d8>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480d0e4:	e3a0000a 	mov	r0, #10
3480d0e8:	eb000118 	bl	3480d550 <__show_boot_progress>
		bootstage_error(BOOTSTAGE_ID_RD_HDR_CHECKSUM);
		return NULL;
	}

	bootstage_mark(BOOTSTAGE_ID_RD_MAGIC);
	image_print_contents(rd_hdr);
3480d0ec:	e1a00006 	mov	r0, r6
3480d0f0:	ebffff3c 	bl	3480cde8 <image_print_contents>

	if (verify) {
3480d0f4:	e3540000 	cmp	r4, #0
3480d0f8:	0a00000b 	beq	3480d12c <boot_get_ramdisk+0xfc>
		puts("   Verifying Checksum ... ");
3480d0fc:	e59f0144 	ldr	r0, [pc, #324]	; 3480d248 <boot_get_ramdisk+0x218>
3480d100:	ebfff00d 	bl	3480913c <puts>
		if (!image_check_dcrc(rd_hdr)) {
3480d104:	e1a00006 	mov	r0, r6
3480d108:	ebfffe92 	bl	3480cb58 <image_check_dcrc>
3480d10c:	e3500000 	cmp	r0, #0
3480d110:	1a000003 	bne	3480d124 <boot_get_ramdisk+0xf4>
			puts("Bad Data CRC\n");
3480d114:	e59f0130 	ldr	r0, [pc, #304]	; 3480d24c <boot_get_ramdisk+0x21c>
3480d118:	ebfff007 	bl	3480913c <puts>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3480d11c:	e3e0000b 	mvn	r0, #11
3480d120:	eaffffed 	b	3480d0dc <boot_get_ramdisk+0xac>
			bootstage_error(BOOTSTAGE_ID_RD_CHECKSUM);
			return NULL;
		}
		puts("OK\n");
3480d124:	e59f0124 	ldr	r0, [pc, #292]	; 3480d250 <boot_get_ramdisk+0x220>
3480d128:	ebfff003 	bl	3480913c <puts>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480d12c:	e3a0000b 	mov	r0, #11
3480d130:	eb000106 	bl	3480d550 <__show_boot_progress>
	}

	bootstage_mark(BOOTSTAGE_ID_RD_HDR_CHECKSUM);

	if (!image_check_os(rd_hdr, IH_OS_LINUX) ||
3480d134:	e5d6301c 	ldrb	r3, [r6, #28]
3480d138:	e3530005 	cmp	r3, #5
3480d13c:	1a000005 	bne	3480d158 <boot_get_ramdisk+0x128>
3480d140:	e5d6301d 	ldrb	r3, [r6, #29]
3480d144:	e153000a 	cmp	r3, sl
3480d148:	1a000002 	bne	3480d158 <boot_get_ramdisk+0x128>
	    !image_check_arch(rd_hdr, arch) ||
3480d14c:	e5d6301e 	ldrb	r3, [r6, #30]
3480d150:	e3530003 	cmp	r3, #3
3480d154:	0a000007 	beq	3480d178 <boot_get_ramdisk+0x148>
	    !image_check_type(rd_hdr, IH_TYPE_RAMDISK)) {
		printf("No Linux %s Ramdisk Image\n",
3480d158:	e1a0000a 	mov	r0, sl
3480d15c:	ebffff0f 	bl	3480cda0 <genimg_get_arch_name>
3480d160:	e1a01000 	mov	r1, r0
3480d164:	e59f00e8 	ldr	r0, [pc, #232]	; 3480d254 <boot_get_ramdisk+0x224>
3480d168:	ebffeffd 	bl	34809164 <printf>
	return 0;
}

static inline ulong bootstage_error(enum bootstage_id id)
{
	show_boot_progress(-id);
3480d16c:	e3e0000c 	mvn	r0, #12
3480d170:	eb0000f6 	bl	3480d550 <__show_boot_progress>
3480d174:	ea000007 	b	3480d198 <boot_get_ramdisk+0x168>
 * returns:
 *     image payload data start address
 */
static inline ulong image_get_data(const image_header_t *hdr)
{
	return ((ulong)hdr + image_get_header_size());
3480d178:	e2863040 	add	r3, r6, #64	; 0x40

			if (rd_hdr == NULL)
				return 1;

			rd_data = image_get_data(rd_hdr);
			rd_len = image_get_data_size(rd_hdr);
3480d17c:	e596000c 	ldr	r0, [r6, #12]
							images->verify);

			if (rd_hdr == NULL)
				return 1;

			rd_data = image_get_data(rd_hdr);
3480d180:	e58d3004 	str	r3, [sp, #4]
			rd_len = image_get_data_size(rd_hdr);
3480d184:	ebfffe5e 	bl	3480cb04 <image_get_data_size.clone.10>
3480d188:	e58d0000 	str	r0, [sp]
				puts("Wrong Ramdisk Image Format\n");
				rd_data = rd_len = rd_load = 0;
				return 1;
			}
		}
	} else if (images->legacy_hdr_valid &&
3480d18c:	ea000016 	b	3480d1ec <boot_get_ramdisk+0x1bc>
				rd_len = simple_strtoul(++end, NULL, 16);
				rd_data = rd_addr;
			} else
#endif
			{
				puts("Wrong Ramdisk Image Format\n");
3480d190:	e59f00c0 	ldr	r0, [pc, #192]	; 3480d258 <boot_get_ramdisk+0x228>
3480d194:	ebffefe8 	bl	3480913c <puts>
				rd_data = rd_len = rd_load = 0;
				return 1;
3480d198:	e3a09001 	mov	r9, #1
3480d19c:	ea000019 	b	3480d208 <boot_get_ramdisk+0x1d8>
			}
		}
	} else if (images->legacy_hdr_valid &&
3480d1a0:	e5d23022 	ldrb	r3, [r2, #34]	; 0x22
3480d1a4:	e3530004 	cmp	r3, #4
3480d1a8:	1a00000a 	bne	3480d1d8 <boot_get_ramdisk+0x1a8>
 * and won't even do that unless CONFIG_SHOW_BOOT_PROGRESS is defined
 */

static inline ulong bootstage_mark(enum bootstage_id id)
{
	show_boot_progress(id);
3480d1ac:	e3a0000d 	mov	r0, #13
3480d1b0:	eb0000e6 	bl	3480d550 <__show_boot_progress>
		/*
		 * Now check if we have a legacy mult-component image,
		 * get second entry data start address and len.
		 */
		bootstage_mark(BOOTSTAGE_ID_RAMDISK);
		printf("## Loading init Ramdisk from multi component "
3480d1b4:	e5941000 	ldr	r1, [r4]
3480d1b8:	e59f009c 	ldr	r0, [pc, #156]	; 3480d25c <boot_get_ramdisk+0x22c>
3480d1bc:	ebffefe8 	bl	34809164 <printf>
				"Legacy Image at %08lx ...\n",
				(ulong)images->legacy_hdr_os);

		image_multi_getimg(images->legacy_hdr_os, 1, &rd_data, &rd_len);
3480d1c0:	e5940000 	ldr	r0, [r4]
3480d1c4:	e3a01001 	mov	r1, #1
3480d1c8:	e28d2004 	add	r2, sp, #4
3480d1cc:	e1a0300d 	mov	r3, sp
3480d1d0:	ebfffe78 	bl	3480cbb8 <image_multi_getimg>
3480d1d4:	ea000004 	b	3480d1ec <boot_get_ramdisk+0x1bc>
3480d1d8:	e3a0000e 	mov	r0, #14
3480d1dc:	eb0000db 	bl	3480d550 <__show_boot_progress>
	} else {
		/*
		 * no initrd image
		 */
		bootstage_mark(BOOTSTAGE_ID_NO_RAMDISK);
		rd_len = rd_data = 0;
3480d1e0:	e3a03000 	mov	r3, #0
3480d1e4:	e58d3004 	str	r3, [sp, #4]
3480d1e8:	e58d3000 	str	r3, [sp]
	}

	if (!rd_data) {
3480d1ec:	e59d9004 	ldr	r9, [sp, #4]
3480d1f0:	e3590000 	cmp	r9, #0
		debug("## No init Ramdisk\n");
	} else {
		*rd_start = rd_data;
3480d1f4:	15879000 	strne	r9, [r7]
		*rd_end = rd_data + rd_len;
3480d1f8:	159d3000 	ldrne	r3, [sp]
3480d1fc:	10839009 	addne	r9, r3, r9
3480d200:	15859000 	strne	r9, [r5]
	}
	debug("   ramdisk start = 0x%08lx, ramdisk end = 0x%08lx\n",
			*rd_start, *rd_end);

	return 0;
3480d204:	13a09000 	movne	r9, #0
}
3480d208:	e1a00009 	mov	r0, r9
3480d20c:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
						"0x%08lx\n",
						fit_uname_ramdisk, rd_addr);
			} else
#endif
			{
				rd_addr = simple_strtoul(argv[2], NULL, 16);
3480d210:	e1a01009 	mov	r1, r9
3480d214:	e5960008 	ldr	r0, [r6, #8]
3480d218:	e3a02010 	mov	r2, #16
3480d21c:	eb003e1b 	bl	3481ca90 <simple_strtoul>
3480d220:	e1a06000 	mov	r6, r0
		/*
		 * Check if there is an initrd image at the
		 * address provided in the second bootm argument
		 * check image type, for FIT images get FIT node.
		 */
		switch (genimg_get_format((void *)rd_addr)) {
3480d224:	ebffff78 	bl	3480d00c <genimg_get_format>
3480d228:	e3500001 	cmp	r0, #1
3480d22c:	e1a09000 	mov	r9, r0
3480d230:	1affffd6 	bne	3480d190 <boot_get_ramdisk+0x160>
3480d234:	eaffff93 	b	3480d088 <boot_get_ramdisk+0x58>
3480d238:	34827481 	.word	0x34827481
3480d23c:	3482648c 	.word	0x3482648c
3480d240:	34822e0d 	.word	0x34822e0d
3480d244:	34822e22 	.word	0x34822e22
3480d248:	34822e37 	.word	0x34822e37
3480d24c:	34822e55 	.word	0x34822e55
3480d250:	34822e63 	.word	0x34822e63
3480d254:	348264c4 	.word	0x348264c4
3480d258:	348264df 	.word	0x348264df
3480d25c:	348264fb 	.word	0x348264fb

3480d260 <boot_ramdisk_high>:
 *      0 - success
 *     -1 - failure
 */
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
3480d260:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
3480d264:	e1a0a000 	mov	sl, r0
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
3480d268:	e59f010c 	ldr	r0, [pc, #268]	; 3480d37c <boot_ramdisk_high+0x11c>
 *      0 - success
 *     -1 - failure
 */
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
3480d26c:	e1a05003 	mov	r5, r3
3480d270:	e1a04001 	mov	r4, r1
3480d274:	e1a06002 	mov	r6, r2
3480d278:	e59d9020 	ldr	r9, [sp, #32]
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
3480d27c:	ebffe8ca 	bl	348075ac <getenv>
3480d280:	e3500000 	cmp	r0, #0
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;
3480d284:	03a07001 	moveq	r7, #1
		initrd_high = simple_strtoul(s, NULL, 16);
		if (initrd_high == ~0)
			initrd_copy_to_ram = 0;
	} else {
		/* not set, no restrictions to load high */
		initrd_high = ~0;
3480d288:	03e03000 	mvneq	r3, #0
{
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;

	if ((s = getenv("initrd_high")) != NULL) {
3480d28c:	0a000005 	beq	3480d2a8 <boot_ramdisk_high+0x48>
		/* a value of "no" or a similar string will act like 0,
		 * turning the "load high" feature off. This is intentional.
		 */
		initrd_high = simple_strtoul(s, NULL, 16);
3480d290:	e3a01000 	mov	r1, #0
3480d294:	e3a02010 	mov	r2, #16
3480d298:	eb003dfc 	bl	3481ca90 <simple_strtoul>
3480d29c:	e1a03000 	mov	r3, r0
int boot_ramdisk_high(struct lmb *lmb, ulong rd_data, ulong rd_len,
		  ulong *initrd_start, ulong *initrd_end)
{
	char	*s;
	ulong	initrd_high;
	int	initrd_copy_to_ram = 1;
3480d2a0:	e2907001 	adds	r7, r0, #1
3480d2a4:	13a07001 	movne	r7, #1
#endif

	debug("## initrd_high = 0x%08lx, copy_to_ram = %d\n",
			initrd_high, initrd_copy_to_ram);

	if (rd_data) {
3480d2a8:	e3540000 	cmp	r4, #0
3480d2ac:	0a00002e 	beq	3480d36c <boot_ramdisk_high+0x10c>
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
3480d2b0:	e3570000 	cmp	r7, #0
3480d2b4:	1a000008 	bne	3480d2dc <boot_ramdisk_high+0x7c>
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
3480d2b8:	e0863004 	add	r3, r6, r4
			initrd_high, initrd_copy_to_ram);

	if (rd_data) {
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
3480d2bc:	e5854000 	str	r4, [r5]
			*initrd_end = rd_data + rd_len;
			lmb_reserve(lmb, rd_data, rd_len);
3480d2c0:	e1a0000a 	mov	r0, sl

	if (rd_data) {
		if (!initrd_copy_to_ram) {	/* zero-copy ramdisk support */
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
3480d2c4:	e5893000 	str	r3, [r9]
			lmb_reserve(lmb, rd_data, rd_len);
3480d2c8:	e1a01004 	mov	r1, r4
3480d2cc:	e1a02006 	mov	r2, r6
3480d2d0:	eb003912 	bl	3481b720 <lmb_reserve>
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
3480d2d4:	e1a00007 	mov	r0, r7
3480d2d8:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
			debug("   in-place initrd\n");
			*initrd_start = rd_data;
			*initrd_end = rd_data + rd_len;
			lmb_reserve(lmb, rd_data, rd_len);
		} else {
			if (initrd_high)
3480d2dc:	e3530000 	cmp	r3, #0
3480d2e0:	0a000004 	beq	3480d2f8 <boot_ramdisk_high+0x98>
				*initrd_start = (ulong)lmb_alloc_base(lmb,
3480d2e4:	e1a0000a 	mov	r0, sl
3480d2e8:	e1a01006 	mov	r1, r6
3480d2ec:	e3a02a01 	mov	r2, #4096	; 0x1000
3480d2f0:	eb00396d 	bl	3481b8ac <lmb_alloc_base>
3480d2f4:	ea000003 	b	3480d308 <boot_ramdisk_high+0xa8>
						rd_len, 0x1000, initrd_high);
			else
				*initrd_start = (ulong)lmb_alloc(lmb, rd_len,
3480d2f8:	e1a0000a 	mov	r0, sl
3480d2fc:	e1a01006 	mov	r1, r6
3480d300:	e3a02a01 	mov	r2, #4096	; 0x1000
3480d304:	eb003975 	bl	3481b8e0 <lmb_alloc>
3480d308:	e5850000 	str	r0, [r5]
								 0x1000);

			if (*initrd_start == 0) {
3480d30c:	e5953000 	ldr	r3, [r5]
3480d310:	e3530000 	cmp	r3, #0
3480d314:	1a000003 	bne	3480d328 <boot_ramdisk_high+0xc8>
				puts("ramdisk - allocation error\n");
3480d318:	e59f0060 	ldr	r0, [pc, #96]	; 3480d380 <boot_ramdisk_high+0x120>
3480d31c:	ebffef86 	bl	3480913c <puts>
			*initrd_start, *initrd_end);

	return 0;

error:
	return -1;
3480d320:	e3e00000 	mvn	r0, #0
				*initrd_start = (ulong)lmb_alloc(lmb, rd_len,
								 0x1000);

			if (*initrd_start == 0) {
				puts("ramdisk - allocation error\n");
				goto error;
3480d324:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3480d328:	e3a0000c 	mov	r0, #12
3480d32c:	eb000087 	bl	3480d550 <__show_boot_progress>
			}
			bootstage_mark(BOOTSTAGE_ID_COPY_RAMDISK);

			*initrd_end = *initrd_start + rd_len;
3480d330:	e5952000 	ldr	r2, [r5]
			printf("   Loading Ramdisk to %08lx, end %08lx ... ",
3480d334:	e59f0048 	ldr	r0, [pc, #72]	; 3480d384 <boot_ramdisk_high+0x124>
				puts("ramdisk - allocation error\n");
				goto error;
			}
			bootstage_mark(BOOTSTAGE_ID_COPY_RAMDISK);

			*initrd_end = *initrd_start + rd_len;
3480d338:	e0862002 	add	r2, r6, r2
3480d33c:	e5892000 	str	r2, [r9]
			printf("   Loading Ramdisk to %08lx, end %08lx ... ",
3480d340:	e5951000 	ldr	r1, [r5]
3480d344:	ebffef86 	bl	34809164 <printf>
					*initrd_start, *initrd_end);

			memmove_wd((void *)*initrd_start,
3480d348:	e5950000 	ldr	r0, [r5]
3480d34c:	e1a01004 	mov	r1, r4
3480d350:	e1a02006 	mov	r2, r6
3480d354:	e3a03801 	mov	r3, #65536	; 0x10000
3480d358:	ebfffe70 	bl	3480cd20 <memmove_wd>
			 * AMP boot scenarios in which we might not be
			 * HW cache coherent
			 */
			flush_cache((unsigned long)*initrd_start, rd_len);
#endif
			puts("OK\n");
3480d35c:	e59f0024 	ldr	r0, [pc, #36]	; 3480d388 <boot_ramdisk_high+0x128>
3480d360:	ebffef75 	bl	3480913c <puts>
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
3480d364:	e3a00000 	mov	r0, #0
3480d368:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
			flush_cache((unsigned long)*initrd_start, rd_len);
#endif
			puts("OK\n");
		}
	} else {
		*initrd_start = 0;
3480d36c:	e5854000 	str	r4, [r5]
		*initrd_end = 0;
	}
	debug("   ramdisk load start = 0x%08lx, ramdisk load end = 0x%08lx\n",
			*initrd_start, *initrd_end);

	return 0;
3480d370:	e1a00004 	mov	r0, r4
#endif
			puts("OK\n");
		}
	} else {
		*initrd_start = 0;
		*initrd_end = 0;
3480d374:	e5894000 	str	r4, [r9]

	return 0;

error:
	return -1;
}
3480d378:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3480d37c:	34826543 	.word	0x34826543
3480d380:	3482654f 	.word	0x3482654f
3480d384:	3482656b 	.word	0x3482656b
3480d388:	34822e63 	.word	0x34822e63

3480d38c <delete_char>:
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
3480d38c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3480d390:	e1a07003 	mov	r7, r3
	char *s;

	if (*np == 0) {
3480d394:	e5933000 	ldr	r3, [r3]
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
3480d398:	e1a04000 	mov	r4, r0
	char *s;

	if (*np == 0) {
3480d39c:	e3530000 	cmp	r3, #0
}

/****************************************************************************/

static char * delete_char (char *buffer, char *p, int *colp, int *np, int plen)
{
3480d3a0:	e1a05001 	mov	r5, r1
3480d3a4:	e1a06002 	mov	r6, r2
3480d3a8:	e59da018 	ldr	sl, [sp, #24]
	char *s;

	if (*np == 0) {
3480d3ac:	0a000028 	beq	3480d454 <delete_char+0xc8>
		return (p);
	}

	if (*(--p) == '\t') {			/* will retype the whole line	*/
3480d3b0:	e5753001 	ldrb	r3, [r5, #-1]!
3480d3b4:	e3530009 	cmp	r3, #9
3480d3b8:	1a00001d 	bne	3480d434 <delete_char+0xa8>
3480d3bc:	ea000004 	b	3480d3d4 <delete_char+0x48>
		while (*colp > plen) {
			puts (erase_seq);
3480d3c0:	e59f0094 	ldr	r0, [pc, #148]	; 3480d45c <delete_char+0xd0>
3480d3c4:	ebffef5c 	bl	3480913c <puts>
			(*colp)--;
3480d3c8:	e5963000 	ldr	r3, [r6]
3480d3cc:	e2433001 	sub	r3, r3, #1
3480d3d0:	e5863000 	str	r3, [r6]
	if (*np == 0) {
		return (p);
	}

	if (*(--p) == '\t') {			/* will retype the whole line	*/
		while (*colp > plen) {
3480d3d4:	e5963000 	ldr	r3, [r6]
3480d3d8:	e153000a 	cmp	r3, sl
3480d3dc:	cafffff7 	bgt	3480d3c0 <delete_char+0x34>
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
			if (*s == '\t') {
				puts (tab_seq+((*colp) & 07));
3480d3e0:	e59fa078 	ldr	sl, [pc, #120]	; 3480d460 <delete_char+0xd4>
3480d3e4:	ea00000f 	b	3480d428 <delete_char+0x9c>
		while (*colp > plen) {
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
			if (*s == '\t') {
3480d3e8:	e4d43001 	ldrb	r3, [r4], #1
3480d3ec:	e5960000 	ldr	r0, [r6]
3480d3f0:	e3530009 	cmp	r3, #9
3480d3f4:	1a000007 	bne	3480d418 <delete_char+0x8c>
				puts (tab_seq+((*colp) & 07));
3480d3f8:	e2000007 	and	r0, r0, #7
3480d3fc:	e08a0000 	add	r0, sl, r0
3480d400:	ebffef4d 	bl	3480913c <puts>
				*colp += 8 - ((*colp) & 07);
3480d404:	e5963000 	ldr	r3, [r6]
3480d408:	e3c33007 	bic	r3, r3, #7
3480d40c:	e2833008 	add	r3, r3, #8
3480d410:	e5863000 	str	r3, [r6]
3480d414:	ea000003 	b	3480d428 <delete_char+0x9c>
			} else {
				++(*colp);
3480d418:	e2800001 	add	r0, r0, #1
3480d41c:	e5860000 	str	r0, [r6]
				putc (*s);
3480d420:	e5540001 	ldrb	r0, [r4, #-1]
3480d424:	ebffef3a 	bl	34809114 <putc>
	if (*(--p) == '\t') {			/* will retype the whole line	*/
		while (*colp > plen) {
			puts (erase_seq);
			(*colp)--;
		}
		for (s=buffer; s<p; ++s) {
3480d428:	e1550004 	cmp	r5, r4
3480d42c:	8affffed 	bhi	3480d3e8 <delete_char+0x5c>
3480d430:	ea000004 	b	3480d448 <delete_char+0xbc>
				++(*colp);
				putc (*s);
			}
		}
	} else {
		puts (erase_seq);
3480d434:	e59f0020 	ldr	r0, [pc, #32]	; 3480d45c <delete_char+0xd0>
3480d438:	ebffef3f 	bl	3480913c <puts>
		(*colp)--;
3480d43c:	e5963000 	ldr	r3, [r6]
3480d440:	e2433001 	sub	r3, r3, #1
3480d444:	e5863000 	str	r3, [r6]
	}
	(*np)--;
3480d448:	e5973000 	ldr	r3, [r7]
3480d44c:	e2433001 	sub	r3, r3, #1
3480d450:	e5873000 	str	r3, [r7]
	return (p);
}
3480d454:	e1a00005 	mov	r0, r5
3480d458:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3480d45c:	34821334 	.word	0x34821334
3480d460:	34821338 	.word	0x34821338

3480d464 <cread_add_char>:
	}					\
}

static void cread_add_char(char ichar, int insert, unsigned long *num,
	       unsigned long *eol_num, char *buf, unsigned long len)
{
3480d464:	e92d41f0 	push	{r4, r5, r6, r7, r8, lr}
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
3480d468:	e3510000 	cmp	r1, #0
	}					\
}

static void cread_add_char(char ichar, int insert, unsigned long *num,
	       unsigned long *eol_num, char *buf, unsigned long len)
{
3480d46c:	e1a04002 	mov	r4, r2
3480d470:	e1a05000 	mov	r5, r0
3480d474:	e59d6018 	ldr	r6, [sp, #24]
3480d478:	e59d201c 	ldr	r2, [sp, #28]
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
3480d47c:	1a000003 	bne	3480d490 <cread_add_char+0x2c>
3480d480:	e594c000 	ldr	ip, [r4]
3480d484:	e5930000 	ldr	r0, [r3]
3480d488:	e15c0000 	cmp	ip, r0
3480d48c:	1a000023 	bne	3480d520 <cread_add_char+0xbc>
		if (*eol_num > len - 1) {
3480d490:	e5937000 	ldr	r7, [r3]
3480d494:	e2422001 	sub	r2, r2, #1
3480d498:	e1570002 	cmp	r7, r2
3480d49c:	9a000002 	bls	3480d4ac <cread_add_char+0x48>
			getcmd_cbeep();
3480d4a0:	e3a00007 	mov	r0, #7
		wlen = 1;
		buf[*num] = ichar;
		putnstr(buf + *num, wlen);
		(*num)++;
	}
}
3480d4a4:	e8bd41f0 	pop	{r4, r5, r6, r7, r8, lr}
	unsigned long wlen;

	/* room ??? */
	if (insert || *num == *eol_num) {
		if (*eol_num > len - 1) {
			getcmd_cbeep();
3480d4a8:	eaffef19 	b	34809114 <putc>
			return;
		}
		(*eol_num)++;
3480d4ac:	e2877001 	add	r7, r7, #1
	}

	if (insert) {
3480d4b0:	e3510000 	cmp	r1, #0
	if (insert || *num == *eol_num) {
		if (*eol_num > len - 1) {
			getcmd_cbeep();
			return;
		}
		(*eol_num)++;
3480d4b4:	e5837000 	str	r7, [r3]
	}

	if (insert) {
3480d4b8:	0a000018 	beq	3480d520 <cread_add_char+0xbc>
		wlen = *eol_num - *num;
3480d4bc:	e5941000 	ldr	r1, [r4]
3480d4c0:	e0617007 	rsb	r7, r1, r7
		if (wlen > 1) {
3480d4c4:	e3570001 	cmp	r7, #1
3480d4c8:	9a000004 	bls	3480d4e0 <cread_add_char+0x7c>
			memmove(&buf[*num+1], &buf[*num], wlen-1);
3480d4cc:	e2810001 	add	r0, r1, #1
3480d4d0:	e0860000 	add	r0, r6, r0
3480d4d4:	e0861001 	add	r1, r6, r1
3480d4d8:	e2472001 	sub	r2, r7, #1
3480d4dc:	eb003ab9 	bl	3481bfc8 <memmove>
		}

		buf[*num] = ichar;
3480d4e0:	e5943000 	ldr	r3, [r4]
		putnstr(buf + *num, wlen);
3480d4e4:	e59f0060 	ldr	r0, [pc, #96]	; 3480d54c <cread_add_char+0xe8>
		wlen = *eol_num - *num;
		if (wlen > 1) {
			memmove(&buf[*num+1], &buf[*num], wlen-1);
		}

		buf[*num] = ichar;
3480d4e8:	e7c65003 	strb	r5, [r6, r3]
		putnstr(buf + *num, wlen);
3480d4ec:	e5942000 	ldr	r2, [r4]
3480d4f0:	e1a01007 	mov	r1, r7
3480d4f4:	e0862002 	add	r2, r6, r2
3480d4f8:	ebffef19 	bl	34809164 <printf>
		(*num)++;
3480d4fc:	e5943000 	ldr	r3, [r4]
3480d500:	e2833001 	add	r3, r3, #1
3480d504:	e5843000 	str	r3, [r4]
		while (--wlen) {
3480d508:	ea000001 	b	3480d514 <cread_add_char+0xb0>
			getcmd_putch(CTL_BACKSPACE);
3480d50c:	e3a00008 	mov	r0, #8
3480d510:	ebffeeff 	bl	34809114 <putc>
		}

		buf[*num] = ichar;
		putnstr(buf + *num, wlen);
		(*num)++;
		while (--wlen) {
3480d514:	e2577001 	subs	r7, r7, #1
3480d518:	1afffffb 	bne	3480d50c <cread_add_char+0xa8>
3480d51c:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
			getcmd_putch(CTL_BACKSPACE);
		}
	} else {
		/* echo the character */
		wlen = 1;
		buf[*num] = ichar;
3480d520:	e5943000 	ldr	r3, [r4]
		putnstr(buf + *num, wlen);
3480d524:	e59f0020 	ldr	r0, [pc, #32]	; 3480d54c <cread_add_char+0xe8>
			getcmd_putch(CTL_BACKSPACE);
		}
	} else {
		/* echo the character */
		wlen = 1;
		buf[*num] = ichar;
3480d528:	e7c65003 	strb	r5, [r6, r3]
		putnstr(buf + *num, wlen);
3480d52c:	e5942000 	ldr	r2, [r4]
3480d530:	e3a01001 	mov	r1, #1
3480d534:	e0862002 	add	r2, r6, r2
3480d538:	ebffef09 	bl	34809164 <printf>
		(*num)++;
3480d53c:	e5943000 	ldr	r3, [r4]
3480d540:	e2833001 	add	r3, r3, #1
3480d544:	e5843000 	str	r3, [r4]
3480d548:	e8bd81f0 	pop	{r4, r5, r6, r7, r8, pc}
3480d54c:	348268e9 	.word	0x348268e9

3480d550 <__show_boot_progress>:
#endif

/*
 * Board-specific Platform code can reimplement show_boot_progress () if needed
 */
void inline __show_boot_progress (int val) {}
3480d550:	e12fff1e 	bx	lr

3480d554 <readline_into_buffer>:
	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
{
3480d554:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
3480d558:	e5983004 	ldr	r3, [r8, #4]
	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
{
3480d55c:	e24dd040 	sub	sp, sp, #64	; 0x40
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
3480d560:	e2133001 	ands	r3, r3, #1
	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
{
3480d564:	e1a06000 	mov	r6, r0
3480d568:	e1a04001 	mov	r4, r1
3480d56c:	e58d201c 	str	r2, [sp, #28]
	 * History uses a global array which is not
	 * writable until after relocation to RAM.
	 * Revert to non-history version if still
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
3480d570:	0a0001b7 	beq	3480dc54 <readline_into_buffer+0x700>
		if (!initted) {
3480d574:	e59f28a0 	ldr	r2, [pc, #2208]	; 3480de1c <readline_into_buffer+0x8c8>
3480d578:	e5923000 	ldr	r3, [r2]
3480d57c:	e3530000 	cmp	r3, #0
3480d580:	1a000010 	bne	3480d5c8 <readline_into_buffer+0x74>
{
	int i;

	hist_max = 0;
	hist_add_idx = 0;
	hist_cur = -1;
3480d584:	e59f1894 	ldr	r1, [pc, #2196]	; 3480de20 <readline_into_buffer+0x8cc>
3480d588:	e3e00000 	mvn	r0, #0
3480d58c:	e5810000 	str	r0, [r1]
	hist_num = 0;
3480d590:	e59f188c 	ldr	r1, [pc, #2188]	; 3480de24 <readline_into_buffer+0x8d0>

	return readline_into_buffer(prompt, console_buffer, 0);
}


int readline_into_buffer(const char *const prompt, char *buffer, int timeout)
3480d594:	e59f088c 	ldr	r0, [pc, #2188]	; 3480de28 <readline_into_buffer+0x8d4>

static void hist_init(void)
{
	int i;

	hist_max = 0;
3480d598:	e5823004 	str	r3, [r2, #4]
	hist_add_idx = 0;
3480d59c:	e5823008 	str	r3, [r2, #8]
	hist_cur = -1;
	hist_num = 0;
3480d5a0:	e582300c 	str	r3, [r2, #12]

	for (i = 0; i < HIST_MAX; i++) {
		hist_list[i] = hist_lines[i];
3480d5a4:	e2822010 	add	r2, r2, #16
3480d5a8:	e5a12004 	str	r2, [r1, #4]!
		hist_list[i][0] = '\0';
3480d5ac:	e4c23100 	strb	r3, [r2], #256	; 0x100
3480d5b0:	e2822001 	add	r2, r2, #1
	hist_max = 0;
	hist_add_idx = 0;
	hist_cur = -1;
	hist_num = 0;

	for (i = 0; i < HIST_MAX; i++) {
3480d5b4:	e1520000 	cmp	r2, r0
3480d5b8:	1afffffa 	bne	3480d5a8 <readline_into_buffer+0x54>
	 * running from flash.
	 */
	if (gd->flags & GD_FLG_RELOC) {
		if (!initted) {
			hist_init();
			initted = 1;
3480d5bc:	e59f3858 	ldr	r3, [pc, #2136]	; 3480de1c <readline_into_buffer+0x8c8>
3480d5c0:	e3a02001 	mov	r2, #1
3480d5c4:	e5832000 	str	r2, [r3]
		}

		if (prompt)
3480d5c8:	e3560000 	cmp	r6, #0
3480d5cc:	0a000001 	beq	3480d5d8 <readline_into_buffer+0x84>
			puts (prompt);
3480d5d0:	e1a00006 	mov	r0, r6
3480d5d4:	ebffeed8 	bl	3480913c <puts>
}

static int cread_line(const char *const prompt, char *buf, unsigned int *len,
		int timeout)
{
	unsigned long num = 0;
3480d5d8:	e3a03000 	mov	r3, #0
	unsigned long wlen;
	char ichar;
	int insert = 1;
	int esc_len = 0;
	char esc_save[8];
	int init_len = strlen(buf);
3480d5dc:	e1a00004 	mov	r0, r4
}

static int cread_line(const char *const prompt, char *buf, unsigned int *len,
		int timeout)
{
	unsigned long num = 0;
3480d5e0:	e58d3034 	str	r3, [sp, #52]	; 0x34
	unsigned long eol_num = 0;
3480d5e4:	e58d3030 	str	r3, [sp, #48]	; 0x30
	unsigned long wlen;
	char ichar;
	int insert = 1;
	int esc_len = 0;
	char esc_save[8];
	int init_len = strlen(buf);
3480d5e8:	eb003995 	bl	3481bc44 <strlen>
	int first = 1;

	if (init_len)
3480d5ec:	e2505000 	subs	r5, r0, #0
3480d5f0:	1a000011 	bne	3480d63c <readline_into_buffer+0xe8>
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);
3480d5f4:	e59d101c 	ldr	r1, [sp, #28]
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
3480d5f8:	e3a0b001 	mov	fp, #1
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);
3480d5fc:	e1a00001 	mov	r0, r1
3480d600:	e1a01fc0 	asr	r1, r0, #31
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
3480d604:	e3a0a000 	mov	sl, #0
3480d608:	e1a0700b 	mov	r7, fp
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);
3480d60c:	e1cd02f0 	strd	r0, [sp, #32]

static char* hist_next(void)
{
	char *ret;

	if (hist_cur < 0)
3480d610:	e59f5808 	ldr	r5, [pc, #2056]	; 3480de20 <readline_into_buffer+0x8cc>
		return NULL;

	if (hist_cur == hist_add_idx)
3480d614:	e59f6800 	ldr	r6, [pc, #2048]	; 3480de1c <readline_into_buffer+0x8c8>
3480d618:	ea00000f 	b	3480d65c <readline_into_buffer+0x108>

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480d61c:	e4d60001 	ldrb	r0, [r6], #1
3480d620:	e3a01001 	mov	r1, #1
3480d624:	e1a02007 	mov	r2, r7
3480d628:	e1a0300a 	mov	r3, sl
3480d62c:	e88d0210 	stm	sp, {r4, r9}
		str++;
3480d630:	e2455001 	sub	r5, r5, #1

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480d634:	ebffff8a 	bl	3480d464 <cread_add_char>
3480d638:	ea000003 	b	3480d64c <readline_into_buffer+0xf8>
	int esc_len = 0;
	char esc_save[8];
	int init_len = strlen(buf);
	int first = 1;

	if (init_len)
3480d63c:	e1a06004 	mov	r6, r4
		cread_add_str(buf, init_len, 1, &num, &eol_num, buf, *len);
3480d640:	e28d7034 	add	r7, sp, #52	; 0x34
3480d644:	e28da030 	add	sl, sp, #48	; 0x30

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480d648:	e3a09c01 	mov	r9, #256	; 0x100
}

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
3480d64c:	e3550000 	cmp	r5, #0
3480d650:	1afffff1 	bne	3480d61c <readline_into_buffer+0xc8>
3480d654:	eaffffe6 	b	3480d5f4 <readline_into_buffer+0xa0>
		case CTL_CH('p'):
		case CTL_CH('n'):
		{
			char * hline;

			esc_len = 0;
3480d658:	e3a0a000 	mov	sl, #0
			if (retry_time >= 0 && get_ticks() > endtime)
				return (-2);	/* timed out */
			WATCHDOG_RESET();
		}
#endif
		if (first && timeout) {
3480d65c:	e59d201c 	ldr	r2, [sp, #28]
3480d660:	e3520000 	cmp	r2, #0
3480d664:	03a03000 	moveq	r3, #0
3480d668:	120b3001 	andne	r3, fp, #1
3480d66c:	e3530000 	cmp	r3, #0
3480d670:	0a000017 	beq	3480d6d4 <readline_into_buffer+0x180>
			uint64_t etime = endtick(timeout);
3480d674:	ebffccce 	bl	348009b4 <get_ticks>
3480d678:	e1cd01f0 	strd	r0, [sp, #16]
3480d67c:	ebffccd0 	bl	348009c4 <get_tbclk>
3480d680:	e59d101c 	ldr	r1, [sp, #28]
3480d684:	e0832190 	umull	r2, r3, r0, r1
3480d688:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
3480d68c:	e0233190 	mla	r3, r0, r1, r3
3480d690:	e1cd01d0 	ldrd	r0, [sp, #16]
3480d694:	e0900002 	adds	r0, r0, r2
3480d698:	e0a11003 	adc	r1, r1, r3
3480d69c:	e1cd01f0 	strd	r0, [sp, #16]
3480d6a0:	ea000007 	b	3480d6c4 <readline_into_buffer+0x170>

			while (!tstc()) {	/* while no incoming data */
				if (get_ticks() >= etime)
3480d6a4:	ebffccc2 	bl	348009b4 <get_ticks>
3480d6a8:	e59d2014 	ldr	r2, [sp, #20]
3480d6ac:	e1520001 	cmp	r2, r1
3480d6b0:	8a000003 	bhi	3480d6c4 <readline_into_buffer+0x170>
3480d6b4:	1a000164 	bne	3480dc4c <readline_into_buffer+0x6f8>
3480d6b8:	e59d3010 	ldr	r3, [sp, #16]
3480d6bc:	e1530000 	cmp	r3, r0
3480d6c0:	9a000161 	bls	3480dc4c <readline_into_buffer+0x6f8>
		}
#endif
		if (first && timeout) {
			uint64_t etime = endtick(timeout);

			while (!tstc()) {	/* while no incoming data */
3480d6c4:	ebffee89 	bl	348090f0 <tstc>
3480d6c8:	e3500000 	cmp	r0, #0
3480d6cc:	0afffff4 	beq	3480d6a4 <readline_into_buffer+0x150>
				if (get_ticks() >= etime)
					return -2;	/* timed out */
				WATCHDOG_RESET();
			}
			first = 0;
3480d6d0:	e3a0b000 	mov	fp, #0
		}

		ichar = getcmd_getch();
3480d6d4:	ebffee7c 	bl	348090cc <getc>
3480d6d8:	e6ef0070 	uxtb	r0, r0

		if ((ichar == '\n') || (ichar == '\r')) {
3480d6dc:	e350000a 	cmp	r0, #10
3480d6e0:	1350000d 	cmpne	r0, #13
3480d6e4:	13a09000 	movne	r9, #0
3480d6e8:	03a09001 	moveq	r9, #1
3480d6ec:	1a000009 	bne	3480d718 <readline_into_buffer+0x1c4>
			putc('\n');
3480d6f0:	e3a0000a 	mov	r0, #10
3480d6f4:	ebffee86 	bl	34809114 <putc>
		default:
			cread_add_char(ichar, insert, &num, &eol_num, buf, *len);
			break;
		}
	}
	*len = eol_num;
3480d6f8:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
	buf[eol_num] = '\0';	/* lose the newline */
3480d6fc:	e3a03000 	mov	r3, #0
3480d700:	e7c43006 	strb	r3, [r4, r6]

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
3480d704:	e5d43000 	ldrb	r3, [r4]
3480d708:	e3530021 	cmp	r3, #33	; 0x21
3480d70c:	13530000 	cmpne	r3, #0
3480d710:	0a000147 	beq	3480dc34 <readline_into_buffer+0x6e0>
3480d714:	ea000134 	b	3480dbec <readline_into_buffer+0x698>
		}

		/*
		 * handle standard linux xterm esc sequences for arrow key, etc.
		 */
		if (esc_len != 0) {
3480d718:	e35a0000 	cmp	sl, #0
3480d71c:	0a000032 	beq	3480d7ec <readline_into_buffer+0x298>
			if (esc_len == 1) {
3480d720:	e35a0001 	cmp	sl, #1
3480d724:	1a00000d 	bne	3480d760 <readline_into_buffer+0x20c>
				if (ichar == '[') {
3480d728:	e350005b 	cmp	r0, #91	; 0x5b
					esc_save[esc_len] = ichar;
3480d72c:	05cd0029 	strbeq	r0, [sp, #41]	; 0x29
					esc_len = 2;
3480d730:	03a0a002 	moveq	sl, #2
		/*
		 * handle standard linux xterm esc sequences for arrow key, etc.
		 */
		if (esc_len != 0) {
			if (esc_len == 1) {
				if (ichar == '[') {
3480d734:	0affffc8 	beq	3480d65c <readline_into_buffer+0x108>

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480d738:	e3a03c01 	mov	r3, #256	; 0x100
3480d73c:	e58d3004 	str	r3, [sp, #4]
3480d740:	e5dd0028 	ldrb	r0, [sp, #40]	; 0x28
3480d744:	e1a01007 	mov	r1, r7
3480d748:	e28d2034 	add	r2, sp, #52	; 0x34
3480d74c:	e28d3030 	add	r3, sp, #48	; 0x30
3480d750:	e58d4000 	str	r4, [sp]
					esc_save[esc_len] = ichar;
					esc_len = 2;
				} else {
					cread_add_str(esc_save, esc_len, insert,
						      &num, &eol_num, buf, *len);
					esc_len = 0;
3480d754:	e1a0a009 	mov	sl, r9

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480d758:	ebffff41 	bl	3480d464 <cread_add_char>
3480d75c:	eaffffbe 	b	3480d65c <readline_into_buffer+0x108>
					esc_len = 0;
				}
				continue;
			}

			switch (ichar) {
3480d760:	e2403041 	sub	r3, r0, #65	; 0x41
3480d764:	e3530007 	cmp	r3, #7
3480d768:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480d76c:	ea000007 	b	3480d790 <readline_into_buffer+0x23c>
3480d770:	3480da84 	.word	0x3480da84
3480d774:	3480dac8 	.word	0x3480dac8
3480d778:	3480d7e0 	.word	0x3480d7e0
3480d77c:	3480d8e0 	.word	0x3480d8e0
3480d780:	3480d790 	.word	0x3480d790
3480d784:	3480d790 	.word	0x3480d790
3480d788:	3480d790 	.word	0x3480d790
3480d78c:	3480d8ac 	.word	0x3480d8ac
			case 'B':	/* down arrow */
				ichar = CTL_CH('n');
				esc_len = 0;
				break;	/* pass off to ^N handler */
			default:
				esc_save[esc_len++] = ichar;
3480d790:	e28d1040 	add	r1, sp, #64	; 0x40
3480d794:	e081300a 	add	r3, r1, sl
3480d798:	e5430018 	strb	r0, [r3, #-24]
3480d79c:	e28aa001 	add	sl, sl, #1
				cread_add_str(esc_save, esc_len, insert,
3480d7a0:	e28d9028 	add	r9, sp, #40	; 0x28

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
		cread_add_char(*str, insert, num, eol_num, buf, len);
3480d7a4:	e3a0cc01 	mov	ip, #256	; 0x100
3480d7a8:	ea000009 	b	3480d7d4 <readline_into_buffer+0x280>
3480d7ac:	e4d90001 	ldrb	r0, [r9], #1
3480d7b0:	e1a01007 	mov	r1, r7
3480d7b4:	e28d2034 	add	r2, sp, #52	; 0x34
3480d7b8:	e28d3030 	add	r3, sp, #48	; 0x30
3480d7bc:	e58dc004 	str	ip, [sp, #4]
3480d7c0:	e58dc00c 	str	ip, [sp, #12]
3480d7c4:	e58d4000 	str	r4, [sp]
3480d7c8:	ebffff25 	bl	3480d464 <cread_add_char>
		str++;
3480d7cc:	e59dc00c 	ldr	ip, [sp, #12]
3480d7d0:	e24aa001 	sub	sl, sl, #1
}

static void cread_add_str(char *str, int strsize, int insert, unsigned long *num,
	      unsigned long *eol_num, char *buf, unsigned long len)
{
	while (strsize--) {
3480d7d4:	e35a0000 	cmp	sl, #0
3480d7d8:	1afffff3 	bne	3480d7ac <readline_into_buffer+0x258>
3480d7dc:	eaffff9e 	b	3480d65c <readline_into_buffer+0x108>
			case 'D':	/* <- key */
				ichar = CTL_CH('b');
				esc_len = 0;
				break;
			case 'C':	/* -> key */
				ichar = CTL_CH('f');
3480d7e0:	e3a00006 	mov	r0, #6
3480d7e4:	e350000b 	cmp	r0, #11
3480d7e8:	ea000001 	b	3480d7f4 <readline_into_buffer+0x2a0>
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480d7ec:	e350000b 	cmp	r0, #11
3480d7f0:	0a00005e 	beq	3480d970 <readline_into_buffer+0x41c>
3480d7f4:	8a00000f 	bhi	3480d838 <readline_into_buffer+0x2e4>
3480d7f8:	e3500004 	cmp	r0, #4
3480d7fc:	0a00003f 	beq	3480d900 <readline_into_buffer+0x3ac>
3480d800:	8a000005 	bhi	3480d81c <readline_into_buffer+0x2c8>
3480d804:	e3500002 	cmp	r0, #2
3480d808:	0a000034 	beq	3480d8e0 <readline_into_buffer+0x38c>
3480d80c:	8a00013e 	bhi	3480dd0c <readline_into_buffer+0x7b8>
3480d810:	e3500001 	cmp	r0, #1
3480d814:	1a0000ec 	bne	3480dbcc <readline_into_buffer+0x678>
3480d818:	ea000023 	b	3480d8ac <readline_into_buffer+0x358>
3480d81c:	e3500006 	cmp	r0, #6
3480d820:	0a000025 	beq	3480d8bc <readline_into_buffer+0x368>
			break;
		case CTL_CH('k'):
			ERASE_TO_EOL();
			break;
		case CTL_CH('e'):
			REFRESH_TO_EOL();
3480d824:	359d2034 	ldrcc	r2, [sp, #52]	; 0x34
3480d828:	359d1030 	ldrcc	r1, [sp, #48]	; 0x30
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480d82c:	3a0000dd 	bcc	3480dba8 <readline_into_buffer+0x654>
3480d830:	e3500008 	cmp	r0, #8
3480d834:	ea000015 	b	3480d890 <readline_into_buffer+0x33c>
3480d838:	e3500015 	cmp	r0, #21
3480d83c:	0a000061 	beq	3480d9c8 <readline_into_buffer+0x474>
3480d840:	8a000007 	bhi	3480d864 <readline_into_buffer+0x310>
3480d844:	e350000f 	cmp	r0, #15
			break;
		case CTL_CH('e'):
			REFRESH_TO_EOL();
			break;
		case CTL_CH('o'):
			insert = !insert;
3480d848:	02277001 	eoreq	r7, r7, #1
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480d84c:	0affff81 	beq	3480d658 <readline_into_buffer+0x104>
3480d850:	e3500010 	cmp	r0, #16
3480d854:	0a00008a 	beq	3480da84 <readline_into_buffer+0x530>
3480d858:	e350000e 	cmp	r0, #14
3480d85c:	1a0000da 	bne	3480dbcc <readline_into_buffer+0x678>
3480d860:	ea000098 	b	3480dac8 <readline_into_buffer+0x574>
3480d864:	e350001b 	cmp	r0, #27
		case 0x1b:
			if (esc_len == 0) {
				esc_save[esc_len] = ichar;
3480d868:	05cd0028 	strbeq	r0, [sp, #40]	; 0x28
				esc_len = 1;
3480d86c:	03a0a001 	moveq	sl, #1
				esc_len = 0;
				continue;
			}
		}

		switch (ichar) {
3480d870:	0affff79 	beq	3480d65c <readline_into_buffer+0x108>
3480d874:	8a000002 	bhi	3480d884 <readline_into_buffer+0x330>
3480d878:	e3500018 	cmp	r0, #24
3480d87c:	1a0000d2 	bne	3480dbcc <readline_into_buffer+0x678>
3480d880:	ea000050 	b	3480d9c8 <readline_into_buffer+0x474>
3480d884:	e350007f 	cmp	r0, #127	; 0x7f
3480d888:	0a000061 	beq	3480da14 <readline_into_buffer+0x4c0>
3480d88c:	e35000ff 	cmp	r0, #255	; 0xff
3480d890:	1a0000cd 	bne	3480dbcc <readline_into_buffer+0x678>
3480d894:	ea00005e 	b	3480da14 <readline_into_buffer+0x4c0>
				esc_len = 0;
			}
			break;

		case CTL_CH('a'):
			BEGINNING_OF_LINE();
3480d898:	e3a00008 	mov	r0, #8
3480d89c:	ebffee1c 	bl	34809114 <putc>
3480d8a0:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d8a4:	e2433001 	sub	r3, r3, #1
3480d8a8:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480d8ac:	e59da034 	ldr	sl, [sp, #52]	; 0x34
3480d8b0:	e35a0000 	cmp	sl, #0
3480d8b4:	1afffff7 	bne	3480d898 <readline_into_buffer+0x344>
3480d8b8:	eaffff67 	b	3480d65c <readline_into_buffer+0x108>
			break;
		case CTL_CH('c'):	/* ^C - break */
			*buf = '\0';	/* discard input */
			return (-1);
		case CTL_CH('f'):
			if (num < eol_num) {
3480d8bc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d8c0:	e59d2030 	ldr	r2, [sp, #48]	; 0x30
3480d8c4:	e1530002 	cmp	r3, r2
3480d8c8:	2affff62 	bcs	3480d658 <readline_into_buffer+0x104>
				getcmd_putch(buf[num]);
3480d8cc:	e7d40003 	ldrb	r0, [r4, r3]
3480d8d0:	ebffee0f 	bl	34809114 <putc>
				num++;
3480d8d4:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d8d8:	e2833001 	add	r3, r3, #1
3480d8dc:	ea0000b8 	b	3480dbc4 <readline_into_buffer+0x670>
			}
			break;
		case CTL_CH('b'):
			if (num) {
3480d8e0:	e59da034 	ldr	sl, [sp, #52]	; 0x34
3480d8e4:	e35a0000 	cmp	sl, #0
3480d8e8:	0affff5b 	beq	3480d65c <readline_into_buffer+0x108>
				getcmd_putch(CTL_BACKSPACE);
3480d8ec:	e3a00008 	mov	r0, #8
3480d8f0:	ebffee07 	bl	34809114 <putc>
				num--;
3480d8f4:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d8f8:	e2433001 	sub	r3, r3, #1
3480d8fc:	ea0000b0 	b	3480dbc4 <readline_into_buffer+0x670>
			}
			break;
		case CTL_CH('d'):
			if (num < eol_num) {
3480d900:	e59d0034 	ldr	r0, [sp, #52]	; 0x34
3480d904:	e59da030 	ldr	sl, [sp, #48]	; 0x30
3480d908:	e150000a 	cmp	r0, sl
3480d90c:	2affff51 	bcs	3480d658 <readline_into_buffer+0x104>
				wlen = eol_num - num - 1;
3480d910:	e24aa001 	sub	sl, sl, #1
				if (wlen) {
3480d914:	e05aa000 	subs	sl, sl, r0
3480d918:	0a000009 	beq	3480d944 <readline_into_buffer+0x3f0>
					memmove(&buf[num], &buf[num+1], wlen);
3480d91c:	e2801001 	add	r1, r0, #1
3480d920:	e0841001 	add	r1, r4, r1
3480d924:	e1a0200a 	mov	r2, sl
3480d928:	e0840000 	add	r0, r4, r0
3480d92c:	eb0039a5 	bl	3481bfc8 <memmove>
					putnstr(buf + num, wlen);
3480d930:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480d934:	e59f04f0 	ldr	r0, [pc, #1264]	; 3480de2c <readline_into_buffer+0x8d8>
3480d938:	e1a0100a 	mov	r1, sl
3480d93c:	e0842002 	add	r2, r4, r2
3480d940:	ebffee07 	bl	34809164 <printf>
				}

				getcmd_putch(' ');
3480d944:	e3a00020 	mov	r0, #32
3480d948:	ebffedf1 	bl	34809114 <putc>
				do {
					getcmd_putch(CTL_BACKSPACE);
3480d94c:	e3a00008 	mov	r0, #8
3480d950:	ebffedef 	bl	34809114 <putc>
				} while (wlen--);
3480d954:	e25aa001 	subs	sl, sl, #1
3480d958:	2afffffb 	bcs	3480d94c <readline_into_buffer+0x3f8>
				eol_num--;
3480d95c:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480d960:	e28aa001 	add	sl, sl, #1
3480d964:	e2433001 	sub	r3, r3, #1
3480d968:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480d96c:	eaffff3a 	b	3480d65c <readline_into_buffer+0x108>
			}
			break;
		case CTL_CH('k'):
			ERASE_TO_EOL();
3480d970:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d974:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
3480d978:	e1530001 	cmp	r3, r1
3480d97c:	2affff36 	bcs	3480d65c <readline_into_buffer+0x108>
3480d980:	e59f04a8 	ldr	r0, [pc, #1192]	; 3480de30 <readline_into_buffer+0x8dc>
3480d984:	e0631001 	rsb	r1, r3, r1
3480d988:	e59f24a4 	ldr	r2, [pc, #1188]	; 3480de34 <readline_into_buffer+0x8e0>
3480d98c:	ebffedf4 	bl	34809164 <printf>
3480d990:	e3a00008 	mov	r0, #8
3480d994:	ebffedde 	bl	34809114 <putc>
3480d998:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480d99c:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480d9a0:	e2433001 	sub	r3, r3, #1
3480d9a4:	e1530002 	cmp	r3, r2
3480d9a8:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480d9ac:	8afffff7 	bhi	3480d990 <readline_into_buffer+0x43c>
3480d9b0:	eaffff28 	b	3480d658 <readline_into_buffer+0x104>
		case CTL_CH('o'):
			insert = !insert;
			break;
		case CTL_CH('x'):
		case CTL_CH('u'):
			BEGINNING_OF_LINE();
3480d9b4:	e3a00008 	mov	r0, #8
3480d9b8:	ebffedd5 	bl	34809114 <putc>
3480d9bc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d9c0:	e2433001 	sub	r3, r3, #1
3480d9c4:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480d9c8:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480d9cc:	e3530000 	cmp	r3, #0
3480d9d0:	1afffff7 	bne	3480d9b4 <readline_into_buffer+0x460>
			ERASE_TO_EOL();
3480d9d4:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
3480d9d8:	e3510000 	cmp	r1, #0
3480d9dc:	01a0a001 	moveq	sl, r1
3480d9e0:	0affff1d 	beq	3480d65c <readline_into_buffer+0x108>
3480d9e4:	e59f0444 	ldr	r0, [pc, #1092]	; 3480de30 <readline_into_buffer+0x8dc>
3480d9e8:	e59f2444 	ldr	r2, [pc, #1092]	; 3480de34 <readline_into_buffer+0x8e0>
3480d9ec:	ebffeddc 	bl	34809164 <printf>
3480d9f0:	e3a00008 	mov	r0, #8
3480d9f4:	ebffedc6 	bl	34809114 <putc>
3480d9f8:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480d9fc:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480da00:	e2433001 	sub	r3, r3, #1
3480da04:	e1530002 	cmp	r3, r2
3480da08:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480da0c:	8afffff7 	bhi	3480d9f0 <readline_into_buffer+0x49c>
3480da10:	eaffff10 	b	3480d658 <readline_into_buffer+0x104>
			break;
		case DEL:
		case DEL7:
		case 8:
			if (num) {
3480da14:	e59da034 	ldr	sl, [sp, #52]	; 0x34
3480da18:	e35a0000 	cmp	sl, #0
3480da1c:	0affff0e 	beq	3480d65c <readline_into_buffer+0x108>
				wlen = eol_num - num;
3480da20:	e59d9030 	ldr	r9, [sp, #48]	; 0x30
				num--;
3480da24:	e24a0001 	sub	r0, sl, #1
			break;
		case DEL:
		case DEL7:
		case 8:
			if (num) {
				wlen = eol_num - num;
3480da28:	e06a9009 	rsb	r9, sl, r9
				num--;
				memmove(&buf[num], &buf[num+1], wlen);
3480da2c:	e084100a 	add	r1, r4, sl
3480da30:	e1a02009 	mov	r2, r9
		case DEL:
		case DEL7:
		case 8:
			if (num) {
				wlen = eol_num - num;
				num--;
3480da34:	e58d0034 	str	r0, [sp, #52]	; 0x34
				memmove(&buf[num], &buf[num+1], wlen);
3480da38:	e0840000 	add	r0, r4, r0
3480da3c:	eb003961 	bl	3481bfc8 <memmove>
				getcmd_putch(CTL_BACKSPACE);
3480da40:	e3a00008 	mov	r0, #8
3480da44:	ebffedb2 	bl	34809114 <putc>
				putnstr(buf + num, wlen);
3480da48:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480da4c:	e59f03d8 	ldr	r0, [pc, #984]	; 3480de2c <readline_into_buffer+0x8d8>
3480da50:	e1a01009 	mov	r1, r9
3480da54:	e0842002 	add	r2, r4, r2
3480da58:	ebffedc1 	bl	34809164 <printf>
				getcmd_putch(' ');
3480da5c:	e3a00020 	mov	r0, #32
3480da60:	ebffedab 	bl	34809114 <putc>
				do {
					getcmd_putch(CTL_BACKSPACE);
3480da64:	e3a00008 	mov	r0, #8
3480da68:	ebffeda9 	bl	34809114 <putc>
				} while (wlen--);
3480da6c:	e2599001 	subs	r9, r9, #1
3480da70:	2afffffb 	bcs	3480da64 <readline_into_buffer+0x510>
				eol_num--;
3480da74:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480da78:	e2433001 	sub	r3, r3, #1
3480da7c:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480da80:	eafffef4 	b	3480d658 <readline_into_buffer+0x104>
static char* hist_prev(void)
{
	char *ret;
	int old_cur;

	if (hist_cur < 0)
3480da84:	e5953000 	ldr	r3, [r5]
3480da88:	e3530000 	cmp	r3, #0
3480da8c:	ba000024 	blt	3480db24 <readline_into_buffer+0x5d0>
		return NULL;

	old_cur = hist_cur;
	if (--hist_cur < 0)
3480da90:	e2432001 	sub	r2, r3, #1
3480da94:	e3720001 	cmn	r2, #1
3480da98:	e5852000 	str	r2, [r5]
		hist_cur = hist_max;
3480da9c:	05962004 	ldreq	r2, [r6, #4]

	if (hist_cur == hist_add_idx) {
3480daa0:	e5961008 	ldr	r1, [r6, #8]
	if (hist_cur < 0)
		return NULL;

	old_cur = hist_cur;
	if (--hist_cur < 0)
		hist_cur = hist_max;
3480daa4:	05852000 	streq	r2, [r5]

	if (hist_cur == hist_add_idx) {
3480daa8:	e5952000 	ldr	r2, [r5]
3480daac:	e1520001 	cmp	r2, r1
		hist_cur = old_cur;
3480dab0:	05853000 	streq	r3, [r5]

	old_cur = hist_cur;
	if (--hist_cur < 0)
		hist_cur = hist_max;

	if (hist_cur == hist_add_idx) {
3480dab4:	0a00001a 	beq	3480db24 <readline_into_buffer+0x5d0>
		hist_cur = old_cur;
		ret = NULL;
	} else
		ret = hist_list[hist_cur];
3480dab8:	e59f3378 	ldr	r3, [pc, #888]	; 3480de38 <readline_into_buffer+0x8e4>
3480dabc:	e0832102 	add	r2, r3, r2, lsl #2
3480dac0:	e512abd4 	ldr	sl, [r2, #-3028]	; 0xbd4
3480dac4:	ea000011 	b	3480db10 <readline_into_buffer+0x5bc>

static char* hist_next(void)
{
	char *ret;

	if (hist_cur < 0)
3480dac8:	e5953000 	ldr	r3, [r5]
3480dacc:	e3530000 	cmp	r3, #0
3480dad0:	ba000013 	blt	3480db24 <readline_into_buffer+0x5d0>
		return NULL;

	if (hist_cur == hist_add_idx)
3480dad4:	e5962008 	ldr	r2, [r6, #8]
3480dad8:	e1530002 	cmp	r3, r2
3480dadc:	0a000010 	beq	3480db24 <readline_into_buffer+0x5d0>
		return NULL;

	if (++hist_cur > hist_max)
3480dae0:	e5961004 	ldr	r1, [r6, #4]
3480dae4:	e2833001 	add	r3, r3, #1
3480dae8:	e1530001 	cmp	r3, r1
		hist_cur = 0;
3480daec:	c3a00000 	movgt	r0, #0
		return NULL;

	if (hist_cur == hist_add_idx)
		return NULL;

	if (++hist_cur > hist_max)
3480daf0:	e5853000 	str	r3, [r5]
		hist_cur = 0;
3480daf4:	c5850000 	strgt	r0, [r5]

	if (hist_cur == hist_add_idx) {
3480daf8:	e5953000 	ldr	r3, [r5]
3480dafc:	e1530002 	cmp	r3, r2
3480db00:	0a000005 	beq	3480db1c <readline_into_buffer+0x5c8>
		ret = "";
	} else
		ret = hist_list[hist_cur];
3480db04:	e59f132c 	ldr	r1, [pc, #812]	; 3480de38 <readline_into_buffer+0x8e4>
3480db08:	e0813103 	add	r3, r1, r3, lsl #2
3480db0c:	e513abd4 	ldr	sl, [r3, #-3028]	; 0xbd4
			if (ichar == CTL_CH('p'))
				hline = hist_prev();
			else
				hline = hist_next();

			if (!hline) {
3480db10:	e35a0000 	cmp	sl, #0
3480db14:	1a00000a 	bne	3480db44 <readline_into_buffer+0x5f0>
3480db18:	ea000001 	b	3480db24 <readline_into_buffer+0x5d0>

	if (++hist_cur > hist_max)
		hist_cur = 0;

	if (hist_cur == hist_add_idx) {
		ret = "";
3480db1c:	e59fa310 	ldr	sl, [pc, #784]	; 3480de34 <readline_into_buffer+0x8e0>
3480db20:	ea000007 	b	3480db44 <readline_into_buffer+0x5f0>
				hline = hist_prev();
			else
				hline = hist_next();

			if (!hline) {
				getcmd_cbeep();
3480db24:	e3a00007 	mov	r0, #7
3480db28:	ebffed79 	bl	34809114 <putc>
3480db2c:	eafffec9 	b	3480d658 <readline_into_buffer+0x104>
				continue;
			}

			/* nuke the current line */
			/* first, go home */
			BEGINNING_OF_LINE();
3480db30:	e3a00008 	mov	r0, #8
3480db34:	ebffed76 	bl	34809114 <putc>
3480db38:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480db3c:	e2433001 	sub	r3, r3, #1
3480db40:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480db44:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
3480db48:	e3530000 	cmp	r3, #0
3480db4c:	1afffff7 	bne	3480db30 <readline_into_buffer+0x5dc>

			/* erase to end of line */
			ERASE_TO_EOL();
3480db50:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
3480db54:	e3510000 	cmp	r1, #0
3480db58:	0a00000a 	beq	3480db88 <readline_into_buffer+0x634>
3480db5c:	e59f02cc 	ldr	r0, [pc, #716]	; 3480de30 <readline_into_buffer+0x8dc>
3480db60:	e59f22cc 	ldr	r2, [pc, #716]	; 3480de34 <readline_into_buffer+0x8e0>
3480db64:	ebffed7e 	bl	34809164 <printf>
3480db68:	e3a00008 	mov	r0, #8
3480db6c:	ebffed68 	bl	34809114 <putc>
3480db70:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480db74:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
3480db78:	e2433001 	sub	r3, r3, #1
3480db7c:	e1530002 	cmp	r3, r2
3480db80:	e58d3030 	str	r3, [sp, #48]	; 0x30
3480db84:	8afffff7 	bhi	3480db68 <readline_into_buffer+0x614>

			/* copy new line into place and display */
			strcpy(buf, hline);
3480db88:	e1a0100a 	mov	r1, sl
3480db8c:	e1a00004 	mov	r0, r4
3480db90:	eb0037c6 	bl	3481bab0 <strcpy>
			eol_num = strlen(buf);
3480db94:	e1a00004 	mov	r0, r4
3480db98:	eb003829 	bl	3481bc44 <strlen>
			REFRESH_TO_EOL();
3480db9c:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
			/* erase to end of line */
			ERASE_TO_EOL();

			/* copy new line into place and display */
			strcpy(buf, hline);
			eol_num = strlen(buf);
3480dba0:	e1a01000 	mov	r1, r0
3480dba4:	e58d0030 	str	r0, [sp, #48]	; 0x30
			REFRESH_TO_EOL();
3480dba8:	e1520001 	cmp	r2, r1
3480dbac:	2afffea9 	bcs	3480d658 <readline_into_buffer+0x104>
3480dbb0:	e0621001 	rsb	r1, r2, r1
3480dbb4:	e59f0270 	ldr	r0, [pc, #624]	; 3480de2c <readline_into_buffer+0x8d8>
3480dbb8:	e0842002 	add	r2, r4, r2
3480dbbc:	ebffed68 	bl	34809164 <printf>
3480dbc0:	e59d3030 	ldr	r3, [sp, #48]	; 0x30
3480dbc4:	e58d3034 	str	r3, [sp, #52]	; 0x34
3480dbc8:	eafffea2 	b	3480d658 <readline_into_buffer+0x104>
			}
			break;
		}
#endif
		default:
			cread_add_char(ichar, insert, &num, &eol_num, buf, *len);
3480dbcc:	e3a03c01 	mov	r3, #256	; 0x100
3480dbd0:	e58d3004 	str	r3, [sp, #4]
3480dbd4:	e1a01007 	mov	r1, r7
3480dbd8:	e28d2034 	add	r2, sp, #52	; 0x34
3480dbdc:	e28d3030 	add	r3, sp, #48	; 0x30
3480dbe0:	e58d4000 	str	r4, [sp]
3480dbe4:	ebfffe1e 	bl	3480d464 <cread_add_char>
3480dbe8:	eafffe9a 	b	3480d658 <readline_into_buffer+0x104>
	}
}

static void cread_add_to_hist(char *line)
{
	strcpy(hist_list[hist_add_idx], line);
3480dbec:	e59f5228 	ldr	r5, [pc, #552]	; 3480de1c <readline_into_buffer+0x8c8>
3480dbf0:	e59f3240 	ldr	r3, [pc, #576]	; 3480de38 <readline_into_buffer+0x8e4>
3480dbf4:	e5952008 	ldr	r2, [r5, #8]
3480dbf8:	e1a01004 	mov	r1, r4
3480dbfc:	e0833102 	add	r3, r3, r2, lsl #2
3480dc00:	e5130bd4 	ldr	r0, [r3, #-3028]	; 0xbd4
3480dc04:	eb0037a9 	bl	3481bab0 <strcpy>

	if (++hist_add_idx >= HIST_MAX)
3480dc08:	e995000c 	ldmib	r5, {r2, r3}
3480dc0c:	e2833001 	add	r3, r3, #1
		hist_add_idx = 0;
3480dc10:	e3530013 	cmp	r3, #19
3480dc14:	c3a03000 	movgt	r3, #0

	if (hist_add_idx > hist_max)
3480dc18:	e1530002 	cmp	r3, r2
static void cread_add_to_hist(char *line)
{
	strcpy(hist_list[hist_add_idx], line);

	if (++hist_add_idx >= HIST_MAX)
		hist_add_idx = 0;
3480dc1c:	e5853008 	str	r3, [r5, #8]

	if (hist_add_idx > hist_max)
		hist_max = hist_add_idx;
3480dc20:	c5853004 	strgt	r3, [r5, #4]

	hist_num++;
3480dc24:	e59f31f0 	ldr	r3, [pc, #496]	; 3480de1c <readline_into_buffer+0x8c8>
3480dc28:	e593200c 	ldr	r2, [r3, #12]
3480dc2c:	e2822001 	add	r2, r2, #1
3480dc30:	e583200c 	str	r2, [r3, #12]
	*len = eol_num;
	buf[eol_num] = '\0';	/* lose the newline */

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
		cread_add_to_hist(buf);
	hist_cur = hist_add_idx;
3480dc34:	e59f31e0 	ldr	r3, [pc, #480]	; 3480de1c <readline_into_buffer+0x8c8>

		if (prompt)
			puts (prompt);

		rc = cread_line(prompt, p, &len, timeout);
		return rc < 0 ? rc : len;
3480dc38:	e1a00006 	mov	r0, r6
	*len = eol_num;
	buf[eol_num] = '\0';	/* lose the newline */

	if (buf[0] && buf[0] != CREAD_HIST_CHAR)
		cread_add_to_hist(buf);
	hist_cur = hist_add_idx;
3480dc3c:	e5932008 	ldr	r2, [r3, #8]
3480dc40:	e59f31d8 	ldr	r3, [pc, #472]	; 3480de20 <readline_into_buffer+0x8cc>
3480dc44:	e5832000 	str	r2, [r3]
3480dc48:	ea000071 	b	3480de14 <readline_into_buffer+0x8c0>
		if (first && timeout) {
			uint64_t etime = endtick(timeout);

			while (!tstc()) {	/* while no incoming data */
				if (get_ticks() >= etime)
					return -2;	/* timed out */
3480dc4c:	e3e00001 	mvn	r0, #1
3480dc50:	ea00006f 	b	3480de14 <readline_into_buffer+0x8c0>
	int	plen = 0;			/* prompt length	*/
	int	col;				/* output column cnt	*/
	char	c;

	/* print prompt */
	if (prompt) {
3480dc54:	e3500000 	cmp	r0, #0
		return rc < 0 ? rc : len;

	} else {
#endif	/* CONFIG_CMDLINE_EDITING */
	char * p_buf = p;
	int	n = 0;				/* buffer index		*/
3480dc58:	e58d303c 	str	r3, [sp, #60]	; 0x3c
	int	plen = 0;			/* prompt length	*/
3480dc5c:	01a05000 	moveq	r5, r0
	int	col;				/* output column cnt	*/
	char	c;

	/* print prompt */
	if (prompt) {
3480dc60:	0a000003 	beq	3480dc74 <readline_into_buffer+0x720>
		plen = strlen (prompt);
3480dc64:	eb0037f6 	bl	3481bc44 <strlen>
3480dc68:	e1a05000 	mov	r5, r0
		puts (prompt);
3480dc6c:	e1a00006 	mov	r0, r6
3480dc70:	ebffed31 	bl	3480913c <puts>
	}
	col = plen;
3480dc74:	e28d6040 	add	r6, sp, #64	; 0x40
					if (cmd_auto_complete(prompt, console_buffer, &n, &col)) {
						p = p_buf + n;	/* reset */
						continue;
					}
#endif
					puts (tab_seq+(col&07));
3480dc78:	e59fa1bc 	ldr	sl, [pc, #444]	; 3480de3c <readline_into_buffer+0x8e8>
	/* print prompt */
	if (prompt) {
		plen = strlen (prompt);
		puts (prompt);
	}
	col = plen;
3480dc7c:	e5265008 	str	r5, [r6, #-8]!
			}
			continue;

		case 0x08:				/* ^H  - backspace	*/
		case 0x7F:				/* DEL - backspace	*/
			p=delete_char(p_buf, p, &col, &n, plen);
3480dc80:	e28d703c 	add	r7, sp, #60	; 0x3c
			while (col > plen) {
				puts (erase_seq);
				--col;
			}
			p = p_buf;
			n = 0;
3480dc84:	e3a09000 	mov	r9, #0
3480dc88:	e1a01004 	mov	r1, r4
		while (!tstc()) {
			show_activity(0);
			WATCHDOG_RESET();
		}
#endif
		c = getc();
3480dc8c:	e58d100c 	str	r1, [sp, #12]
3480dc90:	ebffed0d 	bl	348090cc <getc>
3480dc94:	e6efb070 	uxtb	fp, r0

		/*
		 * Special character handling
		 */
		switch (c) {
3480dc98:	e35b000a 	cmp	fp, #10
3480dc9c:	e59d100c 	ldr	r1, [sp, #12]
3480dca0:	0a000012 	beq	3480dcf0 <readline_into_buffer+0x79c>
3480dca4:	8a000006 	bhi	3480dcc4 <readline_into_buffer+0x770>
3480dca8:	e35b0003 	cmp	fp, #3
3480dcac:	0a000016 	beq	3480dd0c <readline_into_buffer+0x7b8>
3480dcb0:	e35b0008 	cmp	fp, #8
3480dcb4:	0a000030 	beq	3480dd7c <readline_into_buffer+0x828>
3480dcb8:	e35b0000 	cmp	fp, #0
3480dcbc:	0afffff2 	beq	3480dc8c <readline_into_buffer+0x738>
3480dcc0:	ea000034 	b	3480dd98 <readline_into_buffer+0x844>
3480dcc4:	e35b0015 	cmp	fp, #21
3480dcc8:	0a000018 	beq	3480dd30 <readline_into_buffer+0x7dc>
3480dccc:	8a000002 	bhi	3480dcdc <readline_into_buffer+0x788>
3480dcd0:	e35b000d 	cmp	fp, #13
3480dcd4:	1a00002f 	bne	3480dd98 <readline_into_buffer+0x844>
3480dcd8:	ea000004 	b	3480dcf0 <readline_into_buffer+0x79c>
3480dcdc:	e35b0017 	cmp	fp, #23
3480dce0:	0a000018 	beq	3480dd48 <readline_into_buffer+0x7f4>
3480dce4:	e35b007f 	cmp	fp, #127	; 0x7f
3480dce8:	1a00002a 	bne	3480dd98 <readline_into_buffer+0x844>
3480dcec:	ea000022 	b	3480dd7c <readline_into_buffer+0x828>
		case '\r':				/* Enter		*/
		case '\n':
			*p = '\0';
3480dcf0:	e3a03000 	mov	r3, #0
3480dcf4:	e1a0b001 	mov	fp, r1
			puts ("\r\n");
3480dcf8:	e59f0140 	ldr	r0, [pc, #320]	; 3480de40 <readline_into_buffer+0x8ec>
		 * Special character handling
		 */
		switch (c) {
		case '\r':				/* Enter		*/
		case '\n':
			*p = '\0';
3480dcfc:	e5c13000 	strb	r3, [r1]
			puts ("\r\n");
3480dd00:	ebffed0d 	bl	3480913c <puts>
			return (p - p_buf);
3480dd04:	e064000b 	rsb	r0, r4, fp
3480dd08:	ea000041 	b	3480de14 <readline_into_buffer+0x8c0>

		case '\0':				/* nul			*/
			continue;

		case 0x03:				/* ^C - break		*/
			p_buf[0] = '\0';	/* discard input */
3480dd0c:	e3a03000 	mov	r3, #0
3480dd10:	e5c43000 	strb	r3, [r4]
			return (-1);
3480dd14:	e3e00000 	mvn	r0, #0
3480dd18:	ea00003d 	b	3480de14 <readline_into_buffer+0x8c0>

		case 0x15:				/* ^U - erase line	*/
			while (col > plen) {
				puts (erase_seq);
3480dd1c:	e59f0120 	ldr	r0, [pc, #288]	; 3480de44 <readline_into_buffer+0x8f0>
3480dd20:	ebffed05 	bl	3480913c <puts>
				--col;
3480dd24:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3480dd28:	e2433001 	sub	r3, r3, #1
3480dd2c:	e58d3038 	str	r3, [sp, #56]	; 0x38
		case 0x03:				/* ^C - break		*/
			p_buf[0] = '\0';	/* discard input */
			return (-1);

		case 0x15:				/* ^U - erase line	*/
			while (col > plen) {
3480dd30:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3480dd34:	e1530005 	cmp	r3, r5
3480dd38:	cafffff7 	bgt	3480dd1c <readline_into_buffer+0x7c8>
				puts (erase_seq);
				--col;
			}
			p = p_buf;
			n = 0;
3480dd3c:	e58d903c 	str	r9, [sp, #60]	; 0x3c
			continue;
3480dd40:	e1a01004 	mov	r1, r4
3480dd44:	eaffffd0 	b	3480dc8c <readline_into_buffer+0x738>

		case 0x17:				/* ^W - erase word	*/
			p=delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' ')) {
				p=delete_char(p_buf, p, &col, &n, plen);
3480dd48:	e1a03007 	mov	r3, r7
3480dd4c:	e1a00004 	mov	r0, r4
3480dd50:	e1a02006 	mov	r2, r6
3480dd54:	e58d5000 	str	r5, [sp]
3480dd58:	ebfffd8b 	bl	3480d38c <delete_char>
			n = 0;
			continue;

		case 0x17:				/* ^W - erase word	*/
			p=delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' ')) {
3480dd5c:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
				p=delete_char(p_buf, p, &col, &n, plen);
3480dd60:	e1a01000 	mov	r1, r0
			n = 0;
			continue;

		case 0x17:				/* ^W - erase word	*/
			p=delete_char(p_buf, p, &col, &n, plen);
			while ((n > 0) && (*p != ' ')) {
3480dd64:	e3530000 	cmp	r3, #0
3480dd68:	daffffc7 	ble	3480dc8c <readline_into_buffer+0x738>
3480dd6c:	e5d03000 	ldrb	r3, [r0]
3480dd70:	e3530020 	cmp	r3, #32
3480dd74:	1afffff3 	bne	3480dd48 <readline_into_buffer+0x7f4>
3480dd78:	eaffffc3 	b	3480dc8c <readline_into_buffer+0x738>
			}
			continue;

		case 0x08:				/* ^H  - backspace	*/
		case 0x7F:				/* DEL - backspace	*/
			p=delete_char(p_buf, p, &col, &n, plen);
3480dd7c:	e1a00004 	mov	r0, r4
3480dd80:	e1a02006 	mov	r2, r6
3480dd84:	e1a03007 	mov	r3, r7
3480dd88:	e58d5000 	str	r5, [sp]
3480dd8c:	ebfffd7e 	bl	3480d38c <delete_char>
3480dd90:	e1a01000 	mov	r1, r0
			continue;
3480dd94:	eaffffbc 	b	3480dc8c <readline_into_buffer+0x738>

		default:
			/*
			 * Must be a normal character then
			 */
			if (n < CONFIG_SYS_CBSIZE-2) {
3480dd98:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3480dd9c:	e35300fd 	cmp	r3, #253	; 0xfd
3480dda0:	ca000016 	bgt	3480de00 <readline_into_buffer+0x8ac>
				if (c == '\t') {	/* expand TABs		*/
3480dda4:	e35b0009 	cmp	fp, #9
3480dda8:	e59d0038 	ldr	r0, [sp, #56]	; 0x38
3480ddac:	1a000008 	bne	3480ddd4 <readline_into_buffer+0x880>
					if (cmd_auto_complete(prompt, console_buffer, &n, &col)) {
						p = p_buf + n;	/* reset */
						continue;
					}
#endif
					puts (tab_seq+(col&07));
3480ddb0:	e2000007 	and	r0, r0, #7
3480ddb4:	e08a0000 	add	r0, sl, r0
3480ddb8:	e58d100c 	str	r1, [sp, #12]
3480ddbc:	ebffecde 	bl	3480913c <puts>
					col += 8 - (col&07);
3480ddc0:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
3480ddc4:	e3c33007 	bic	r3, r3, #7
3480ddc8:	e2833008 	add	r3, r3, #8
3480ddcc:	e58d3038 	str	r3, [sp, #56]	; 0x38
3480ddd0:	ea000004 	b	3480dde8 <readline_into_buffer+0x894>
				} else {
					++col;		/* echo input		*/
3480ddd4:	e2800001 	add	r0, r0, #1
3480ddd8:	e58d0038 	str	r0, [sp, #56]	; 0x38
					putc (c);
3480dddc:	e1a0000b 	mov	r0, fp
3480dde0:	e58d100c 	str	r1, [sp, #12]
3480dde4:	ebffecca 	bl	34809114 <putc>
3480dde8:	e59d100c 	ldr	r1, [sp, #12]
				}
				*p++ = c;
3480ddec:	e4c1b001 	strb	fp, [r1], #1
				++n;
3480ddf0:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3480ddf4:	e2833001 	add	r3, r3, #1
3480ddf8:	e58d303c 	str	r3, [sp, #60]	; 0x3c
3480ddfc:	eaffffa2 	b	3480dc8c <readline_into_buffer+0x738>
			} else {			/* Buffer full		*/
				putc ('\a');
3480de00:	e3a00007 	mov	r0, #7
3480de04:	e58d100c 	str	r1, [sp, #12]
3480de08:	ebffecc1 	bl	34809114 <putc>
3480de0c:	e59d100c 	ldr	r1, [sp, #12]
3480de10:	eaffff9d 	b	3480dc8c <readline_into_buffer+0x738>
		}
	}
#ifdef CONFIG_CMDLINE_EDITING
	}
#endif
}
3480de14:	e28dd040 	add	sp, sp, #64	; 0x40
3480de18:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480de1c:	3482a004 	.word	0x3482a004
3480de20:	34828a3c 	.word	0x34828a3c
3480de24:	3482b424 	.word	0x3482b424
3480de28:	3482b428 	.word	0x3482b428
3480de2c:	348268e9 	.word	0x348268e9
3480de30:	348268ee 	.word	0x348268ee
3480de34:	34823cce 	.word	0x34823cce
3480de38:	3482bffc 	.word	0x3482bffc
3480de3c:	34821338 	.word	0x34821338
3480de40:	348268f2 	.word	0x348268f2
3480de44:	34821334 	.word	0x34821334

3480de48 <readline>:
{
	/*
	 * If console_buffer isn't 0-length the user will be prompted to modify
	 * it instead of entering it from scratch as desired.
	 */
	console_buffer[0] = '\0';
3480de48:	e59f300c 	ldr	r3, [pc, #12]	; 3480de5c <readline+0x14>

	return readline_into_buffer(prompt, console_buffer, 0);
3480de4c:	e59f100c 	ldr	r1, [pc, #12]	; 3480de60 <readline+0x18>
{
	/*
	 * If console_buffer isn't 0-length the user will be prompted to modify
	 * it instead of entering it from scratch as desired.
	 */
	console_buffer[0] = '\0';
3480de50:	e3a02000 	mov	r2, #0
3480de54:	e5432b84 	strb	r2, [r3, #-2948]	; 0xb84

	return readline_into_buffer(prompt, console_buffer, 0);
3480de58:	eafffdbd 	b	3480d554 <readline_into_buffer>
3480de5c:	3482bffc 	.word	0x3482bffc
3480de60:	3482b478 	.word	0x3482b478

3480de64 <parse_line>:
}

/****************************************************************************/

int parse_line (char *line, char *argv[])
{
3480de64:	e92d4010 	push	{r4, lr}
	int nargs = 0;
3480de68:	e1a0c001 	mov	ip, r1
3480de6c:	e3a04000 	mov	r4, #0
3480de70:	e1a02000 	mov	r2, r0
	printf ("parse_line: \"%s\"\n", line);
#endif
	while (nargs < CONFIG_SYS_MAXARGS) {

		/* skip any white space */
		while (isblank(*line))
3480de74:	e4d03001 	ldrb	r3, [r0], #1
3480de78:	e3530020 	cmp	r3, #32
3480de7c:	13530009 	cmpne	r3, #9
3480de80:	0afffffa 	beq	3480de70 <parse_line+0xc>
			++line;

		if (*line == '\0') {	/* end of line, no more args	*/
3480de84:	e3530000 	cmp	r3, #0
3480de88:	0a000005 	beq	3480dea4 <parse_line+0x40>
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
		}

		argv[nargs++] = line;	/* begin of argument string	*/
3480de8c:	e48c2004 	str	r2, [ip], #4
3480de90:	e2844001 	add	r4, r4, #1

		/* find end of string */
		while (*line && !isblank(*line))
3480de94:	e1a00002 	mov	r0, r2
3480de98:	e4d23001 	ldrb	r3, [r2], #1
3480de9c:	e3530000 	cmp	r3, #0
3480dea0:	1a000001 	bne	3480deac <parse_line+0x48>
			++line;

		if (*line == '\0') {	/* end of line, no more args	*/
			argv[nargs] = NULL;
3480dea4:	e7813104 	str	r3, [r1, r4, lsl #2]
#ifdef DEBUG_PARSER
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
3480dea8:	ea00000b 	b	3480dedc <parse_line+0x78>
		}

		argv[nargs++] = line;	/* begin of argument string	*/

		/* find end of string */
		while (*line && !isblank(*line))
3480deac:	e3530009 	cmp	r3, #9
3480deb0:	13530020 	cmpne	r3, #32
3480deb4:	03a03000 	moveq	r3, #0
3480deb8:	13a03001 	movne	r3, #1
3480debc:	1afffff4 	bne	3480de94 <parse_line+0x30>
	int nargs = 0;

#ifdef DEBUG_PARSER
	printf ("parse_line: \"%s\"\n", line);
#endif
	while (nargs < CONFIG_SYS_MAXARGS) {
3480dec0:	e3540010 	cmp	r4, #16
		printf ("parse_line: nargs=%d\n", nargs);
#endif
			return (nargs);
		}

		*line++ = '\0';		/* terminate current arg	 */
3480dec4:	e5c03000 	strb	r3, [r0]
3480dec8:	12800001 	addne	r0, r0, #1
3480decc:	1affffe7 	bne	3480de70 <parse_line+0xc>
	}

	printf ("** Too many args (max. %d) **\n", CONFIG_SYS_MAXARGS);
3480ded0:	e59f000c 	ldr	r0, [pc, #12]	; 3480dee4 <parse_line+0x80>
3480ded4:	e1a01004 	mov	r1, r4
3480ded8:	ebffeca1 	bl	34809164 <printf>

#ifdef DEBUG_PARSER
	printf ("parse_line: nargs=%d\n", nargs);
#endif
	return (nargs);
}
3480dedc:	e1a00004 	mov	r0, r4
3480dee0:	e8bd8010 	pop	{r4, pc}
3480dee4:	348268f5 	.word	0x348268f5

3480dee8 <run_command>:
	if (builtin_run_command(cmd, flag) == -1)
		return 1;

	return 0;
#else
	return parse_string_outer(cmd,
3480dee8:	e3a01003 	mov	r1, #3
3480deec:	eafff702 	b	3480bafc <parse_string_outer>

3480def0 <run_command_list>:
{
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
	int rcode = 0;

	if (len == -1) {
3480def0:	e3710001 	cmn	r1, #1
	return rcode;
}
#endif

int run_command_list(const char *cmd, int len, int flag)
{
3480def4:	e92d4070 	push	{r4, r5, r6, lr}
3480def8:	e1a06000 	mov	r6, r0
3480defc:	e1a04001 	mov	r4, r1
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
	int rcode = 0;

	if (len == -1) {
3480df00:	1a000002 	bne	3480df10 <run_command_list+0x20>
		len = strlen(cmd);
3480df04:	eb00374e 	bl	3481bc44 <strlen>
#endif

int run_command_list(const char *cmd, int len, int flag)
{
	int need_buff = 1;
	char *buff = (char *)cmd;	/* cast away const */
3480df08:	e1a05006 	mov	r5, r6
3480df0c:	ea000008 	b	3480df34 <run_command_list+0x44>
		/* the built-in parser will change our string if it sees \n */
		need_buff = strchr(cmd, '\n') != NULL;
#endif
	}
	if (need_buff) {
		buff = malloc(len + 1);
3480df10:	e2810001 	add	r0, r1, #1
3480df14:	ebffee59 	bl	34809880 <malloc>
		if (!buff)
3480df18:	e2505000 	subs	r5, r0, #0
3480df1c:	0a000008 	beq	3480df44 <run_command_list+0x54>
			return 1;
		memcpy(buff, cmd, len);
3480df20:	e1a01006 	mov	r1, r6
3480df24:	e1a02004 	mov	r2, r4
3480df28:	eb003809 	bl	3481bf54 <memcpy>
		buff[len] = '\0';
3480df2c:	e3a03000 	mov	r3, #0
3480df30:	e7c53004 	strb	r3, [r5, r4]
	}
#ifdef CONFIG_SYS_HUSH_PARSER
	rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);
3480df34:	e1a00005 	mov	r0, r5
3480df38:	e3a01002 	mov	r1, #2
	if (need_buff)
		free(buff);
#endif

	return rcode;
}
3480df3c:	e8bd4070 	pop	{r4, r5, r6, lr}
			return 1;
		memcpy(buff, cmd, len);
		buff[len] = '\0';
	}
#ifdef CONFIG_SYS_HUSH_PARSER
	rcode = parse_string_outer(buff, FLAG_PARSE_SEMICOLON);
3480df40:	eafff6ed 	b	3480bafc <parse_string_outer>
	if (need_buff)
		free(buff);
#endif

	return rcode;
}
3480df44:	e3a00001 	mov	r0, #1
3480df48:	e8bd8070 	pop	{r4, r5, r6, pc}

3480df4c <main_loop>:
#endif	/* CONFIG_BOOTDELAY >= 0  */

/****************************************************************************/

void main_loop (void)
{
3480df4c:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
		setenv ("ver", version_string);  /* set version variable */
	}
#endif /* CONFIG_VERSION_VARIABLE */

#ifdef CONFIG_SYS_HUSH_PARSER
	u_boot_hush_start ();
3480df50:	ebfffacc 	bl	3480ca88 <u_boot_hush_start>
#if defined(CONFIG_UPDATE_TFTP)
	update_tftp (0UL);
#endif /* CONFIG_UPDATE_TFTP */

#if defined(CONFIG_BOOTDELAY) && (CONFIG_BOOTDELAY >= 0)
	s = getenv ("bootdelay");
3480df54:	e59f00fc 	ldr	r0, [pc, #252]	; 3480e058 <main_loop+0x10c>
3480df58:	ebffe593 	bl	348075ac <getenv>
	bootdelay = s ? (int)simple_strtol(s, NULL, 10) : CONFIG_BOOTDELAY;
3480df5c:	e3500000 	cmp	r0, #0
3480df60:	03a04001 	moveq	r4, #1
3480df64:	0a000003 	beq	3480df78 <main_loop+0x2c>
3480df68:	e3a01000 	mov	r1, #0
3480df6c:	e3a0200a 	mov	r2, #10
3480df70:	eb003b0f 	bl	3481cbb4 <simple_strtol>
3480df74:	e1a04000 	mov	r4, r0
		        (unsigned)bootlimit);
		s = getenv ("altbootcmd");
	}
	else
#endif /* CONFIG_BOOTCOUNT_LIMIT */
		s = getenv ("bootcmd");
3480df78:	e59f00dc 	ldr	r0, [pc, #220]	; 3480e05c <main_loop+0x110>
3480df7c:	ebffe58a 	bl	348075ac <getenv>

	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");

	if (bootdelay != -1 && s && !abortboot(bootdelay)) {
3480df80:	e3500000 	cmp	r0, #0
3480df84:	13740001 	cmnne	r4, #1
3480df88:	e1a06000 	mov	r6, r0
3480df8c:	0a00002f 	beq	3480e050 <main_loop+0x104>
	int abort = 0;

#ifdef CONFIG_MENUPROMPT
	printf(CONFIG_MENUPROMPT);
#else
	if (bootdelay >= 0)
3480df90:	e3540000 	cmp	r4, #0
#ifndef CONFIG_MENU
static inline
#endif
int abortboot(int bootdelay)
{
	int abort = 0;
3480df94:	b3a05000 	movlt	r5, #0

#ifdef CONFIG_MENUPROMPT
	printf(CONFIG_MENUPROMPT);
#else
	if (bootdelay >= 0)
3480df98:	ba00001d 	blt	3480e014 <main_loop+0xc8>
		printf("Hit any key to stop autoboot: %2d ", bootdelay);
3480df9c:	e1a01004 	mov	r1, r4
3480dfa0:	e59f00b8 	ldr	r0, [pc, #184]	; 3480e060 <main_loop+0x114>
3480dfa4:	ebffec6e 	bl	34809164 <printf>
	/*
	 * Check if key already pressed
	 * Don't check if bootdelay < 0
	 */
	if (bootdelay >= 0) {
		if (tstc()) {	/* we got a key press	*/
3480dfa8:	ebffec50 	bl	348090f0 <tstc>
3480dfac:	e2505000 	subs	r5, r0, #0
3480dfb0:	0a000017 	beq	3480e014 <main_loop+0xc8>
			(void) getc();  /* consume input	*/
3480dfb4:	ebffec44 	bl	348090cc <getc>
			puts ("\b\b\b 0");
3480dfb8:	e59f00a4 	ldr	r0, [pc, #164]	; 3480e064 <main_loop+0x118>
3480dfbc:	ebffec5e 	bl	3480913c <puts>
			abort = 1;	/* don't auto boot	*/
3480dfc0:	e3a05001 	mov	r5, #1
3480dfc4:	ea000012 	b	3480e014 <main_loop+0xc8>
		int i;

		--bootdelay;
		/* delay 100 * 10ms */
		for (i=0; !abort && i<100; ++i) {
			if (tstc()) {	/* we got a key press	*/
3480dfc8:	ebffec48 	bl	348090f0 <tstc>
3480dfcc:	e3500000 	cmp	r0, #0
3480dfd0:	0a000003 	beq	3480dfe4 <main_loop+0x98>
				abort  = 1;	/* don't auto boot	*/
				bootdelay = 0;	/* no more delay	*/
# ifdef CONFIG_MENUKEY
				menukey = getc();
# else
				(void) getc();  /* consume input	*/
3480dfd4:	ebffec3c 	bl	348090cc <getc>

		--bootdelay;
		/* delay 100 * 10ms */
		for (i=0; !abort && i<100; ++i) {
			if (tstc()) {	/* we got a key press	*/
				abort  = 1;	/* don't auto boot	*/
3480dfd8:	e3a05001 	mov	r5, #1
				bootdelay = 0;	/* no more delay	*/
3480dfdc:	e3a04000 	mov	r4, #0
3480dfe0:	ea000008 	b	3480e008 <main_loop+0xbc>
# else
				(void) getc();  /* consume input	*/
# endif
				break;
			}
			udelay(10000);
3480dfe4:	e3020710 	movw	r0, #10000	; 0x2710
3480dfe8:	eb003864 	bl	3481c180 <udelay>
	while ((bootdelay > 0) && (!abort)) {
		int i;

		--bootdelay;
		/* delay 100 * 10ms */
		for (i=0; !abort && i<100; ++i) {
3480dfec:	e2877001 	add	r7, r7, #1
3480dff0:	e3570063 	cmp	r7, #99	; 0x63
3480dff4:	c3a05000 	movgt	r5, #0
3480dff8:	d3a05001 	movle	r5, #1
3480dffc:	e3550000 	cmp	r5, #0
3480e000:	1afffff0 	bne	3480dfc8 <main_loop+0x7c>
#endif

	while ((bootdelay > 0) && (!abort)) {
		int i;

		--bootdelay;
3480e004:	e2444001 	sub	r4, r4, #1
				break;
			}
			udelay(10000);
		}

		printf("\b\b\b%2d ", bootdelay);
3480e008:	e59f0058 	ldr	r0, [pc, #88]	; 3480e068 <main_loop+0x11c>
3480e00c:	e1a01004 	mov	r1, r4
3480e010:	ebffec53 	bl	34809164 <printf>
			abort = 1;	/* don't auto boot	*/
		}
	}
#endif

	while ((bootdelay > 0) && (!abort)) {
3480e014:	e2753001 	rsbs	r3, r5, #1
3480e018:	33a03000 	movcc	r3, #0
3480e01c:	e3540000 	cmp	r4, #0
3480e020:	d3a03000 	movle	r3, #0
3480e024:	e3530000 	cmp	r3, #0
3480e028:	13a07000 	movne	r7, #0
3480e02c:	1affffef 	bne	3480dff0 <main_loop+0xa4>
		}

		printf("\b\b\b%2d ", bootdelay);
	}

	putc('\n');
3480e030:	e3a0000a 	mov	r0, #10
3480e034:	ebffec36 	bl	34809114 <putc>
#endif /* CONFIG_BOOTCOUNT_LIMIT */
		s = getenv ("bootcmd");

	debug ("### main_loop: bootcmd=\"%s\"\n", s ? s : "<UNDEFINED>");

	if (bootdelay != -1 && s && !abortboot(bootdelay)) {
3480e038:	e3550000 	cmp	r5, #0
3480e03c:	1a000003 	bne	3480e050 <main_loop+0x104>
# ifdef CONFIG_AUTOBOOT_KEYED
		int prev = disable_ctrlc(1);	/* disable Control C checking */
# endif

		run_command_list(s, -1, 0);
3480e040:	e1a00006 	mov	r0, r6
3480e044:	e3e01000 	mvn	r1, #0
3480e048:	e1a02005 	mov	r2, r5
3480e04c:	ebffffa7 	bl	3480def0 <run_command_list>

	/*
	 * Main Loop for Monitor Command Processing
	 */
#ifdef CONFIG_SYS_HUSH_PARSER
	parse_file_outer();
3480e050:	ebfffa7b 	bl	3480ca44 <parse_file_outer>
3480e054:	eafffffe 	b	3480e054 <main_loop+0x108>
3480e058:	34826914 	.word	0x34826914
3480e05c:	34822d48 	.word	0x34822d48
3480e060:	3482691e 	.word	0x3482691e
3480e064:	34826941 	.word	0x34826941
3480e068:	34826947 	.word	0x34826947

3480e06c <do_run>:
#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
	int i;

	if (argc < 2)
3480e06c:	e3520001 	cmp	r2, #1

/****************************************************************************/

#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
3480e070:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	int i;

	if (argc < 2)
		return CMD_RET_USAGE;
3480e074:	d3e00000 	mvnle	r0, #0

/****************************************************************************/

#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
{
3480e078:	e1a04002 	mov	r4, r2
	int i;

	if (argc < 2)
3480e07c:	d8bd80f8 	pople	{r3, r4, r5, r6, r7, pc}
}

/****************************************************************************/

#if defined(CONFIG_CMD_RUN)
int do_run (cmd_tbl_t * cmdtp, int flag, int argc, char * const argv[])
3480e080:	e2836004 	add	r6, r3, #4
3480e084:	e3a05001 	mov	r5, #1
{
	int i;

	if (argc < 2)
3480e088:	e1a07006 	mov	r7, r6
		return CMD_RET_USAGE;

	for (i=1; i<argc; ++i) {
		char *arg;

		if ((arg = getenv (argv[i])) == NULL) {
3480e08c:	e4960004 	ldr	r0, [r6], #4
3480e090:	ebffe545 	bl	348075ac <getenv>
3480e094:	e3500000 	cmp	r0, #0
3480e098:	1a000004 	bne	3480e0b0 <do_run+0x44>
			printf ("## Error: \"%s\" not defined\n", argv[i]);
3480e09c:	e59f0034 	ldr	r0, [pc, #52]	; 3480e0d8 <do_run+0x6c>
3480e0a0:	e5971000 	ldr	r1, [r7]
3480e0a4:	ebffec2e 	bl	34809164 <printf>
			return 1;
3480e0a8:	e3a00001 	mov	r0, #1
3480e0ac:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	if (builtin_run_command(cmd, flag) == -1)
		return 1;

	return 0;
#else
	return parse_string_outer(cmd,
3480e0b0:	e3a01003 	mov	r1, #3
3480e0b4:	ebfff690 	bl	3480bafc <parse_string_outer>
		if ((arg = getenv (argv[i])) == NULL) {
			printf ("## Error: \"%s\" not defined\n", argv[i]);
			return 1;
		}

		if (run_command(arg, flag) != 0)
3480e0b8:	e3500000 	cmp	r0, #0
3480e0bc:	1a000003 	bne	3480e0d0 <do_run+0x64>
	int i;

	if (argc < 2)
		return CMD_RET_USAGE;

	for (i=1; i<argc; ++i) {
3480e0c0:	e2855001 	add	r5, r5, #1
3480e0c4:	e1550004 	cmp	r5, r4
3480e0c8:	baffffee 	blt	3480e088 <do_run+0x1c>
3480e0cc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
			printf ("## Error: \"%s\" not defined\n", argv[i]);
			return 1;
		}

		if (run_command(arg, flag) != 0)
			return 1;
3480e0d0:	e3a00001 	mov	r0, #1
	}
	return 0;
}
3480e0d4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3480e0d8:	348251f1 	.word	0x348251f1

3480e0dc <get_ram_size>:
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
{
3480e0dc:	e92d40f0 	push	{r4, r5, r6, r7, lr}
3480e0e0:	e24dd084 	sub	sp, sp, #132	; 0x84
3480e0e4:	e1a03000 	mov	r3, r0
	long           cnt;
	long           val;
	long           size;
	int            i = 0;

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
3480e0e8:	e1a04121 	lsr	r4, r1, #2
3480e0ec:	e1a021a1 	lsr	r2, r1, #3
3480e0f0:	e24d0004 	sub	r0, sp, #4
	volatile long *addr;
	long           save[32];
	long           cnt;
	long           val;
	long           size;
	int            i = 0;
3480e0f4:	e3a0c000 	mov	ip, #0

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
3480e0f8:	ea000005 	b	3480e114 <get_ram_size+0x38>
		addr = base + cnt;	/* pointer arith! */
		sync ();
		save[i++] = *addr;
3480e0fc:	e7935102 	ldr	r5, [r3, r2, lsl #2]
3480e100:	e28cc001 	add	ip, ip, #1
3480e104:	e5a05004 	str	r5, [r0, #4]!
		sync ();
		*addr = ~cnt;
3480e108:	e1e05002 	mvn	r5, r2
3480e10c:	e7835102 	str	r5, [r3, r2, lsl #2]
	long           cnt;
	long           val;
	long           size;
	int            i = 0;

	for (cnt = (maxsize / sizeof (long)) >> 1; cnt > 0; cnt >>= 1) {
3480e110:	e1a020c2 	asr	r2, r2, #1
3480e114:	e3520000 	cmp	r2, #0
3480e118:	1afffff7 	bne	3480e0fc <get_ram_size+0x20>
		*addr = ~cnt;
	}

	addr = base;
	sync ();
	save[i] = *addr;
3480e11c:	e5935000 	ldr	r5, [r3]
3480e120:	e1a0010c 	lsl	r0, ip, #2
3480e124:	e28d7080 	add	r7, sp, #128	; 0x80
3480e128:	e0876000 	add	r6, r7, r0
3480e12c:	e5065080 	str	r5, [r6, #-128]	; 0x80
	sync ();
	*addr = 0;
3480e130:	e5832000 	str	r2, [r3]

	sync ();
	if ((val = *addr) != 0) {
3480e134:	e5932000 	ldr	r2, [r3]
3480e138:	e3520000 	cmp	r2, #0
3480e13c:	e1a0200d 	mov	r2, sp
/*
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
3480e140:	10820000 	addne	r0, r2, r0
3480e144:	008d5000 	addeq	r5, sp, r0
3480e148:	03a02001 	moveq	r2, #1
	sync ();
	if ((val = *addr) != 0) {
		/* Restore the original data before leaving the function.
		 */
		sync ();
		*addr = save[i];
3480e14c:	15835000 	strne	r5, [r3]
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
3480e150:	13a02001 	movne	r2, #1
	save[i] = *addr;
	sync ();
	*addr = 0;

	sync ();
	if ((val = *addr) != 0) {
3480e154:	1a000003 	bne	3480e168 <get_ram_size+0x8c>
3480e158:	ea000018 	b	3480e1c0 <get_ram_size+0xe4>
		sync ();
		*addr = save[i];
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
			addr  = base + cnt;
			sync ();
			*addr = save[--i];
3480e15c:	e5301004 	ldr	r1, [r0, #-4]!
3480e160:	e7831102 	str	r1, [r3, r2, lsl #2]
	if ((val = *addr) != 0) {
		/* Restore the original data before leaving the function.
		 */
		sync ();
		*addr = save[i];
		for (cnt = 1; cnt < maxsize / sizeof(long); cnt <<= 1) {
3480e164:	e1a02082 	lsl	r2, r2, #1
3480e168:	e1520004 	cmp	r2, r4
3480e16c:	3afffffa 	bcc	3480e15c <get_ram_size+0x80>
			addr  = base + cnt;
			sync ();
			*addr = save[--i];
		}
		return (0);
3480e170:	e3a00000 	mov	r0, #0
3480e174:	ea000014 	b	3480e1cc <get_ram_size+0xf0>
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
		val = *addr;
		*addr = save[--i];
3480e178:	e5356004 	ldr	r6, [r5, #-4]!
		return (0);
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
		val = *addr;
3480e17c:	e7937102 	ldr	r7, [r3, r2, lsl #2]
		*addr = save[--i];
3480e180:	e7836102 	str	r6, [r3, r2, lsl #2]
		if (val != ~cnt) {
3480e184:	e1e06002 	mvn	r6, r2
3480e188:	e1570006 	cmp	r7, r6
		}
		return (0);
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
		addr = base + cnt;	/* pointer arith! */
3480e18c:	e1a00102 	lsl	r0, r2, #2
		val = *addr;
		*addr = save[--i];
3480e190:	e24cc001 	sub	ip, ip, #1
3480e194:	e1a02082 	lsl	r2, r2, #1
		if (val != ~cnt) {
3480e198:	0a000008 	beq	3480e1c0 <get_ram_size+0xe4>
/*
 * Check memory range for valid RAM. A simple memory test determines
 * the actually available RAM size between addresses `base' and
 * `base + maxsize'.
 */
long get_ram_size(long *base, long maxsize)
3480e19c:	e1a0100d 	mov	r1, sp
3480e1a0:	e081c10c 	add	ip, r1, ip, lsl #2
		*addr = save[--i];
		if (val != ~cnt) {
			size = cnt * sizeof (long);
			/* Restore the original data before leaving the function.
			 */
			for (cnt <<= 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
3480e1a4:	ea000002 	b	3480e1b4 <get_ram_size+0xd8>
				addr  = base + cnt;
				*addr = save[--i];
3480e1a8:	e53c1004 	ldr	r1, [ip, #-4]!
3480e1ac:	e7831102 	str	r1, [r3, r2, lsl #2]
		*addr = save[--i];
		if (val != ~cnt) {
			size = cnt * sizeof (long);
			/* Restore the original data before leaving the function.
			 */
			for (cnt <<= 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
3480e1b0:	e1a02082 	lsl	r2, r2, #1
3480e1b4:	e1520004 	cmp	r2, r4
3480e1b8:	3afffffa 	bcc	3480e1a8 <get_ram_size+0xcc>
3480e1bc:	ea000002 	b	3480e1cc <get_ram_size+0xf0>
			*addr = save[--i];
		}
		return (0);
	}

	for (cnt = 1; cnt < maxsize / sizeof (long); cnt <<= 1) {
3480e1c0:	e1520004 	cmp	r2, r4
3480e1c4:	3affffeb 	bcc	3480e178 <get_ram_size+0x9c>
			}
			return (size);
		}
	}

	return (maxsize);
3480e1c8:	e1a00001 	mov	r0, r1
}
3480e1cc:	e28dd084 	add	sp, sp, #132	; 0x84
3480e1d0:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

3480e1d4 <hex1_bin>:
	return (srec_type);
}

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
3480e1d4:	e2403030 	sub	r3, r0, #48	; 0x30
3480e1d8:	e6ef2073 	uxtb	r2, r3
3480e1dc:	e3520009 	cmp	r2, #9
		return (c - '0');
3480e1e0:	91a00003 	movls	r0, r3
	return (srec_type);
}

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
3480e1e4:	912fff1e 	bxls	lr
		return (c - '0');
	if (c >= 'a' && c <= 'f')
3480e1e8:	e2403061 	sub	r3, r0, #97	; 0x61
3480e1ec:	e6ef3073 	uxtb	r3, r3
3480e1f0:	e3530005 	cmp	r3, #5
		return (c + 10 - 'a');
3480e1f4:	92400057 	subls	r0, r0, #87	; 0x57

static int hex1_bin (char c)
{
	if (c >= '0' && c <= '9')
		return (c - '0');
	if (c >= 'a' && c <= 'f')
3480e1f8:	912fff1e 	bxls	lr
		return (c + 10 - 'a');
	if (c >= 'A' && c <= 'F')
3480e1fc:	e2403041 	sub	r3, r0, #65	; 0x41
3480e200:	e6ef3073 	uxtb	r3, r3
3480e204:	e3530005 	cmp	r3, #5
		return (c + 10 - 'A');
3480e208:	92400037 	subls	r0, r0, #55	; 0x37
	return (-1);
3480e20c:	83e00000 	mvnhi	r0, #0
}
3480e210:	e12fff1e 	bx	lr

3480e214 <hex2_bin>:

static int hex2_bin (char *s)
{
3480e214:	e92d4038 	push	{r3, r4, r5, lr}
3480e218:	e1a04000 	mov	r4, r0
	int i, j;

	if ((i = hex1_bin(*s++)) < 0) {
3480e21c:	e5d00000 	ldrb	r0, [r0]
3480e220:	ebffffeb 	bl	3480e1d4 <hex1_bin>
3480e224:	e2505000 	subs	r5, r0, #0
		return (-1);
3480e228:	b3e00000 	mvnlt	r0, #0

static int hex2_bin (char *s)
{
	int i, j;

	if ((i = hex1_bin(*s++)) < 0) {
3480e22c:	b8bd8038 	poplt	{r3, r4, r5, pc}
		return (-1);
	}
	if ((j = hex1_bin(*s)) < 0) {
3480e230:	e5d40001 	ldrb	r0, [r4, #1]
3480e234:	ebffffe6 	bl	3480e1d4 <hex1_bin>
3480e238:	e3500000 	cmp	r0, #0
		return (-1);
	}

	return ((i<<4) + j);
3480e23c:	a0800205 	addge	r0, r0, r5, lsl #4

	if ((i = hex1_bin(*s++)) < 0) {
		return (-1);
	}
	if ((j = hex1_bin(*s)) < 0) {
		return (-1);
3480e240:	b3e00000 	mvnlt	r0, #0
	}

	return ((i<<4) + j);
}
3480e244:	e8bd8038 	pop	{r3, r4, r5, pc}

3480e248 <srec_decode>:

static int hex1_bin (char  c);
static int hex2_bin (char *s);

int srec_decode (char *input, int *count, ulong *addr, char *data)
{
3480e248:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
3480e24c:	e1a04001 	mov	r4, r1
3480e250:	e1a05002 	mov	r5, r2
3480e254:	e1a09003 	mov	r9, r3

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
3480e258:	ea000002 	b	3480e268 <srec_decode+0x20>
		if (*input == 'S') {		/* skip 'S' */
3480e25c:	e3530053 	cmp	r3, #83	; 0x53
			++input;
3480e260:	01a07000 	moveq	r7, r0
			break;
3480e264:	0a000004 	beq	3480e27c <srec_decode+0x34>

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
3480e268:	e5d03000 	ldrb	r3, [r0]
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
3480e26c:	e1a07000 	mov	r7, r0

	/* skip anything before 'S', and the 'S' itself.
	 * Return error if not found
	 */

	for (; *input; ++input) {
3480e270:	e3530000 	cmp	r3, #0
3480e274:	e2800001 	add	r0, r0, #1
3480e278:	1afffff7 	bne	3480e25c <srec_decode+0x14>
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
		}
	}
	if (*input == '\0') {			/* no more data?	*/
3480e27c:	e5d7b000 	ldrb	fp, [r7]
3480e280:	e35b0000 	cmp	fp, #0
		return (SREC_EMPTY);
3480e284:	03a0600a 	moveq	r6, #10
		if (*input == 'S') {		/* skip 'S' */
			++input;
			break;
		}
	}
	if (*input == '\0') {			/* no more data?	*/
3480e288:	0a000088 	beq	3480e4b0 <srec_decode+0x268>
		return (SREC_EMPTY);
	}

	v = *input++;				/* record type		*/
3480e28c:	e2877001 	add	r7, r7, #1

	if ((*count = hex2_bin(input)) < 0) {
3480e290:	e1a00007 	mov	r0, r7
3480e294:	ebffffde 	bl	3480e214 <hex2_bin>
3480e298:	e3500000 	cmp	r0, #0
3480e29c:	e5840000 	str	r0, [r4]
3480e2a0:	ba000081 	blt	3480e4ac <srec_decode+0x264>
	}

	chksum += *count;
	input  += 2;

	switch (v) {				/* record type		*/
3480e2a4:	e24b3030 	sub	r3, fp, #48	; 0x30
3480e2a8:	e3530009 	cmp	r3, #9
3480e2ac:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480e2b0:	ea00007b 	b	3480e4a4 <srec_decode+0x25c>
3480e2b4:	3480e2dc 	.word	0x3480e2dc
3480e2b8:	3480e2ec 	.word	0x3480e2ec
3480e2bc:	3480e2fc 	.word	0x3480e2fc
3480e2c0:	3480e30c 	.word	0x3480e30c
3480e2c4:	3480e4a4 	.word	0x3480e4a4
3480e2c8:	3480e31c 	.word	0x3480e31c
3480e2cc:	3480e4a4 	.word	0x3480e4a4
3480e2d0:	3480e32c 	.word	0x3480e32c
3480e2d4:	3480e33c 	.word	0x3480e33c
3480e2d8:	3480e34c 	.word	0x3480e34c

	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
3480e2dc:	e2403003 	sub	r3, r0, #3
3480e2e0:	e5843000 	str	r3, [r4]
	input  += 2;

	switch (v) {				/* record type		*/

	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
3480e2e4:	e3a06000 	mov	r6, #0
		*count   -= 3;			/* - checksum and addr	*/
		break;
3480e2e8:	ea00001a 	b	3480e358 <srec_decode+0x110>
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
3480e2ec:	e2403003 	sub	r3, r0, #3
3480e2f0:	e5843000 	str	r3, [r4]
	case '0':				/* start record		*/
		srec_type = SREC_START;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
		break;
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
3480e2f4:	e3a06001 	mov	r6, #1
		*count   -= 3;			/* - checksum and addr	*/
		break;
3480e2f8:	ea000016 	b	3480e358 <srec_decode+0x110>
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
3480e2fc:	e2403004 	sub	r3, r0, #4
3480e300:	e5843000 	str	r3, [r4]
	case '1':
		srec_type = SREC_DATA2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
		break;
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
3480e304:	e3a06002 	mov	r6, #2
		*count   -= 4;			/* - checksum and addr	*/
		break;
3480e308:	ea000012 	b	3480e358 <srec_decode+0x110>
	case '3':				/* data record with a	*/
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
3480e30c:	e2403005 	sub	r3, r0, #5
3480e310:	e5843000 	str	r3, [r4]
	case '2':
		srec_type = SREC_DATA3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
		break;
	case '3':				/* data record with a	*/
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
3480e314:	e3a06003 	mov	r6, #3
		*count   -= 5;			/* - checksum and addr	*/
		break;
3480e318:	ea00000e 	b	3480e358 <srec_decode+0x110>
/***	case '4'  ***/
	case '5':			/* count record, addr field contains */
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
		*count    = 0;			/* no data		*/
3480e31c:	e3a03000 	mov	r3, #0
3480e320:	e5843000 	str	r3, [r4]
		srec_type = SREC_DATA4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
		break;
/***	case '4'  ***/
	case '5':			/* count record, addr field contains */
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
3480e324:	e3a06005 	mov	r6, #5
		*count    = 0;			/* no data		*/
		break;
3480e328:	ea00000a 	b	3480e358 <srec_decode+0x110>
/***	case '6' -- not used  ***/
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
3480e32c:	e2403005 	sub	r3, r0, #5
3480e330:	e5843000 	str	r3, [r4]
		srec_type = SREC_COUNT;	/* a 2 byte record counter	*/
		*count    = 0;			/* no data		*/
		break;
/***	case '6' -- not used  ***/
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
3480e334:	e3a06007 	mov	r6, #7
		*count   -= 5;			/* - checksum and addr	*/
		break;
3480e338:	ea000006 	b	3480e358 <srec_decode+0x110>
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
3480e33c:	e2403004 	sub	r3, r0, #4
3480e340:	e5843000 	str	r3, [r4]
	case '7':				/* end record with a	*/
		srec_type = SREC_END4;		/* 4 byte addr field	*/
		*count   -= 5;			/* - checksum and addr	*/
		break;
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
3480e344:	e3a06008 	mov	r6, #8
		*count   -= 4;			/* - checksum and addr	*/
		break;
3480e348:	ea000002 	b	3480e358 <srec_decode+0x110>
	case '9':				/* end record with a	*/
		srec_type = SREC_END2;		/* 2 byte addr field	*/
		*count   -= 3;			/* - checksum and addr	*/
3480e34c:	e2403003 	sub	r3, r0, #3
3480e350:	e5843000 	str	r3, [r4]
	case '8':				/* end record with a	*/
		srec_type = SREC_END3;		/* 3 byte addr field	*/
		*count   -= 4;			/* - checksum and addr	*/
		break;
	case '9':				/* end record with a	*/
		srec_type = SREC_END2;		/* 2 byte addr field	*/
3480e354:	e3a06009 	mov	r6, #9
	default:
		return (SREC_E_BADTYPE);
	}

	/* read address field */
	*addr = 0;
3480e358:	e3a03000 	mov	r3, #0

	switch (v) {
3480e35c:	e24bb030 	sub	fp, fp, #48	; 0x30
	default:
		return (SREC_E_BADTYPE);
	}

	/* read address field */
	*addr = 0;
3480e360:	e5853000 	str	r3, [r5]

	switch (v) {
3480e364:	e6ef307b 	uxtb	r3, fp
3480e368:	e3530009 	cmp	r3, #9

	if ((*count = hex2_bin(input)) < 0) {
		return (SREC_E_NOSREC);
	}

	chksum += *count;
3480e36c:	e6efa070 	uxtb	sl, r0
	input  += 2;
3480e370:	e2877002 	add	r7, r7, #2
	}

	/* read address field */
	*addr = 0;

	switch (v) {
3480e374:	8a00004a 	bhi	3480e4a4 <srec_decode+0x25c>
3480e378:	e3a03001 	mov	r3, #1
3480e37c:	e6afb07b 	sxtb	fp, fp
3480e380:	e1a0bb13 	lsl	fp, r3, fp
3480e384:	e3003223 	movw	r3, #547	; 0x223
3480e388:	e00b3003 	and	r3, fp, r3
3480e38c:	e3530000 	cmp	r3, #0
3480e390:	1a000016 	bne	3480e3f0 <srec_decode+0x1a8>
3480e394:	e31b0088 	tst	fp, #136	; 0x88
3480e398:	1a000002 	bne	3480e3a8 <srec_decode+0x160>
3480e39c:	e31b0f41 	tst	fp, #260	; 0x104
3480e3a0:	1a000008 	bne	3480e3c8 <srec_decode+0x180>
3480e3a4:	ea00003e 	b	3480e4a4 <srec_decode+0x25c>
	case '3':				/* 4 byte addr field	*/
	case '7':
		if ((v = hex2_bin(input)) < 0) {
3480e3a8:	e1a00007 	mov	r0, r7
3480e3ac:	ebffff98 	bl	3480e214 <hex2_bin>
3480e3b0:	e3500000 	cmp	r0, #0
3480e3b4:	ba00003c 	blt	3480e4ac <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		*addr  += v;
		chksum += v;
3480e3b8:	e08aa000 	add	sl, sl, r0
	case '3':				/* 4 byte addr field	*/
	case '7':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr  += v;
3480e3bc:	e5850000 	str	r0, [r5]
		chksum += v;
3480e3c0:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480e3c4:	e2877002 	add	r7, r7, #2
		/* FALL THRU */
	case '2':				/* 3 byte addr field	*/
	case '8':
		if ((v = hex2_bin(input)) < 0) {
3480e3c8:	e1a00007 	mov	r0, r7
3480e3cc:	ebffff90 	bl	3480e214 <hex2_bin>
3480e3d0:	e3500000 	cmp	r0, #0
3480e3d4:	ba000034 	blt	3480e4ac <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
3480e3d8:	e5953000 	ldr	r3, [r5]
		*addr  += v;
		chksum += v;
3480e3dc:	e08aa000 	add	sl, sl, r0
	case '8':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480e3e0:	e0803403 	add	r3, r0, r3, lsl #8
3480e3e4:	e5853000 	str	r3, [r5]
		chksum += v;
3480e3e8:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480e3ec:	e2877002 	add	r7, r7, #2
		/* FALL THRU */
	case '0':				/* 2 byte addr field	*/
	case '1':
	case '5':
	case '9':
		if ((v = hex2_bin(input)) < 0) {
3480e3f0:	e1a00007 	mov	r0, r7
3480e3f4:	ebffff86 	bl	3480e214 <hex2_bin>
3480e3f8:	e250b000 	subs	fp, r0, #0
3480e3fc:	ba00002a 	blt	3480e4ac <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
3480e400:	e5953000 	ldr	r3, [r5]
		*addr  += v;
		chksum += v;
		input  += 2;
3480e404:	e2877002 	add	r7, r7, #2
	case '9':
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480e408:	e08b3403 	add	r3, fp, r3, lsl #8
3480e40c:	e5853000 	str	r3, [r5]
		chksum += v;
		input  += 2;

		if ((v = hex2_bin(input)) < 0) {
3480e410:	e1a00007 	mov	r0, r7
3480e414:	e58d3004 	str	r3, [sp, #4]
3480e418:	ebffff7d 	bl	3480e214 <hex2_bin>
3480e41c:	e3500000 	cmp	r0, #0
3480e420:	e59d3004 	ldr	r3, [sp, #4]
3480e424:	ba000020 	blt	3480e4ac <srec_decode+0x264>
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
		chksum += v;
3480e428:	e08aa00b 	add	sl, sl, fp

		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480e42c:	e0803403 	add	r3, r0, r3, lsl #8
		chksum += v;
3480e430:	e6e0a07a 	uxtab	sl, r0, sl

		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		*addr <<= 8;
		*addr  += v;
3480e434:	e5853000 	str	r3, [r5]
		chksum += v;
3480e438:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480e43c:	e2877002 	add	r7, r7, #2
	default:
		return (SREC_E_BADTYPE);
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
3480e440:	e3a05000 	mov	r5, #0
3480e444:	ea000009 	b	3480e470 <srec_decode+0x228>
		if ((v = hex2_bin(input)) < 0) {
3480e448:	e1a00007 	mov	r0, r7
3480e44c:	ebffff70 	bl	3480e214 <hex2_bin>
3480e450:	e3500000 	cmp	r0, #0
3480e454:	ba000014 	blt	3480e4ac <srec_decode+0x264>
			return (SREC_E_NOSREC);
		}
		data[i] = v;
3480e458:	e6ef0070 	uxtb	r0, r0
		chksum += v;
3480e45c:	e080a00a 	add	sl, r0, sl
	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
		if ((v = hex2_bin(input)) < 0) {
			return (SREC_E_NOSREC);
		}
		data[i] = v;
3480e460:	e7c90005 	strb	r0, [r9, r5]
		chksum += v;
3480e464:	e6efa07a 	uxtb	sl, sl
		input  += 2;
3480e468:	e2877002 	add	r7, r7, #2
	default:
		return (SREC_E_BADTYPE);
	}

	/* convert data and calculate checksum */
	for (i=0; i < *count; ++i) {
3480e46c:	e2855001 	add	r5, r5, #1
3480e470:	e5943000 	ldr	r3, [r4]
3480e474:	e1550003 	cmp	r5, r3
3480e478:	bafffff2 	blt	3480e448 <srec_decode+0x200>
		chksum += v;
		input  += 2;
	}

	/* read anc check checksum */
	if ((v = hex2_bin(input)) < 0) {
3480e47c:	e1a00007 	mov	r0, r7
3480e480:	ebffff63 	bl	3480e214 <hex2_bin>
3480e484:	e3500000 	cmp	r0, #0
3480e488:	ba000007 	blt	3480e4ac <srec_decode+0x264>
		return (SREC_E_NOSREC);
	}

	if ((unsigned char)v != (unsigned char)~chksum) {
3480e48c:	e1e0a00a 	mvn	sl, sl
3480e490:	e6ef0070 	uxtb	r0, r0
3480e494:	e6efa07a 	uxtb	sl, sl
		return (SREC_E_BADCHKS);
3480e498:	e150000a 	cmp	r0, sl
3480e49c:	13e06002 	mvnne	r6, #2
3480e4a0:	ea000002 	b	3480e4b0 <srec_decode+0x268>
		chksum += v;
		input  += 2;

		break;
	default:
		return (SREC_E_BADTYPE);
3480e4a4:	e3e06000 	mvn	r6, #0
3480e4a8:	ea000000 	b	3480e4b0 <srec_decode+0x268>
		input  += 2;
	}

	/* read anc check checksum */
	if ((v = hex2_bin(input)) < 0) {
		return (SREC_E_NOSREC);
3480e4ac:	e3e06001 	mvn	r6, #1
	if ((unsigned char)v != (unsigned char)~chksum) {
		return (SREC_E_BADCHKS);
	}

	return (srec_type);
}
3480e4b0:	e1a00006 	mov	r0, r6
3480e4b4:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

3480e4b8 <get_current>:
	for (s = serial_devices; s; s = s->next)
		s->init();
}

static struct serial_device *get_current(void)
{
3480e4b8:	e92d4008 	push	{r3, lr}
	struct serial_device *dev;

	if (!(gd->flags & GD_FLG_RELOC) || !serial_current) {
3480e4bc:	e5983004 	ldr	r3, [r8, #4]
3480e4c0:	e3130001 	tst	r3, #1
3480e4c4:	0a000003 	beq	3480e4d8 <get_current+0x20>
3480e4c8:	e59f301c 	ldr	r3, [pc, #28]	; 3480e4ec <get_current+0x34>
3480e4cc:	e5930000 	ldr	r0, [r3]
3480e4d0:	e3500000 	cmp	r0, #0
3480e4d4:	18bd8008 	popne	{r3, pc}
		dev = default_serial_console();
3480e4d8:	eb0026cd 	bl	34818014 <default_serial_console>

		/* We must have a console device */
		if (!dev)
3480e4dc:	e3500000 	cmp	r0, #0
3480e4e0:	18bd8008 	popne	{r3, pc}
			panic("Cannot find console");
3480e4e4:	e59f0004 	ldr	r0, [pc, #4]	; 3480e4f0 <get_current+0x38>
3480e4e8:	eb003a17 	bl	3481cd4c <panic>
3480e4ec:	3482b57c 	.word	0x3482b57c
3480e4f0:	3482694f 	.word	0x3482694f

3480e4f4 <serial_register>:
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480e4f4:	e59f300c 	ldr	r3, [pc, #12]	; 3480e508 <serial_register+0x14>
3480e4f8:	e5932004 	ldr	r2, [r3, #4]
	serial_devices = dev;
3480e4fc:	e5830004 	str	r0, [r3, #4]
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480e500:	e580202c 	str	r2, [r0, #44]	; 0x2c
	serial_devices = dev;
}
3480e504:	e12fff1e 	bx	lr
3480e508:	3482b57c 	.word	0x3482b57c

3480e50c <serial_stdio_init>:
#endif
	serial_assign(default_serial_console()->name);
}

void serial_stdio_init(void)
{
3480e50c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;
3480e510:	e59f3080 	ldr	r3, [pc, #128]	; 3480e598 <serial_stdio_init+0x8c>
#endif
	serial_assign(default_serial_console()->name);
}

void serial_stdio_init(void)
{
3480e514:	e24dd044 	sub	sp, sp, #68	; 0x44
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;

	while (s) {
		memset(&dev, 0, sizeof(dev));
3480e518:	e28d5004 	add	r5, sp, #4
}

void serial_stdio_init(void)
{
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;
3480e51c:	e5934004 	ldr	r4, [r3, #4]

	while (s) {
		memset(&dev, 0, sizeof(dev));

		strcpy(dev.name, s->name);
3480e520:	e2857008 	add	r7, r5, #8
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;
3480e524:	e3a06003 	mov	r6, #3
void serial_stdio_init(void)
{
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;

	while (s) {
3480e528:	ea000016 	b	3480e588 <serial_stdio_init+0x7c>
		memset(&dev, 0, sizeof(dev));
3480e52c:	e3a0203c 	mov	r2, #60	; 0x3c
3480e530:	e3a01000 	mov	r1, #0
3480e534:	e1a00005 	mov	r0, r5
3480e538:	eb003661 	bl	3481bec4 <memset>

		strcpy(dev.name, s->name);
3480e53c:	e1a01004 	mov	r1, r4
3480e540:	e1a00007 	mov	r0, r7
3480e544:	eb003559 	bl	3481bab0 <strcpy>
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;

		dev.start = s->init;
3480e548:	e5943010 	ldr	r3, [r4, #16]
		dev.putc = s->putc;
		dev.puts = s->puts;
		dev.getc = s->getc;
		dev.tstc = s->tstc;

		stdio_register(&dev);
3480e54c:	e1a00005 	mov	r0, r5
		memset(&dev, 0, sizeof(dev));

		strcpy(dev.name, s->name);
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;

		dev.start = s->init;
3480e550:	e58d301c 	str	r3, [sp, #28]
		dev.stop = s->uninit;
3480e554:	e5943014 	ldr	r3, [r4, #20]

	while (s) {
		memset(&dev, 0, sizeof(dev));

		strcpy(dev.name, s->name);
		dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT;
3480e558:	e58d6004 	str	r6, [sp, #4]

		dev.start = s->init;
		dev.stop = s->uninit;
3480e55c:	e58d3020 	str	r3, [sp, #32]
		dev.putc = s->putc;
3480e560:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3480e564:	e58d3024 	str	r3, [sp, #36]	; 0x24
		dev.puts = s->puts;
3480e568:	e5943028 	ldr	r3, [r4, #40]	; 0x28
3480e56c:	e58d3028 	str	r3, [sp, #40]	; 0x28
		dev.getc = s->getc;
3480e570:	e594301c 	ldr	r3, [r4, #28]
3480e574:	e58d3030 	str	r3, [sp, #48]	; 0x30
		dev.tstc = s->tstc;
3480e578:	e5943020 	ldr	r3, [r4, #32]
3480e57c:	e58d302c 	str	r3, [sp, #44]	; 0x2c

		stdio_register(&dev);
3480e580:	eb000083 	bl	3480e794 <stdio_register>

		s = s->next;
3480e584:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
void serial_stdio_init(void)
{
	struct stdio_dev dev;
	struct serial_device *s = serial_devices;

	while (s) {
3480e588:	e3540000 	cmp	r4, #0
3480e58c:	1affffe6 	bne	3480e52c <serial_stdio_init+0x20>

		stdio_register(&dev);

		s = s->next;
	}
}
3480e590:	e28dd044 	add	sp, sp, #68	; 0x44
3480e594:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
3480e598:	3482b57c 	.word	0x3482b57c

3480e59c <serial_assign>:

int serial_assign(const char *name)
{
3480e59c:	e92d4038 	push	{r3, r4, r5, lr}
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
3480e5a0:	e59f303c 	ldr	r3, [pc, #60]	; 3480e5e4 <serial_assign+0x48>
		s = s->next;
	}
}

int serial_assign(const char *name)
{
3480e5a4:	e1a05000 	mov	r5, r0
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
3480e5a8:	e5934004 	ldr	r4, [r3, #4]
3480e5ac:	ea000008 	b	3480e5d4 <serial_assign+0x38>
		if (strcmp(s->name, name) == 0) {
3480e5b0:	e1a00004 	mov	r0, r4
3480e5b4:	e1a01005 	mov	r1, r5
3480e5b8:	eb00356d 	bl	3481bb74 <strcmp>
3480e5bc:	e3500000 	cmp	r0, #0
3480e5c0:	1a000002 	bne	3480e5d0 <serial_assign+0x34>
			serial_current = s;
3480e5c4:	e59f3018 	ldr	r3, [pc, #24]	; 3480e5e4 <serial_assign+0x48>
3480e5c8:	e5834000 	str	r4, [r3]
			return 0;
3480e5cc:	e8bd8038 	pop	{r3, r4, r5, pc}

int serial_assign(const char *name)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next) {
3480e5d0:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
3480e5d4:	e3540000 	cmp	r4, #0
3480e5d8:	1afffff4 	bne	3480e5b0 <serial_assign+0x14>
			serial_current = s;
			return 0;
		}
	}

	return 1;
3480e5dc:	e3a00001 	mov	r0, #1
}
3480e5e0:	e8bd8038 	pop	{r3, r4, r5, pc}
3480e5e4:	3482b57c 	.word	0x3482b57c

3480e5e8 <serial_initialize>:
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480e5e8:	e59f3034 	ldr	r3, [pc, #52]	; 3480e624 <serial_initialize+0x3c>
3480e5ec:	e59f1034 	ldr	r1, [pc, #52]	; 3480e628 <serial_initialize+0x40>
3480e5f0:	e5932004 	ldr	r2, [r3, #4]
	serial_devices = dev;
}

void serial_initialize(void)
{
3480e5f4:	e92d4010 	push	{r4, lr}
	dev->tstc += gd->reloc_off;
	dev->putc += gd->reloc_off;
	dev->puts += gd->reloc_off;
#endif

	dev->next = serial_devices;
3480e5f8:	e581202c 	str	r2, [r1, #44]	; 0x2c
3480e5fc:	e59f2028 	ldr	r2, [pc, #40]	; 3480e62c <serial_initialize+0x44>
3480e600:	e582102c 	str	r1, [r2, #44]	; 0x2c
3480e604:	e59f1024 	ldr	r1, [pc, #36]	; 3480e630 <serial_initialize+0x48>
3480e608:	e581202c 	str	r2, [r1, #44]	; 0x2c
3480e60c:	e59f2020 	ldr	r2, [pc, #32]	; 3480e634 <serial_initialize+0x4c>
3480e610:	e582102c 	str	r1, [r2, #44]	; 0x2c
	serial_devices = dev;
3480e614:	e5832004 	str	r2, [r3, #4]
# endif
# ifdef CONFIG_ZYNQ_SERIAL_BASEADDR1
	serial_register(&uart_zynq_serial1_device);
# endif
#endif
	serial_assign(default_serial_console()->name);
3480e618:	eb00267d 	bl	34818014 <default_serial_console>
}
3480e61c:	e8bd4010 	pop	{r4, lr}
# endif
# ifdef CONFIG_ZYNQ_SERIAL_BASEADDR1
	serial_register(&uart_zynq_serial1_device);
# endif
#endif
	serial_assign(default_serial_console()->name);
3480e620:	eaffffdd 	b	3480e59c <serial_assign>
3480e624:	3482b57c 	.word	0x3482b57c
3480e628:	34829258 	.word	0x34829258
3480e62c:	34829288 	.word	0x34829288
3480e630:	34829228 	.word	0x34829228
3480e634:	348292b8 	.word	0x348292b8

3480e638 <serial_reinit_all>:

void serial_reinit_all(void)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next)
3480e638:	e59f3020 	ldr	r3, [pc, #32]	; 3480e660 <serial_reinit_all+0x28>

	return 1;
}

void serial_reinit_all(void)
{
3480e63c:	e92d4010 	push	{r4, lr}
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next)
3480e640:	e5934004 	ldr	r4, [r3, #4]
3480e644:	ea000002 	b	3480e654 <serial_reinit_all+0x1c>
		s->init();
3480e648:	e5943010 	ldr	r3, [r4, #16]
3480e64c:	e12fff33 	blx	r3

void serial_reinit_all(void)
{
	struct serial_device *s;

	for (s = serial_devices; s; s = s->next)
3480e650:	e594402c 	ldr	r4, [r4, #44]	; 0x2c
3480e654:	e3540000 	cmp	r4, #0
3480e658:	1afffffa 	bne	3480e648 <serial_reinit_all+0x10>
		s->init();
}
3480e65c:	e8bd8010 	pop	{r4, pc}
3480e660:	3482b57c 	.word	0x3482b57c

3480e664 <serial_init>:
		dev = serial_current;
	return dev;
}

int serial_init(void)
{
3480e664:	e92d4008 	push	{r3, lr}
	return get_current()->init();
3480e668:	ebffff92 	bl	3480e4b8 <get_current>
3480e66c:	e5903010 	ldr	r3, [r0, #16]
3480e670:	e12fff33 	blx	r3
}
3480e674:	e8bd8008 	pop	{r3, pc}

3480e678 <serial_setbrg>:

void serial_setbrg(void)
{
3480e678:	e92d4008 	push	{r3, lr}
	get_current()->setbrg();
3480e67c:	ebffff8d 	bl	3480e4b8 <get_current>
3480e680:	e5903018 	ldr	r3, [r0, #24]
3480e684:	e12fff33 	blx	r3
}
3480e688:	e8bd8008 	pop	{r3, pc}

3480e68c <serial_getc>:

int serial_getc(void)
{
3480e68c:	e92d4008 	push	{r3, lr}
	return get_current()->getc();
3480e690:	ebffff88 	bl	3480e4b8 <get_current>
3480e694:	e590301c 	ldr	r3, [r0, #28]
3480e698:	e12fff33 	blx	r3
}
3480e69c:	e8bd8008 	pop	{r3, pc}

3480e6a0 <serial_tstc>:

int serial_tstc(void)
{
3480e6a0:	e92d4008 	push	{r3, lr}
	return get_current()->tstc();
3480e6a4:	ebffff83 	bl	3480e4b8 <get_current>
3480e6a8:	e5903020 	ldr	r3, [r0, #32]
3480e6ac:	e12fff33 	blx	r3
}
3480e6b0:	e8bd8008 	pop	{r3, pc}

3480e6b4 <serial_putc>:

void serial_putc(const char c)
{
3480e6b4:	e92d4010 	push	{r4, lr}
3480e6b8:	e1a04000 	mov	r4, r0
	get_current()->putc(c);
3480e6bc:	ebffff7d 	bl	3480e4b8 <get_current>
3480e6c0:	e5903024 	ldr	r3, [r0, #36]	; 0x24
3480e6c4:	e1a00004 	mov	r0, r4
3480e6c8:	e12fff33 	blx	r3
}
3480e6cc:	e8bd8010 	pop	{r4, pc}

3480e6d0 <serial_puts>:

void serial_puts(const char *s)
{
3480e6d0:	e92d4010 	push	{r4, lr}
3480e6d4:	e1a04000 	mov	r4, r0
	get_current()->puts(s);
3480e6d8:	ebffff76 	bl	3480e4b8 <get_current>
3480e6dc:	e5903028 	ldr	r3, [r0, #40]	; 0x28
3480e6e0:	e1a00004 	mov	r0, r4
3480e6e4:	e12fff33 	blx	r3
}
3480e6e8:	e8bd8010 	pop	{r4, pc}

3480e6ec <stdio_get_list>:
 **************************************************************************
 */
struct list_head* stdio_get_list(void)
{
	return &(devs.list);
}
3480e6ec:	e59f0000 	ldr	r0, [pc, #0]	; 3480e6f4 <stdio_get_list+0x8>
3480e6f0:	e12fff1e 	bx	lr
3480e6f4:	3482b5b8 	.word	0x3482b5b8

3480e6f8 <stdio_get_by_name>:

struct stdio_dev* stdio_get_by_name(const char *name)
{
3480e6f8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
3480e6fc:	e2507000 	subs	r7, r0, #0
		return NULL;

	list_for_each(pos, &(devs.list)) {
3480e700:	159f6040 	ldrne	r6, [pc, #64]	; 3480e748 <stdio_get_by_name+0x50>
3480e704:	15b65034 	ldrne	r5, [r6, #52]!	; 0x34
struct stdio_dev* stdio_get_by_name(const char *name)
{
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
3480e708:	0a00000b 	beq	3480e73c <stdio_get_by_name+0x44>
3480e70c:	ea000006 	b	3480e72c <stdio_get_by_name+0x34>
		return NULL;

	list_for_each(pos, &(devs.list)) {
		dev = list_entry(pos, struct stdio_dev, list);
3480e710:	e2454034 	sub	r4, r5, #52	; 0x34
		if(strcmp(dev->name, name) == 0)
3480e714:	e2840008 	add	r0, r4, #8
3480e718:	e1a01007 	mov	r1, r7
3480e71c:	eb003514 	bl	3481bb74 <strcmp>
3480e720:	e3500000 	cmp	r0, #0
3480e724:	0a000005 	beq	3480e740 <stdio_get_by_name+0x48>
	struct stdio_dev *dev;

	if(!name)
		return NULL;

	list_for_each(pos, &(devs.list)) {
3480e728:	e5955000 	ldr	r5, [r5]
3480e72c:	e1550006 	cmp	r5, r6
3480e730:	1afffff6 	bne	3480e710 <stdio_get_by_name+0x18>
		dev = list_entry(pos, struct stdio_dev, list);
		if(strcmp(dev->name, name) == 0)
			return dev;
	}

	return NULL;
3480e734:	e3a04000 	mov	r4, #0
3480e738:	ea000000 	b	3480e740 <stdio_get_by_name+0x48>
{
	struct list_head *pos;
	struct stdio_dev *dev;

	if(!name)
		return NULL;
3480e73c:	e1a04007 	mov	r4, r7
		if(strcmp(dev->name, name) == 0)
			return dev;
	}

	return NULL;
}
3480e740:	e1a00004 	mov	r0, r4
3480e744:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3480e748:	3482b584 	.word	0x3482b584

3480e74c <stdio_clone>:

struct stdio_dev* stdio_clone(struct stdio_dev *dev)
{
3480e74c:	e92d4038 	push	{r3, r4, r5, lr}
	struct stdio_dev *_dev;

	if(!dev)
3480e750:	e2505000 	subs	r5, r0, #0
		return NULL;
3480e754:	01a04005 	moveq	r4, r5

struct stdio_dev* stdio_clone(struct stdio_dev *dev)
{
	struct stdio_dev *_dev;

	if(!dev)
3480e758:	0a00000b 	beq	3480e78c <stdio_clone+0x40>
		return NULL;

	_dev = calloc(1, sizeof(struct stdio_dev));
3480e75c:	e3a00001 	mov	r0, #1
3480e760:	e3a0103c 	mov	r1, #60	; 0x3c
3480e764:	ebffedb2 	bl	34809e34 <calloc>

	if(!_dev)
3480e768:	e2504000 	subs	r4, r0, #0
3480e76c:	0a000006 	beq	3480e78c <stdio_clone+0x40>
		return NULL;

	memcpy(_dev, dev, sizeof(struct stdio_dev));
3480e770:	e1a01005 	mov	r1, r5
3480e774:	e3a0203c 	mov	r2, #60	; 0x3c
3480e778:	eb0035f5 	bl	3481bf54 <memcpy>
	strncpy(_dev->name, dev->name, 16);
3480e77c:	e2840008 	add	r0, r4, #8
3480e780:	e2851008 	add	r1, r5, #8
3480e784:	e3a02010 	mov	r2, #16
3480e788:	eb0034cf 	bl	3481bacc <strncpy>

	return _dev;
}
3480e78c:	e1a00004 	mov	r0, r4
3480e790:	e8bd8038 	pop	{r3, r4, r5, pc}

3480e794 <stdio_register>:

int stdio_register (struct stdio_dev * dev)
{
3480e794:	e92d4008 	push	{r3, lr}
	struct stdio_dev *_dev;

	_dev = stdio_clone(dev);
3480e798:	ebffffeb 	bl	3480e74c <stdio_clone>
	if(!_dev)
3480e79c:	e3500000 	cmp	r0, #0
3480e7a0:	0a000009 	beq	3480e7cc <stdio_register+0x38>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
3480e7a4:	e59f3028 	ldr	r3, [pc, #40]	; 3480e7d4 <stdio_register+0x40>
		return -1;
	list_add_tail(&(_dev->list), &(devs.list));
3480e7a8:	e2801034 	add	r1, r0, #52	; 0x34
3480e7ac:	e5932038 	ldr	r2, [r3, #56]	; 0x38
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
3480e7b0:	e5831038 	str	r1, [r3, #56]	; 0x38
	new->next = next;
3480e7b4:	e2833034 	add	r3, r3, #52	; 0x34
3480e7b8:	e5803034 	str	r3, [r0, #52]	; 0x34
	new->prev = prev;
3480e7bc:	e5802038 	str	r2, [r0, #56]	; 0x38
	prev->next = new;
3480e7c0:	e5821000 	str	r1, [r2]
	return 0;
3480e7c4:	e3a00000 	mov	r0, #0
3480e7c8:	e8bd8008 	pop	{r3, pc}
{
	struct stdio_dev *_dev;

	_dev = stdio_clone(dev);
	if(!_dev)
		return -1;
3480e7cc:	e3e00000 	mvn	r0, #0
	list_add_tail(&(_dev->list), &(devs.list));
	return 0;
}
3480e7d0:	e8bd8008 	pop	{r3, pc}
3480e7d4:	3482b584 	.word	0x3482b584

3480e7d8 <stdio_init>:
	return 0;
}
#endif	/* CONFIG_SYS_STDIO_DEREGISTER */

int stdio_init (void)
{
3480e7d8:	e92d4010 	push	{r4, lr}
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
3480e7dc:	e59f3078 	ldr	r3, [pc, #120]	; 3480e85c <stdio_init+0x84>
3480e7e0:	e24dd040 	sub	sp, sp, #64	; 0x40
3480e7e4:	e2832034 	add	r2, r3, #52	; 0x34
3480e7e8:	e5832034 	str	r2, [r3, #52]	; 0x34
	list->prev = list;
3480e7ec:	e5832038 	str	r2, [r3, #56]	; 0x38

static void drv_system_init (void)
{
	struct stdio_dev dev;

	memset (&dev, 0, sizeof (dev));
3480e7f0:	e28d4004 	add	r4, sp, #4

#ifdef CONFIG_ARM_DCC_MULTI
	drv_arm_dcc_init ();
#endif
#if defined(CONFIG_HARD_I2C) || defined(CONFIG_SOFT_I2C)
	i2c_init (CONFIG_SYS_I2C_SPEED, CONFIG_SYS_I2C_SLAVE);
3480e7f4:	e30c0350 	movw	r0, #50000	; 0xc350
3480e7f8:	e3a010fe 	mov	r1, #254	; 0xfe
3480e7fc:	eb000654 	bl	34810154 <i2c_init>

static void drv_system_init (void)
{
	struct stdio_dev dev;

	memset (&dev, 0, sizeof (dev));
3480e800:	e3a0203c 	mov	r2, #60	; 0x3c
3480e804:	e1a00004 	mov	r0, r4
3480e808:	e3a01000 	mov	r1, #0
3480e80c:	eb0035ac 	bl	3481bec4 <memset>

	strcpy (dev.name, "serial");
3480e810:	e59f1048 	ldr	r1, [pc, #72]	; 3480e860 <stdio_init+0x88>
3480e814:	e2840008 	add	r0, r4, #8
3480e818:	eb0034a4 	bl	3481bab0 <strcpy>
	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
3480e81c:	e3a0310e 	mov	r3, #-2147483645	; 0x80000003
3480e820:	e58d3004 	str	r3, [sp, #4]
	dev.putc = serial_putc;
3480e824:	e59f3038 	ldr	r3, [pc, #56]	; 3480e864 <stdio_init+0x8c>
	dev.puts = serial_puts;
	dev.getc = serial_getc;
	dev.tstc = serial_tstc;
	stdio_register (&dev);
3480e828:	e1a00004 	mov	r0, r4

	memset (&dev, 0, sizeof (dev));

	strcpy (dev.name, "serial");
	dev.flags = DEV_FLAGS_OUTPUT | DEV_FLAGS_INPUT | DEV_FLAGS_SYSTEM;
	dev.putc = serial_putc;
3480e82c:	e58d3024 	str	r3, [sp, #36]	; 0x24
	dev.puts = serial_puts;
3480e830:	e59f3030 	ldr	r3, [pc, #48]	; 3480e868 <stdio_init+0x90>
3480e834:	e58d3028 	str	r3, [sp, #40]	; 0x28
	dev.getc = serial_getc;
3480e838:	e59f302c 	ldr	r3, [pc, #44]	; 3480e86c <stdio_init+0x94>
3480e83c:	e58d3030 	str	r3, [sp, #48]	; 0x30
	dev.tstc = serial_tstc;
3480e840:	e59f3028 	ldr	r3, [pc, #40]	; 3480e870 <stdio_init+0x98>
3480e844:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	stdio_register (&dev);
3480e848:	ebffffd1 	bl	3480e794 <stdio_register>
#ifdef CONFIG_LOGBUFFER
	drv_logbuff_init ();
#endif
	drv_system_init ();
#ifdef CONFIG_SERIAL_MULTI
	serial_stdio_init ();
3480e84c:	ebffff2e 	bl	3480e50c <serial_stdio_init>
#ifdef CONFIG_JTAG_CONSOLE
	drv_jtag_console_init ();
#endif

	return (0);
}
3480e850:	e3a00000 	mov	r0, #0
3480e854:	e28dd040 	add	sp, sp, #64	; 0x40
3480e858:	e8bd8010 	pop	{r4, pc}
3480e85c:	3482b584 	.word	0x3482b584
3480e860:	3482605a 	.word	0x3482605a
3480e864:	3480e6b4 	.word	0x3480e6b4
3480e868:	3480e6d0 	.word	0x3480e6d0
3480e86c:	3480e68c 	.word	0x3480e68c
3480e870:	3480e6a0 	.word	0x3480e6a0

3480e874 <CYGACC_COMM_IF_GETC_TIMEOUT>:

#ifndef REDBOOT			/*SB */
typedef int cyg_int32;
int
CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
{
3480e874:	e92d4070 	push	{r4, r5, r6, lr}
3480e878:	e1a05001 	mov	r5, r1
#define DELAY 20
  unsigned long counter = 0;
3480e87c:	e3a04000 	mov	r4, #0
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
3480e880:	e59f603c 	ldr	r6, [pc, #60]	; 3480e8c4 <CYGACC_COMM_IF_GETC_TIMEOUT+0x50>
3480e884:	ea000002 	b	3480e894 <CYGACC_COMM_IF_GETC_TIMEOUT+0x20>
    {
      udelay (DELAY);
3480e888:	e3a00014 	mov	r0, #20
3480e88c:	eb00363b 	bl	3481c180 <udelay>
      counter++;
3480e890:	e2844001 	add	r4, r4, #1
int
CYGACC_COMM_IF_GETC_TIMEOUT (char chan, char *c)
{
#define DELAY 20
  unsigned long counter = 0;
  while (!tstc () && (counter < xyzModem_CHAR_TIMEOUT * 1000 / DELAY))
3480e894:	ebffea15 	bl	348090f0 <tstc>
3480e898:	e3500000 	cmp	r0, #0
3480e89c:	1a000001 	bne	3480e8a8 <CYGACC_COMM_IF_GETC_TIMEOUT+0x34>
3480e8a0:	e1540006 	cmp	r4, r6
3480e8a4:	1afffff7 	bne	3480e888 <CYGACC_COMM_IF_GETC_TIMEOUT+0x14>
    {
      udelay (DELAY);
      counter++;
    }
  if (tstc ())
3480e8a8:	ebffea10 	bl	348090f0 <tstc>
3480e8ac:	e3500000 	cmp	r0, #0
3480e8b0:	08bd8070 	popeq	{r4, r5, r6, pc}
    {
      *c = getc ();
3480e8b4:	ebffea04 	bl	348090cc <getc>
3480e8b8:	e5c50000 	strb	r0, [r5]
      return 1;
3480e8bc:	e3a00001 	mov	r0, #1
    }
  return 0;
}
3480e8c0:	e8bd8070 	pop	{r4, r5, r6, pc}
3480e8c4:	000186a0 	.word	0x000186a0

3480e8c8 <xyzModem_flush>:
#endif

/* Wait for the line to go idle */
static void
xyzModem_flush (void)
{
3480e8c8:	e92d4037 	push	{r0, r1, r2, r4, r5, lr}
  int res;
  char c;
  while (true)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480e8cc:	e59f501c 	ldr	r5, [pc, #28]	; 3480e8f0 <xyzModem_flush+0x28>
3480e8d0:	e28d4007 	add	r4, sp, #7
3480e8d4:	e5953000 	ldr	r3, [r5]
3480e8d8:	e1a01004 	mov	r1, r4
3480e8dc:	e5d30000 	ldrb	r0, [r3]
3480e8e0:	ebffffe3 	bl	3480e874 <CYGACC_COMM_IF_GETC_TIMEOUT>
      if (!res)
3480e8e4:	e3500000 	cmp	r0, #0
3480e8e8:	1afffff9 	bne	3480e8d4 <xyzModem_flush+0xc>
	return;
    }
}
3480e8ec:	e8bd803e 	pop	{r1, r2, r3, r4, r5, pc}
3480e8f0:	3482b5cc 	.word	0x3482b5cc

3480e8f4 <xyzModem_get_hdr>:

static int
xyzModem_get_hdr (void)
{
3480e8f4:	e92d44f3 	push	{r0, r1, r4, r5, r6, r7, sl, lr}
  ZM_DEBUG (zm_new ());
  /* Find the start of a header */
  can_total = 0;
  hdr_chars = 0;

  if (xyz.tx_ack)
3480e8f8:	e59f4250 	ldr	r4, [pc, #592]	; 3480eb50 <xyzModem_get_hdr+0x25c>
3480e8fc:	e5943430 	ldr	r3, [r4, #1072]	; 0x430
3480e900:	e3530000 	cmp	r3, #0
3480e904:	0a000003 	beq	3480e918 <xyzModem_get_hdr+0x24>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480e908:	e3a00006 	mov	r0, #6
3480e90c:	ebffea00 	bl	34809114 <putc>
  hdr_chars = 0;

  if (xyz.tx_ack)
    {
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
3480e910:	e3a03000 	mov	r3, #0
3480e914:	e5843430 	str	r3, [r4, #1072]	; 0x430
    }
}

static int
xyzModem_get_hdr (void)
{
3480e918:	e3a05000 	mov	r5, #0
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480e91c:	e59f622c 	ldr	r6, [pc, #556]	; 3480eb50 <xyzModem_get_hdr+0x25c>
    }
}

static int
xyzModem_get_hdr (void)
{
3480e920:	e1a07005 	mov	r7, r5
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480e924:	e28da007 	add	sl, sp, #7
3480e928:	e5963000 	ldr	r3, [r6]
3480e92c:	e1a0100a 	mov	r1, sl
3480e930:	e5d30000 	ldrb	r0, [r3]
3480e934:	ebffffce 	bl	3480e874 <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (c));
      if (res)
3480e938:	e3500000 	cmp	r0, #0
      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
      xyz.tx_ack = false;
    }
  while (!hdr_found)
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480e93c:	e59f420c 	ldr	r4, [pc, #524]	; 3480eb50 <xyzModem_get_hdr+0x25c>
      ZM_DEBUG (zm_save (c));
      if (res)
3480e940:	0a000021 	beq	3480e9cc <xyzModem_get_hdr+0xd8>
	{
	  hdr_chars++;
	  switch (c)
3480e944:	e5dd3007 	ldrb	r3, [sp, #7]
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
      ZM_DEBUG (zm_save (c));
      if (res)
	{
	  hdr_chars++;
3480e948:	e2855001 	add	r5, r5, #1
	  switch (c)
3480e94c:	e3530002 	cmp	r3, #2
3480e950:	0a00000c 	beq	3480e988 <xyzModem_get_hdr+0x94>
3480e954:	8a000002 	bhi	3480e964 <xyzModem_get_hdr+0x70>
3480e958:	e3530001 	cmp	r3, #1
3480e95c:	1afffff1 	bne	3480e928 <xyzModem_get_hdr+0x34>
3480e960:	ea000004 	b	3480e978 <xyzModem_get_hdr+0x84>
3480e964:	e3530004 	cmp	r3, #4
3480e968:	0a000011 	beq	3480e9b4 <xyzModem_get_hdr+0xc0>
3480e96c:	e3530018 	cmp	r3, #24
3480e970:	1affffec 	bne	3480e928 <xyzModem_get_hdr+0x34>
3480e974:	ea000007 	b	3480e998 <xyzModem_get_hdr+0xa4>
	    {
	    case SOH:
	      xyz.total_SOH++;
3480e978:	e594341c 	ldr	r3, [r4, #1052]	; 0x41c
3480e97c:	e2833001 	add	r3, r3, #1
3480e980:	e584341c 	str	r3, [r4, #1052]	; 0x41c
3480e984:	ea000069 	b	3480eb30 <xyzModem_get_hdr+0x23c>
	    case STX:
	      if (c == STX)
		xyz.total_STX++;
3480e988:	e5943420 	ldr	r3, [r4, #1056]	; 0x420
3480e98c:	e2833001 	add	r3, r3, #1
3480e990:	e5843420 	str	r3, [r4, #1056]	; 0x420
3480e994:	ea000065 	b	3480eb30 <xyzModem_get_hdr+0x23c>
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
3480e998:	e5963424 	ldr	r3, [r6, #1060]	; 0x424
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
3480e99c:	e2877001 	add	r7, r7, #1
	      if (c == STX)
		xyz.total_STX++;
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
3480e9a0:	e2833001 	add	r3, r3, #1
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
3480e9a4:	e3570003 	cmp	r7, #3
	      if (c == STX)
		xyz.total_STX++;
	      hdr_found = true;
	      break;
	    case CAN:
	      xyz.total_CAN++;
3480e9a8:	e5863424 	str	r3, [r6, #1060]	; 0x424
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
3480e9ac:	1affffdd 	bne	3480e928 <xyzModem_get_hdr+0x34>
3480e9b0:	ea00005a 	b	3480eb20 <xyzModem_get_hdr+0x22c>
		  /* Wait for multiple CAN to avoid early quits */
		  break;
		}
	    case EOT:
	      /* EOT only supported if no noise */
	      if (hdr_chars == 1)
3480e9b4:	e3550001 	cmp	r5, #1
3480e9b8:	1affffda 	bne	3480e928 <xyzModem_get_hdr+0x34>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480e9bc:	e3a00006 	mov	r0, #6
3480e9c0:	ebffe9d3 	bl	34809114 <putc>
	      if (hdr_chars == 1)
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		  ZM_DEBUG (zm_dprintf ("ACK on EOT #%d\n", __LINE__));
		  ZM_DEBUG (zm_dump (__LINE__));
		  return xyzModem_eof;
3480e9c4:	e3e00003 	mvn	r0, #3
3480e9c8:	ea000057 	b	3480eb2c <xyzModem_get_hdr+0x238>
	    }
	}
      else
	{
	  /* Data stream timed out */
	  xyzModem_flush ();	/* Toss any current input */
3480e9cc:	ebffffbd 	bl	3480e8c8 <xyzModem_flush>
	  ZM_DEBUG (zm_dump (__LINE__));
	  CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
3480e9d0:	e59f017c 	ldr	r0, [pc, #380]	; 3480eb54 <xyzModem_get_hdr+0x260>
3480e9d4:	eb0035e9 	bl	3481c180 <udelay>
3480e9d8:	ea000052 	b	3480eb28 <xyzModem_get_hdr+0x234>
  if (!res)
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.cblk);
3480e9dc:	e5943000 	ldr	r3, [r4]
3480e9e0:	e59f1170 	ldr	r1, [pc, #368]	; 3480eb58 <xyzModem_get_hdr+0x264>
3480e9e4:	e5d30000 	ldrb	r0, [r3]
3480e9e8:	ebffffa1 	bl	3480e874 <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.cblk));
  if (!res)
3480e9ec:	e3500000 	cmp	r0, #0
3480e9f0:	0a00004c 	beq	3480eb28 <xyzModem_get_hdr+0x234>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
3480e9f4:	e28d7008 	add	r7, sp, #8
3480e9f8:	e5773001 	ldrb	r3, [r7, #-1]!
  xyz.bufp = xyz.pkt;
  for (i = 0; i < xyz.len; i++)
3480e9fc:	e3a05000 	mov	r5, #0
  if (!res)
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
3480ea00:	e3530001 	cmp	r3, #1
3480ea04:	13a03b01 	movne	r3, #1024	; 0x400
3480ea08:	03a03080 	moveq	r3, #128	; 0x80
3480ea0c:	e5843410 	str	r3, [r4, #1040]	; 0x410
  xyz.bufp = xyz.pkt;
3480ea10:	e2843004 	add	r3, r4, #4
3480ea14:	e5843404 	str	r3, [r4, #1028]	; 0x404
  for (i = 0; i < xyz.len; i++)
3480ea18:	ea000009 	b	3480ea44 <xyzModem_get_hdr+0x150>
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
3480ea1c:	e5943000 	ldr	r3, [r4]
3480ea20:	e1a01007 	mov	r1, r7
3480ea24:	e5d30000 	ldrb	r0, [r3]
3480ea28:	ebffff91 	bl	3480e874 <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (c));
      if (res)
3480ea2c:	e3500000 	cmp	r0, #0
3480ea30:	0a00003c 	beq	3480eb28 <xyzModem_get_hdr+0x234>
	{
	  xyz.pkt[i] = c;
3480ea34:	e5dd2007 	ldrb	r2, [sp, #7]
	return;
    }
}

static int
xyzModem_get_hdr (void)
3480ea38:	e0843005 	add	r3, r4, r5
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, &c);
      ZM_DEBUG (zm_save (c));
      if (res)
	{
	  xyz.pkt[i] = c;
3480ea3c:	e5c32004 	strb	r2, [r3, #4]
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  xyz.len = (c == SOH) ? 128 : 1024;
  xyz.bufp = xyz.pkt;
  for (i = 0; i < xyz.len; i++)
3480ea40:	e2855001 	add	r5, r5, #1
3480ea44:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480ea48:	e59f6100 	ldr	r6, [pc, #256]	; 3480eb50 <xyzModem_get_hdr+0x25c>
3480ea4c:	e1550003 	cmp	r5, r3
3480ea50:	bafffff1 	blt	3480ea1c <xyzModem_get_hdr+0x128>
	{
	  ZM_DEBUG (zm_dump (__LINE__));
	  return xyzModem_timeout;
	}
    }
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc1);
3480ea54:	e5963000 	ldr	r3, [r6]
3480ea58:	e59f10fc 	ldr	r1, [pc, #252]	; 3480eb5c <xyzModem_get_hdr+0x268>
3480ea5c:	e5d30000 	ldrb	r0, [r3]
3480ea60:	ebffff83 	bl	3480e874 <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.crc1));
  if (!res)
3480ea64:	e3500000 	cmp	r0, #0
3480ea68:	0a00002e 	beq	3480eb28 <xyzModem_get_hdr+0x234>
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
    }
  if (xyz.crc_mode)
3480ea6c:	e5963428 	ldr	r3, [r6, #1064]	; 0x428
3480ea70:	e3530000 	cmp	r3, #0
3480ea74:	0a000005 	beq	3480ea90 <xyzModem_get_hdr+0x19c>
    {
      res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.crc2);
3480ea78:	e5963000 	ldr	r3, [r6]
3480ea7c:	e59f10dc 	ldr	r1, [pc, #220]	; 3480eb60 <xyzModem_get_hdr+0x26c>
3480ea80:	e5d30000 	ldrb	r0, [r3]
3480ea84:	ebffff7a 	bl	3480e874 <CYGACC_COMM_IF_GETC_TIMEOUT>
      ZM_DEBUG (zm_save (xyz.crc2));
      if (!res)
3480ea88:	e3500000 	cmp	r0, #0
3480ea8c:	0a000025 	beq	3480eb28 <xyzModem_get_hdr+0x234>
	  return xyzModem_timeout;
	}
    }
  ZM_DEBUG (zm_dump (__LINE__));
  /* Validate the message */
  if ((xyz.blk ^ xyz.cblk) != (unsigned char) 0xFF)
3480ea90:	e59f40b8 	ldr	r4, [pc, #184]	; 3480eb50 <xyzModem_get_hdr+0x25c>
3480ea94:	e5d42409 	ldrb	r2, [r4, #1033]	; 0x409
3480ea98:	e5d43408 	ldrb	r3, [r4, #1032]	; 0x408
3480ea9c:	e0223003 	eor	r3, r2, r3
3480eaa0:	e35300ff 	cmp	r3, #255	; 0xff
3480eaa4:	0a000002 	beq	3480eab4 <xyzModem_get_hdr+0x1c0>
    {
      ZM_DEBUG (zm_dprintf
		("Framing error - blk: %x/%x/%x\n", xyz.blk, xyz.cblk,
		 (xyz.blk ^ xyz.cblk)));
      ZM_DEBUG (zm_dump_buf (xyz.pkt, xyz.len));
      xyzModem_flush ();
3480eaa8:	ebffff86 	bl	3480e8c8 <xyzModem_flush>
      return xyzModem_frame;
3480eaac:	e3e00005 	mvn	r0, #5
3480eab0:	ea00001d 	b	3480eb2c <xyzModem_get_hdr+0x238>
    }
  /* Verify checksum/CRC */
  if (xyz.crc_mode)
3480eab4:	e5943428 	ldr	r3, [r4, #1064]	; 0x428
3480eab8:	e3530000 	cmp	r3, #0
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
3480eabc:	05941410 	ldreq	r1, [r4, #1040]	; 0x410
3480eac0:	01a02003 	moveq	r2, r3
      ZM_DEBUG (zm_dump_buf (xyz.pkt, xyz.len));
      xyzModem_flush ();
      return xyzModem_frame;
    }
  /* Verify checksum/CRC */
  if (xyz.crc_mode)
3480eac4:	0a00000c 	beq	3480eafc <xyzModem_get_hdr+0x208>
    {
      cksum = cyg_crc16 (xyz.pkt, xyz.len);
3480eac8:	e2840004 	add	r0, r4, #4
3480eacc:	e5941410 	ldr	r1, [r4, #1040]	; 0x410
3480ead0:	eb002d52 	bl	3481a020 <cyg_crc16>
      if (cksum != ((xyz.crc1 << 8) | xyz.crc2))
3480ead4:	e5d4240a 	ldrb	r2, [r4, #1034]	; 0x40a
3480ead8:	e5d4340b 	ldrb	r3, [r4, #1035]	; 0x40b
3480eadc:	e1833402 	orr	r3, r3, r2, lsl #8
		     cksum & 0xFF));
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
3480eae0:	e1500003 	cmp	r0, r3
3480eae4:	ea00000a 	b	3480eb14 <xyzModem_get_hdr+0x220>
	return;
    }
}

static int
xyzModem_get_hdr (void)
3480eae8:	e0840002 	add	r0, r4, r2
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
	{
	  cksum += xyz.pkt[i];
3480eaec:	e5d00004 	ldrb	r0, [r0, #4]
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
3480eaf0:	e2822001 	add	r2, r2, #1
	{
	  cksum += xyz.pkt[i];
3480eaf4:	e0833000 	add	r3, r3, r0
3480eaf8:	e6ff3073 	uxth	r3, r3
	}
    }
  else
    {
      cksum = 0;
      for (i = 0; i < xyz.len; i++)
3480eafc:	e1520001 	cmp	r2, r1
3480eb00:	bafffff8 	blt	3480eae8 <xyzModem_get_hdr+0x1f4>
	{
	  cksum += xyz.pkt[i];
	}
      if (xyz.crc1 != (cksum & 0xFF))
3480eb04:	e59f2044 	ldr	r2, [pc, #68]	; 3480eb50 <xyzModem_get_hdr+0x25c>
3480eb08:	e20330ff 	and	r3, r3, #255	; 0xff
3480eb0c:	e5d2240a 	ldrb	r2, [r2, #1034]	; 0x40a
		     cksum & 0xFF));
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
3480eb10:	e1520003 	cmp	r2, r3
3480eb14:	13e00006 	mvnne	r0, #6
3480eb18:	03a00000 	moveq	r0, #0
3480eb1c:	ea000002 	b	3480eb2c <xyzModem_get_hdr+0x238>
	    case CAN:
	      xyz.total_CAN++;
	      ZM_DEBUG (zm_dump (__LINE__));
	      if (++can_total == xyzModem_CAN_COUNT)
		{
		  return xyzModem_cancel;
3480eb20:	e3e00004 	mvn	r0, #4
3480eb24:	ea000000 	b	3480eb2c <xyzModem_get_hdr+0x238>
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.blk);
  ZM_DEBUG (zm_save (xyz.blk));
  if (!res)
    {
      ZM_DEBUG (zm_dump (__LINE__));
      return xyzModem_timeout;
3480eb28:	e3e00002 	mvn	r0, #2
	  return xyzModem_cksum;
	}
    }
  /* If we get here, the message passes [structural] muster */
  return 0;
}
3480eb2c:	e8bd84fc 	pop	{r2, r3, r4, r5, r6, r7, sl, pc}
	  return xyzModem_timeout;
	}
    }

  /* Header found, now read the data */
  res = CYGACC_COMM_IF_GETC_TIMEOUT (*xyz.__chan, (char *) &xyz.blk);
3480eb30:	e59f4018 	ldr	r4, [pc, #24]	; 3480eb50 <xyzModem_get_hdr+0x25c>
3480eb34:	e59f1028 	ldr	r1, [pc, #40]	; 3480eb64 <xyzModem_get_hdr+0x270>
3480eb38:	e5943000 	ldr	r3, [r4]
3480eb3c:	e5d30000 	ldrb	r0, [r3]
3480eb40:	ebffff4b 	bl	3480e874 <CYGACC_COMM_IF_GETC_TIMEOUT>
  ZM_DEBUG (zm_save (xyz.blk));
  if (!res)
3480eb44:	e3500000 	cmp	r0, #0
3480eb48:	0afffff6 	beq	3480eb28 <xyzModem_get_hdr+0x234>
3480eb4c:	eaffffa2 	b	3480e9dc <xyzModem_get_hdr+0xe8>
3480eb50:	3482b5cc 	.word	0x3482b5cc
3480eb54:	0003d090 	.word	0x0003d090
3480eb58:	3482b9d5 	.word	0x3482b9d5
3480eb5c:	3482b9d6 	.word	0x3482b9d6
3480eb60:	3482b9d7 	.word	0x3482b9d7
3480eb64:	3482b9d4 	.word	0x3482b9d4

3480eb68 <CYGACC_COMM_IF_PUTC>:
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480eb68:	e1a00001 	mov	r0, r1
3480eb6c:	eaffe968 	b	34809114 <putc>

3480eb70 <parse_num>:
}

/* Parse (scan) a number */
bool
parse_num (char *s, unsigned long *val, char **es, char *delim)
{
3480eb70:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
  int radix = 10;
  char c;
  unsigned long result = 0;
  int digit;

  while (*s == ' ')
3480eb74:	e5d04000 	ldrb	r4, [r0]
3480eb78:	e1a0c000 	mov	ip, r0
3480eb7c:	e3540020 	cmp	r4, #32
3480eb80:	e2800001 	add	r0, r0, #1
3480eb84:	0afffffa 	beq	3480eb74 <parse_num+0x4>
3480eb88:	e3a05000 	mov	r5, #0
3480eb8c:	e3a0600a 	mov	r6, #10
3480eb90:	e3a00001 	mov	r0, #1
3480eb94:	ea000037 	b	3480ec78 <parse_num+0x108>
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
3480eb98:	e3500000 	cmp	r0, #0
3480eb9c:	0a00000a 	beq	3480ebcc <parse_num+0x5c>
3480eba0:	e3540030 	cmp	r4, #48	; 0x30
3480eba4:	1a000008 	bne	3480ebcc <parse_num+0x5c>
3480eba8:	e5dc0001 	ldrb	r0, [ip, #1]

/* Convert a character to lower case */
__inline__ static char
_tolower (char c)
{
  if ((c >= 'A') && (c <= 'Z'))
3480ebac:	e2404041 	sub	r4, r0, #65	; 0x41
3480ebb0:	e6ef4074 	uxtb	r4, r4
3480ebb4:	e3540019 	cmp	r4, #25
    {
      c = (c - 'A') + 'a';
3480ebb8:	92800020 	addls	r0, r0, #32
3480ebbc:	96ef0070 	uxtbls	r0, r0

  while (*s == ' ')
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
3480ebc0:	e3500078 	cmp	r0, #120	; 0x78
	{
	  radix = 16;
	  s += 2;
3480ebc4:	028cc002 	addeq	ip, ip, #2
    s++;
  while (*s)
    {
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
	{
	  radix = 16;
3480ebc8:	03a06010 	moveq	r6, #16
	  s += 2;
	}
      first = false;
      c = *s++;
3480ebcc:	e4dc4001 	ldrb	r4, [ip], #1

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480ebd0:	e2447030 	sub	r7, r4, #48	; 0x30
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480ebd4:	e2440041 	sub	r0, r4, #65	; 0x41

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480ebd8:	e6efa077 	uxtb	sl, r7
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480ebdc:	e6ef0070 	uxtb	r0, r0

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480ebe0:	e35a0009 	cmp	sl, #9
3480ebe4:	83a0a000 	movhi	sl, #0
3480ebe8:	93a0a001 	movls	sl, #1
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480ebec:	e3500005 	cmp	r0, #5
3480ebf0:	83a00000 	movhi	r0, #0
3480ebf4:	93a00001 	movls	r0, #1

/* Validate a hex character */
__inline__ static bool
_is_hex (char c)
{
  return (((c >= '0') && (c <= '9')) ||
3480ebf8:	e190900a 	orrs	r9, r0, sl
3480ebfc:	1a000004 	bne	3480ec14 <parse_num+0xa4>
	  ((c >= 'A') && (c <= 'F')) || ((c >= 'a') && (c <= 'f')));
3480ec00:	e2447061 	sub	r7, r4, #97	; 0x61
3480ec04:	e6ef7077 	uxtb	r7, r7
3480ec08:	e3570005 	cmp	r7, #5
3480ec0c:	9a000003 	bls	3480ec20 <parse_num+0xb0>
3480ec10:	ea00000f 	b	3480ec54 <parse_num+0xe4>
__inline__ static int
_from_hex (char c)
{
  int ret = 0;

  if ((c >= '0') && (c <= '9'))
3480ec14:	e35a0000 	cmp	sl, #0
    {
      ret = (c - '0');
3480ec18:	11a00007 	movne	r0, r7
__inline__ static int
_from_hex (char c)
{
  int ret = 0;

  if ((c >= '0') && (c <= '9'))
3480ec1c:	1a000009 	bne	3480ec48 <parse_num+0xd8>
    {
      ret = (c - '0');
    }
  else if ((c >= 'a') && (c <= 'f'))
3480ec20:	e2447061 	sub	r7, r4, #97	; 0x61
3480ec24:	e6ef7077 	uxtb	r7, r7
3480ec28:	e3570005 	cmp	r7, #5
    {
      ret = (c - 'a' + 0x0a);
3480ec2c:	92440057 	subls	r0, r4, #87	; 0x57

  if ((c >= '0') && (c <= '9'))
    {
      ret = (c - '0');
    }
  else if ((c >= 'a') && (c <= 'f'))
3480ec30:	9a000002 	bls	3480ec40 <parse_num+0xd0>
    {
      ret = (c - 'a' + 0x0a);
    }
  else if ((c >= 'A') && (c <= 'F'))
3480ec34:	e3500000 	cmp	r0, #0
3480ec38:	0a000002 	beq	3480ec48 <parse_num+0xd8>
    {
      ret = (c - 'A' + 0x0A);
3480ec3c:	e2440037 	sub	r0, r4, #55	; 0x37
	  radix = 16;
	  s += 2;
	}
      first = false;
      c = *s++;
      if (_is_hex (c) && ((digit = _from_hex (c)) < radix))
3480ec40:	e1500006 	cmp	r0, r6
3480ec44:	aa000002 	bge	3480ec54 <parse_num+0xe4>
	    result = result << 4;
	  else
	    result = 10 * result;
	  result += digit;
#else
	  result = (result * radix) + digit;
3480ec48:	e0250695 	mla	r5, r5, r6, r0
      if (first && (s[0] == '0') && (_tolower (s[1]) == 'x'))
	{
	  radix = 16;
	  s += 2;
	}
      first = false;
3480ec4c:	e3a00000 	mov	r0, #0
	    result = result << 4;
	  else
	    result = 10 * result;
	  result += digit;
#else
	  result = (result * radix) + digit;
3480ec50:	ea000008 	b	3480ec78 <parse_num+0x108>
#endif
	}
      else
	{
	  if (delim != (char *) 0)
3480ec54:	e3530000 	cmp	r3, #0
	      while (*dp && (c != *dp))
		dp++;
	      if (*dp)
		break;		/* Found a good delimiter */
	    }
	  return false;		/* Malformatted number */
3480ec58:	01a00003 	moveq	r0, r3
	  result = (result * radix) + digit;
#endif
	}
      else
	{
	  if (delim != (char *) 0)
3480ec5c:	08bd86f0 	popeq	{r4, r5, r6, r7, r9, sl, pc}
	    {
	      /* See if this character is one of the delimiters */
	      char *dp = delim;
	      while (*dp && (c != *dp))
3480ec60:	e4d30001 	ldrb	r0, [r3], #1
3480ec64:	e3500000 	cmp	r0, #0
3480ec68:	08bd86f0 	popeq	{r4, r5, r6, r7, r9, sl, pc}
3480ec6c:	e1540000 	cmp	r4, r0
3480ec70:	1afffffa 	bne	3480ec60 <parse_num+0xf0>
3480ec74:	ea000002 	b	3480ec84 <parse_num+0x114>
  unsigned long result = 0;
  int digit;

  while (*s == ' ')
    s++;
  while (*s)
3480ec78:	e5dc4000 	ldrb	r4, [ip]
3480ec7c:	e3540000 	cmp	r4, #0
3480ec80:	1affffc4 	bne	3480eb98 <parse_num+0x28>
	    }
	  return false;		/* Malformatted number */
	}
    }
  *val = result;
  if (es != (char **) 0)
3480ec84:	e3520000 	cmp	r2, #0
		break;		/* Found a good delimiter */
	    }
	  return false;		/* Malformatted number */
	}
    }
  *val = result;
3480ec88:	e5815000 	str	r5, [r1]
  if (es != (char **) 0)
    {
      *es = s;
    }
  return true;
3480ec8c:	13a00001 	movne	r0, #1
	}
    }
  *val = result;
  if (es != (char **) 0)
    {
      *es = s;
3480ec90:	1582c000 	strne	ip, [r2]
    }
  return true;
3480ec94:	03a00001 	moveq	r0, #1
}
3480ec98:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

3480ec9c <xyzModem_stream_open>:
  return 0;
}

int
xyzModem_stream_open (connection_info_t * info, int *err)
{
3480ec9c:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
  CYGACC_COMM_IF_CONTROL (*xyz.__chan, __COMMCTL_SET_TIMEOUT,
			  xyzModem_CHAR_TIMEOUT);
#else
/* TODO: CHECK ! */
  int dummy = 0;
  xyz.__chan = &dummy;
3480eca0:	e59f412c 	ldr	r4, [pc, #300]	; 3480edd4 <xyzModem_stream_open+0x138>
  CYGACC_CALL_IF_SET_CONSOLE_COMM (console_chan);
  CYGACC_COMM_IF_CONTROL (*xyz.__chan, __COMMCTL_SET_TIMEOUT,
			  xyzModem_CHAR_TIMEOUT);
#else
/* TODO: CHECK ! */
  int dummy = 0;
3480eca4:	e3a05000 	mov	r5, #0
3480eca8:	e28d3008 	add	r3, sp, #8
3480ecac:	e5235004 	str	r5, [r3, #-4]!
  xyz.__chan = &dummy;
3480ecb0:	e5843000 	str	r3, [r4]
#endif
  xyz.len = 0;
  xyz.crc_mode = true;
3480ecb4:	e3a03001 	mov	r3, #1
3480ecb8:	e5843428 	str	r3, [r4, #1064]	; 0x428
  xyz.at_eof = false;
  xyz.tx_ack = false;
  xyz.mode = info->mode;
3480ecbc:	e5903004 	ldr	r3, [r0, #4]
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480ecc0:	e3a00043 	mov	r0, #67	; 0x43
#endif
  xyz.len = 0;
  xyz.crc_mode = true;
  xyz.at_eof = false;
  xyz.tx_ack = false;
  xyz.mode = info->mode;
3480ecc4:	e5843414 	str	r3, [r4, #1044]	; 0x414
  return 0;
}

int
xyzModem_stream_open (connection_info_t * info, int *err)
{
3480ecc8:	e1a0a001 	mov	sl, r1
#else
/* TODO: CHECK ! */
  int dummy = 0;
  xyz.__chan = &dummy;
#endif
  xyz.len = 0;
3480eccc:	e5845410 	str	r5, [r4, #1040]	; 0x410
  xyz.crc_mode = true;
  xyz.at_eof = false;
3480ecd0:	e584542c 	str	r5, [r4, #1068]	; 0x42c
  xyz.tx_ack = false;
3480ecd4:	e5845430 	str	r5, [r4, #1072]	; 0x430
  xyz.mode = info->mode;
  xyz.total_retries = 0;
3480ecd8:	e5845418 	str	r5, [r4, #1048]	; 0x418
  xyz.total_SOH = 0;
3480ecdc:	e584541c 	str	r5, [r4, #1052]	; 0x41c
  xyz.total_STX = 0;
3480ece0:	e5845420 	str	r5, [r4, #1056]	; 0x420
  xyz.total_CAN = 0;
3480ece4:	e5845424 	str	r5, [r4, #1060]	; 0x424
#ifdef USE_YMODEM_LENGTH
  xyz.read_length = 0;
3480ece8:	e5845438 	str	r5, [r4, #1080]	; 0x438
  xyz.file_length = 0;
3480ecec:	e5845434 	str	r5, [r4, #1076]	; 0x434
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480ecf0:	ebffe907 	bl	34809114 <putc>
  xyz.file_length = 0;
#endif

  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
3480ecf4:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
3480ecf8:	e3530001 	cmp	r3, #1
3480ecfc:	13a0700a 	movne	r7, #10
3480ed00:	13a06014 	movne	r6, #20
	  return 0;
	}
      else if (stat == xyzModem_timeout)
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
3480ed04:	11a09005 	movne	r9, r5
  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
    {
      /* X-modem doesn't have an information header - exit here */
      xyz.next_blk = 1;
3480ed08:	05c4340c 	strbeq	r3, [r4, #1036]	; 0x40c
      return 0;
3480ed0c:	01a00005 	moveq	r0, r5
  xyz.file_length = 0;
#endif

  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));

  if (xyz.mode == xyzModem_xmodem)
3480ed10:	1a00002a 	bne	3480edc0 <xyzModem_stream_open+0x124>
3480ed14:	ea00002d 	b	3480edd0 <xyzModem_stream_open+0x134>
      return 0;
    }

  while (retries-- > 0)
    {
      stat = xyzModem_get_hdr ();
3480ed18:	ebfffef5 	bl	3480e8f4 <xyzModem_get_hdr>
      if (stat == 0)
3480ed1c:	e2505000 	subs	r5, r0, #0
3480ed20:	1a000014 	bne	3480ed78 <xyzModem_stream_open+0xdc>
	{
	  /* Y-modem file information header */
	  if (xyz.blk == 0)
3480ed24:	e59f30a8 	ldr	r3, [pc, #168]	; 3480edd4 <xyzModem_stream_open+0x138>
3480ed28:	e5d32408 	ldrb	r2, [r3, #1032]	; 0x408
3480ed2c:	e3520000 	cmp	r2, #0
3480ed30:	1a00000a 	bne	3480ed60 <xyzModem_stream_open+0xc4>
	    {
#ifdef USE_YMODEM_LENGTH
	      /* skip filename */
	      while (*xyz.bufp++);
3480ed34:	e5930404 	ldr	r0, [r3, #1028]	; 0x404
3480ed38:	e4d02001 	ldrb	r2, [r0], #1
3480ed3c:	e3520000 	cmp	r2, #0
3480ed40:	e5830404 	str	r0, [r3, #1028]	; 0x404
3480ed44:	1afffffa 	bne	3480ed34 <xyzModem_stream_open+0x98>
	      /* get the length */
	      parse_num ((char *) xyz.bufp, &xyz.file_length, NULL, " ");
3480ed48:	e59f3088 	ldr	r3, [pc, #136]	; 3480edd8 <xyzModem_stream_open+0x13c>
3480ed4c:	e59f1088 	ldr	r1, [pc, #136]	; 3480eddc <xyzModem_stream_open+0x140>
3480ed50:	ebffff86 	bl	3480eb70 <parse_num>
#endif
	      /* The rest of the file name data block quietly discarded */
	      xyz.tx_ack = true;
3480ed54:	e59f3078 	ldr	r3, [pc, #120]	; 3480edd4 <xyzModem_stream_open+0x138>
3480ed58:	e3a02001 	mov	r2, #1
3480ed5c:	e5832430 	str	r2, [r3, #1072]	; 0x430
	    }
	  xyz.next_blk = 1;
3480ed60:	e59f306c 	ldr	r3, [pc, #108]	; 3480edd4 <xyzModem_stream_open+0x138>
3480ed64:	e3a02001 	mov	r2, #1
	  xyz.len = 0;
3480ed68:	e3a00000 	mov	r0, #0
	      parse_num ((char *) xyz.bufp, &xyz.file_length, NULL, " ");
#endif
	      /* The rest of the file name data block quietly discarded */
	      xyz.tx_ack = true;
	    }
	  xyz.next_blk = 1;
3480ed6c:	e5c3240c 	strb	r2, [r3, #1036]	; 0x40c
	  xyz.len = 0;
3480ed70:	e5830410 	str	r0, [r3, #1040]	; 0x410
	  return 0;
3480ed74:	ea000015 	b	3480edd0 <xyzModem_stream_open+0x134>
	}
      else if (stat == xyzModem_timeout)
3480ed78:	e3750003 	cmn	r5, #3
3480ed7c:	1a00000d 	bne	3480edb8 <xyzModem_stream_open+0x11c>
	{
	  if (--crc_retries <= 0)
3480ed80:	e2477001 	sub	r7, r7, #1
3480ed84:	e3570000 	cmp	r7, #0
	    xyz.crc_mode = false;
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
3480ed88:	e59f0050 	ldr	r0, [pc, #80]	; 3480ede0 <xyzModem_stream_open+0x144>
	  return 0;
	}
      else if (stat == xyzModem_timeout)
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
3480ed8c:	d5849428 	strle	r9, [r4, #1064]	; 0x428
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
3480ed90:	eb0034fa 	bl	3481c180 <udelay>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
3480ed94:	e5940428 	ldr	r0, [r4, #1064]	; 0x428
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480ed98:	e3500000 	cmp	r0, #0
3480ed9c:	03a00015 	moveq	r0, #21
3480eda0:	13a00043 	movne	r0, #67	; 0x43
3480eda4:	ebffe8da 	bl	34809114 <putc>
	{
	  if (--crc_retries <= 0)
	    xyz.crc_mode = false;
	  CYGACC_CALL_IF_DELAY_US (5 * 100000);	/* Extra delay for startup */
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	  xyz.total_retries++;
3480eda8:	e5943418 	ldr	r3, [r4, #1048]	; 0x418
3480edac:	e2833001 	add	r3, r3, #1
3480edb0:	e5843418 	str	r3, [r4, #1048]	; 0x418
3480edb4:	ea000001 	b	3480edc0 <xyzModem_stream_open+0x124>
	  ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	}
      if (stat == xyzModem_cancel)
3480edb8:	e3750005 	cmn	r5, #5
3480edbc:	0a000001 	beq	3480edc8 <xyzModem_stream_open+0x12c>
      /* X-modem doesn't have an information header - exit here */
      xyz.next_blk = 1;
      return 0;
    }

  while (retries-- > 0)
3480edc0:	e2566001 	subs	r6, r6, #1
3480edc4:	2affffd3 	bcs	3480ed18 <xyzModem_stream_open+0x7c>
      if (stat == xyzModem_cancel)
	{
	  break;
	}
    }
  *err = stat;
3480edc8:	e58a5000 	str	r5, [sl]
  ZM_DEBUG (zm_flush ());
  return -1;
3480edcc:	e3e00000 	mvn	r0, #0
}
3480edd0:	e8bd86fe 	pop	{r1, r2, r3, r4, r5, r6, r7, r9, sl, pc}
3480edd4:	3482b5cc 	.word	0x3482b5cc
3480edd8:	34826429 	.word	0x34826429
3480eddc:	3482ba00 	.word	0x3482ba00
3480ede0:	0007a120 	.word	0x0007a120

3480ede4 <xyzModem_stream_read>:

int
xyzModem_stream_read (char *buf, int size, int *err)
{
3480ede4:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
3480ede8:	e59f4240 	ldr	r4, [pc, #576]	; 3480f030 <xyzModem_stream_read+0x24c>
  return -1;
}

int
xyzModem_stream_read (char *buf, int size, int *err)
{
3480edec:	e1a09000 	mov	r9, r0
3480edf0:	e1a0a001 	mov	sl, r1
3480edf4:	e58d2004 	str	r2, [sp, #4]
  int stat, total, len;
  int retries;

  total = 0;
3480edf8:	e3a0b000 	mov	fp, #0
  stat = xyzModem_cancel;
3480edfc:	e3e05004 	mvn	r5, #4
		      ZM_DEBUG (zm_dprintf ("FINAL ACK (%d)\n", __LINE__));
		    }
		  xyz.at_eof = true;
		  break;
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
3480ee00:	e1a07004 	mov	r7, r4
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
3480ee04:	ea00007f 	b	3480f008 <xyzModem_stream_read+0x224>
    {
      if (xyz.len == 0)
3480ee08:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480ee0c:	e3530000 	cmp	r3, #0
3480ee10:	03a06014 	moveq	r6, #20
3480ee14:	0a00005d 	beq	3480ef90 <xyzModem_stream_read+0x1ac>
3480ee18:	ea000066 	b	3480efb8 <xyzModem_stream_read+0x1d4>
	{
	  retries = xyzModem_MAX_RETRIES;
	  while (retries-- > 0)
	    {
	      stat = xyzModem_get_hdr ();
3480ee1c:	ebfffeb4 	bl	3480e8f4 <xyzModem_get_hdr>
	      if (stat == 0)
3480ee20:	e2505000 	subs	r5, r0, #0
3480ee24:	1a000039 	bne	3480ef10 <xyzModem_stream_read+0x12c>
		{
		  if (xyz.blk == xyz.next_blk)
3480ee28:	e5d43408 	ldrb	r3, [r4, #1032]	; 0x408
3480ee2c:	e5d4240c 	ldrb	r2, [r4, #1036]	; 0x40c
3480ee30:	e1530002 	cmp	r3, r2
3480ee34:	1a00002d 	bne	3480eef0 <xyzModem_stream_read+0x10c>
		    {
		      xyz.tx_ack = true;
3480ee38:	e3a02001 	mov	r2, #1
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;
3480ee3c:	e0833002 	add	r3, r3, r2
	      stat = xyzModem_get_hdr ();
	      if (stat == 0)
		{
		  if (xyz.blk == xyz.next_blk)
		    {
		      xyz.tx_ack = true;
3480ee40:	e5872430 	str	r2, [r7, #1072]	; 0x430
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;

#if defined(xyzModem_zmodem) || defined(USE_YMODEM_LENGTH)
		      if (xyz.mode == xyzModem_xmodem || xyz.file_length == 0)
3480ee44:	e5972414 	ldr	r2, [r7, #1044]	; 0x414
		  if (xyz.blk == xyz.next_blk)
		    {
		      xyz.tx_ack = true;
		      ZM_DEBUG (zm_dprintf
				("ACK block %d (%d)\n", xyz.blk, __LINE__));
		      xyz.next_blk = (xyz.next_blk + 1) & 0xFF;
3480ee48:	e5c7340c 	strb	r3, [r7, #1036]	; 0x40c

#if defined(xyzModem_zmodem) || defined(USE_YMODEM_LENGTH)
		      if (xyz.mode == xyzModem_xmodem || xyz.file_length == 0)
3480ee4c:	e3520001 	cmp	r2, #1
3480ee50:	0a000002 	beq	3480ee60 <xyzModem_stream_read+0x7c>
3480ee54:	e5973434 	ldr	r3, [r7, #1076]	; 0x434
3480ee58:	e3530000 	cmp	r3, #0
3480ee5c:	1a000017 	bne	3480eec0 <xyzModem_stream_read+0xdc>
		      if (1)
			{
#endif
			  /* Data blocks can be padded with ^Z (EOF) characters */
			  /* This code tries to detect and remove them */
			  if ((xyz.bufp[xyz.len - 1] == EOF) &&
3480ee60:	e5941404 	ldr	r1, [r4, #1028]	; 0x404
3480ee64:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480ee68:	e0813003 	add	r3, r1, r3
3480ee6c:	e5530001 	ldrb	r0, [r3, #-1]
3480ee70:	e350001a 	cmp	r0, #26
3480ee74:	1a00000f 	bne	3480eeb8 <xyzModem_stream_read+0xd4>
3480ee78:	e5530002 	ldrb	r0, [r3, #-2]
3480ee7c:	e350001a 	cmp	r0, #26
3480ee80:	1a00000c 	bne	3480eeb8 <xyzModem_stream_read+0xd4>
			      (xyz.bufp[xyz.len - 2] == EOF) &&
3480ee84:	e5533003 	ldrb	r3, [r3, #-3]
3480ee88:	e353001a 	cmp	r3, #26
3480ee8c:	1a000009 	bne	3480eeb8 <xyzModem_stream_read+0xd4>
3480ee90:	ea000001 	b	3480ee9c <xyzModem_stream_read+0xb8>
			      (xyz.bufp[xyz.len - 3] == EOF))
			    {
			      while (xyz.len
				     && (xyz.bufp[xyz.len - 1] == EOF))
				{
				  xyz.len--;
3480ee94:	e2433001 	sub	r3, r3, #1
3480ee98:	e5843410 	str	r3, [r4, #1040]	; 0x410
			  /* This code tries to detect and remove them */
			  if ((xyz.bufp[xyz.len - 1] == EOF) &&
			      (xyz.bufp[xyz.len - 2] == EOF) &&
			      (xyz.bufp[xyz.len - 3] == EOF))
			    {
			      while (xyz.len
3480ee9c:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
3480eea0:	e3530000 	cmp	r3, #0
3480eea4:	0a000003 	beq	3480eeb8 <xyzModem_stream_read+0xd4>
				     && (xyz.bufp[xyz.len - 1] == EOF))
3480eea8:	e0810003 	add	r0, r1, r3
3480eeac:	e5500001 	ldrb	r0, [r0, #-1]
3480eeb0:	e350001a 	cmp	r0, #26
3480eeb4:	0afffff6 	beq	3480ee94 <xyzModem_stream_read+0xb0>
		       * See if accumulated length exceeds that of the file.
		       * If so, reduce size (i.e., cut out pad bytes)
		       * Only do this for Y-modem (and Z-modem should it ever
		       * be supported since it can fall back to Y-modem mode).
		       */
		      if (xyz.mode != xyzModem_xmodem && 0 != xyz.file_length)
3480eeb8:	e3520001 	cmp	r2, #1
3480eebc:	0a00003d 	beq	3480efb8 <xyzModem_stream_read+0x1d4>
3480eec0:	e5942434 	ldr	r2, [r4, #1076]	; 0x434
3480eec4:	e3520000 	cmp	r2, #0
3480eec8:	0a00003a 	beq	3480efb8 <xyzModem_stream_read+0x1d4>
			{
			  xyz.read_length += xyz.len;
3480eecc:	e5941410 	ldr	r1, [r4, #1040]	; 0x410
3480eed0:	e5943438 	ldr	r3, [r4, #1080]	; 0x438
3480eed4:	e0813003 	add	r3, r1, r3
			  if (xyz.read_length > xyz.file_length)
3480eed8:	e1530002 	cmp	r3, r2
			    {
			      xyz.len -= (xyz.read_length - xyz.file_length);
3480eedc:	80812002 	addhi	r2, r1, r2
		       * Only do this for Y-modem (and Z-modem should it ever
		       * be supported since it can fall back to Y-modem mode).
		       */
		      if (xyz.mode != xyzModem_xmodem && 0 != xyz.file_length)
			{
			  xyz.read_length += xyz.len;
3480eee0:	e5843438 	str	r3, [r4, #1080]	; 0x438
			  if (xyz.read_length > xyz.file_length)
			    {
			      xyz.len -= (xyz.read_length - xyz.file_length);
3480eee4:	80633002 	rsbhi	r3, r3, r2
3480eee8:	85843410 	strhi	r3, [r4, #1040]	; 0x410
3480eeec:	ea000031 	b	3480efb8 <xyzModem_stream_read+0x1d4>
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
3480eef0:	e2422001 	sub	r2, r2, #1
3480eef4:	e20220ff 	and	r2, r2, #255	; 0xff
3480eef8:	e1530002 	cmp	r3, r2
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      continue;	/* Need new header */
		    }
		  else
		    {
		      stat = xyzModem_sequence;
3480eefc:	13e05007 	mvnne	r5, #7
			    }
			}
#endif
		      break;
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
3480ef00:	1a00001a 	bne	3480ef70 <xyzModem_stream_read+0x18c>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480ef04:	e3a00006 	mov	r0, #6
3480ef08:	ebffe881 	bl	34809114 <putc>
		    }
		  else if (xyz.blk == ((xyz.next_blk - 1) & 0xFF))
		    {
		      /* Just re-ACK this so sender will get on with it */
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      continue;	/* Need new header */
3480ef0c:	ea00001f 	b	3480ef90 <xyzModem_stream_read+0x1ac>
		  else
		    {
		      stat = xyzModem_sequence;
		    }
		}
	      if (stat == xyzModem_cancel)
3480ef10:	e3750005 	cmn	r5, #5
3480ef14:	0a000021 	beq	3480efa0 <xyzModem_stream_read+0x1bc>
		{
		  break;
		}
	      if (stat == xyzModem_eof)
3480ef18:	e3750004 	cmn	r5, #4
3480ef1c:	1a000013 	bne	3480ef70 <xyzModem_stream_read+0x18c>
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480ef20:	e3a00006 	mov	r0, #6
3480ef24:	ebffe87a 	bl	34809114 <putc>
		}
	      if (stat == xyzModem_eof)
		{
		  CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		  ZM_DEBUG (zm_dprintf ("ACK (%d)\n", __LINE__));
		  if (xyz.mode == xyzModem_ymodem)
3480ef28:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
3480ef2c:	e3530002 	cmp	r3, #2
3480ef30:	1a00000b 	bne	3480ef64 <xyzModem_stream_read+0x180>
		    {
		      CYGACC_COMM_IF_PUTC (*xyz.__chan,
3480ef34:	e5940428 	ldr	r0, [r4, #1064]	; 0x428
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480ef38:	e3500000 	cmp	r0, #0
3480ef3c:	03a00015 	moveq	r0, #21
3480ef40:	13a00043 	movne	r0, #67	; 0x43
3480ef44:	ebffe872 	bl	34809114 <putc>
		  ZM_DEBUG (zm_dprintf ("ACK (%d)\n", __LINE__));
		  if (xyz.mode == xyzModem_ymodem)
		    {
		      CYGACC_COMM_IF_PUTC (*xyz.__chan,
					   (xyz.crc_mode ? 'C' : NAK));
		      xyz.total_retries++;
3480ef48:	e5943418 	ldr	r3, [r4, #1048]	; 0x418
3480ef4c:	e2833001 	add	r3, r3, #1
3480ef50:	e5843418 	str	r3, [r4, #1048]	; 0x418
		      ZM_DEBUG (zm_dprintf ("Reading Final Header\n"));
		      stat = xyzModem_get_hdr ();
3480ef54:	ebfffe66 	bl	3480e8f4 <xyzModem_get_hdr>
3480ef58:	e1a05000 	mov	r5, r0
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480ef5c:	e3a00006 	mov	r0, #6
3480ef60:	ebffe86b 	bl	34809114 <putc>
		      ZM_DEBUG (zm_dprintf ("Reading Final Header\n"));
		      stat = xyzModem_get_hdr ();
		      CYGACC_COMM_IF_PUTC (*xyz.__chan, ACK);
		      ZM_DEBUG (zm_dprintf ("FINAL ACK (%d)\n", __LINE__));
		    }
		  xyz.at_eof = true;
3480ef64:	e3a03001 	mov	r3, #1
3480ef68:	e584342c 	str	r3, [r4, #1068]	; 0x42c
		  break;
3480ef6c:	ea000009 	b	3480ef98 <xyzModem_stream_read+0x1b4>
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
3480ef70:	e5940428 	ldr	r0, [r4, #1064]	; 0x428
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480ef74:	e3500000 	cmp	r0, #0
3480ef78:	03a00015 	moveq	r0, #21
3480ef7c:	13a00043 	movne	r0, #67	; 0x43
3480ef80:	ebffe863 	bl	34809114 <putc>
		    }
		  xyz.at_eof = true;
		  break;
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	      xyz.total_retries++;
3480ef84:	e5943418 	ldr	r3, [r4, #1048]	; 0x418
3480ef88:	e2833001 	add	r3, r3, #1
3480ef8c:	e5843418 	str	r3, [r4, #1048]	; 0x418
  while (!xyz.at_eof && (size > 0))
    {
      if (xyz.len == 0)
	{
	  retries = xyzModem_MAX_RETRIES;
	  while (retries-- > 0)
3480ef90:	e2566001 	subs	r6, r6, #1
3480ef94:	2affffa0 	bcs	3480ee1c <xyzModem_stream_read+0x38>
		}
	      CYGACC_COMM_IF_PUTC (*xyz.__chan, (xyz.crc_mode ? 'C' : NAK));
	      xyz.total_retries++;
	      ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	    }
	  if (stat < 0)
3480ef98:	e3550000 	cmp	r5, #0
3480ef9c:	aa000005 	bge	3480efb8 <xyzModem_stream_read+0x1d4>
	    {
	      *err = stat;
3480efa0:	e59d2004 	ldr	r2, [sp, #4]
	      xyz.len = -1;
3480efa4:	e59f3084 	ldr	r3, [pc, #132]	; 3480f030 <xyzModem_stream_read+0x24c>
	      xyz.total_retries++;
	      ZM_DEBUG (zm_dprintf ("NAK (%d)\n", __LINE__));
	    }
	  if (stat < 0)
	    {
	      *err = stat;
3480efa8:	e5825000 	str	r5, [r2]
	      xyz.len = -1;
3480efac:	e3e02000 	mvn	r2, #0
3480efb0:	e5832410 	str	r2, [r3, #1040]	; 0x410
	      return total;
3480efb4:	ea00001b 	b	3480f028 <xyzModem_stream_read+0x244>
	    }
	}
      /* Don't "read" data from the EOF protocol package */
      if (!xyz.at_eof)
3480efb8:	e594342c 	ldr	r3, [r4, #1068]	; 0x42c
3480efbc:	e3530000 	cmp	r3, #0
3480efc0:	1a000010 	bne	3480f008 <xyzModem_stream_read+0x224>
	{
	  len = xyz.len;
3480efc4:	e5946410 	ldr	r6, [r4, #1040]	; 0x410
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
3480efc8:	e1a00009 	mov	r0, r9
	    }
	}
      /* Don't "read" data from the EOF protocol package */
      if (!xyz.at_eof)
	{
	  len = xyz.len;
3480efcc:	e15a0006 	cmp	sl, r6
3480efd0:	b1a0600a 	movlt	r6, sl
3480efd4:	a1a06006 	movge	r6, r6
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
3480efd8:	e1a02006 	mov	r2, r6
3480efdc:	e5941404 	ldr	r1, [r4, #1028]	; 0x404
3480efe0:	eb0033db 	bl	3481bf54 <memcpy>
	  size -= len;
	  buf += len;
	  total += len;
	  xyz.len -= len;
3480efe4:	e5943410 	ldr	r3, [r4, #1040]	; 0x410
	{
	  len = xyz.len;
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
	  size -= len;
3480efe8:	e066a00a 	rsb	sl, r6, sl
	  buf += len;
	  total += len;
	  xyz.len -= len;
3480efec:	e0663003 	rsb	r3, r6, r3
3480eff0:	e5843410 	str	r3, [r4, #1040]	; 0x410
	  xyz.bufp += len;
3480eff4:	e5943404 	ldr	r3, [r4, #1028]	; 0x404
	  len = xyz.len;
	  if (size < len)
	    len = size;
	  memcpy (buf, xyz.bufp, len);
	  size -= len;
	  buf += len;
3480eff8:	e0899006 	add	r9, r9, r6
	  total += len;
3480effc:	e08bb006 	add	fp, fp, r6
	  xyz.len -= len;
	  xyz.bufp += len;
3480f000:	e0836006 	add	r6, r3, r6
3480f004:	e5846404 	str	r6, [r4, #1028]	; 0x404
  int retries;

  total = 0;
  stat = xyzModem_cancel;
  /* Try and get 'size' bytes into the buffer */
  while (!xyz.at_eof && (size > 0))
3480f008:	e594242c 	ldr	r2, [r4, #1068]	; 0x42c
3480f00c:	e35a0000 	cmp	sl, #0
3480f010:	d3a03000 	movle	r3, #0
3480f014:	c3a03001 	movgt	r3, #1
3480f018:	e3520000 	cmp	r2, #0
3480f01c:	13a03000 	movne	r3, #0
3480f020:	e3530000 	cmp	r3, #0
3480f024:	1affff77 	bne	3480ee08 <xyzModem_stream_read+0x24>
	  xyz.len -= len;
	  xyz.bufp += len;
	}
    }
  return total;
}
3480f028:	e1a0000b 	mov	r0, fp
3480f02c:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3480f030:	3482b5cc 	.word	0x3482b5cc

3480f034 <xyzModem_stream_close>:

void
xyzModem_stream_close (int *err)
{
3480f034:	e92d4007 	push	{r0, r1, r2, lr}
  diag_printf
    ("xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries\n",
     xyz.crc_mode ? "CRC" : "Cksum", xyz.total_SOH, xyz.total_STX,
3480f038:	e59f3034 	ldr	r3, [pc, #52]	; 3480f074 <xyzModem_stream_close+0x40>

void
xyzModem_stream_close (int *err)
{
  diag_printf
    ("xyzModem - %s mode, %d(SOH)/%d(STX)/%d(CAN) packets, %d retries\n",
3480f03c:	e59f1034 	ldr	r1, [pc, #52]	; 3480f078 <xyzModem_stream_close+0x44>
3480f040:	e5932424 	ldr	r2, [r3, #1060]	; 0x424
3480f044:	e593c428 	ldr	ip, [r3, #1064]	; 0x428
3480f048:	e58d2000 	str	r2, [sp]
3480f04c:	e5932418 	ldr	r2, [r3, #1048]	; 0x418
3480f050:	e35c0000 	cmp	ip, #0
3480f054:	e58d2004 	str	r2, [sp, #4]
3480f058:	e59f201c 	ldr	r2, [pc, #28]	; 3480f07c <xyzModem_stream_close+0x48>
3480f05c:	e59f001c 	ldr	r0, [pc, #28]	; 3480f080 <xyzModem_stream_close+0x4c>
3480f060:	11a01002 	movne	r1, r2
3480f064:	e593241c 	ldr	r2, [r3, #1052]	; 0x41c
3480f068:	e5933420 	ldr	r3, [r3, #1056]	; 0x420
3480f06c:	ebffe83c 	bl	34809164 <printf>
     xyz.crc_mode ? "CRC" : "Cksum", xyz.total_SOH, xyz.total_STX,
     xyz.total_CAN, xyz.total_retries);
  ZM_DEBUG (zm_flush ());
}
3480f070:	e8bd800e 	pop	{r1, r2, r3, pc}
3480f074:	3482b5cc 	.word	0x3482b5cc
3480f078:	34826963 	.word	0x34826963
3480f07c:	348260bd 	.word	0x348260bd
3480f080:	34826969 	.word	0x34826969

3480f084 <xyzModem_stream_terminate>:
void
xyzModem_stream_terminate (bool abort, int (*getc) (void))
{
  int c;

  if (abort)
3480f084:	e3500000 	cmp	r0, #0

/* Need to be able to clean out the input buffer, so have to take the */
/* getc */
void
xyzModem_stream_terminate (bool abort, int (*getc) (void))
{
3480f088:	e92d4010 	push	{r4, lr}
3480f08c:	e1a04001 	mov	r4, r1
  int c;

  if (abort)
3480f090:	0a000018 	beq	3480f0f8 <xyzModem_stream_terminate+0x74>
    {
      ZM_DEBUG (zm_dprintf ("!!!! TRANSFER ABORT !!!!\n"));
      switch (xyz.mode)
3480f094:	e59f4074 	ldr	r4, [pc, #116]	; 3480f110 <xyzModem_stream_terminate+0x8c>
3480f098:	e5943414 	ldr	r3, [r4, #1044]	; 0x414
3480f09c:	e2433001 	sub	r3, r3, #1
3480f0a0:	e3530001 	cmp	r3, #1
3480f0a4:	88bd8010 	pophi	{r4, pc}
}

void
CYGACC_COMM_IF_PUTC (char x, char y)
{
  putc (y);
3480f0a8:	e3a00018 	mov	r0, #24
3480f0ac:	ebffe818 	bl	34809114 <putc>
3480f0b0:	e3a00018 	mov	r0, #24
3480f0b4:	ebffe816 	bl	34809114 <putc>
3480f0b8:	e3a00018 	mov	r0, #24
3480f0bc:	ebffe814 	bl	34809114 <putc>
3480f0c0:	e3a00018 	mov	r0, #24
3480f0c4:	ebffe812 	bl	34809114 <putc>
3480f0c8:	e3a00008 	mov	r0, #8
3480f0cc:	ebffe810 	bl	34809114 <putc>
3480f0d0:	e3a00008 	mov	r0, #8
3480f0d4:	ebffe80e 	bl	34809114 <putc>
3480f0d8:	e3a00008 	mov	r0, #8
3480f0dc:	ebffe80c 	bl	34809114 <putc>
3480f0e0:	e3a00008 	mov	r0, #8
3480f0e4:	ebffe80a 	bl	34809114 <putc>
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  CYGACC_COMM_IF_PUTC (*xyz.__chan, BSP);
	  /* Now consume the rest of what's waiting on the line. */
	  ZM_DEBUG (zm_dprintf ("Flushing serial line.\n"));
	  xyzModem_flush ();
3480f0e8:	ebfffdf6 	bl	3480e8c8 <xyzModem_flush>
	  xyz.at_eof = true;
3480f0ec:	e3a03001 	mov	r3, #1
3480f0f0:	e584342c 	str	r3, [r4, #1068]	; 0x42c
3480f0f4:	e8bd8010 	pop	{r4, pc}
       * previous received blocks. Since very few files are an exact multiple
       * of the transfer block size, there will almost always be some gunk here.
       * If we don't eat it now, RedBoot will think the user typed it.
       */
      ZM_DEBUG (zm_dprintf ("Trailing gunk:\n"));
      while ((c = (*getc) ()) > -1);
3480f0f8:	e12fff34 	blx	r4
3480f0fc:	e3500000 	cmp	r0, #0
3480f100:	aafffffc 	bge	3480f0f8 <xyzModem_stream_terminate+0x74>
      /*
       * Make a small delay to give terminal programs like minicom
       * time to get control again after their file transfer program
       * exits.
       */
      CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
3480f104:	e59f0008 	ldr	r0, [pc, #8]	; 3480f114 <xyzModem_stream_terminate+0x90>
    }
}
3480f108:	e8bd4010 	pop	{r4, lr}
      /*
       * Make a small delay to give terminal programs like minicom
       * time to get control again after their file transfer program
       * exits.
       */
      CYGACC_CALL_IF_DELAY_US ((cyg_int32) 250000);
3480f10c:	ea00341b 	b	3481c180 <udelay>
3480f110:	3482b5cc 	.word	0x3482b5cc
3480f114:	0003d090 	.word	0x0003d090

3480f118 <xyzModem_error>:
    }
}

char *
xyzModem_error (int err)
{
3480f118:	e2800008 	add	r0, r0, #8
3480f11c:	e3500007 	cmp	r0, #7
3480f120:	959f3008 	ldrls	r3, [pc, #8]	; 3480f130 <xyzModem_error+0x18>
3480f124:	859f0008 	ldrhi	r0, [pc, #8]	; 3480f134 <xyzModem_error+0x1c>
3480f128:	97930100 	ldrls	r0, [r3, r0, lsl #2]
      break;
    default:
      return "Unknown error";
      break;
    }
}
3480f12c:	e12fff1e 	bx	lr
3480f130:	34821344 	.word	0x34821344
3480f134:	348269aa 	.word	0x348269aa

3480f138 <get_dev>:
};

DECLARE_GLOBAL_DATA_PTR;

block_dev_desc_t *get_dev(const char *ifname, int dev)
{
3480f138:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
3480f13c:	e2505000 	subs	r5, r0, #0
};

DECLARE_GLOBAL_DATA_PTR;

block_dev_desc_t *get_dev(const char *ifname, int dev)
{
3480f140:	e1a07001 	mov	r7, r1
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
3480f144:	159f4054 	ldrne	r4, [pc, #84]	; 3480f1a0 <get_dev+0x68>
3480f148:	0a000012 	beq	3480f198 <get_dev+0x60>
3480f14c:	ea00000c 	b	3480f184 <get_dev+0x4c>
		reloc_get_dev = drvr->get_dev;
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		name += gd->reloc_off;
		reloc_get_dev += gd->reloc_off;
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
3480f150:	e1a0000a 	mov	r0, sl
#ifdef CONFIG_NEEDS_MANUAL_RELOC
	name += gd->reloc_off;
#endif
	while (drvr->name) {
		name = drvr->name;
		reloc_get_dev = drvr->get_dev;
3480f154:	e5146004 	ldr	r6, [r4, #-4]
#ifdef CONFIG_NEEDS_MANUAL_RELOC
		name += gd->reloc_off;
		reloc_get_dev += gd->reloc_off;
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
3480f158:	eb0032b9 	bl	3481bc44 <strlen>
3480f15c:	e1a0100a 	mov	r1, sl
3480f160:	e1a02000 	mov	r2, r0
3480f164:	e1a00005 	mov	r0, r5
3480f168:	eb00328d 	bl	3481bba4 <strncmp>
3480f16c:	e3500000 	cmp	r0, #0
3480f170:	e2844008 	add	r4, r4, #8
3480f174:	1a000002 	bne	3480f184 <get_dev+0x4c>
			return reloc_get_dev(dev);
3480f178:	e1a00007 	mov	r0, r7
3480f17c:	e12fff36 	blx	r6
3480f180:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	name = drvr->name;
#ifdef CONFIG_NEEDS_MANUAL_RELOC
	name += gd->reloc_off;
#endif
	while (drvr->name) {
3480f184:	e514a008 	ldr	sl, [r4, #-8]
3480f188:	e35a0000 	cmp	sl, #0
3480f18c:	1affffef 	bne	3480f150 <get_dev+0x18>
#endif
		if (strncmp(ifname, name, strlen(name)) == 0)
			return reloc_get_dev(dev);
		drvr++;
	}
	return NULL;
3480f190:	e1a0000a 	mov	r0, sl
3480f194:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	const struct block_drvr *drvr = block_drvr;
	block_dev_desc_t* (*reloc_get_dev)(int dev);
	char *name;

	if (!ifname)
		return NULL;
3480f198:	e1a00005 	mov	r0, r5
		if (strncmp(ifname, name, strlen(name)) == 0)
			return reloc_get_dev(dev);
		drvr++;
	}
	return NULL;
}
3480f19c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3480f1a0:	3482136c 	.word	0x3482136c

3480f1a4 <dev_print>:
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
3480f1a4:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
3480f1a8:	e5d0300b 	ldrb	r3, [r0, #11]
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
3480f1ac:	e1a04000 	mov	r4, r0
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
3480f1b0:	e35300ff 	cmp	r3, #255	; 0xff
	bc_rem  = block_count - div_by * bc_quot;
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
}

void dev_print (block_dev_desc_t *dev_desc)
{
3480f1b4:	e24dd014 	sub	sp, sp, #20
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
		puts ("not available\n");
3480f1b8:	059f01b0 	ldreq	r0, [pc, #432]	; 3480f370 <dev_print+0x1cc>

void dev_print (block_dev_desc_t *dev_desc)
{
	lba512_t lba512; /* number of blocks if 512bytes block size */

	if (dev_desc->type == DEV_TYPE_UNKNOWN) {
3480f1bc:	0a000068 	beq	3480f364 <dev_print+0x1c0>
		puts ("not available\n");
		return;
	}

	switch (dev_desc->if_type) {
3480f1c0:	e5941000 	ldr	r1, [r4]
3480f1c4:	e3510008 	cmp	r1, #8
3480f1c8:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
3480f1cc:	ea00001e 	b	3480f24c <dev_print+0xa8>
3480f1d0:	3480f244 	.word	0x3480f244
3480f1d4:	3480f21c 	.word	0x3480f21c
3480f1d8:	3480f1f4 	.word	0x3480f1f4
3480f1dc:	3480f21c 	.word	0x3480f21c
3480f1e0:	3480f224 	.word	0x3480f224
3480f1e4:	3480f23c 	.word	0x3480f23c
3480f1e8:	3480f224 	.word	0x3480f224
3480f1ec:	3480f224 	.word	0x3480f224
3480f1f0:	3480f21c 	.word	0x3480f21c
	case IF_TYPE_SCSI:
		printf ("(%d:%d) Vendor: %s Prod.: %s Rev: %s\n",
3480f1f4:	e2843041 	add	r3, r4, #65	; 0x41
3480f1f8:	e5d41009 	ldrb	r1, [r4, #9]
3480f1fc:	e5d4200a 	ldrb	r2, [r4, #10]
3480f200:	e58d3000 	str	r3, [sp]
3480f204:	e2843056 	add	r3, r4, #86	; 0x56
3480f208:	e58d3004 	str	r3, [sp, #4]
3480f20c:	e59f0160 	ldr	r0, [pc, #352]	; 3480f374 <dev_print+0x1d0>
3480f210:	e2843018 	add	r3, r4, #24
3480f214:	ebffe7d2 	bl	34809164 <printf>
			dev_desc->target,dev_desc->lun,
			dev_desc->vendor,
			dev_desc->product,
			dev_desc->revision);
		break;
3480f218:	ea00000f 	b	3480f25c <dev_print+0xb8>
	case IF_TYPE_ATAPI:
	case IF_TYPE_IDE:
	case IF_TYPE_SATA:
		printf ("Model: %s Firm: %s Ser#: %s\n",
3480f21c:	e59f0154 	ldr	r0, [pc, #340]	; 3480f378 <dev_print+0x1d4>
3480f220:	ea000000 	b	3480f228 <dev_print+0x84>
			dev_desc->product);
		break;
	case IF_TYPE_SD:
	case IF_TYPE_MMC:
	case IF_TYPE_USB:
		printf ("Vendor: %s Rev: %s Prod: %s\n",
3480f224:	e59f0150 	ldr	r0, [pc, #336]	; 3480f37c <dev_print+0x1d8>
3480f228:	e2841018 	add	r1, r4, #24
3480f22c:	e2842056 	add	r2, r4, #86	; 0x56
3480f230:	e2843041 	add	r3, r4, #65	; 0x41
3480f234:	ebffe7ca 	bl	34809164 <printf>
			dev_desc->vendor,
			dev_desc->revision,
			dev_desc->product);
		break;
3480f238:	ea000007 	b	3480f25c <dev_print+0xb8>
	case IF_TYPE_DOC:
		puts("device type DOC\n");
3480f23c:	e59f013c 	ldr	r0, [pc, #316]	; 3480f380 <dev_print+0x1dc>
3480f240:	ea000047 	b	3480f364 <dev_print+0x1c0>
		return;
	case IF_TYPE_UNKNOWN:
		puts("device type unknown\n");
3480f244:	e59f0138 	ldr	r0, [pc, #312]	; 3480f384 <dev_print+0x1e0>
3480f248:	ea000045 	b	3480f364 <dev_print+0x1c0>
		return;
	default:
		printf("Unhandled device type: %i\n", dev_desc->if_type);
3480f24c:	e59f0134 	ldr	r0, [pc, #308]	; 3480f388 <dev_print+0x1e4>
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
	}
}
3480f250:	e28dd014 	add	sp, sp, #20
3480f254:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
		return;
	case IF_TYPE_UNKNOWN:
		puts("device type unknown\n");
		return;
	default:
		printf("Unhandled device type: %i\n", dev_desc->if_type);
3480f258:	eaffe7c1 	b	34809164 <printf>
		return;
	}
	puts ("            Type: ");
3480f25c:	e59f0128 	ldr	r0, [pc, #296]	; 3480f38c <dev_print+0x1e8>
3480f260:	ebffe7b5 	bl	3480913c <puts>
	if (dev_desc->removable)
3480f264:	e5d4300c 	ldrb	r3, [r4, #12]
3480f268:	e3530000 	cmp	r3, #0
3480f26c:	0a000001 	beq	3480f278 <dev_print+0xd4>
		puts ("Removable ");
3480f270:	e59f0118 	ldr	r0, [pc, #280]	; 3480f390 <dev_print+0x1ec>
3480f274:	ebffe7b0 	bl	3480913c <puts>
	switch (dev_desc->type & 0x1F) {
3480f278:	e5d4100b 	ldrb	r1, [r4, #11]
3480f27c:	e201101f 	and	r1, r1, #31
3480f280:	e3510007 	cmp	r1, #7
3480f284:	979ff101 	ldrls	pc, [pc, r1, lsl #2]
3480f288:	ea000010 	b	3480f2d0 <dev_print+0x12c>
3480f28c:	3480f2ac 	.word	0x3480f2ac
3480f290:	3480f2c8 	.word	0x3480f2c8
3480f294:	3480f2d0 	.word	0x3480f2d0
3480f298:	3480f2d0 	.word	0x3480f2d0
3480f29c:	3480f2d0 	.word	0x3480f2d0
3480f2a0:	3480f2b4 	.word	0x3480f2b4
3480f2a4:	3480f2d0 	.word	0x3480f2d0
3480f2a8:	3480f2c0 	.word	0x3480f2c0
	case DEV_TYPE_HARDDISK:
		puts ("Hard Disk");
3480f2ac:	e59f00e0 	ldr	r0, [pc, #224]	; 3480f394 <dev_print+0x1f0>
3480f2b0:	ea000000 	b	3480f2b8 <dev_print+0x114>
		break;
	case DEV_TYPE_CDROM:
		puts ("CD ROM");
3480f2b4:	e59f00dc 	ldr	r0, [pc, #220]	; 3480f398 <dev_print+0x1f4>
3480f2b8:	ebffe79f 	bl	3480913c <puts>
		break;
3480f2bc:	ea000005 	b	3480f2d8 <dev_print+0x134>
	case DEV_TYPE_OPDISK:
		puts ("Optical Device");
3480f2c0:	e59f00d4 	ldr	r0, [pc, #212]	; 3480f39c <dev_print+0x1f8>
3480f2c4:	eafffffb 	b	3480f2b8 <dev_print+0x114>
		break;
	case DEV_TYPE_TAPE:
		puts ("Tape");
3480f2c8:	e59f00d0 	ldr	r0, [pc, #208]	; 3480f3a0 <dev_print+0x1fc>
3480f2cc:	eafffff9 	b	3480f2b8 <dev_print+0x114>
		break;
	default:
		printf ("# %02X #", dev_desc->type & 0x1F);
3480f2d0:	e59f00cc 	ldr	r0, [pc, #204]	; 3480f3a4 <dev_print+0x200>
3480f2d4:	ebffe7a2 	bl	34809164 <printf>
		break;
	}
	puts ("\n");
3480f2d8:	e59f00c8 	ldr	r0, [pc, #200]	; 3480f3a8 <dev_print+0x204>
3480f2dc:	ebffe796 	bl	3480913c <puts>
	if ((dev_desc->lba * dev_desc->blksz)>0L) {
3480f2e0:	e5947010 	ldr	r7, [r4, #16]
3480f2e4:	e5946014 	ldr	r6, [r4, #20]
3480f2e8:	e0130697 	muls	r3, r7, r6
			gb_quot, gb_rem,
			(ulong)lba,
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
3480f2ec:	059f00b8 	ldreq	r0, [pc, #184]	; 3480f3ac <dev_print+0x208>
	default:
		printf ("# %02X #", dev_desc->type & 0x1F);
		break;
	}
	puts ("\n");
	if ((dev_desc->lba * dev_desc->blksz)>0L) {
3480f2f0:	0a00001b 	beq	3480f364 <dev_print+0x1c0>
		ulong mb, mb_quot, mb_rem, gb, gb_quot, gb_rem;
		lbaint_t lba;

		lba = dev_desc->lba;

		lba512 = (lba * (dev_desc->blksz/512));
3480f2f4:	e1a024a6 	lsr	r2, r6, #9
3480f2f8:	e0020297 	mul	r2, r7, r2
static lba512_t lba512_muldiv (lba512_t block_count, lba512_t mul_by, lba512_t div_by)
{
	lba512_t bc_quot, bc_rem;

	/* x * m / d == x / d * m + (x % d) * m / d */
	bc_quot = block_count / div_by;
3480f2fc:	e1a035a2 	lsr	r3, r2, #11
	bc_rem  = block_count - div_by * bc_quot;
3480f300:	e1a05583 	lsl	r5, r3, #11
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
3480f304:	e3a0400a 	mov	r4, #10
{
	lba512_t bc_quot, bc_rem;

	/* x * m / d == x / d * m + (x % d) * m / d */
	bc_quot = block_count / div_by;
	bc_rem  = block_count - div_by * bc_quot;
3480f308:	e0655002 	rsb	r5, r5, r2
	return bc_quot * mul_by + (bc_rem * mul_by) / div_by;
3480f30c:	e0030394 	mul	r3, r4, r3
3480f310:	e0050594 	mul	r5, r4, r5
3480f314:	e08355a5 	add	r5, r3, r5, lsr #11

		lba512 = (lba * (dev_desc->blksz/512));
		/* round to 1 digit */
		mb = lba512_muldiv(lba512, 10, 2048);	/* 2048 = (1024 * 1024) / 512 MB */

		mb_quot	= mb / 10;
3480f318:	e1a01004 	mov	r1, r4
3480f31c:	e1a00005 	mov	r0, r5
3480f320:	eb00421e 	bl	3481fba0 <__udivsi3>
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
3480f324:	e1a0a435 	lsr	sl, r5, r4

		lba512 = (lba * (dev_desc->blksz/512));
		/* round to 1 digit */
		mb = lba512_muldiv(lba512, 10, 2048);	/* 2048 = (1024 * 1024) / 512 MB */

		mb_quot	= mb / 10;
3480f328:	e1a09000 	mov	r9, r0
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
		gb_quot	= gb / 10;
3480f32c:	e1a01004 	mov	r1, r4
3480f330:	e1a0000a 	mov	r0, sl
3480f334:	eb004219 	bl	3481fba0 <__udivsi3>
		gb_rem	= gb - (10 * gb_quot);
3480f338:	e06aa094 	mls	sl, r4, r0, sl

		mb_quot	= mb / 10;
		mb_rem	= mb - (10 * mb_quot);

		gb = mb / 1024;
		gb_quot	= gb / 10;
3480f33c:	e1a03000 	mov	r3, r0
			mb_quot, mb_rem,
			gb_quot, gb_rem,
			lba,
			dev_desc->blksz);
#else
		printf ("            Capacity: %ld.%ld MB = %ld.%ld GB (%ld x %ld)\n",
3480f340:	e1a01009 	mov	r1, r9
3480f344:	e0625994 	mls	r2, r4, r9, r5
3480f348:	e59f0060 	ldr	r0, [pc, #96]	; 3480f3b0 <dev_print+0x20c>
3480f34c:	e58da000 	str	sl, [sp]
3480f350:	e58d7004 	str	r7, [sp, #4]
3480f354:	e58d6008 	str	r6, [sp, #8]
3480f358:	ebffe781 	bl	34809164 <printf>
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
	}
}
3480f35c:	e28dd014 	add	sp, sp, #20
3480f360:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
3480f364:	e28dd014 	add	sp, sp, #20
3480f368:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
			gb_quot, gb_rem,
			(ulong)lba,
			dev_desc->blksz);
#endif
	} else {
		puts ("            Capacity: not available\n");
3480f36c:	eaffe772 	b	3480913c <puts>
3480f370:	34826b80 	.word	0x34826b80
3480f374:	34826a42 	.word	0x34826a42
3480f378:	34826a68 	.word	0x34826a68
3480f37c:	34826a85 	.word	0x34826a85
3480f380:	34826aa2 	.word	0x34826aa2
3480f384:	34826ab3 	.word	0x34826ab3
3480f388:	34826ac8 	.word	0x34826ac8
3480f38c:	34826ae3 	.word	0x34826ae3
3480f390:	34826af6 	.word	0x34826af6
3480f394:	34826b01 	.word	0x34826b01
3480f398:	34826b0b 	.word	0x34826b0b
3480f39c:	34826b12 	.word	0x34826b12
3480f3a0:	34826b21 	.word	0x34826b21
3480f3a4:	34826b26 	.word	0x34826b26
3480f3a8:	34826214 	.word	0x34826214
3480f3ac:	34826b6a 	.word	0x34826b6a
3480f3b0:	34826b2f 	.word	0x34826b2f

3480f3b4 <init_part>:
    defined(CONFIG_ISO_PARTITION) || \
    defined(CONFIG_AMIGA_PARTITION) || \
    defined(CONFIG_EFI_PARTITION)

void init_part (block_dev_desc_t * dev_desc)
{
3480f3b4:	e92d4010 	push	{r4, lr}
3480f3b8:	e1a04000 	mov	r4, r0
		return;
	}
#endif

#ifdef CONFIG_DOS_PARTITION
	if (test_part_dos(dev_desc) == 0) {
3480f3bc:	eb000259 	bl	3480fd28 <test_part_dos>
3480f3c0:	e3500000 	cmp	r0, #0
		dev_desc->part_type = PART_TYPE_DOS;
3480f3c4:	03a03002 	moveq	r3, #2
	if (test_part_amiga(dev_desc) == 0) {
	    dev_desc->part_type = PART_TYPE_AMIGA;
	    return;
	}
#endif
	dev_desc->part_type = PART_TYPE_UNKNOWN;
3480f3c8:	13a03000 	movne	r3, #0
3480f3cc:	e5c43008 	strb	r3, [r4, #8]
3480f3d0:	e8bd8010 	pop	{r4, pc}

3480f3d4 <print_part>:
	printf (" device %d  --   Partition Type: %s\n\n",
			dev_desc->dev, type);
}

void print_part (block_dev_desc_t * dev_desc)
{
3480f3d4:	e92d4010 	push	{r4, lr}

		switch (dev_desc->part_type) {
3480f3d8:	e5d03008 	ldrb	r3, [r0, #8]
	printf (" device %d  --   Partition Type: %s\n\n",
			dev_desc->dev, type);
}

void print_part (block_dev_desc_t * dev_desc)
{
3480f3dc:	e1a04000 	mov	r4, r0

		switch (dev_desc->part_type) {
3480f3e0:	e3530002 	cmp	r3, #2
3480f3e4:	1a000025 	bne	3480f480 <print_part+0xac>
}


static void print_part_header (const char *type, block_dev_desc_t * dev_desc)
{
	puts ("\nPartition Map for ");
3480f3e8:	e59f009c 	ldr	r0, [pc, #156]	; 3480f48c <print_part+0xb8>
3480f3ec:	ebffe752 	bl	3480913c <puts>
	switch (dev_desc->if_type) {
3480f3f0:	e5943000 	ldr	r3, [r4]
3480f3f4:	e2433001 	sub	r3, r3, #1
3480f3f8:	e3530007 	cmp	r3, #7
3480f3fc:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480f400:	ea000015 	b	3480f45c <print_part+0x88>
3480f404:	3480f424 	.word	0x3480f424
3480f408:	3480f434 	.word	0x3480f434
3480f40c:	3480f43c 	.word	0x3480f43c
3480f410:	3480f444 	.word	0x3480f444
3480f414:	3480f44c 	.word	0x3480f44c
3480f418:	3480f454 	.word	0x3480f454
3480f41c:	3480f45c 	.word	0x3480f45c
3480f420:	3480f42c 	.word	0x3480f42c
	case IF_TYPE_IDE:
		puts ("IDE");
3480f424:	e59f0064 	ldr	r0, [pc, #100]	; 3480f490 <print_part+0xbc>
3480f428:	ea00000c 	b	3480f460 <print_part+0x8c>
		break;
	case IF_TYPE_SATA:
		puts ("SATA");
3480f42c:	e59f0060 	ldr	r0, [pc, #96]	; 3480f494 <print_part+0xc0>
3480f430:	ea00000a 	b	3480f460 <print_part+0x8c>
		break;
	case IF_TYPE_SCSI:
		puts ("SCSI");
3480f434:	e59f005c 	ldr	r0, [pc, #92]	; 3480f498 <print_part+0xc4>
3480f438:	ea000008 	b	3480f460 <print_part+0x8c>
		break;
	case IF_TYPE_ATAPI:
		puts ("ATAPI");
3480f43c:	e59f0058 	ldr	r0, [pc, #88]	; 3480f49c <print_part+0xc8>
3480f440:	ea000006 	b	3480f460 <print_part+0x8c>
		break;
	case IF_TYPE_USB:
		puts ("USB");
3480f444:	e59f0054 	ldr	r0, [pc, #84]	; 3480f4a0 <print_part+0xcc>
3480f448:	ea000004 	b	3480f460 <print_part+0x8c>
		break;
	case IF_TYPE_DOC:
		puts ("DOC");
3480f44c:	e59f0050 	ldr	r0, [pc, #80]	; 3480f4a4 <print_part+0xd0>
3480f450:	ea000002 	b	3480f460 <print_part+0x8c>
		break;
	case IF_TYPE_MMC:
		puts ("MMC");
3480f454:	e59f004c 	ldr	r0, [pc, #76]	; 3480f4a8 <print_part+0xd4>
3480f458:	ea000000 	b	3480f460 <print_part+0x8c>
		break;
	default:
		puts ("UNKNOWN");
3480f45c:	e59f0048 	ldr	r0, [pc, #72]	; 3480f4ac <print_part+0xd8>
3480f460:	ebffe735 	bl	3480913c <puts>
		break;
	}
	printf (" device %d  --   Partition Type: %s\n\n",
3480f464:	e5941004 	ldr	r1, [r4, #4]
3480f468:	e59f2040 	ldr	r2, [pc, #64]	; 3480f4b0 <print_part+0xdc>
3480f46c:	e59f0040 	ldr	r0, [pc, #64]	; 3480f4b4 <print_part+0xe0>
3480f470:	ebffe73b 	bl	34809164 <printf>
#endif
#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		PRINTF ("## Testing for valid DOS partition ##\n");
		print_part_header ("DOS", dev_desc);
		print_part_dos (dev_desc);
3480f474:	e1a00004 	mov	r0, r4
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
}
3480f478:	e8bd4010 	pop	{r4, lr}
#endif
#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		PRINTF ("## Testing for valid DOS partition ##\n");
		print_part_header ("DOS", dev_desc);
		print_part_dos (dev_desc);
3480f47c:	ea000241 	b	3480fd88 <print_part_dos>
		print_part_header ("EFI", dev_desc);
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
3480f480:	e59f0030 	ldr	r0, [pc, #48]	; 3480f4b8 <print_part+0xe4>
}
3480f484:	e8bd4010 	pop	{r4, lr}
		print_part_header ("EFI", dev_desc);
		print_part_efi (dev_desc);
		return;
#endif
	}
	puts ("## Unknown partition table\n");
3480f488:	eaffe72b 	b	3480913c <puts>
3480f48c:	34826b8f 	.word	0x34826b8f
3480f490:	34826ba3 	.word	0x34826ba3
3480f494:	34826ba7 	.word	0x34826ba7
3480f498:	34826bac 	.word	0x34826bac
3480f49c:	34826bb1 	.word	0x34826bb1
3480f4a0:	34826bb7 	.word	0x34826bb7
3480f4a4:	34826bbb 	.word	0x34826bbb
3480f4a8:	34824199 	.word	0x34824199
3480f4ac:	34826bbf 	.word	0x34826bbf
3480f4b0:	34826bed 	.word	0x34826bed
3480f4b4:	34826bc7 	.word	0x34826bc7
3480f4b8:	34826bf1 	.word	0x34826bf1

3480f4bc <get_partition_info>:

#endif

int get_partition_info(block_dev_desc_t *dev_desc, int part
					, disk_partition_t *info)
{
3480f4bc:	e92d4008 	push	{r3, lr}
#ifdef CONFIG_PARTITION_UUIDS
	/* The common case is no UUID support */
	info->uuid[0] = 0;
#endif

	switch (dev_desc->part_type) {
3480f4c0:	e5d03008 	ldrb	r3, [r0, #8]
3480f4c4:	e3530002 	cmp	r3, #2
3480f4c8:	1a000003 	bne	3480f4dc <get_partition_info+0x20>
		break;
#endif

#ifdef CONFIG_DOS_PARTITION
	case PART_TYPE_DOS:
		if (get_partition_info_dos(dev_desc, part, info) == 0) {
3480f4cc:	eb000238 	bl	3480fdb4 <get_partition_info_dos>
3480f4d0:	e3500000 	cmp	r0, #0
	default:
		break;
	}
#endif

	return -1;
3480f4d4:	13e00000 	mvnne	r0, #0
3480f4d8:	e8bd8008 	pop	{r3, pc}
3480f4dc:	e3e00000 	mvn	r0, #0
}
3480f4e0:	e8bd8008 	pop	{r3, pc}

3480f4e4 <get_device>:

int get_device(const char *ifname, const char *dev_str,
	       block_dev_desc_t **dev_desc)
{
3480f4e4:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
3480f4e8:	e1a05000 	mov	r5, r0
3480f4ec:	e1a04001 	mov	r4, r1
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
3480f4f0:	e1a00001 	mov	r0, r1
	return -1;
}

int get_device(const char *ifname, const char *dev_str,
	       block_dev_desc_t **dev_desc)
{
3480f4f4:	e1a06002 	mov	r6, r2
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
3480f4f8:	e28d1004 	add	r1, sp, #4
3480f4fc:	e3a02010 	mov	r2, #16
3480f500:	eb003562 	bl	3481ca90 <simple_strtoul>
	if (*ep) {
3480f504:	e59d3004 	ldr	r3, [sp, #4]
3480f508:	e5d33000 	ldrb	r3, [r3]
3480f50c:	e3530000 	cmp	r3, #0
		printf("** Bad device specification %s %s **\n",
3480f510:	159f0044 	ldrne	r0, [pc, #68]	; 3480f55c <get_device+0x78>
{
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
	if (*ep) {
3480f514:	1a00000a 	bne	3480f544 <get_device+0x60>
	       block_dev_desc_t **dev_desc)
{
	char *ep;
	int dev;

	dev = simple_strtoul(dev_str, &ep, 16);
3480f518:	e1a07000 	mov	r7, r0
		printf("** Bad device specification %s %s **\n",
		       ifname, dev_str);
		return -1;
	}

	*dev_desc = get_dev(ifname, dev);
3480f51c:	e1a01007 	mov	r1, r7
3480f520:	e1a00005 	mov	r0, r5
3480f524:	ebffff03 	bl	3480f138 <get_dev>
	if (!(*dev_desc) || ((*dev_desc)->type == DEV_TYPE_UNKNOWN)) {
3480f528:	e3500000 	cmp	r0, #0
		printf("** Bad device specification %s %s **\n",
		       ifname, dev_str);
		return -1;
	}

	*dev_desc = get_dev(ifname, dev);
3480f52c:	e5860000 	str	r0, [r6]
	if (!(*dev_desc) || ((*dev_desc)->type == DEV_TYPE_UNKNOWN)) {
3480f530:	0a000002 	beq	3480f540 <get_device+0x5c>
3480f534:	e5d0300b 	ldrb	r3, [r0, #11]
3480f538:	e35300ff 	cmp	r3, #255	; 0xff
3480f53c:	1a000004 	bne	3480f554 <get_device+0x70>
		printf("** Bad device %s %s **\n", ifname, dev_str);
3480f540:	e59f0018 	ldr	r0, [pc, #24]	; 3480f560 <get_device+0x7c>
3480f544:	e1a01005 	mov	r1, r5
3480f548:	e1a02004 	mov	r2, r4
3480f54c:	ebffe704 	bl	34809164 <printf>
		return -1;
3480f550:	e3e07000 	mvn	r7, #0
	}

	return dev;
}
3480f554:	e1a00007 	mov	r0, r7
3480f558:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}
3480f55c:	34826c0d 	.word	0x34826c0d
3480f560:	34826c33 	.word	0x34826c33

3480f564 <get_device_and_partition>:
#define PART_AUTO -1
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
3480f564:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
3480f568:	e2516000 	subs	r6, r1, #0
#define PART_AUTO -1
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
3480f56c:	e24dd058 	sub	sp, sp, #88	; 0x58
3480f570:	e1a09000 	mov	r9, r0
3480f574:	e1a0b002 	mov	fp, r2
3480f578:	e1a05003 	mov	r5, r3
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
3480f57c:	0a000008 	beq	3480f5a4 <get_device_and_partition+0x40>
3480f580:	e1a00006 	mov	r0, r6
3480f584:	eb0031ae 	bl	3481bc44 <strlen>
3480f588:	e3500000 	cmp	r0, #0
3480f58c:	0a000004 	beq	3480f5a4 <get_device_and_partition+0x40>
	    !strcmp(dev_part_str, "-"))
3480f590:	e1a00006 	mov	r0, r6
3480f594:	e59f1280 	ldr	r1, [pc, #640]	; 3480f81c <get_device_and_partition+0x2b8>
3480f598:	eb003175 	bl	3481bb74 <strcmp>
	int p;
	int part;
	disk_partition_t tmpinfo;

	/* If no dev_part_str, use bootdevice environment variable */
	if (!dev_part_str || !strlen(dev_part_str) ||
3480f59c:	e3500000 	cmp	r0, #0
3480f5a0:	1a000007 	bne	3480f5c4 <get_device_and_partition+0x60>
	    !strcmp(dev_part_str, "-"))
		dev_part_str = getenv("bootdevice");
3480f5a4:	e59f0274 	ldr	r0, [pc, #628]	; 3480f820 <get_device_and_partition+0x2bc>
3480f5a8:	ebffdfff 	bl	348075ac <getenv>

	/* If still no dev_part_str, it's an error */
	if (!dev_part_str) {
3480f5ac:	e2506000 	subs	r6, r0, #0
3480f5b0:	1a000003 	bne	3480f5c4 <get_device_and_partition+0x60>
		printf("** No device specified **\n");
3480f5b4:	e59f0268 	ldr	r0, [pc, #616]	; 3480f824 <get_device_and_partition+0x2c0>
3480f5b8:	ebffe6e9 	bl	34809164 <printf>
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
	int ret = -1;
	const char *part_str;
	char *dup_str = NULL;
3480f5bc:	e1a07006 	mov	r7, r6
3480f5c0:	ea00008f 	b	3480f804 <get_device_and_partition+0x2a0>
		printf("** No device specified **\n");
		goto cleanup;
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
3480f5c4:	e1a00006 	mov	r0, r6
3480f5c8:	e3a0103a 	mov	r1, #58	; 0x3a
3480f5cc:	eb003186 	bl	3481bbec <strchr>
	if (part_str) {
3480f5d0:	e2504000 	subs	r4, r0, #0
3480f5d4:	01a0a006 	moveq	sl, r6
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
	int ret = -1;
	const char *part_str;
	char *dup_str = NULL;
3480f5d8:	01a07004 	moveq	r7, r4
		goto cleanup;
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
	if (part_str) {
3480f5dc:	0a000007 	beq	3480f600 <get_device_and_partition+0x9c>
		dup_str = strdup(dev_part_str);
3480f5e0:	e1a00006 	mov	r0, r6
3480f5e4:	eb0031cb 	bl	3481bd18 <strdup>
		dup_str[part_str - dev_part_str] = 0;
3480f5e8:	e0663004 	rsb	r3, r6, r4
3480f5ec:	e3a02000 	mov	r2, #0
	}

	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
	if (part_str) {
		dup_str = strdup(dev_part_str);
3480f5f0:	e1a07000 	mov	r7, r0
		dup_str[part_str - dev_part_str] = 0;
3480f5f4:	e7c02003 	strb	r2, [r0, r3]
		dev_str = dup_str;
		part_str++;
3480f5f8:	e2844001 	add	r4, r4, #1
	/* Separate device and partition ID specification */
	part_str = strchr(dev_part_str, ':');
	if (part_str) {
		dup_str = strdup(dev_part_str);
		dup_str[part_str - dev_part_str] = 0;
		dev_str = dup_str;
3480f5fc:	e1a0a000 	mov	sl, r0
	} else {
		dev_str = dev_part_str;
	}

	/* Look up the device */
	dev = get_device(ifname, dev_str, dev_desc);
3480f600:	e1a00009 	mov	r0, r9
3480f604:	e1a0100a 	mov	r1, sl
3480f608:	e1a0200b 	mov	r2, fp
3480f60c:	ebffffb4 	bl	3480f4e4 <get_device>
	if (dev < 0)
3480f610:	e3500000 	cmp	r0, #0
3480f614:	ba00007a 	blt	3480f804 <get_device_and_partition+0x2a0>
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
3480f618:	e3540000 	cmp	r4, #0
3480f61c:	0a000018 	beq	3480f684 <get_device_and_partition+0x120>
3480f620:	e5d43000 	ldrb	r3, [r4]
3480f624:	e3530000 	cmp	r3, #0
3480f628:	0a000015 	beq	3480f684 <get_device_and_partition+0x120>
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
3480f62c:	e1a00004 	mov	r0, r4
3480f630:	e59f11f0 	ldr	r1, [pc, #496]	; 3480f828 <get_device_and_partition+0x2c4>
3480f634:	eb00314e 	bl	3481bb74 <strcmp>
3480f638:	e3500000 	cmp	r0, #0
		part = PART_AUTO;
3480f63c:	03e04000 	mvneq	r4, #0
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
3480f640:	0a000010 	beq	3480f688 <get_device_and_partition+0x124>
		part = PART_AUTO;
	} else {
		/* Something specified -> use exactly that */
		part = (int)simple_strtoul(part_str, &ep, 16);
3480f644:	e1a00004 	mov	r0, r4
3480f648:	e28d1054 	add	r1, sp, #84	; 0x54
3480f64c:	e3a02010 	mov	r2, #16
3480f650:	eb00350e 	bl	3481ca90 <simple_strtoul>
		/*
		 * Less than whole string converted,
		 * or request for whole device, but caller requires partition.
		 */
		if (*ep || (part == 0 && !allow_whole_dev)) {
3480f654:	e59d3054 	ldr	r3, [sp, #84]	; 0x54
3480f658:	e5d33000 	ldrb	r3, [r3]
3480f65c:	e3530000 	cmp	r3, #0
3480f660:	1a000003 	bne	3480f674 <get_device_and_partition+0x110>
3480f664:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
		part = PART_UNSPECIFIED;
	} else if (!strcmp(part_str, "auto")) {
		part = PART_AUTO;
	} else {
		/* Something specified -> use exactly that */
		part = (int)simple_strtoul(part_str, &ep, 16);
3480f668:	e1a04000 	mov	r4, r0
		/*
		 * Less than whole string converted,
		 * or request for whole device, but caller requires partition.
		 */
		if (*ep || (part == 0 && !allow_whole_dev)) {
3480f66c:	e1902002 	orrs	r2, r0, r2
3480f670:	1a000004 	bne	3480f688 <get_device_and_partition+0x124>
			printf("** Bad partition specification %s %s **\n",
3480f674:	e59f01b0 	ldr	r0, [pc, #432]	; 3480f82c <get_device_and_partition+0x2c8>
3480f678:	e1a01009 	mov	r1, r9
3480f67c:	e1a02006 	mov	r2, r6
3480f680:	ea00000d 	b	3480f6bc <get_device_and_partition+0x158>
	if (dev < 0)
		goto cleanup;

	/* Convert partition ID string to number */
	if (!part_str || !*part_str) {
		part = PART_UNSPECIFIED;
3480f684:	e3e04001 	mvn	r4, #1

	/*
	 * No partition table on device,
	 * or user requested partition 0 (entire device).
	 */
	if (((*dev_desc)->part_type == PART_TYPE_UNKNOWN) ||
3480f688:	e59b0000 	ldr	r0, [fp]
3480f68c:	e5d03008 	ldrb	r3, [r0, #8]
3480f690:	e3530000 	cmp	r3, #0
3480f694:	13540000 	cmpne	r4, #0
3480f698:	13a03000 	movne	r3, #0
3480f69c:	03a03001 	moveq	r3, #1
3480f6a0:	1a000015 	bne	3480f6fc <get_device_and_partition+0x198>
	    (part == 0)) {
		if (!(*dev_desc)->lba) {
3480f6a4:	e5903010 	ldr	r3, [r0, #16]
3480f6a8:	e3530000 	cmp	r3, #0
3480f6ac:	1a000004 	bne	3480f6c4 <get_device_and_partition+0x160>
			printf("** Bad device size - %s %s **\n", ifname,
3480f6b0:	e59f0178 	ldr	r0, [pc, #376]	; 3480f830 <get_device_and_partition+0x2cc>
3480f6b4:	e1a01009 	mov	r1, r9
3480f6b8:	e1a0200a 	mov	r2, sl
3480f6bc:	ebffe6a8 	bl	34809164 <printf>
3480f6c0:	ea00004f 	b	3480f804 <get_device_and_partition+0x2a0>
		/*
		 * If user specified a partition ID other than 0,
		 * or the calling command only accepts partitions,
		 * it's an error.
		 */
		if ((part > 0) || (!allow_whole_dev)) {
3480f6c4:	e59d2078 	ldr	r2, [sp, #120]	; 0x78
3480f6c8:	e2726001 	rsbs	r6, r2, #1
3480f6cc:	33a06000 	movcc	r6, #0
3480f6d0:	e3540000 	cmp	r4, #0
3480f6d4:	c3866001 	orrgt	r6, r6, #1
3480f6d8:	e3560000 	cmp	r6, #0
			printf("** No partition table - %s %s **\n", ifname,
3480f6dc:	159f0150 	ldrne	r0, [pc, #336]	; 3480f834 <get_device_and_partition+0x2d0>
		/*
		 * If user specified a partition ID other than 0,
		 * or the calling command only accepts partitions,
		 * it's an error.
		 */
		if ((part > 0) || (!allow_whole_dev)) {
3480f6e0:	1afffff3 	bne	3480f6b4 <get_device_and_partition+0x150>
			       dev_str);
			goto cleanup;
		}

		info->start = 0;
		info->size = (*dev_desc)->lba;
3480f6e4:	e5853004 	str	r3, [r5, #4]
		info->blksz = (*dev_desc)->blksz;
3480f6e8:	e5903014 	ldr	r3, [r0, #20]
			printf("** No partition table - %s %s **\n", ifname,
			       dev_str);
			goto cleanup;
		}

		info->start = 0;
3480f6ec:	e5856000 	str	r6, [r5]
		info->size = (*dev_desc)->lba;
		info->blksz = (*dev_desc)->blksz;
3480f6f0:	e5853008 	str	r3, [r5, #8]
		info->bootable = 0;
3480f6f4:	e585604c 	str	r6, [r5, #76]	; 0x4c
#ifdef CONFIG_PARTITION_UUIDS
		info->uuid[0] = 0;
#endif

		ret = 0;
		goto cleanup;
3480f6f8:	ea000042 	b	3480f808 <get_device_and_partition+0x2a4>

	/*
	 * Now there's known to be a partition table,
	 * not specifying a partition means to pick partition 1.
	 */
	if (part == PART_UNSPECIFIED)
3480f6fc:	e3740002 	cmn	r4, #2
3480f700:	0a000005 	beq	3480f71c <get_device_and_partition+0x1b8>

	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
3480f704:	e3740001 	cmn	r4, #1
3480f708:	01a04003 	moveq	r4, r3
3480f70c:	03a0a001 	moveq	sl, #1
			 * We now need to search further for best possible.
			 * If we what we just queried was the best so far,
			 * save the info since we over-write it next loop.
			 */
			if (part == p)
				tmpinfo = *info;
3480f710:	028d9004 	addeq	r9, sp, #4

	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
3480f714:	0a00000a 	beq	3480f744 <get_device_and_partition+0x1e0>
3480f718:	ea000000 	b	3480f720 <get_device_and_partition+0x1bc>
	/*
	 * Now there's known to be a partition table,
	 * not specifying a partition means to pick partition 1.
	 */
	if (part == PART_UNSPECIFIED)
		part = 1;
3480f71c:	e3a04001 	mov	r4, #1
	/*
	 * If user didn't specify a partition number, or did specify something
	 * other than "auto", use that partition number directly.
	 */
	if (part != PART_AUTO) {
		ret = get_partition_info(*dev_desc, part, info);
3480f720:	e1a01004 	mov	r1, r4
3480f724:	e1a02005 	mov	r2, r5
3480f728:	ebffff63 	bl	3480f4bc <get_partition_info>
		if (ret) {
3480f72c:	e2506000 	subs	r6, r0, #0
3480f730:	0a000028 	beq	3480f7d8 <get_device_and_partition+0x274>
			printf("** Invalid partition %d **\n", part);
3480f734:	e1a01004 	mov	r1, r4
3480f738:	e59f00f8 	ldr	r0, [pc, #248]	; 3480f838 <get_device_and_partition+0x2d4>
3480f73c:	ebffe688 	bl	34809164 <printf>
			goto cleanup;
3480f740:	ea000030 	b	3480f808 <get_device_and_partition+0x2a4>
		 * Find the first bootable partition.
		 * If none are bootable, fall back to the first valid partition.
		 */
		part = 0;
		for (p = 1; p <= MAX_SEARCH_PARTITIONS; p++) {
			ret = get_partition_info(*dev_desc, p, info);
3480f744:	e59b0000 	ldr	r0, [fp]
3480f748:	e1a0100a 	mov	r1, sl
3480f74c:	e1a02005 	mov	r2, r5
3480f750:	ebffff59 	bl	3480f4bc <get_partition_info>
			if (ret)
3480f754:	e2506000 	subs	r6, r0, #0
3480f758:	1a000011 	bne	3480f7a4 <get_device_and_partition+0x240>

			/*
			 * First valid partition, or new better partition?
			 * If so, save partition ID.
			 */
			if (!part || info->bootable)
3480f75c:	e3540000 	cmp	r4, #0
3480f760:	01a0400a 	moveq	r4, sl
3480f764:	0a000002 	beq	3480f774 <get_device_and_partition+0x210>
3480f768:	e595304c 	ldr	r3, [r5, #76]	; 0x4c
3480f76c:	e3530000 	cmp	r3, #0
3480f770:	11a0400a 	movne	r4, sl
				part = p;

			/* Best possible partition? Stop searching. */
			if (info->bootable)
3480f774:	e595304c 	ldr	r3, [r5, #76]	; 0x4c
3480f778:	e3530000 	cmp	r3, #0
3480f77c:	0a000002 	beq	3480f78c <get_device_and_partition+0x228>
		if (part) {
			/*
			 * If we searched all possible partition IDs,
			 * return the first valid partition we found.
			 */
			if (p == MAX_SEARCH_PARTITIONS + 1)
3480f780:	e35a0011 	cmp	sl, #17
3480f784:	1a000013 	bne	3480f7d8 <get_device_and_partition+0x274>
3480f788:	ea00000a 	b	3480f7b8 <get_device_and_partition+0x254>
			/*
			 * We now need to search further for best possible.
			 * If we what we just queried was the best so far,
			 * save the info since we over-write it next loop.
			 */
			if (part == p)
3480f78c:	e154000a 	cmp	r4, sl
3480f790:	1a000003 	bne	3480f7a4 <get_device_and_partition+0x240>
				tmpinfo = *info;
3480f794:	e1a00009 	mov	r0, r9
3480f798:	e1a01005 	mov	r1, r5
3480f79c:	e3a02050 	mov	r2, #80	; 0x50
3480f7a0:	eb0031eb 	bl	3481bf54 <memcpy>
		/*
		 * Find the first bootable partition.
		 * If none are bootable, fall back to the first valid partition.
		 */
		part = 0;
		for (p = 1; p <= MAX_SEARCH_PARTITIONS; p++) {
3480f7a4:	e28aa001 	add	sl, sl, #1
3480f7a8:	e35a0011 	cmp	sl, #17
3480f7ac:	1affffe4 	bne	3480f744 <get_device_and_partition+0x1e0>
			 */
			if (part == p)
				tmpinfo = *info;
		}
		/* If we found any acceptable partition */
		if (part) {
3480f7b0:	e3540000 	cmp	r4, #0
3480f7b4:	0a000004 	beq	3480f7cc <get_device_and_partition+0x268>
			/*
			 * If we searched all possible partition IDs,
			 * return the first valid partition we found.
			 */
			if (p == MAX_SEARCH_PARTITIONS + 1)
				*info = tmpinfo;
3480f7b8:	e1a00005 	mov	r0, r5
3480f7bc:	e28d1004 	add	r1, sp, #4
3480f7c0:	e3a02050 	mov	r2, #80	; 0x50
3480f7c4:	eb0031e2 	bl	3481bf54 <memcpy>
3480f7c8:	ea000002 	b	3480f7d8 <get_device_and_partition+0x274>
			ret = 0;
		} else {
			printf("** No valid partitions found **\n");
3480f7cc:	e59f0068 	ldr	r0, [pc, #104]	; 3480f83c <get_device_and_partition+0x2d8>
3480f7d0:	ebffe663 	bl	34809164 <printf>
			goto cleanup;
3480f7d4:	ea00000b 	b	3480f808 <get_device_and_partition+0x2a4>
		}
	}
	if (strncmp((char *)info->type, BOOT_PART_TYPE, sizeof(info->type)) != 0) {
3480f7d8:	e285502c 	add	r5, r5, #44	; 0x2c
3480f7dc:	e1a00005 	mov	r0, r5
3480f7e0:	e59f1058 	ldr	r1, [pc, #88]	; 3480f840 <get_device_and_partition+0x2dc>
3480f7e4:	e3a02020 	mov	r2, #32
3480f7e8:	eb0030ed 	bl	3481bba4 <strncmp>
3480f7ec:	e3500000 	cmp	r0, #0
			info->type);
		ret  = -1;
		goto cleanup;
	}

	ret = part;
3480f7f0:	01a06004 	moveq	r6, r4
		} else {
			printf("** No valid partitions found **\n");
			goto cleanup;
		}
	}
	if (strncmp((char *)info->type, BOOT_PART_TYPE, sizeof(info->type)) != 0) {
3480f7f4:	0a000003 	beq	3480f808 <get_device_and_partition+0x2a4>
		printf("** Invalid partition type \"%.32s\""
3480f7f8:	e59f0044 	ldr	r0, [pc, #68]	; 3480f844 <get_device_and_partition+0x2e0>
3480f7fc:	e1a01005 	mov	r1, r5
3480f800:	ebffe657 	bl	34809164 <printf>
#define MAX_SEARCH_PARTITIONS 16
int get_device_and_partition(const char *ifname, const char *dev_part_str,
			     block_dev_desc_t **dev_desc,
			     disk_partition_t *info, int allow_whole_dev)
{
	int ret = -1;
3480f804:	e3e06000 	mvn	r6, #0

	ret = part;
	goto cleanup;

cleanup:
	free(dup_str);
3480f808:	e1a00007 	mov	r0, r7
3480f80c:	ebffe792 	bl	3480965c <free>
	return ret;
}
3480f810:	e1a00006 	mov	r0, r6
3480f814:	e28dd058 	add	sp, sp, #88	; 0x58
3480f818:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480f81c:	34827481 	.word	0x34827481
3480f820:	34826c4b 	.word	0x34826c4b
3480f824:	34826c56 	.word	0x34826c56
3480f828:	34826c71 	.word	0x34826c71
3480f82c:	34826c76 	.word	0x34826c76
3480f830:	34826c9f 	.word	0x34826c9f
3480f834:	34826cbe 	.word	0x34826cbe
3480f838:	34826ce0 	.word	0x34826ce0
3480f83c:	34826cfc 	.word	0x34826cfc
3480f840:	348268e2 	.word	0x348268e2
3480f844:	34826d1d 	.word	0x34826d1d

3480f848 <le32_to_int>:
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
3480f848:	e5d03002 	ldrb	r3, [r0, #2]

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
3480f84c:	e5d02003 	ldrb	r2, [r0, #3]
	    (le32[2] << 16) +
3480f850:	e1a03803 	lsl	r3, r3, #16

/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
3480f854:	e0833c02 	add	r3, r3, r2, lsl #24
	    (le32[2] << 16) +
	    (le32[1] << 8) +
3480f858:	e5d02000 	ldrb	r2, [r0]
3480f85c:	e5d00001 	ldrb	r0, [r0, #1]
/* Convert char[4] in little endian format to the host format integer
 */
static inline int le32_to_int(unsigned char *le32)
{
    return ((le32[3] << 24) +
	    (le32[2] << 16) +
3480f860:	e0833002 	add	r3, r3, r2
	    (le32[1] << 8) +
	     le32[0]
	   );
}
3480f864:	e0830400 	add	r0, r3, r0, lsl #8
3480f868:	e12fff1e 	bx	lr

3480f86c <is_extended>:

static inline int is_extended(int part_type)
{
    return (part_type == 0x5 ||
3480f86c:	e3500005 	cmp	r0, #5
3480f870:	1350000f 	cmpne	r0, #15
3480f874:	0a000003 	beq	3480f888 <is_extended+0x1c>
3480f878:	e3500085 	cmp	r0, #133	; 0x85
3480f87c:	13a00000 	movne	r0, #0
3480f880:	03a00001 	moveq	r0, #1
3480f884:	e12fff1e 	bx	lr
3480f888:	e3a00001 	mov	r0, #1
	    part_type == 0xf ||
	    part_type == 0x85);
}
3480f88c:	e12fff1e 	bx	lr

3480f890 <test_block_type>:
		(is_extended(p->sys_ind) ? " Extd" : ""),
		(is_bootable(p) ? " Boot" : ""));
}

static int test_block_type(unsigned char *buffer)
{
3480f890:	e92d4010 	push	{r4, lr}
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
3480f894:	e5d031fe 	ldrb	r3, [r0, #510]	; 0x1fe
		(is_extended(p->sys_ind) ? " Extd" : ""),
		(is_bootable(p) ? " Boot" : ""));
}

static int test_block_type(unsigned char *buffer)
{
3480f898:	e1a04000 	mov	r4, r0
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
3480f89c:	e3530055 	cmp	r3, #85	; 0x55
3480f8a0:	1a00000f 	bne	3480f8e4 <test_block_type+0x54>
3480f8a4:	e5d031ff 	ldrb	r3, [r0, #511]	; 0x1ff
3480f8a8:	e35300aa 	cmp	r3, #170	; 0xaa
3480f8ac:	1a00000c 	bne	3480f8e4 <test_block_type+0x54>
	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
		return (-1);
	} /* no DOS Signature at all */
	if (strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],"FAT",3)==0 ||
3480f8b0:	e2800036 	add	r0, r0, #54	; 0x36
3480f8b4:	e59f1038 	ldr	r1, [pc, #56]	; 3480f8f4 <test_block_type+0x64>
3480f8b8:	e3a02003 	mov	r2, #3
3480f8bc:	eb0030b8 	bl	3481bba4 <strncmp>
3480f8c0:	e3500000 	cmp	r0, #0
3480f8c4:	0a000008 	beq	3480f8ec <test_block_type+0x5c>
	    strncmp((char *)&buffer[DOS_PBR32_FSTYPE_OFFSET],"FAT32",5)==0) {
3480f8c8:	e2840052 	add	r0, r4, #82	; 0x52
3480f8cc:	e59f1024 	ldr	r1, [pc, #36]	; 3480f8f8 <test_block_type+0x68>
3480f8d0:	e3a02005 	mov	r2, #5
3480f8d4:	eb0030b2 	bl	3481bba4 <strncmp>

static int test_block_type(unsigned char *buffer)
{
	if((buffer[DOS_PART_MAGIC_OFFSET + 0] != 0x55) ||
	    (buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) ) {
		return (-1);
3480f8d8:	e2700001 	rsbs	r0, r0, #1
3480f8dc:	33a00000 	movcc	r0, #0
3480f8e0:	e8bd8010 	pop	{r4, pc}
3480f8e4:	e3e00000 	mvn	r0, #0
3480f8e8:	e8bd8010 	pop	{r4, pc}
	} /* no DOS Signature at all */
	if (strncmp((char *)&buffer[DOS_PBR_FSTYPE_OFFSET],"FAT",3)==0 ||
	    strncmp((char *)&buffer[DOS_PBR32_FSTYPE_OFFSET],"FAT32",5)==0) {
		return DOS_PBR; /* is PBR */
3480f8ec:	e3a00001 	mov	r0, #1
	}
	return DOS_MBR;	    /* Is MBR */
}
3480f8f0:	e8bd8010 	pop	{r4, pc}
3480f8f4:	34826d52 	.word	0x34826d52
3480f8f8:	34826d56 	.word	0x34826d56

3480f8fc <print_partition_extended>:

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
3480f8fc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480f900:	e28db01c 	add	fp, sp, #28
3480f904:	e24dd020 	sub	sp, sp, #32
3480f908:	e1a0a003 	mov	sl, r3
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480f90c:	e5903014 	ldr	r3, [r0, #20]

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
3480f910:	e50b2024 	str	r2, [fp, #-36]	; 0x24
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480f914:	e283303f 	add	r3, r3, #63	; 0x3f
3480f918:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3480f91c:	e2833048 	add	r3, r3, #72	; 0x48
3480f920:	e04dd003 	sub	sp, sp, r3
3480f924:	e28d504f 	add	r5, sp, #79	; 0x4f
3480f928:	e3c5503f 	bic	r5, r5, #63	; 0x3f
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480f92c:	e590c060 	ldr	ip, [r0, #96]	; 0x60

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
3480f930:	e1a04000 	mov	r4, r0
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480f934:	e3a02001 	mov	r2, #1
3480f938:	e5900004 	ldr	r0, [r0, #4]
3480f93c:	e1a03005 	mov	r3, r5

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
							   int part_num)
{
3480f940:	e1a07001 	mov	r7, r1
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read(dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480f944:	e12fff3c 	blx	ip
3480f948:	e3500001 	cmp	r0, #1
		printf ("** Can't read partition table on %d:%d **\n",
3480f94c:	159f0158 	ldrne	r0, [pc, #344]	; 3480faac <print_partition_extended+0x1b0>
3480f950:	15941004 	ldrne	r1, [r4, #4]
3480f954:	11a02007 	movne	r2, r7
3480f958:	1a000006 	bne	3480f978 <print_partition_extended+0x7c>
			dev_desc->dev, ext_part_sector);
		return;
	}
	i=test_block_type(buffer);
3480f95c:	e1a00005 	mov	r0, r5
3480f960:	ebffffca 	bl	3480f890 <test_block_type>
	if (i != DOS_MBR) {
3480f964:	e3500000 	cmp	r0, #0
3480f968:	0a000004 	beq	3480f980 <print_partition_extended+0x84>
		printf ("bad MBR sector signature 0x%02x%02x\n",
3480f96c:	e59f013c 	ldr	r0, [pc, #316]	; 3480fab0 <print_partition_extended+0x1b4>
3480f970:	e5d511fe 	ldrb	r1, [r5, #510]	; 0x1fe
3480f974:	e5d521ff 	ldrb	r2, [r5, #511]	; 0x1ff
3480f978:	ebffe5f9 	bl	34809164 <printf>
3480f97c:	ea000048 	b	3480faa4 <print_partition_extended+0x1a8>
			buffer[DOS_PART_MAGIC_OFFSET + 1]);
		return;
	}

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
3480f980:	e2856f6f 	add	r6, r5, #444	; 0x1bc
3480f984:	e2866002 	add	r6, r6, #2
	return 0;
}

/*  Print a partition that is relative to its Extended partition table
 */
static void print_partition_extended (block_dev_desc_t *dev_desc, int ext_part_sector, int relative,
3480f988:	e2855f7b 	add	r5, r5, #492	; 0x1ec
3480f98c:	e2859002 	add	r9, r5, #2
			buffer[DOS_PART_MAGIC_OFFSET + 1]);
		return;
	}

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
3480f990:	e1a05006 	mov	r5, r6
		/*
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */

		if ((pt->sys_ind != 0) &&
3480f994:	e5d51004 	ldrb	r1, [r5, #4]
3480f998:	e3510000 	cmp	r1, #0
3480f99c:	e50b1020 	str	r1, [fp, #-32]
3480f9a0:	0a000022 	beq	3480fa30 <print_partition_extended+0x134>
3480f9a4:	e3570000 	cmp	r7, #0
3480f9a8:	0a000003 	beq	3480f9bc <print_partition_extended+0xc0>
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
3480f9ac:	e1a00001 	mov	r0, r1
3480f9b0:	ebffffad 	bl	3480f86c <is_extended>
3480f9b4:	e3500000 	cmp	r0, #0
3480f9b8:	1a00001e 	bne	3480fa38 <print_partition_extended+0x13c>
	return p->boot_ind == 0x80;
}

static void print_one_part (dos_partition_t *p, int ext_part_sector, int part_num)
{
	int lba_start = ext_part_sector + le32_to_int (p->start4);
3480f9bc:	e2850008 	add	r0, r5, #8
3480f9c0:	ebffffa0 	bl	3480f848 <le32_to_int>
3480f9c4:	e0802007 	add	r2, r0, r7
	int lba_size  = le32_to_int (p->size4);
3480f9c8:	e285000c 	add	r0, r5, #12
3480f9cc:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
3480f9d0:	ebffff9c 	bl	3480f848 <le32_to_int>
3480f9d4:	e1a03000 	mov	r3, r0

	printf("%5d\t\t%10d\t%10d\t%2x%s%s\n",
		part_num, lba_start, lba_size, p->sys_ind,
		(is_extended(p->sys_ind) ? " Extd" : ""),
3480f9d8:	e51b0020 	ldr	r0, [fp, #-32]
3480f9dc:	e50b3028 	str	r3, [fp, #-40]	; 0x28
3480f9e0:	ebffffa1 	bl	3480f86c <is_extended>
static void print_one_part (dos_partition_t *p, int ext_part_sector, int part_num)
{
	int lba_start = ext_part_sector + le32_to_int (p->start4);
	int lba_size  = le32_to_int (p->size4);

	printf("%5d\t\t%10d\t%10d\t%2x%s%s\n",
3480f9e4:	e59fe0c8 	ldr	lr, [pc, #200]	; 3480fab4 <print_partition_extended+0x1b8>
3480f9e8:	e5d51000 	ldrb	r1, [r5]
3480f9ec:	e59fc0c4 	ldr	ip, [pc, #196]	; 3480fab8 <print_partition_extended+0x1bc>
3480f9f0:	e3500000 	cmp	r0, #0
3480f9f4:	11a0c00e 	movne	ip, lr
3480f9f8:	e59fe0bc 	ldr	lr, [pc, #188]	; 3480fabc <print_partition_extended+0x1c0>
3480f9fc:	e1a0000c 	mov	r0, ip
3480fa00:	e3510080 	cmp	r1, #128	; 0x80
3480fa04:	e59fc0ac 	ldr	ip, [pc, #172]	; 3480fab8 <print_partition_extended+0x1bc>
3480fa08:	01a0c00e 	moveq	ip, lr
3480fa0c:	e1a0100c 	mov	r1, ip
3480fa10:	e51bc020 	ldr	ip, [fp, #-32]
3480fa14:	e98d0003 	stmib	sp, {r0, r1}
3480fa18:	e59f00a0 	ldr	r0, [pc, #160]	; 3480fac0 <print_partition_extended+0x1c4>
3480fa1c:	e1a0100a 	mov	r1, sl
3480fa20:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
3480fa24:	e51b3028 	ldr	r3, [fp, #-40]	; 0x28
3480fa28:	e58dc000 	str	ip, [sp]
3480fa2c:	ebffe5cc 	bl	34809164 <printf>
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
			print_one_part (pt, ext_part_sector, part_num);
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
3480fa30:	e3570000 	cmp	r7, #0
3480fa34:	0a000005 	beq	3480fa50 <print_partition_extended+0x154>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
3480fa38:	e5d50004 	ldrb	r0, [r5, #4]
		    (ext_part_sector == 0 || !is_extended (pt->sys_ind)) ) {
			print_one_part (pt, ext_part_sector, part_num);
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
3480fa3c:	e3500000 	cmp	r0, #0
3480fa40:	0a000003 	beq	3480fa54 <print_partition_extended+0x158>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
3480fa44:	ebffff88 	bl	3480f86c <is_extended>
3480fa48:	e3500000 	cmp	r0, #0
3480fa4c:	1a000000 	bne	3480fa54 <print_partition_extended+0x158>
			part_num++;
3480fa50:	e28aa001 	add	sl, sl, #1
		return;
	}

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
3480fa54:	e1550009 	cmp	r5, r9
3480fa58:	12855010 	addne	r5, r5, #16
3480fa5c:	1affffcc 	bne	3480f994 <print_partition_extended+0x98>
3480fa60:	e51b5024 	ldr	r5, [fp, #-36]	; 0x24
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
3480fa64:	e5d60004 	ldrb	r0, [r6, #4]
3480fa68:	ebffff7f 	bl	3480f86c <is_extended>
3480fa6c:	e3500000 	cmp	r0, #0
3480fa70:	0a000008 	beq	3480fa98 <print_partition_extended+0x19c>
			int lba_start = le32_to_int (pt->start4) + relative;
3480fa74:	e2860008 	add	r0, r6, #8
3480fa78:	ebffff72 	bl	3480f848 <le32_to_int>

			print_partition_extended (dev_desc, lba_start,
3480fa7c:	e3570000 	cmp	r7, #0

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
			int lba_start = le32_to_int (pt->start4) + relative;
3480fa80:	e0801005 	add	r1, r0, r5

			print_partition_extended (dev_desc, lba_start,
3480fa84:	11a02005 	movne	r2, r5
3480fa88:	e1a00004 	mov	r0, r4
3480fa8c:	01a02001 	moveq	r2, r1
3480fa90:	e1a0300a 	mov	r3, sl
3480fa94:	ebffff98 	bl	3480f8fc <print_partition_extended>
		}
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
3480fa98:	e1560009 	cmp	r6, r9
3480fa9c:	12866010 	addne	r6, r6, #16
3480faa0:	1affffef 	bne	3480fa64 <print_partition_extended+0x168>
						  part_num);
		}
	}

	return;
}
3480faa4:	e24bd01c 	sub	sp, fp, #28
3480faa8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480faac:	34826d68 	.word	0x34826d68
3480fab0:	34826d93 	.word	0x34826d93
3480fab4:	34826d5c 	.word	0x34826d5c
3480fab8:	34823cce 	.word	0x34823cce
3480fabc:	34826d62 	.word	0x34826d62
3480fac0:	34826db8 	.word	0x34826db8

3480fac4 <get_partition_info_extended.clone.1>:


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3480fac4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3480fac8:	e28db01c 	add	fp, sp, #28
3480facc:	e24dd010 	sub	sp, sp, #16
3480fad0:	e1a06003 	mov	r6, r3
				 int relative, int part_num,
				 int which_part, disk_partition_t *info,
				 unsigned int disksig)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480fad4:	e5903014 	ldr	r3, [r0, #20]
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480fad8:	e590c060 	ldr	ip, [r0, #96]	; 0x60
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
				 int relative, int part_num,
				 int which_part, disk_partition_t *info,
				 unsigned int disksig)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480fadc:	e283303f 	add	r3, r3, #63	; 0x3f
3480fae0:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3480fae4:	e2833048 	add	r3, r3, #72	; 0x48
3480fae8:	e04dd003 	sub	sp, sp, r3
3480faec:	e28d4047 	add	r4, sp, #71	; 0x47
3480faf0:	e3c4403f 	bic	r4, r4, #63	; 0x3f
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3480faf4:	e1a05000 	mov	r5, r0
3480faf8:	e1a09002 	mov	r9, r2
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480fafc:	e5900004 	ldr	r0, [r0, #4]
3480fb00:	e3a02001 	mov	r2, #1
3480fb04:	e1a03004 	mov	r3, r4
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3480fb08:	e1a0a001 	mov	sl, r1
3480fb0c:	e59b7008 	ldr	r7, [fp, #8]
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
	dos_partition_t *pt;
	int i;

	if (dev_desc->block_read (dev_desc->dev, ext_part_sector, 1, (ulong *) buffer) != 1) {
3480fb10:	e12fff3c 	blx	ip
3480fb14:	e3500001 	cmp	r0, #1
		printf ("** Can't read partition table on %d:%d **\n",
3480fb18:	159f01e8 	ldrne	r0, [pc, #488]	; 3480fd08 <get_partition_info_extended.clone.1+0x244>
3480fb1c:	15951004 	ldrne	r1, [r5, #4]
3480fb20:	11a0200a 	movne	r2, sl
3480fb24:	1a000007 	bne	3480fb48 <get_partition_info_extended.clone.1+0x84>
			dev_desc->dev, ext_part_sector);
		return -1;
	}
	if (buffer[DOS_PART_MAGIC_OFFSET] != 0x55 ||
3480fb28:	e5d411fe 	ldrb	r1, [r4, #510]	; 0x1fe
3480fb2c:	e3510055 	cmp	r1, #85	; 0x55
3480fb30:	1a000002 	bne	3480fb40 <get_partition_info_extended.clone.1+0x7c>
3480fb34:	e5d431ff 	ldrb	r3, [r4, #511]	; 0x1ff
3480fb38:	e35300aa 	cmp	r3, #170	; 0xaa
3480fb3c:	0a000003 	beq	3480fb50 <get_partition_info_extended.clone.1+0x8c>
		buffer[DOS_PART_MAGIC_OFFSET + 1] != 0xaa) {
		printf ("bad MBR sector signature 0x%02x%02x\n",
3480fb40:	e59f01c4 	ldr	r0, [pc, #452]	; 3480fd0c <get_partition_info_extended.clone.1+0x248>
3480fb44:	e5d421ff 	ldrb	r2, [r4, #511]	; 0x1ff
3480fb48:	ebffe585 	bl	34809164 <printf>
3480fb4c:	ea00006a 	b	3480fcfc <get_partition_info_extended.clone.1+0x238>
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
3480fb50:	e2843f6f 	add	r3, r4, #444	; 0x1bc
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3480fb54:	e2844f7b 	add	r4, r4, #492	; 0x1ec
3480fb58:	e2844002 	add	r4, r4, #2
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
3480fb5c:	e2833002 	add	r3, r3, #2
}


/*  Print a partition that is relative to its Extended partition table
 */
static int get_partition_info_extended (block_dev_desc_t *dev_desc, int ext_part_sector,
3480fb60:	e50b4020 	str	r4, [fp, #-32]
	if (!ext_part_sector)
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
3480fb64:	e1a04003 	mov	r4, r3
	for (i = 0; i < 4; i++, pt++) {
		/*
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */
		if (((pt->boot_ind & ~0x80) == 0) &&
3480fb68:	e5d42000 	ldrb	r2, [r4]
3480fb6c:	e312007f 	tst	r2, #127	; 0x7f
3480fb70:	1a00003b 	bne	3480fc64 <get_partition_info_extended.clone.1+0x1a0>
		    (pt->sys_ind != 0) &&
3480fb74:	e5d40004 	ldrb	r0, [r4, #4]
3480fb78:	e59b1004 	ldr	r1, [fp, #4]
3480fb7c:	e1560001 	cmp	r6, r1
3480fb80:	13a02000 	movne	r2, #0
3480fb84:	03a02001 	moveq	r2, #1
3480fb88:	e3500000 	cmp	r0, #0
3480fb8c:	03a02000 	moveq	r2, #0
3480fb90:	e3520000 	cmp	r2, #0
3480fb94:	0a000032 	beq	3480fc64 <get_partition_info_extended.clone.1+0x1a0>
		    (part_num == which_part) &&
		    (is_extended(pt->sys_ind) == 0)) {
3480fb98:	e50b3024 	str	r3, [fp, #-36]	; 0x24
3480fb9c:	ebffff32 	bl	3480f86c <is_extended>
		 * fdisk does not show the extended partitions that
		 * are not in the MBR
		 */
		if (((pt->boot_ind & ~0x80) == 0) &&
		    (pt->sys_ind != 0) &&
		    (part_num == which_part) &&
3480fba0:	e3500000 	cmp	r0, #0
3480fba4:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
3480fba8:	1a00002d 	bne	3480fc64 <get_partition_info_extended.clone.1+0x1a0>
		    (is_extended(pt->sys_ind) == 0)) {
			info->blksz = 512;
3480fbac:	e3a03c02 	mov	r3, #512	; 0x200
3480fbb0:	e5873008 	str	r3, [r7, #8]
			info->start = ext_part_sector + le32_to_int (pt->start4);
3480fbb4:	e2840008 	add	r0, r4, #8
3480fbb8:	ebffff22 	bl	3480f848 <le32_to_int>
3480fbbc:	e080000a 	add	r0, r0, sl
3480fbc0:	e5870000 	str	r0, [r7]
			info->size  = le32_to_int (pt->size4);
3480fbc4:	e284000c 	add	r0, r4, #12
3480fbc8:	ebffff1e 	bl	3480f848 <le32_to_int>
			switch(dev_desc->if_type) {
3480fbcc:	e5953000 	ldr	r3, [r5]
		    (pt->sys_ind != 0) &&
		    (part_num == which_part) &&
		    (is_extended(pt->sys_ind) == 0)) {
			info->blksz = 512;
			info->start = ext_part_sector + le32_to_int (pt->start4);
			info->size  = le32_to_int (pt->size4);
3480fbd0:	e5870004 	str	r0, [r7, #4]
			switch(dev_desc->if_type) {
3480fbd4:	e2433001 	sub	r3, r3, #1
3480fbd8:	e287000c 	add	r0, r7, #12
3480fbdc:	e5952004 	ldr	r2, [r5, #4]
3480fbe0:	e3530007 	cmp	r3, #7
3480fbe4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3480fbe8:	ea00000f 	b	3480fc2c <get_partition_info_extended.clone.1+0x168>
3480fbec:	3480fc0c 	.word	0x3480fc0c
3480fbf0:	3480fc14 	.word	0x3480fc14
3480fbf4:	3480fc0c 	.word	0x3480fc0c
3480fbf8:	3480fc1c 	.word	0x3480fc1c
3480fbfc:	3480fc24 	.word	0x3480fc24
3480fc00:	3480fc2c 	.word	0x3480fc2c
3480fc04:	3480fc2c 	.word	0x3480fc2c
3480fc08:	3480fc0c 	.word	0x3480fc0c
				case IF_TYPE_IDE:
				case IF_TYPE_SATA:
				case IF_TYPE_ATAPI:
					sprintf ((char *)info->name, "hd%c%d",
3480fc0c:	e59f10fc 	ldr	r1, [pc, #252]	; 3480fd10 <get_partition_info_extended.clone.1+0x24c>
3480fc10:	ea000006 	b	3480fc30 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_SCSI:
					sprintf ((char *)info->name, "sd%c%d",
3480fc14:	e59f10f8 	ldr	r1, [pc, #248]	; 3480fd14 <get_partition_info_extended.clone.1+0x250>
3480fc18:	ea000004 	b	3480fc30 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_USB:
					sprintf ((char *)info->name, "usbd%c%d",
3480fc1c:	e59f10f4 	ldr	r1, [pc, #244]	; 3480fd18 <get_partition_info_extended.clone.1+0x254>
3480fc20:	ea000002 	b	3480fc30 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				case IF_TYPE_DOC:
					sprintf ((char *)info->name, "docd%c%d",
3480fc24:	e59f10f0 	ldr	r1, [pc, #240]	; 3480fd1c <get_partition_info_extended.clone.1+0x258>
3480fc28:	ea000000 	b	3480fc30 <get_partition_info_extended.clone.1+0x16c>
						'a' + dev_desc->dev, part_num);
					break;
				default:
					sprintf ((char *)info->name, "xx%c%d",
3480fc2c:	e59f10ec 	ldr	r1, [pc, #236]	; 3480fd20 <get_partition_info_extended.clone.1+0x25c>
3480fc30:	e1a03006 	mov	r3, r6
3480fc34:	e2822061 	add	r2, r2, #97	; 0x61
3480fc38:	eb00343a 	bl	3481cd28 <sprintf>
						'a' + dev_desc->dev, part_num);
					break;
			}
			/* sprintf(info->type, "%d, pt->sys_ind); */
			sprintf ((char *)info->type, "U-Boot");
3480fc3c:	e287002c 	add	r0, r7, #44	; 0x2c
3480fc40:	e59f10dc 	ldr	r1, [pc, #220]	; 3480fd24 <get_partition_info_extended.clone.1+0x260>
3480fc44:	eb003437 	bl	3481cd28 <sprintf>
	    part_type == 0x85);
}

static inline int is_bootable(dos_partition_t *p)
{
	return p->boot_ind == 0x80;
3480fc48:	e5d43000 	ldrb	r3, [r4]
			sprintf ((char *)info->type, "U-Boot");
			info->bootable = is_bootable(pt);
#ifdef CONFIG_PARTITION_UUIDS
			sprintf(info->uuid, "%08x-%02x", disksig, part_num);
#endif
			return 0;
3480fc4c:	e3a00000 	mov	r0, #0
	    part_type == 0x85);
}

static inline int is_bootable(dos_partition_t *p)
{
	return p->boot_ind == 0x80;
3480fc50:	e3530080 	cmp	r3, #128	; 0x80
3480fc54:	13a03000 	movne	r3, #0
3480fc58:	03a03001 	moveq	r3, #1
						'a' + dev_desc->dev, part_num);
					break;
			}
			/* sprintf(info->type, "%d, pt->sys_ind); */
			sprintf ((char *)info->type, "U-Boot");
			info->bootable = is_bootable(pt);
3480fc5c:	e587304c 	str	r3, [r7, #76]	; 0x4c
3480fc60:	ea000026 	b	3480fd00 <get_partition_info_extended.clone.1+0x23c>
#endif
			return 0;
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
3480fc64:	e35a0000 	cmp	sl, #0
3480fc68:	0a000007 	beq	3480fc8c <get_partition_info_extended.clone.1+0x1c8>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
3480fc6c:	e5d40004 	ldrb	r0, [r4, #4]
#endif
			return 0;
		}

		/* Reverse engr the fdisk part# assignment rule! */
		if ((ext_part_sector == 0) ||
3480fc70:	e3500000 	cmp	r0, #0
3480fc74:	0a000005 	beq	3480fc90 <get_partition_info_extended.clone.1+0x1cc>
		    (pt->sys_ind != 0 && !is_extended (pt->sys_ind)) ) {
3480fc78:	e50b3024 	str	r3, [fp, #-36]	; 0x24
3480fc7c:	ebfffefa 	bl	3480f86c <is_extended>
3480fc80:	e3500000 	cmp	r0, #0
3480fc84:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
3480fc88:	1a000000 	bne	3480fc90 <get_partition_info_extended.clone.1+0x1cc>
			part_num++;
3480fc8c:	e2866001 	add	r6, r6, #1
		disksig = le32_to_int(&buffer[DOS_PART_DISKSIG_OFFSET]);
#endif

	/* Print all primary/logical partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
3480fc90:	e51b2020 	ldr	r2, [fp, #-32]
3480fc94:	e1540002 	cmp	r4, r2
3480fc98:	12844010 	addne	r4, r4, #16
3480fc9c:	1affffb1 	bne	3480fb68 <get_partition_info_extended.clone.1+0xa4>
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
3480fca0:	e5d30004 	ldrb	r0, [r3, #4]
3480fca4:	e50b3024 	str	r3, [fp, #-36]	; 0x24
3480fca8:	ebfffeef 	bl	3480f86c <is_extended>
3480fcac:	e3500000 	cmp	r0, #0
3480fcb0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
3480fcb4:	0a00000c 	beq	3480fcec <get_partition_info_extended.clone.1+0x228>
			int lba_start = le32_to_int (pt->start4) + relative;
3480fcb8:	e2830008 	add	r0, r3, #8
3480fcbc:	ebfffee1 	bl	3480f848 <le32_to_int>

			return get_partition_info_extended (dev_desc, lba_start,
3480fcc0:	e59b3004 	ldr	r3, [fp, #4]

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
		if (is_extended (pt->sys_ind)) {
			int lba_start = le32_to_int (pt->start4) + relative;
3480fcc4:	e0801009 	add	r1, r0, r9

			return get_partition_info_extended (dev_desc, lba_start,
3480fcc8:	e35a0000 	cmp	sl, #0
3480fccc:	e58d3000 	str	r3, [sp]
3480fcd0:	e1a00005 	mov	r0, r5
3480fcd4:	11a02009 	movne	r2, r9
3480fcd8:	01a02001 	moveq	r2, r1
3480fcdc:	e1a03006 	mov	r3, r6
3480fce0:	e58d7004 	str	r7, [sp, #4]
3480fce4:	ebffff76 	bl	3480fac4 <get_partition_info_extended.clone.1>
3480fce8:	ea000004 	b	3480fd00 <get_partition_info_extended.clone.1+0x23c>
		}
	}

	/* Follows the extended partitions */
	pt = (dos_partition_t *) (buffer + DOS_PART_TBL_OFFSET);
	for (i = 0; i < 4; i++, pt++) {
3480fcec:	e51b1020 	ldr	r1, [fp, #-32]
3480fcf0:	e1530001 	cmp	r3, r1
3480fcf4:	12833010 	addne	r3, r3, #16
3480fcf8:	1affffe8 	bne	3480fca0 <get_partition_info_extended.clone.1+0x1dc>
			return get_partition_info_extended (dev_desc, lba_start,
				 ext_part_sector == 0 ? lba_start : relative,
				 part_num, which_part, info, disksig);
		}
	}
	return -1;
3480fcfc:	e3e00000 	mvn	r0, #0
}
3480fd00:	e24bd01c 	sub	sp, fp, #28
3480fd04:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3480fd08:	34826d68 	.word	0x34826d68
3480fd0c:	34826d93 	.word	0x34826d93
3480fd10:	34826dd0 	.word	0x34826dd0
3480fd14:	34826dd7 	.word	0x34826dd7
3480fd18:	34826dde 	.word	0x34826dde
3480fd1c:	34826de7 	.word	0x34826de7
3480fd20:	34826df0 	.word	0x34826df0
3480fd24:	348268e2 	.word	0x348268e2

3480fd28 <test_part_dos>:
	return DOS_MBR;	    /* Is MBR */
}


int test_part_dos (block_dev_desc_t *dev_desc)
{
3480fd28:	e92d4818 	push	{r3, r4, fp, lr}
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480fd2c:	e5903014 	ldr	r3, [r0, #20]
	return DOS_MBR;	    /* Is MBR */
}


int test_part_dos (block_dev_desc_t *dev_desc)
{
3480fd30:	e28db00c 	add	fp, sp, #12
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);
3480fd34:	e283303f 	add	r3, r3, #63	; 0x3f
3480fd38:	e3c3303f 	bic	r3, r3, #63	; 0x3f
3480fd3c:	e2833048 	add	r3, r3, #72	; 0x48
3480fd40:	e04dd003 	sub	sp, sp, r3
3480fd44:	e28d403f 	add	r4, sp, #63	; 0x3f
3480fd48:	e3c4403f 	bic	r4, r4, #63	; 0x3f

	if (dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1)
3480fd4c:	e590c060 	ldr	ip, [r0, #96]	; 0x60
3480fd50:	e3a01000 	mov	r1, #0
3480fd54:	e5900004 	ldr	r0, [r0, #4]
3480fd58:	e3a02001 	mov	r2, #1
3480fd5c:	e1a03004 	mov	r3, r4
3480fd60:	e12fff3c 	blx	ip
3480fd64:	e3500001 	cmp	r0, #1
		return -1;
3480fd68:	13e00000 	mvnne	r0, #0

int test_part_dos (block_dev_desc_t *dev_desc)
{
	ALLOC_CACHE_ALIGN_BUFFER(unsigned char, buffer, dev_desc->blksz);

	if (dev_desc->block_read(dev_desc->dev, 0, 1, (ulong *) buffer) != 1)
3480fd6c:	1a000003 	bne	3480fd80 <test_part_dos+0x58>
		return -1;

	if (test_block_type(buffer) != DOS_MBR)
3480fd70:	e1a00004 	mov	r0, r4
3480fd74:	ebfffec5 	bl	3480f890 <test_block_type>
3480fd78:	e3500000 	cmp	r0, #0
		return -1;
3480fd7c:	13e00000 	mvnne	r0, #0

	return 0;
}
3480fd80:	e24bd00c 	sub	sp, fp, #12
3480fd84:	e8bd8818 	pop	{r3, r4, fp, pc}

3480fd88 <print_part_dos>:
	}
	return -1;
}

void print_part_dos (block_dev_desc_t *dev_desc)
{
3480fd88:	e92d4010 	push	{r4, lr}
3480fd8c:	e1a04000 	mov	r4, r0
	printf ("Partition     Start Sector     Num Sectors     Type\n");
3480fd90:	e59f0018 	ldr	r0, [pc, #24]	; 3480fdb0 <print_part_dos+0x28>
3480fd94:	ebffe4f2 	bl	34809164 <printf>
	print_partition_extended (dev_desc, 0, 0, 1);
3480fd98:	e3a01000 	mov	r1, #0
3480fd9c:	e1a00004 	mov	r0, r4
3480fda0:	e1a02001 	mov	r2, r1
3480fda4:	e3a03001 	mov	r3, #1
}
3480fda8:	e8bd4010 	pop	{r4, lr}
}

void print_part_dos (block_dev_desc_t *dev_desc)
{
	printf ("Partition     Start Sector     Num Sectors     Type\n");
	print_partition_extended (dev_desc, 0, 0, 1);
3480fdac:	eafffed2 	b	3480f8fc <print_partition_extended>
3480fdb0:	34826df7 	.word	0x34826df7

3480fdb4 <get_partition_info_dos>:
}

int get_partition_info_dos (block_dev_desc_t *dev_desc, int part, disk_partition_t * info)
{
3480fdb4:	e92d4007 	push	{r0, r1, r2, lr}
	return get_partition_info_extended(dev_desc, 0, 0, 1, part, info, 0);
3480fdb8:	e58d1000 	str	r1, [sp]
3480fdbc:	e3a01000 	mov	r1, #0
3480fdc0:	e58d2004 	str	r2, [sp, #4]
3480fdc4:	e3a03001 	mov	r3, #1
3480fdc8:	e1a02001 	mov	r2, r1
3480fdcc:	ebffff3c 	bl	3480fac4 <get_partition_info_extended.clone.1>
}
3480fdd0:	e8bd800e 	pop	{r1, r2, r3, pc}

3480fdd4 <s5p_gpio_cfg_pin>:

void s5p_gpio_cfg_pin(struct s5p_gpio_bank *bank, int gpio, int cfg)
{
	unsigned int value;

	value = readl(&bank->con);
3480fdd4:	e5903000 	ldr	r3, [r0]
	value &= ~CON_MASK(gpio);
3480fdd8:	e3a0c00f 	mov	ip, #15
3480fddc:	e1a01101 	lsl	r1, r1, #2
3480fde0:	e1c3311c 	bic	r3, r3, ip, lsl r1
	value |= CON_SFR(gpio, cfg);
3480fde4:	e1831112 	orr	r1, r3, r2, lsl r1
	writel(value, &bank->con);
3480fde8:	e5801000 	str	r1, [r0]
}
3480fdec:	e12fff1e 	bx	lr

3480fdf0 <s5p_gpio_direction_output>:

void s5p_gpio_direction_output(struct s5p_gpio_bank *bank, int gpio, int en)
{
3480fdf0:	e92d4070 	push	{r4, r5, r6, lr}
3480fdf4:	e1a04000 	mov	r4, r0
3480fdf8:	e1a05002 	mov	r5, r2
	unsigned int value;

	s5p_gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);
3480fdfc:	e3a02001 	mov	r2, #1
	value |= CON_SFR(gpio, cfg);
	writel(value, &bank->con);
}

void s5p_gpio_direction_output(struct s5p_gpio_bank *bank, int gpio, int en)
{
3480fe00:	e1a06001 	mov	r6, r1
	unsigned int value;

	s5p_gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);
3480fe04:	ebfffff2 	bl	3480fdd4 <s5p_gpio_cfg_pin>

	value = readl(&bank->dat);
3480fe08:	e5943004 	ldr	r3, [r4, #4]
	value &= ~DAT_MASK(gpio);
3480fe0c:	e3a02001 	mov	r2, #1
3480fe10:	e1a06612 	lsl	r6, r2, r6
	if (en)
3480fe14:	e3550000 	cmp	r5, #0
	unsigned int value;

	s5p_gpio_cfg_pin(bank, gpio, GPIO_OUTPUT);

	value = readl(&bank->dat);
	value &= ~DAT_MASK(gpio);
3480fe18:	e1c33006 	bic	r3, r3, r6
	if (en)
		value |= DAT_SET(gpio);
3480fe1c:	11833006 	orrne	r3, r3, r6
	writel(value, &bank->dat);
3480fe20:	e5843004 	str	r3, [r4, #4]
}
3480fe24:	e8bd8070 	pop	{r4, r5, r6, pc}

3480fe28 <s5p_gpio_direction_input>:

void s5p_gpio_direction_input(struct s5p_gpio_bank *bank, int gpio)
{
	s5p_gpio_cfg_pin(bank, gpio, GPIO_INPUT);
3480fe28:	e3a02000 	mov	r2, #0
3480fe2c:	eaffffe8 	b	3480fdd4 <s5p_gpio_cfg_pin>

3480fe30 <s5p_gpio_set_value>:

void s5p_gpio_set_value(struct s5p_gpio_bank *bank, int gpio, int en)
{
	unsigned int value;

	value = readl(&bank->dat);
3480fe30:	e5903004 	ldr	r3, [r0, #4]
	value &= ~DAT_MASK(gpio);
3480fe34:	e3a0c001 	mov	ip, #1
3480fe38:	e1a0111c 	lsl	r1, ip, r1
	if (en)
3480fe3c:	e3520000 	cmp	r2, #0
void s5p_gpio_set_value(struct s5p_gpio_bank *bank, int gpio, int en)
{
	unsigned int value;

	value = readl(&bank->dat);
	value &= ~DAT_MASK(gpio);
3480fe40:	e1c33001 	bic	r3, r3, r1
	if (en)
		value |= DAT_SET(gpio);
3480fe44:	11833001 	orrne	r3, r3, r1
	writel(value, &bank->dat);
3480fe48:	e5803004 	str	r3, [r0, #4]
}
3480fe4c:	e12fff1e 	bx	lr

3480fe50 <s5p_gpio_get_value>:

unsigned int s5p_gpio_get_value(struct s5p_gpio_bank *bank, int gpio)
{
	unsigned int value;

	value = readl(&bank->dat);
3480fe50:	e5903004 	ldr	r3, [r0, #4]
	return !!(value & DAT_MASK(gpio));
3480fe54:	e3a02001 	mov	r2, #1
3480fe58:	e0132112 	ands	r2, r3, r2, lsl r1
}
3480fe5c:	03a00000 	moveq	r0, #0
3480fe60:	13a00001 	movne	r0, #1
3480fe64:	e12fff1e 	bx	lr

3480fe68 <s5p_gpio_set_pull>:

void s5p_gpio_set_pull(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->pull);
3480fe68:	e5903008 	ldr	r3, [r0, #8]
	value &= ~PULL_MASK(gpio);
3480fe6c:	e3a0c003 	mov	ip, #3
3480fe70:	e1a01081 	lsl	r1, r1, #1
3480fe74:	e1c3311c 	bic	r3, r3, ip, lsl r1

	switch (mode) {
3480fe78:	e242c001 	sub	ip, r2, #1
3480fe7c:	e35c0001 	cmp	ip, #1
	case GPIO_PULL_DOWN:
	case GPIO_PULL_UP:
		value |= PULL_MODE(gpio, mode);
3480fe80:	91833112 	orrls	r3, r3, r2, lsl r1
		break;
	default:
		break;
	}

	writel(value, &bank->pull);
3480fe84:	e5803008 	str	r3, [r0, #8]
}
3480fe88:	e12fff1e 	bx	lr

3480fe8c <s5p_gpio_set_drv>:

void s5p_gpio_set_drv(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
3480fe8c:	e590300c 	ldr	r3, [r0, #12]
	value &= ~DRV_MASK(gpio);

	switch (mode) {
3480fe90:	e3520003 	cmp	r2, #3
3480fe94:	812fff1e 	bxhi	lr
void s5p_gpio_set_drv(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
	value &= ~DRV_MASK(gpio);
3480fe98:	e1a01081 	lsl	r1, r1, #1
3480fe9c:	e3a0c003 	mov	ip, #3
3480fea0:	e1c3311c 	bic	r3, r3, ip, lsl r1
	switch (mode) {
	case GPIO_DRV_1X:
	case GPIO_DRV_2X:
	case GPIO_DRV_3X:
	case GPIO_DRV_4X:
		value |= DRV_SET(gpio, mode);
3480fea4:	e1831112 	orr	r1, r3, r2, lsl r1
		break;
	default:
		return;
	}

	writel(value, &bank->drv);
3480fea8:	e580100c 	str	r1, [r0, #12]
3480feac:	e12fff1e 	bx	lr

3480feb0 <s5p_gpio_set_rate>:

void s5p_gpio_set_rate(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
3480feb0:	e590300c 	ldr	r3, [r0, #12]
	value &= ~RATE_MASK(gpio);

	switch (mode) {
3480feb4:	e3520001 	cmp	r2, #1
3480feb8:	812fff1e 	bxhi	lr
void s5p_gpio_set_rate(struct s5p_gpio_bank *bank, int gpio, int mode)
{
	unsigned int value;

	value = readl(&bank->drv);
	value &= ~RATE_MASK(gpio);
3480febc:	e3a02001 	mov	r2, #1
3480fec0:	e2811010 	add	r1, r1, #16
3480fec4:	e1a01112 	lsl	r1, r2, r1
3480fec8:	e1c33001 	bic	r3, r3, r1

	switch (mode) {
	case GPIO_DRV_FAST:
	case GPIO_DRV_SLOW:
		value |= RATE_SET(gpio);
3480fecc:	e1831001 	orr	r1, r3, r1
		break;
	default:
		return;
	}

	writel(value, &bank->drv);
3480fed0:	e580100c 	str	r1, [r0, #12]
3480fed4:	e12fff1e 	bx	lr

3480fed8 <s5p_gpio_get_bank>:
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
3480fed8:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
3480fedc:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
3480fee0:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
}
3480fee4:	e2800602 	add	r0, r0, #2097152	; 0x200000
3480fee8:	e12fff1e 	bx	lr

3480feec <s5p_gpio_get_pin>:

int s5p_gpio_get_pin(unsigned gpio)
{
	return gpio % GPIO_PER_BANK;
}
3480feec:	e2000007 	and	r0, r0, #7
3480fef0:	e12fff1e 	bx	lr

3480fef4 <gpio_request>:
/* Common GPIO API */

int gpio_request(unsigned gpio, const char *label)
{
	return 0;
}
3480fef4:	e3a00000 	mov	r0, #0
3480fef8:	e12fff1e 	bx	lr

3480fefc <gpio_free>:

int gpio_free(unsigned gpio)
{
	return 0;
}
3480fefc:	e3a00000 	mov	r0, #0
3480ff00:	e12fff1e 	bx	lr

3480ff04 <gpio_direction_input>:

int gpio_direction_input(unsigned gpio)
{
3480ff04:	e1a01000 	mov	r1, r0
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
3480ff08:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
3480ff0c:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
3480ff10:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
{
	return 0;
}

int gpio_direction_input(unsigned gpio)
{
3480ff14:	e92d4008 	push	{r3, lr}
	s5p_gpio_direction_input(s5p_gpio_get_bank(gpio),
3480ff18:	e2800602 	add	r0, r0, #2097152	; 0x200000
3480ff1c:	e2011007 	and	r1, r1, #7
3480ff20:	ebffffc0 	bl	3480fe28 <s5p_gpio_direction_input>
				s5p_gpio_get_pin(gpio));
	return 0;
}
3480ff24:	e3a00000 	mov	r0, #0
3480ff28:	e8bd8008 	pop	{r3, pc}

3480ff2c <gpio_direction_output>:

int gpio_direction_output(unsigned gpio, int value)
{
3480ff2c:	e92d4008 	push	{r3, lr}
3480ff30:	e1a03000 	mov	r3, r0
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
3480ff34:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
3480ff38:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
3480ff3c:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
				s5p_gpio_get_pin(gpio));
	return 0;
}

int gpio_direction_output(unsigned gpio, int value)
{
3480ff40:	e1a02001 	mov	r2, r1
	s5p_gpio_direction_output(s5p_gpio_get_bank(gpio),
3480ff44:	e2800602 	add	r0, r0, #2097152	; 0x200000
3480ff48:	e2031007 	and	r1, r3, #7
3480ff4c:	ebffffa7 	bl	3480fdf0 <s5p_gpio_direction_output>
				 s5p_gpio_get_pin(gpio), value);
	return 0;
}
3480ff50:	e3a00000 	mov	r0, #0
3480ff54:	e8bd8008 	pop	{r3, pc}

3480ff58 <gpio_get_value>:
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
3480ff58:	e1a031a0 	lsr	r3, r0, #3

unsigned int s5p_gpio_get_value(struct s5p_gpio_bank *bank, int gpio)
{
	unsigned int value;

	value = readl(&bank->dat);
3480ff5c:	e1a03283 	lsl	r3, r3, #5
3480ff60:	e283320e 	add	r3, r3, #-536870912	; 0xe0000000
3480ff64:	e2833602 	add	r3, r3, #2097152	; 0x200000
3480ff68:	e5933004 	ldr	r3, [r3, #4]
	return 0;
}

int gpio_get_value(unsigned gpio)
{
	return (int) s5p_gpio_get_value(s5p_gpio_get_bank(gpio),
3480ff6c:	e3a02001 	mov	r2, #1
	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
}

int s5p_gpio_get_pin(unsigned gpio)
{
	return gpio % GPIO_PER_BANK;
3480ff70:	e2000007 	and	r0, r0, #7
	return 0;
}

int gpio_get_value(unsigned gpio)
{
	return (int) s5p_gpio_get_value(s5p_gpio_get_bank(gpio),
3480ff74:	e0132012 	ands	r2, r3, r2, lsl r0
				       s5p_gpio_get_pin(gpio));
}
3480ff78:	03a00000 	moveq	r0, #0
3480ff7c:	13a00001 	movne	r0, #1
3480ff80:	e12fff1e 	bx	lr

3480ff84 <gpio_set_value>:

int gpio_set_value(unsigned gpio, int value)
{
3480ff84:	e92d4008 	push	{r3, lr}
3480ff88:	e1a03000 	mov	r3, r0
	writel(value, &bank->drv);
}

struct s5p_gpio_bank *s5p_gpio_get_bank(unsigned gpio)
{
	int bank = gpio / GPIO_PER_BANK;
3480ff8c:	e1a001a0 	lsr	r0, r0, #3
	bank *= sizeof(struct s5p_gpio_bank);
3480ff90:	e1a00280 	lsl	r0, r0, #5

	return (struct s5p_gpio_bank *) (s5p_gpio_base(gpio) + bank);
3480ff94:	e280020e 	add	r0, r0, #-536870912	; 0xe0000000
	return (int) s5p_gpio_get_value(s5p_gpio_get_bank(gpio),
				       s5p_gpio_get_pin(gpio));
}

int gpio_set_value(unsigned gpio, int value)
{
3480ff98:	e1a02001 	mov	r2, r1
	s5p_gpio_set_value(s5p_gpio_get_bank(gpio),
3480ff9c:	e2800602 	add	r0, r0, #2097152	; 0x200000
3480ffa0:	e2031007 	and	r1, r3, #7
3480ffa4:	ebffffa1 	bl	3480fe30 <s5p_gpio_set_value>
			  s5p_gpio_get_pin(gpio), value);

	return 0;
}
3480ffa8:	e3a00000 	mov	r0, #0
3480ffac:	e8bd8008 	pop	{r3, pc}

3480ffb0 <send_start>:

/*-----------------------------------------------------------------------
 * START: High -> Low on SDA while SCL is High
 */
static void send_start(void)
{
3480ffb0:	e92d4010 	push	{r4, lr}
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_DELAY;
3480ffb4:	e3a00005 	mov	r0, #5
3480ffb8:	eb003070 	bl	3481c180 <udelay>
	I2C_SDA(1);
3480ffbc:	e3a000b0 	mov	r0, #176	; 0xb0
3480ffc0:	ebffffcf 	bl	3480ff04 <gpio_direction_input>
	I2C_ACTIVE;
	I2C_DELAY;
3480ffc4:	e3a00005 	mov	r0, #5
3480ffc8:	eb00306c 	bl	3481c180 <udelay>
	I2C_SCL(1);
3480ffcc:	e3a01001 	mov	r1, #1
3480ffd0:	e3a000b3 	mov	r0, #179	; 0xb3
3480ffd4:	ebffffd4 	bl	3480ff2c <gpio_direction_output>
	I2C_DELAY;
3480ffd8:	e3a00005 	mov	r0, #5
3480ffdc:	eb003067 	bl	3481c180 <udelay>
	I2C_SDA(0);
3480ffe0:	e3a01000 	mov	r1, #0
3480ffe4:	e3a000b0 	mov	r0, #176	; 0xb0
3480ffe8:	ebffffcf 	bl	3480ff2c <gpio_direction_output>
	I2C_DELAY;
3480ffec:	e3a00005 	mov	r0, #5
}
3480fff0:	e8bd4010 	pop	{r4, lr}
	I2C_ACTIVE;
	I2C_DELAY;
	I2C_SCL(1);
	I2C_DELAY;
	I2C_SDA(0);
	I2C_DELAY;
3480fff4:	ea003061 	b	3481c180 <udelay>

3480fff8 <send_stop>:

/*-----------------------------------------------------------------------
 * STOP: Low -> High on SDA while SCL is High
 */
static void send_stop(void)
{
3480fff8:	e92d4010 	push	{r4, lr}
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_SCL(0);
3480fffc:	e3a01000 	mov	r1, #0
34810000:	e3a000b3 	mov	r0, #179	; 0xb3
34810004:	ebffffc8 	bl	3480ff2c <gpio_direction_output>
	I2C_DELAY;
34810008:	e3a00005 	mov	r0, #5
3481000c:	eb00305b 	bl	3481c180 <udelay>
	I2C_SDA(0);
34810010:	e3a01000 	mov	r1, #0
34810014:	e3a000b0 	mov	r0, #176	; 0xb0
34810018:	ebffffc3 	bl	3480ff2c <gpio_direction_output>
	I2C_ACTIVE;
	I2C_DELAY;
3481001c:	e3a00005 	mov	r0, #5
34810020:	eb003056 	bl	3481c180 <udelay>
	I2C_SCL(1);
34810024:	e3a01001 	mov	r1, #1
34810028:	e3a000b3 	mov	r0, #179	; 0xb3
3481002c:	ebffffbe 	bl	3480ff2c <gpio_direction_output>
	I2C_DELAY;
34810030:	e3a00005 	mov	r0, #5
34810034:	eb003051 	bl	3481c180 <udelay>
	I2C_SDA(1);
34810038:	e3a000b0 	mov	r0, #176	; 0xb0
3481003c:	ebffffb0 	bl	3480ff04 <gpio_direction_input>
	I2C_DELAY;
34810040:	e3a00005 	mov	r0, #5
	I2C_TRISTATE;
}
34810044:	e8bd4010 	pop	{r4, lr}
	I2C_ACTIVE;
	I2C_DELAY;
	I2C_SCL(1);
	I2C_DELAY;
	I2C_SDA(1);
	I2C_DELAY;
34810048:	ea00304c 	b	3481c180 <udelay>

3481004c <write_byte>:

/*-----------------------------------------------------------------------
 * Send 8 bits and look for an acknowledgement.
 */
static int write_byte(uchar data)
{
3481004c:	e92d4038 	push	{r3, r4, r5, lr}
34810050:	e1a05000 	mov	r5, r0
34810054:	e3a04008 	mov	r4, #8
	int j;
	int nack;

	I2C_ACTIVE;
	for(j = 0; j < 8; j++) {
		I2C_SCL(0);
34810058:	e3a01000 	mov	r1, #0
3481005c:	e3a000b3 	mov	r0, #179	; 0xb3
34810060:	ebffffb1 	bl	3480ff2c <gpio_direction_output>
		I2C_DELAY;
34810064:	e3a00005 	mov	r0, #5
34810068:	eb003044 	bl	3481c180 <udelay>
		I2C_SDA(data & 0x80);
3481006c:	e3150080 	tst	r5, #128	; 0x80
34810070:	0a000002 	beq	34810080 <write_byte+0x34>
34810074:	e3a000b0 	mov	r0, #176	; 0xb0
34810078:	ebffffa1 	bl	3480ff04 <gpio_direction_input>
3481007c:	ea000002 	b	3481008c <write_byte+0x40>
34810080:	e3a000b0 	mov	r0, #176	; 0xb0
34810084:	e3a01000 	mov	r1, #0
34810088:	ebffffa7 	bl	3480ff2c <gpio_direction_output>
		I2C_DELAY;
3481008c:	e3a00005 	mov	r0, #5
34810090:	eb00303a 	bl	3481c180 <udelay>
		I2C_SCL(1);
34810094:	e3a01001 	mov	r1, #1
34810098:	e3a000b3 	mov	r0, #179	; 0xb3
3481009c:	ebffffa2 	bl	3480ff2c <gpio_direction_output>
		I2C_DELAY;
348100a0:	e3a00005 	mov	r0, #5
348100a4:	eb003035 	bl	3481c180 <udelay>
		I2C_DELAY;
348100a8:	e3a00005 	mov	r0, #5
348100ac:	eb003033 	bl	3481c180 <udelay>
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */
	int j;
	int nack;

	I2C_ACTIVE;
	for(j = 0; j < 8; j++) {
348100b0:	e2544001 	subs	r4, r4, #1
		I2C_DELAY;
		I2C_SCL(1);
		I2C_DELAY;
		I2C_DELAY;

		data <<= 1;
348100b4:	11a05085 	lslne	r5, r5, #1
348100b8:	16ef5075 	uxtbne	r5, r5
348100bc:	1affffe5 	bne	34810058 <write_byte+0xc>
	}

	/*
	 * Look for an <ACK>(negative logic) and return it.
	 */
	I2C_SCL(0);
348100c0:	e1a01004 	mov	r1, r4
348100c4:	e3a000b3 	mov	r0, #179	; 0xb3
348100c8:	ebffff97 	bl	3480ff2c <gpio_direction_output>
	I2C_DELAY;
348100cc:	e3a00005 	mov	r0, #5
348100d0:	eb00302a 	bl	3481c180 <udelay>
	I2C_SDA(1);
348100d4:	e3a000b0 	mov	r0, #176	; 0xb0
348100d8:	ebffff89 	bl	3480ff04 <gpio_direction_input>
	I2C_TRISTATE;
	I2C_DELAY;
348100dc:	e3a00005 	mov	r0, #5
348100e0:	eb003026 	bl	3481c180 <udelay>
	I2C_SCL(1);
348100e4:	e3a01001 	mov	r1, #1
348100e8:	e3a000b3 	mov	r0, #179	; 0xb3
348100ec:	ebffff8e 	bl	3480ff2c <gpio_direction_output>
	I2C_DELAY;
348100f0:	e3a00005 	mov	r0, #5
348100f4:	eb003021 	bl	3481c180 <udelay>
	I2C_DELAY;
348100f8:	e3a00005 	mov	r0, #5
348100fc:	eb00301f 	bl	3481c180 <udelay>
	nack = I2C_READ;
34810100:	e3a000b0 	mov	r0, #176	; 0xb0
34810104:	ebffff93 	bl	3480ff58 <gpio_get_value>
	I2C_SCL(0);
34810108:	e1a01004 	mov	r1, r4
	I2C_TRISTATE;
	I2C_DELAY;
	I2C_SCL(1);
	I2C_DELAY;
	I2C_DELAY;
	nack = I2C_READ;
3481010c:	e1a05000 	mov	r5, r0
	I2C_SCL(0);
34810110:	e3a000b3 	mov	r0, #179	; 0xb3
34810114:	ebffff84 	bl	3480ff2c <gpio_direction_output>
	I2C_DELAY;
34810118:	e3a00005 	mov	r0, #5
3481011c:	eb003017 	bl	3481c180 <udelay>
	I2C_ACTIVE;

	return(nack);	/* not a nack is an ack */
}
34810120:	e1a00005 	mov	r0, r5
34810124:	e8bd8038 	pop	{r3, r4, r5, pc}

34810128 <i2c_get_bus_num>:
 * Functions for multiple I2C bus handling
 */
unsigned int i2c_get_bus_num(void)
{
	return i2c_bus_num;
}
34810128:	e59f3004 	ldr	r3, [pc, #4]	; 34810134 <i2c_get_bus_num+0xc>
3481012c:	e5930000 	ldr	r0, [r3]
34810130:	e12fff1e 	bx	lr
34810134:	34828a4c 	.word	0x34828a4c

34810138 <i2c_set_bus_num>:
			i2c_bus_num = bus;
		else
			return ret;
	}
#else
	if (bus >= CONFIG_SYS_MAX_I2C_BUS)
34810138:	e3500006 	cmp	r0, #6
		return -1;
	i2c_bus_num = bus;
3481013c:	959f300c 	ldrls	r3, [pc, #12]	; 34810150 <i2c_set_bus_num+0x18>
		else
			return ret;
	}
#else
	if (bus >= CONFIG_SYS_MAX_I2C_BUS)
		return -1;
34810140:	83e00000 	mvnhi	r0, #0
	i2c_bus_num = bus;
34810144:	95830000 	strls	r0, [r3]
#endif
	return 0;
34810148:	93a00000 	movls	r0, #0
}
3481014c:	e12fff1e 	bx	lr
34810150:	34828a4c 	.word	0x34828a4c

34810154 <i2c_init>:

/*-----------------------------------------------------------------------
 * Initialization
 */
void i2c_init (int speed, int slaveaddr)
{
34810154:	e92d4010 	push	{r4, lr}
static void send_reset(void)
{
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */
	int j;

	I2C_SCL(1);
34810158:	e3a01001 	mov	r1, #1
3481015c:	e3a000b3 	mov	r0, #179	; 0xb3
34810160:	ebffff71 	bl	3480ff2c <gpio_direction_output>
	I2C_SDA(1);
34810164:	e3a000b0 	mov	r0, #176	; 0xb0
34810168:	ebffff65 	bl	3480ff04 <gpio_direction_input>
#ifdef	I2C_INIT
	I2C_INIT;
3481016c:	e59f105c 	ldr	r1, [pc, #92]	; 348101d0 <i2c_init+0x7c>
34810170:	e3a000b3 	mov	r0, #179	; 0xb3
34810174:	ebffff5e 	bl	3480fef4 <gpio_request>
34810178:	e3a000b0 	mov	r0, #176	; 0xb0
3481017c:	e59f104c 	ldr	r1, [pc, #76]	; 348101d0 <i2c_init+0x7c>
34810180:	ebffff5b 	bl	3480fef4 <gpio_request>
34810184:	e3a04009 	mov	r4, #9
#endif
	I2C_TRISTATE;
	for(j = 0; j < 9; j++) {
		I2C_SCL(0);
34810188:	e3a01000 	mov	r1, #0
3481018c:	e3a000b3 	mov	r0, #179	; 0xb3
34810190:	ebffff65 	bl	3480ff2c <gpio_direction_output>
		I2C_DELAY;
34810194:	e3a00005 	mov	r0, #5
34810198:	eb002ff8 	bl	3481c180 <udelay>
		I2C_DELAY;
3481019c:	e3a00005 	mov	r0, #5
348101a0:	eb002ff6 	bl	3481c180 <udelay>
		I2C_SCL(1);
348101a4:	e3a01001 	mov	r1, #1
348101a8:	e3a000b3 	mov	r0, #179	; 0xb3
348101ac:	ebffff5e 	bl	3480ff2c <gpio_direction_output>
		I2C_DELAY;
348101b0:	e3a00005 	mov	r0, #5
348101b4:	eb002ff1 	bl	3481c180 <udelay>
		I2C_DELAY;
348101b8:	e3a00005 	mov	r0, #5
348101bc:	eb002fef 	bl	3481c180 <udelay>
	I2C_SDA(1);
#ifdef	I2C_INIT
	I2C_INIT;
#endif
	I2C_TRISTATE;
	for(j = 0; j < 9; j++) {
348101c0:	e2544001 	subs	r4, r4, #1
348101c4:	1affffef 	bne	34810188 <i2c_init+0x34>
	 * the DIMM SPD, for instance), RAM won't be usable and your
	 * system will crash.
	 */
	send_reset ();
#endif
}
348101c8:	e8bd4010 	pop	{r4, lr}
		I2C_DELAY;
		I2C_SCL(1);
		I2C_DELAY;
		I2C_DELAY;
	}
	send_stop();
348101cc:	eaffff89 	b	3480fff8 <send_stop>
348101d0:	34826e2c 	.word	0x34826e2c

348101d4 <i2c_probe>:
 * Probe to see if a chip is present.  Also good for checking for the
 * completion of EEPROM writes since the chip stops responding until
 * the write completes (typically 10mSec).
 */
int i2c_probe(uchar addr)
{
348101d4:	e92d4010 	push	{r4, lr}
348101d8:	e1a04000 	mov	r4, r0

	/*
	 * perform 1 byte write transaction with just address byte
	 * (fake write)
	 */
	send_start();
348101dc:	ebffff73 	bl	3480ffb0 <send_start>
	rc = write_byte ((addr << 1) | 0);
348101e0:	e1a00084 	lsl	r0, r4, #1
348101e4:	e20000fe 	and	r0, r0, #254	; 0xfe
348101e8:	ebffff97 	bl	3481004c <write_byte>
348101ec:	e1a04000 	mov	r4, r0
	send_stop();
348101f0:	ebffff80 	bl	3480fff8 <send_stop>

	return (rc ? 1 : 0);
}
348101f4:	e2540000 	subs	r0, r4, #0
348101f8:	13a00001 	movne	r0, #1
348101fc:	e8bd8010 	pop	{r4, pc}

34810200 <i2c_read>:

/*-----------------------------------------------------------------------
 * Read bytes
 */
int  i2c_read(uchar chip, uint addr, int alen, uchar *buffer, int len)
{
34810200:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
34810204:	e1a07002 	mov	r7, r2
34810208:	e1a04000 	mov	r4, r0
3481020c:	e1a05001 	mov	r5, r1
34810210:	e1a0a003 	mov	sl, r3
34810214:	e59d6020 	ldr	r6, [sp, #32]
	 * Do the addressing portion of a write cycle to set the
	 * chip's address pointer.  If the address length is zero,
	 * don't do the normal write cycle to set the address pointer,
	 * there is no address pointer in this chip.
	 */
	send_start();
34810218:	ebffff64 	bl	3480ffb0 <send_start>
	if(alen > 0) {
3481021c:	e3570000 	cmp	r7, #0
34810220:	da000014 	ble	34810278 <i2c_read+0x78>
		if(write_byte(chip << 1)) {	/* write cycle */
34810224:	e1a00084 	lsl	r0, r4, #1
34810228:	e20000fe 	and	r0, r0, #254	; 0xfe
3481022c:	ebffff86 	bl	3481004c <write_byte>
34810230:	e3500000 	cmp	r0, #0
			send_stop();
			PRINTD("i2c_read, no chip responded %02X\n", chip);
			return(1);
		}
		shift = (alen-1) * 8;
34810234:	02479001 	subeq	r9, r7, #1
34810238:	01a09189 	lsleq	r9, r9, #3
	 * don't do the normal write cycle to set the address pointer,
	 * there is no address pointer in this chip.
	 */
	send_start();
	if(alen > 0) {
		if(write_byte(chip << 1)) {	/* write cycle */
3481023c:	0a000009 	beq	34810268 <i2c_read+0x68>
			send_stop();
34810240:	ebffff6c 	bl	3480fff8 <send_stop>
			PRINTD("i2c_read, no chip responded %02X\n", chip);
			return(1);
34810244:	e3a00001 	mov	r0, #1
34810248:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		}
		shift = (alen-1) * 8;
		while(alen-- > 0) {
			if(write_byte(addr >> shift)) {
3481024c:	e1a00935 	lsr	r0, r5, r9
34810250:	e6ef0070 	uxtb	r0, r0
34810254:	ebffff7c 	bl	3481004c <write_byte>
34810258:	e3500000 	cmp	r0, #0
3481025c:	e2477001 	sub	r7, r7, #1
34810260:	1a000041 	bne	3481036c <i2c_read+0x16c>
				PRINTD("i2c_read, address not <ACK>ed\n");
				return(1);
			}
			shift -= 8;
34810264:	e2499008 	sub	r9, r9, #8
			send_stop();
			PRINTD("i2c_read, no chip responded %02X\n", chip);
			return(1);
		}
		shift = (alen-1) * 8;
		while(alen-- > 0) {
34810268:	e3570000 	cmp	r7, #0
3481026c:	cafffff6 	bgt	3481024c <i2c_read+0x4c>
		 * stop/start sequence.
		 */
#ifdef CONFIG_SOFT_I2C_READ_REPEATED_START
		send_start();
#else
		send_stop();
34810270:	ebffff60 	bl	3480fff8 <send_stop>
		send_start();
34810274:	ebffff4d 	bl	3480ffb0 <send_start>
	/*
	 * Send the chip address again, this time for a read cycle.
	 * Then read the data.  On the last byte, we do a NACK instead
	 * of an ACK(len == 0) to terminate the read.
	 */
	write_byte((chip << 1) | 1);	/* read cycle */
34810278:	e1a04084 	lsl	r4, r4, #1
3481027c:	e3840001 	orr	r0, r4, #1
34810280:	e6ef0070 	uxtb	r0, r0
34810284:	ebffff70 	bl	3481004c <write_byte>
	while(len-- > 0) {
34810288:	ea000032 	b	34810358 <i2c_read+0x158>

	/*
	 * Read 8 bits, MSB first.
	 */
	I2C_TRISTATE;
	I2C_SDA(1);
3481028c:	e3a000b0 	mov	r0, #176	; 0xb0
34810290:	ebffff1b 	bl	3480ff04 <gpio_direction_input>
34810294:	e3a04008 	mov	r4, #8
	data = 0;
34810298:	e3a05000 	mov	r5, #0
	for(j = 0; j < 8; j++) {
		I2C_SCL(0);
3481029c:	e3a01000 	mov	r1, #0
348102a0:	e3a000b3 	mov	r0, #179	; 0xb3
348102a4:	ebffff20 	bl	3480ff2c <gpio_direction_output>
		I2C_DELAY;
348102a8:	e3a00005 	mov	r0, #5
348102ac:	eb002fb3 	bl	3481c180 <udelay>
		I2C_SCL(1);
348102b0:	e3a01001 	mov	r1, #1
348102b4:	e3a000b3 	mov	r0, #179	; 0xb3
348102b8:	ebffff1b 	bl	3480ff2c <gpio_direction_output>
		I2C_DELAY;
348102bc:	e3a00005 	mov	r0, #5
348102c0:	eb002fae 	bl	3481c180 <udelay>
		data <<= 1;
		data |= I2C_READ;
348102c4:	e3a000b0 	mov	r0, #176	; 0xb0
348102c8:	ebffff22 	bl	3480ff58 <gpio_get_value>
	for(j = 0; j < 8; j++) {
		I2C_SCL(0);
		I2C_DELAY;
		I2C_SCL(1);
		I2C_DELAY;
		data <<= 1;
348102cc:	e1a05085 	lsl	r5, r5, #1
		data |= I2C_READ;
348102d0:	e1855000 	orr	r5, r5, r0
		I2C_DELAY;
348102d4:	e3a00005 	mov	r0, #5
348102d8:	eb002fa8 	bl	3481c180 <udelay>
	 * Read 8 bits, MSB first.
	 */
	I2C_TRISTATE;
	I2C_SDA(1);
	data = 0;
	for(j = 0; j < 8; j++) {
348102dc:	e2544001 	subs	r4, r4, #1
348102e0:	1affffed 	bne	3481029c <i2c_read+0x9c>
 */
static void send_ack(int ack)
{
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_SCL(0);
348102e4:	e1a01004 	mov	r1, r4
348102e8:	e3a000b3 	mov	r0, #179	; 0xb3
348102ec:	ebffff0e 	bl	3480ff2c <gpio_direction_output>
	 * Send the chip address again, this time for a read cycle.
	 * Then read the data.  On the last byte, we do a NACK instead
	 * of an ACK(len == 0) to terminate the read.
	 */
	write_byte((chip << 1) | 1);	/* read cycle */
	while(len-- > 0) {
348102f0:	e2466001 	sub	r6, r6, #1
static void send_ack(int ack)
{
	I2C_SOFT_DECLARATIONS	/* intentional without ';' */

	I2C_SCL(0);
	I2C_DELAY;
348102f4:	e3a00005 	mov	r0, #5
348102f8:	eb002fa0 	bl	3481c180 <udelay>
	I2C_ACTIVE;
	I2C_SDA(ack);
348102fc:	e3560000 	cmp	r6, #0
34810300:	1a000002 	bne	34810310 <i2c_read+0x110>
34810304:	e3a000b0 	mov	r0, #176	; 0xb0
34810308:	ebfffefd 	bl	3480ff04 <gpio_direction_input>
3481030c:	ea000002 	b	3481031c <i2c_read+0x11c>
34810310:	e3a000b0 	mov	r0, #176	; 0xb0
34810314:	e1a01004 	mov	r1, r4
34810318:	ebffff03 	bl	3480ff2c <gpio_direction_output>
	I2C_DELAY;
3481031c:	e3a00005 	mov	r0, #5
34810320:	eb002f96 	bl	3481c180 <udelay>
	I2C_SCL(1);
34810324:	e3a01001 	mov	r1, #1
34810328:	e3a000b3 	mov	r0, #179	; 0xb3
3481032c:	ebfffefe 	bl	3480ff2c <gpio_direction_output>
	I2C_DELAY;
34810330:	e3a00005 	mov	r0, #5
34810334:	eb002f91 	bl	3481c180 <udelay>
	I2C_DELAY;
34810338:	e3a00005 	mov	r0, #5
3481033c:	eb002f8f 	bl	3481c180 <udelay>
	I2C_SCL(0);
34810340:	e3a01000 	mov	r1, #0
34810344:	e3a000b3 	mov	r0, #179	; 0xb3
34810348:	ebfffef7 	bl	3480ff2c <gpio_direction_output>
	I2C_DELAY;
3481034c:	e3a00005 	mov	r0, #5
34810350:	eb002f8a 	bl	3481c180 <udelay>
		data |= I2C_READ;
		I2C_DELAY;
	}
	send_ack(ack);

	return(data);
34810354:	e4ca5001 	strb	r5, [sl], #1
	 * Send the chip address again, this time for a read cycle.
	 * Then read the data.  On the last byte, we do a NACK instead
	 * of an ACK(len == 0) to terminate the read.
	 */
	write_byte((chip << 1) | 1);	/* read cycle */
	while(len-- > 0) {
34810358:	e3560000 	cmp	r6, #0
3481035c:	caffffca 	bgt	3481028c <i2c_read+0x8c>
		*buffer++ = read_byte(len == 0);
	}
	send_stop();
34810360:	ebffff24 	bl	3480fff8 <send_stop>
	return(0);
34810364:	e3a00000 	mov	r0, #0
34810368:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
		}
		shift = (alen-1) * 8;
		while(alen-- > 0) {
			if(write_byte(addr >> shift)) {
				PRINTD("i2c_read, address not <ACK>ed\n");
				return(1);
3481036c:	e3a00001 	mov	r0, #1
	while(len-- > 0) {
		*buffer++ = read_byte(len == 0);
	}
	send_stop();
	return(0);
}
34810370:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}

34810374 <i2c_write>:

/*-----------------------------------------------------------------------
 * Write bytes
 */
int  i2c_write(uchar chip, uint addr, int alen, uchar *buffer, int len)
{
34810374:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34810378:	e1a05000 	mov	r5, r0
3481037c:	e1a06002 	mov	r6, r2
34810380:	e1a04001 	mov	r4, r1
34810384:	e1a07003 	mov	r7, r3
	int shift, failures = 0;

	PRINTD("i2c_write: chip %02X addr %02X alen %d buffer %p len %d\n",
		chip, addr, alen, buffer, len);

	send_start();
34810388:	ebffff08 	bl	3480ffb0 <send_start>
	if(write_byte(chip << 1)) {	/* write cycle */
3481038c:	e1a00085 	lsl	r0, r5, #1
34810390:	e20000fe 	and	r0, r0, #254	; 0xfe
34810394:	ebffff2c 	bl	3481004c <write_byte>
34810398:	e3500000 	cmp	r0, #0
		send_stop();
		PRINTD("i2c_write, no chip responded %02X\n", chip);
		return(1);
	}
	shift = (alen-1) * 8;
3481039c:	02465001 	subeq	r5, r6, #1
348103a0:	01a05185 	lsleq	r5, r5, #3

	PRINTD("i2c_write: chip %02X addr %02X alen %d buffer %p len %d\n",
		chip, addr, alen, buffer, len);

	send_start();
	if(write_byte(chip << 1)) {	/* write cycle */
348103a4:	0a000008 	beq	348103cc <i2c_write+0x58>
		send_stop();
348103a8:	ebffff12 	bl	3480fff8 <send_stop>
348103ac:	ea000014 	b	34810404 <i2c_write+0x90>
		PRINTD("i2c_write, no chip responded %02X\n", chip);
		return(1);
	}
	shift = (alen-1) * 8;
	while(alen-- > 0) {
		if(write_byte(addr >> shift)) {
348103b0:	e1a00534 	lsr	r0, r4, r5
348103b4:	e6ef0070 	uxtb	r0, r0
348103b8:	ebffff23 	bl	3481004c <write_byte>
348103bc:	e3500000 	cmp	r0, #0
348103c0:	e2466001 	sub	r6, r6, #1
348103c4:	1a00000e 	bne	34810404 <i2c_write+0x90>
			PRINTD("i2c_write, address not <ACK>ed\n");
			return(1);
		}
		shift -= 8;
348103c8:	e2455008 	sub	r5, r5, #8
		send_stop();
		PRINTD("i2c_write, no chip responded %02X\n", chip);
		return(1);
	}
	shift = (alen-1) * 8;
	while(alen-- > 0) {
348103cc:	e3560000 	cmp	r6, #0
348103d0:	cafffff6 	bgt	348103b0 <i2c_write+0x3c>
348103d4:	e59d5018 	ldr	r5, [sp, #24]
348103d8:	e3a04000 	mov	r4, #0
348103dc:	ea000004 	b	348103f4 <i2c_write+0x80>
		}
		shift -= 8;
	}

	while(len-- > 0) {
		if(write_byte(*buffer++)) {
348103e0:	e4d70001 	ldrb	r0, [r7], #1
348103e4:	ebffff18 	bl	3481004c <write_byte>
348103e8:	e3500000 	cmp	r0, #0
			failures++;
348103ec:	12844001 	addne	r4, r4, #1
348103f0:	e2455001 	sub	r5, r5, #1
			return(1);
		}
		shift -= 8;
	}

	while(len-- > 0) {
348103f4:	e3550000 	cmp	r5, #0
348103f8:	cafffff8 	bgt	348103e0 <i2c_write+0x6c>
		if(write_byte(*buffer++)) {
			failures++;
		}
	}
	send_stop();
348103fc:	ebfffefd 	bl	3480fff8 <send_stop>
	return(failures);
34810400:	ea000000 	b	34810408 <i2c_write+0x94>
	}
	shift = (alen-1) * 8;
	while(alen-- > 0) {
		if(write_byte(addr >> shift)) {
			PRINTD("i2c_write, address not <ACK>ed\n");
			return(1);
34810404:	e3a04001 	mov	r4, #1
			failures++;
		}
	}
	send_stop();
	return(failures);
}
34810408:	e1a00004 	mov	r0, r4
3481040c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

34810410 <sort_array_by_ordering>:
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
34810410:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34810414:	e28db01c 	add	fp, sp, #28
34810418:	e24dd008 	sub	sp, sp, #8
3481041c:	e50b2020 	str	r2, [fp, #-32]
	int temp[count];
34810420:	e1a02101 	lsl	r2, r1, #2
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
34810424:	e1a09003 	mov	r9, r3
	int temp[count];
34810428:	e282300e 	add	r3, r2, #14
3481042c:	e3c33007 	bic	r3, r3, #7
34810430:	e04dd003 	sub	sp, sp, r3
 * @return number of elements in dest that are in order (these will be at the
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
34810434:	e1a04000 	mov	r4, r0
34810438:	e1a05001 	mov	r5, r1
	int dest_count;
	int same;	/* number of elements which are the same */
	int i;

	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
3481043c:	e1a0000d 	mov	r0, sp
34810440:	e1a01004 	mov	r1, r4
34810444:	eb002ec2 	bl	3481bf54 <memcpy>
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810448:	e3a02000 	mov	r2, #0
 *	start of dest).
 */
static int sort_array_by_ordering(int *dest, int count, int *order,
				   int ocount)
{
	int temp[count];
3481044c:	e1a0600d 	mov	r6, sp
	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810450:	e51b0020 	ldr	r0, [fp, #-32]
	int same;	/* number of elements which are the same */
	int i;

	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
	dest_count = 0;
34810454:	e1a03002 	mov	r3, r2

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810458:	ea00000d 	b	34810494 <sort_array_by_ordering+0x84>
		if (array_search(temp, count, order[i]) != -1)
3481045c:	e490c004 	ldr	ip, [r0], #4
34810460:	e1a07006 	mov	r7, r6
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
34810464:	e3a01000 	mov	r1, #0
34810468:	ea000003 	b	3481047c <sort_array_by_ordering+0x6c>
		if (array[i] == key)
3481046c:	e497a004 	ldr	sl, [r7], #4
34810470:	e15a000c 	cmp	sl, ip
34810474:	0a000003 	beq	34810488 <sort_array_by_ordering+0x78>
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
34810478:	e2811001 	add	r1, r1, #1
3481047c:	e1510005 	cmp	r1, r5
34810480:	bafffff9 	blt	3481046c <sort_array_by_ordering+0x5c>
34810484:	ea000001 	b	34810490 <sort_array_by_ordering+0x80>
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
		if (array_search(temp, count, order[i]) != -1)
			dest[dest_count++] = order[i];
34810488:	e784c103 	str	ip, [r4, r3, lsl #2]
3481048c:	e2833001 	add	r3, r3, #1
	/* setup output items, copy items to be sorted into our temp area */
	memcpy(temp, dest, count * sizeof(*dest));
	dest_count = 0;

	/* work through the ordering, move over the elements we agree on */
	for (i = 0; i < ocount; i++) {
34810490:	e2822001 	add	r2, r2, #1
34810494:	e1520009 	cmp	r2, r9
34810498:	baffffef 	blt	3481045c <sort_array_by_ordering+0x4c>
3481049c:	e1a00003 	mov	r0, r3
348104a0:	e3a02000 	mov	r2, #0
348104a4:	ea00000b 	b	348104d8 <sort_array_by_ordering+0xc8>
	}
	same = dest_count;

	/* now move over the elements that are not in the ordering */
	for (i = 0; i < count; i++) {
		if (array_search(order, ocount, temp[i]) == -1)
348104a8:	e496c004 	ldr	ip, [r6], #4
348104ac:	e51b7020 	ldr	r7, [fp, #-32]
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
348104b0:	e3a01000 	mov	r1, #0
348104b4:	ea000003 	b	348104c8 <sort_array_by_ordering+0xb8>
		if (array[i] == key)
348104b8:	e497a004 	ldr	sl, [r7], #4
348104bc:	e15a000c 	cmp	sl, ip
348104c0:	0a000003 	beq	348104d4 <sort_array_by_ordering+0xc4>
 */
static int array_search(int *array, int count, int key)
{
	int i;

	for (i = 0; i < count; i++) {
348104c4:	e2811001 	add	r1, r1, #1
348104c8:	e1510009 	cmp	r1, r9
348104cc:	bafffff9 	blt	348104b8 <sort_array_by_ordering+0xa8>
348104d0:	ea000004 	b	348104e8 <sort_array_by_ordering+0xd8>
			dest[dest_count++] = order[i];
	}
	same = dest_count;

	/* now move over the elements that are not in the ordering */
	for (i = 0; i < count; i++) {
348104d4:	e2822001 	add	r2, r2, #1
348104d8:	e1520005 	cmp	r2, r5
348104dc:	bafffff1 	blt	348104a8 <sort_array_by_ordering+0x98>
		if (array_search(order, ocount, temp[i]) == -1)
			dest[dest_count++] = temp[i];
	}
	assert(dest_count == count);
	return same;
}
348104e0:	e24bd01c 	sub	sp, fp, #28
348104e4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	same = dest_count;

	/* now move over the elements that are not in the ordering */
	for (i = 0; i < count; i++) {
		if (array_search(order, ocount, temp[i]) == -1)
			dest[dest_count++] = temp[i];
348104e8:	e784c103 	str	ip, [r4, r3, lsl #2]
348104ec:	e2833001 	add	r3, r3, #1
348104f0:	eafffff7 	b	348104d4 <sort_array_by_ordering+0xc4>

348104f4 <input_queue_ascii>:
};


int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
348104f4:	e5903010 	ldr	r3, [r0, #16]
348104f8:	e5902014 	ldr	r2, [r0, #20]
348104fc:	e353000f 	cmp	r3, #15
34810500:	1a000003 	bne	34810514 <input_queue_ascii+0x20>
		if (!config->fifo_out)
34810504:	e3520000 	cmp	r2, #0
			return -1; /* buffer full */
		else
			config->fifo_in = 0;
34810508:	13a03000 	movne	r3, #0


int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
		if (!config->fifo_out)
3481050c:	1a000003 	bne	34810520 <input_queue_ascii+0x2c>
34810510:	ea000007 	b	34810534 <input_queue_ascii+0x40>
			return -1; /* buffer full */
		else
			config->fifo_in = 0;
	} else {
		if (config->fifo_in + 1 == config->fifo_out)
34810514:	e2833001 	add	r3, r3, #1
34810518:	e1530002 	cmp	r3, r2
3481051c:	0a000006 	beq	3481053c <input_queue_ascii+0x48>
			return -1; /* buffer full */
		config->fifo_in++;
34810520:	e5803010 	str	r3, [r0, #16]
	}
	config->fifo[config->fifo_in] = (uchar)ch;
34810524:	e5903010 	ldr	r3, [r0, #16]
34810528:	e7c01003 	strb	r1, [r0, r3]

	return 0;
3481052c:	e3a00000 	mov	r0, #0
34810530:	e12fff1e 	bx	lr

int input_queue_ascii(struct input_config *config, int ch)
{
	if (config->fifo_in + 1 == INPUT_BUFFER_LEN) {
		if (!config->fifo_out)
			return -1; /* buffer full */
34810534:	e3e00000 	mvn	r0, #0
34810538:	e12fff1e 	bx	lr
		else
			config->fifo_in = 0;
	} else {
		if (config->fifo_in + 1 == config->fifo_out)
			return -1; /* buffer full */
3481053c:	e3e00000 	mvn	r0, #0
		config->fifo_in++;
	}
	config->fifo[config->fifo_in] = (uchar)ch;

	return 0;
}
34810540:	e12fff1e 	bx	lr

34810544 <input_tstc>:

int input_tstc(struct input_config *config)
{
	if (config->fifo_in == config->fifo_out && config->read_keys) {
34810544:	e5902010 	ldr	r2, [r0, #16]
34810548:	e5903014 	ldr	r3, [r0, #20]

	return 0;
}

int input_tstc(struct input_config *config)
{
3481054c:	e92d4010 	push	{r4, lr}
	if (config->fifo_in == config->fifo_out && config->read_keys) {
34810550:	e1520003 	cmp	r2, r3

	return 0;
}

int input_tstc(struct input_config *config)
{
34810554:	e1a04000 	mov	r4, r0
	if (config->fifo_in == config->fifo_out && config->read_keys) {
34810558:	1a000005 	bne	34810574 <input_tstc+0x30>
3481055c:	e59030a0 	ldr	r3, [r0, #160]	; 0xa0
34810560:	e3530000 	cmp	r3, #0
34810564:	0a000002 	beq	34810574 <input_tstc+0x30>
		if (!(*config->read_keys)(config))
34810568:	e12fff33 	blx	r3
3481056c:	e3500000 	cmp	r0, #0
34810570:	08bd8010 	popeq	{r4, pc}
			return 0;
	}
	return config->fifo_in != config->fifo_out;
34810574:	e5940010 	ldr	r0, [r4, #16]
34810578:	e5943014 	ldr	r3, [r4, #20]
3481057c:	e0500003 	subs	r0, r0, r3
34810580:	13a00001 	movne	r0, #1
}
34810584:	e8bd8010 	pop	{r4, pc}

34810588 <input_getc>:

int input_getc(struct input_config *config)
{
34810588:	e92d4010 	push	{r4, lr}
3481058c:	e1a04000 	mov	r4, r0
	int err = 0;

	while (config->fifo_in == config->fifo_out) {
34810590:	ea000006 	b	348105b0 <input_getc+0x28>
		if (config->read_keys)
34810594:	e59430a0 	ldr	r3, [r4, #160]	; 0xa0
34810598:	e3530000 	cmp	r3, #0
3481059c:	0a000003 	beq	348105b0 <input_getc+0x28>
			err = (*config->read_keys)(config);
348105a0:	e1a00004 	mov	r0, r4
348105a4:	e12fff33 	blx	r3
		if (err)
348105a8:	e3500000 	cmp	r0, #0
348105ac:	1a00000b 	bne	348105e0 <input_getc+0x58>

int input_getc(struct input_config *config)
{
	int err = 0;

	while (config->fifo_in == config->fifo_out) {
348105b0:	e5943014 	ldr	r3, [r4, #20]
348105b4:	e5942010 	ldr	r2, [r4, #16]
348105b8:	e1520003 	cmp	r2, r3
348105bc:	0afffff4 	beq	34810594 <input_getc+0xc>
			err = (*config->read_keys)(config);
		if (err)
			return -1;
	}

	if (++config->fifo_out == INPUT_BUFFER_LEN)
348105c0:	e2833001 	add	r3, r3, #1
348105c4:	e3530010 	cmp	r3, #16
348105c8:	e5843014 	str	r3, [r4, #20]
		config->fifo_out = 0;
348105cc:	03a03000 	moveq	r3, #0
348105d0:	05843014 	streq	r3, [r4, #20]

	return config->fifo[config->fifo_out];
348105d4:	e5943014 	ldr	r3, [r4, #20]
348105d8:	e7d40003 	ldrb	r0, [r4, r3]
348105dc:	e8bd8010 	pop	{r4, pc}

	while (config->fifo_in == config->fifo_out) {
		if (config->read_keys)
			err = (*config->read_keys)(config);
		if (err)
			return -1;
348105e0:	e3e00000 	mvn	r0, #0

	if (++config->fifo_out == INPUT_BUFFER_LEN)
		config->fifo_out = 0;

	return config->fifo[config->fifo_out];
}
348105e4:	e8bd8010 	pop	{r4, pc}

348105e8 <input_send_keycodes>:
	return ch_count;
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
348105e8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348105ec:	e28db01c 	add	fp, sp, #28
348105f0:	e24dd010 	sub	sp, sp, #16
 */
static int input_check_keycodes(struct input_config *config,
			   int keycode[], int num_keycodes, int *same)
{
	/* Select the 'plain' xlate table to start with */
	if (!config->num_tables) {
348105f4:	e5d0701b 	ldrb	r7, [r0, #27]
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
	char ch[num_keycodes];
348105f8:	e282300e 	add	r3, r2, #14
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
348105fc:	e3a09000 	mov	r9, #0
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
	char ch[num_keycodes];
34810600:	e3c33007 	bic	r3, r3, #7
34810604:	e04dd003 	sub	sp, sp, r3
 */
static int input_check_keycodes(struct input_config *config,
			   int keycode[], int num_keycodes, int *same)
{
	/* Select the 'plain' xlate table to start with */
	if (!config->num_tables) {
34810608:	e1570009 	cmp	r7, r9
	char ch[num_keycodes];
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
3481060c:	e5c09018 	strb	r9, [r0, #24]
	return ch_count;
}

int input_send_keycodes(struct input_config *config,
			int keycode[], int num_keycodes)
{
34810610:	e1a04000 	mov	r4, r0
34810614:	e1a06001 	mov	r6, r1
34810618:	e1a05002 	mov	r5, r2
	char ch[num_keycodes];
3481061c:	e50bd020 	str	sp, [fp, #-32]
	int count, i, same = 0;
	int is_repeat = 0;
34810620:	01a09007 	moveq	r9, r7
 */
static int input_check_keycodes(struct input_config *config,
			   int keycode[], int num_keycodes, int *same)
{
	/* Select the 'plain' xlate table to start with */
	if (!config->num_tables) {
34810624:	0a000012 	beq	34810674 <input_send_keycodes+0x8c>
		debug("%s: No xlate tables: cannot decode keys\n", __func__);
		return -1;
	}

	/* sort the keycodes into the same order as the previous ones */
	*same = sort_array_by_ordering(keycode, num_keycodes,
34810628:	e280a01c 	add	sl, r0, #28
3481062c:	e594305c 	ldr	r3, [r4, #92]	; 0x5c
34810630:	e1a00001 	mov	r0, r1
34810634:	e1a01002 	mov	r1, r2
34810638:	e1a0200a 	mov	r2, sl
3481063c:	ebffff73 	bl	34810410 <sort_array_by_ordering>
			config->prev_keycodes, config->num_prev_keycodes);

	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
34810640:	e1a01006 	mov	r1, r6
		debug("%s: No xlate tables: cannot decode keys\n", __func__);
		return -1;
	}

	/* sort the keycodes into the same order as the previous ones */
	*same = sort_array_by_ordering(keycode, num_keycodes,
34810644:	e1a07000 	mov	r7, r0
			config->prev_keycodes, config->num_prev_keycodes);

	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
34810648:	e1a02105 	lsl	r2, r5, #2
3481064c:	e1a0000a 	mov	r0, sl
34810650:	eb002e3f 	bl	3481bf54 <memcpy>
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
	if (!input_check_keycodes(config, keycode, num_keycodes, &same)) {
34810654:	e1570005 	cmp	r7, r5
	/* sort the keycodes into the same order as the previous ones */
	*same = sort_array_by_ordering(keycode, num_keycodes,
			config->prev_keycodes, config->num_prev_keycodes);

	memcpy(config->prev_keycodes, keycode, num_keycodes * sizeof(int));
	config->num_prev_keycodes = num_keycodes;
34810658:	e584505c 	str	r5, [r4, #92]	; 0x5c
	int count, i, same = 0;
	int is_repeat = 0;
	unsigned delay_ms;

	config->modifiers = 0;
	if (!input_check_keycodes(config, keycode, num_keycodes, &same)) {
3481065c:	1a000004 	bne	34810674 <input_send_keycodes+0x8c>
		 * the caller may not call in again for a while, our
		 * auto-repeat speed is not quite correct. We should
		 * insert another character if we later realise that we
		 * have missed a repeat slot.
		 */
		is_repeat = (int)get_timer(config->next_repeat_ms) >= 0;
34810660:	e59400a4 	ldr	r0, [r4, #164]	; 0xa4
34810664:	ebffc0ae 	bl	34800924 <get_timer>
		if (!is_repeat)
34810668:	e1500009 	cmp	r0, r9
3481066c:	a2899001 	addge	r9, r9, #1
34810670:	ba000061 	blt	348107fc <input_send_keycodes+0x214>
{
	struct input_key_xlate *table;
	int ch_count;
	int i;

	table = &config->table[0];
34810674:	e2840060 	add	r0, r4, #96	; 0x60
		is_repeat = (int)get_timer(config->next_repeat_ms) >= 0;
		if (!is_repeat)
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
34810678:	e3590000 	cmp	r9, #0
3481067c:	13a07000 	movne	r7, #0
{
	struct input_key_xlate *table;
	int ch_count;
	int i;

	table = &config->table[0];
34810680:	e50b0024 	str	r0, [fp, #-36]	; 0x24
34810684:	e1a0e006 	mov	lr, r6
34810688:	e1a03000 	mov	r3, r0

	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
3481068c:	e3a0c000 	mov	ip, #0
34810690:	ea000032 	b	34810760 <input_send_keycodes+0x178>
		int key = keycode[i] & KEY_MASK;
34810694:	e49e1004 	ldr	r1, [lr], #4

		if (key >= table->num_entries || table->xlate[key] == 0xff) {
34810698:	e593a00c 	ldr	sl, [r3, #12]

	table = &config->table[0];

	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
		int key = keycode[i] & KEY_MASK;
3481069c:	e1a00a01 	lsl	r0, r1, #20
348106a0:	e1a02a20 	lsr	r2, r0, #20

		if (key >= table->num_entries || table->xlate[key] == 0xff) {
348106a4:	e152000a 	cmp	r2, sl
348106a8:	aa000003 	bge	348106bc <input_send_keycodes+0xd4>
348106ac:	e593a008 	ldr	sl, [r3, #8]
348106b0:	e7da0a20 	ldrb	r0, [sl, r0, lsr #20]
348106b4:	e35000ff 	cmp	r0, #255	; 0xff
348106b8:	1a000027 	bne	3481075c <input_send_keycodes+0x174>
			table = process_modifier(config, key,
348106bc:	e2011902 	and	r1, r1, #32768	; 0x8000
348106c0:	e50b1028 	str	r1, [fp, #-40]	; 0x28
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
348106c4:	e5d4101b 	ldrb	r1, [r4, #27]
348106c8:	e1a00004 	mov	r0, r4
348106cc:	e50b102c 	str	r1, [fp, #-44]	; 0x2c
	int flip = -1;
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
348106d0:	e51b3024 	ldr	r3, [fp, #-36]	; 0x24
	for (i = 1; i < config->num_tables; i++) {
348106d4:	e3a01001 	mov	r1, #1
348106d8:	ea000009 	b	34810704 <input_send_keycodes+0x11c>
		struct input_key_xlate *tab = &config->table[i];

		if (key == tab->left_keycode || key == tab->right_keycode)
348106dc:	e590a070 	ldr	sl, [r0, #112]	; 0x70
348106e0:	e152000a 	cmp	r2, sl
348106e4:	0a000002 	beq	348106f4 <input_send_keycodes+0x10c>
348106e8:	e590a074 	ldr	sl, [r0, #116]	; 0x74
348106ec:	e152000a 	cmp	r2, sl
348106f0:	1a000001 	bne	348106fc <input_send_keycodes+0x114>

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
		struct input_key_xlate *tab = &config->table[i];
348106f4:	e2813006 	add	r3, r1, #6
348106f8:	e0843203 	add	r3, r4, r3, lsl #4
	int i;

	/* Start with the main table, and see what modifiers change it */
	assert(config->num_tables > 0);
	table = &config->table[0];
	for (i = 1; i < config->num_tables; i++) {
348106fc:	e2811001 	add	r1, r1, #1
34810700:	e2800010 	add	r0, r0, #16
34810704:	e51ba02c 	ldr	sl, [fp, #-44]	; 0x2c
34810708:	e151000a 	cmp	r1, sl
3481070c:	bafffff2 	blt	348106dc <input_send_keycodes+0xf4>
		if (key == tab->left_keycode || key == tab->right_keycode)
			table = tab;
	}

	/* Handle the lighted keys */
	if (!release) {
34810710:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
34810714:	e3500000 	cmp	r0, #0
34810718:	1a00000f 	bne	3481075c <input_send_keycodes+0x174>
3481071c:	e242203a 	sub	r2, r2, #58	; 0x3a
34810720:	e352000c 	cmp	r2, #12
34810724:	8a00000c 	bhi	3481075c <input_send_keycodes+0x174>
			flip = FLAG_CAPS_LOCK;
			break;
		}
	}

	if (flip != -1) {
34810728:	e59f10d8 	ldr	r1, [pc, #216]	; 34810808 <input_send_keycodes+0x220>
3481072c:	e7912102 	ldr	r2, [r1, r2, lsl #2]
34810730:	e3720001 	cmn	r2, #1
34810734:	0a000008 	beq	3481075c <input_send_keycodes+0x174>
		int leds = 0;

		config->leds ^= flip;
		if (config->flags & FLAG_NUM_LOCK)
34810738:	e5d41019 	ldrb	r1, [r4, #25]
			leds |= INPUT_LED_NUM;
3481073c:	e3110001 	tst	r1, #1
34810740:	03a02000 	moveq	r2, #0
34810744:	13a02004 	movne	r2, #4
		if (config->flags & FLAG_CAPS_LOCK)
34810748:	e3110002 	tst	r1, #2
			leds |= INPUT_LED_CAPS;
3481074c:	13822002 	orrne	r2, r2, #2
		if (config->flags & FLAG_SCROLL_LOCK)
34810750:	e3110004 	tst	r1, #4
			leds |= INPUT_LED_SCROLL;
34810754:	13822001 	orrne	r2, r2, #1
		config->leds = leds;
34810758:	e5c4201a 	strb	r2, [r4, #26]
	int i;

	table = &config->table[0];

	/* deal with modifiers first */
	for (i = 0; i < num_keycodes; i++) {
3481075c:	e28cc001 	add	ip, ip, #1
34810760:	e15c0005 	cmp	ip, r5
34810764:	baffffca 	blt	34810694 <input_send_keycodes+0xac>
34810768:	e3a02000 	mov	r2, #0
3481076c:	e1a0a002 	mov	sl, r2
34810770:	ea00000f 	b	348107b4 <input_send_keycodes+0x1cc>
		}
	}

	/* now find normal keys */
	for (i = ch_count = 0; i < num_keycodes; i++) {
		int key = keycode[i];
34810774:	e4961004 	ldr	r1, [r6], #4

		if (key < table->num_entries && i >= same) {
34810778:	e593c00c 	ldr	ip, [r3, #12]
3481077c:	e1520007 	cmp	r2, r7
34810780:	b3a00000 	movlt	r0, #0
34810784:	a3a00001 	movge	r0, #1
34810788:	e151000c 	cmp	r1, ip
3481078c:	a3a00000 	movge	r0, #0
34810790:	e3500000 	cmp	r0, #0
34810794:	0a000005 	beq	348107b0 <input_send_keycodes+0x1c8>
			int ch = table->xlate[key];
34810798:	e5930008 	ldr	r0, [r3, #8]
3481079c:	e7d01001 	ldrb	r1, [r0, r1]

			/* If a normal key with an ASCII value, add it! */
			if (ch != 0xff)
348107a0:	e35100ff 	cmp	r1, #255	; 0xff
				output_ch[ch_count++] = (uchar)ch;
348107a4:	151b0020 	ldrne	r0, [fp, #-32]
348107a8:	17c0100a 	strbne	r1, [r0, sl]
348107ac:	128aa001 	addne	sl, sl, #1
					keycode[i] & KEY_RELEASE);
		}
	}

	/* now find normal keys */
	for (i = ch_count = 0; i < num_keycodes; i++) {
348107b0:	e2822001 	add	r2, r2, #1
348107b4:	e1520005 	cmp	r2, r5
348107b8:	baffffed 	blt	34810774 <input_send_keycodes+0x18c>
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
348107bc:	e3a05000 	mov	r5, #0
348107c0:	ea000004 	b	348107d8 <input_send_keycodes+0x1f0>
		input_queue_ascii(config, ch[i]);
348107c4:	e51b3020 	ldr	r3, [fp, #-32]
348107c8:	e1a00004 	mov	r0, r4
348107cc:	e7d31005 	ldrb	r1, [r3, r5]
348107d0:	ebffff47 	bl	348104f4 <input_queue_ascii>
			return 0;
	}

	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
348107d4:	e2855001 	add	r5, r5, #1
348107d8:	e155000a 	cmp	r5, sl
348107dc:	bafffff8 	blt	348107c4 <input_send_keycodes+0x1dc>
		input_queue_ascii(config, ch[i]);
	delay_ms = is_repeat ?
			config->repeat_rate_ms :
348107e0:	e3590000 	cmp	r9, #0
			config->repeat_delay_ms;

	config->next_repeat_ms = get_timer(0) + delay_ms;
348107e4:	e3a00000 	mov	r0, #0
	count = input_keycodes_to_ascii(config, keycode, num_keycodes,
					ch, is_repeat ? 0 : same);
	for (i = 0; i < count; i++)
		input_queue_ascii(config, ch[i]);
	delay_ms = is_repeat ?
			config->repeat_rate_ms :
348107e8:	159450ac 	ldrne	r5, [r4, #172]	; 0xac
348107ec:	059450a8 	ldreq	r5, [r4, #168]	; 0xa8
			config->repeat_delay_ms;

	config->next_repeat_ms = get_timer(0) + delay_ms;
348107f0:	ebffc04b 	bl	34800924 <get_timer>
348107f4:	e0800005 	add	r0, r0, r5
348107f8:	e58400a4 	str	r0, [r4, #164]	; 0xa4
	return 0;
}
348107fc:	e3a00000 	mov	r0, #0
34810800:	e24bd01c 	sub	sp, fp, #28
34810804:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34810808:	34821374 	.word	0x34821374

3481080c <input_add_table>:

int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
3481080c:	e92d4010 	push	{r4, lr}
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810810:	e5d0c01b 	ldrb	ip, [r0, #27]
34810814:	e35c0004 	cmp	ip, #4
34810818:	0a00000b 	beq	3481084c <input_add_table+0x40>
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
3481081c:	e28c4001 	add	r4, ip, #1
34810820:	e5c0401b 	strb	r4, [r0, #27]
	table->left_keycode = left_keycode;
34810824:	e28c4006 	add	r4, ip, #6
34810828:	e7801204 	str	r1, [r0, r4, lsl #4]
	table->right_keycode = right_keycode;
3481082c:	e0804204 	add	r4, r0, r4, lsl #4
	table->xlate = xlate;
34810830:	e080020c 	add	r0, r0, ip, lsl #4
34810834:	e5803068 	str	r3, [r0, #104]	; 0x68
	table->num_entries = num_entries;
34810838:	e59d3008 	ldr	r3, [sp, #8]
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
3481083c:	e5842004 	str	r2, [r4, #4]
	table->xlate = xlate;
	table->num_entries = num_entries;
34810840:	e580306c 	str	r3, [r0, #108]	; 0x6c

	return 0;
34810844:	e3a00000 	mov	r0, #0
34810848:	e8bd8010 	pop	{r4, pc}
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
3481084c:	e3e00000 	mvn	r0, #0
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;

	return 0;
}
34810850:	e8bd8010 	pop	{r4, pc}

34810854 <input_init>:

int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
34810854:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34810858:	e1a04000 	mov	r4, r0
3481085c:	e1a06001 	mov	r6, r1
34810860:	e1a05002 	mov	r5, r2
	memset(config, '\0', sizeof(*config));
34810864:	e3a01000 	mov	r1, #0
34810868:	e3a020b0 	mov	r2, #176	; 0xb0
	return 0;
}

int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
3481086c:	e1a07003 	mov	r7, r3
	memset(config, '\0', sizeof(*config));
34810870:	eb002d93 	bl	3481bec4 <memset>
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810874:	e5d4301b 	ldrb	r3, [r4, #27]

int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
	memset(config, '\0', sizeof(*config));
	config->leds = leds;
34810878:	e5c4601a 	strb	r6, [r4, #26]
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
3481087c:	e3530004 	cmp	r3, #4
int input_init(struct input_config *config, int leds, int repeat_delay_ms,
	       int repeat_rate_ms)
{
	memset(config, '\0', sizeof(*config));
	config->leds = leds;
	config->repeat_delay_ms = repeat_delay_ms;
34810880:	e58450a8 	str	r5, [r4, #168]	; 0xa8
	config->repeat_rate_ms = repeat_rate_ms;
34810884:	e58470ac 	str	r7, [r4, #172]	; 0xac
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810888:	0a00002b 	beq	3481093c <input_init+0xe8>
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
3481088c:	e2831006 	add	r1, r3, #6
34810890:	e3e00000 	mvn	r0, #0
34810894:	e7840201 	str	r0, [r4, r1, lsl #4]
	table->right_keycode = right_keycode;
34810898:	e0841201 	add	r1, r4, r1, lsl #4
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
3481089c:	e2832001 	add	r2, r3, #1
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
348108a0:	e5810004 	str	r0, [r1, #4]
	table->xlate = xlate;
348108a4:	e59f1098 	ldr	r1, [pc, #152]	; 34810944 <input_init+0xf0>
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
348108a8:	e6ef2072 	uxtb	r2, r2
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
348108ac:	e0843203 	add	r3, r4, r3, lsl #4
348108b0:	e5831068 	str	r1, [r3, #104]	; 0x68
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
348108b4:	e3520004 	cmp	r2, #4

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;
348108b8:	e3a01063 	mov	r1, #99	; 0x63
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
348108bc:	e5c4201b 	strb	r2, [r4, #27]
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
	table->num_entries = num_entries;
348108c0:	e583106c 	str	r1, [r3, #108]	; 0x6c
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
348108c4:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
348108c8:	e282c006 	add	ip, r2, #6
348108cc:	e3a0502a 	mov	r5, #42	; 0x2a
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
348108d0:	e2823001 	add	r3, r2, #1
	table->left_keycode = left_keycode;
348108d4:	e784520c 	str	r5, [r4, ip, lsl #4]
	table->right_keycode = right_keycode;
348108d8:	e084c20c 	add	ip, r4, ip, lsl #4
348108dc:	e285500c 	add	r5, r5, #12
	if (config->num_tables == INPUT_MAX_MODIFIERS) {
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
348108e0:	e6ef3073 	uxtb	r3, r3
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
348108e4:	e58c5004 	str	r5, [ip, #4]
	table->xlate = xlate;
348108e8:	e59fc058 	ldr	ip, [pc, #88]	; 34810948 <input_init+0xf4>
348108ec:	e0842202 	add	r2, r4, r2, lsl #4
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
348108f0:	e3530004 	cmp	r3, #4
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
348108f4:	e5c4301b 	strb	r3, [r4, #27]
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
	table->xlate = xlate;
348108f8:	e582c068 	str	ip, [r2, #104]	; 0x68
	table->num_entries = num_entries;
348108fc:	e582106c 	str	r1, [r2, #108]	; 0x6c
int input_add_table(struct input_config *config, int left_keycode,
		    int right_keycode, const uchar *xlate, int num_entries)
{
	struct input_key_xlate *table;

	if (config->num_tables == INPUT_MAX_MODIFIERS) {
34810900:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		debug("%s: Too many modifier tables\n", __func__);
		return -1;
	}

	table = &config->table[config->num_tables++];
34810904:	e2832001 	add	r2, r3, #1
34810908:	e5c4201b 	strb	r2, [r4, #27]
	table->left_keycode = left_keycode;
3481090c:	e280001e 	add	r0, r0, #30
34810910:	e2832006 	add	r2, r3, #6
34810914:	e7840202 	str	r0, [r4, r2, lsl #4]
	table->right_keycode = right_keycode;
	table->xlate = xlate;
34810918:	e28cc064 	add	ip, ip, #100	; 0x64
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
3481091c:	e0842202 	add	r2, r4, r2, lsl #4
34810920:	e2800044 	add	r0, r0, #68	; 0x44
	table->xlate = xlate;
34810924:	e0844203 	add	r4, r4, r3, lsl #4
		return -1;
	}

	table = &config->table[config->num_tables++];
	table->left_keycode = left_keycode;
	table->right_keycode = right_keycode;
34810928:	e5820004 	str	r0, [r2, #4]
	table->xlate = xlate;
3481092c:	e584c068 	str	ip, [r4, #104]	; 0x68
	table->num_entries = num_entries;
34810930:	e584106c 	str	r1, [r4, #108]	; 0x6c
			kbd_ctrl_xlate, ARRAY_SIZE(kbd_ctrl_xlate))) {
		debug("%s: Could not add modifier tables\n", __func__);
		return -1;
	}

	return 0;
34810934:	e3a00000 	mov	r0, #0
34810938:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
		input_add_table(config, KEY_LEFTSHIFT, KEY_RIGHTSHIFT,
			kbd_shift_xlate, ARRAY_SIZE(kbd_shift_xlate)) ||
		input_add_table(config, KEY_LEFTCTRL, KEY_RIGHTCTRL,
			kbd_ctrl_xlate, ARRAY_SIZE(kbd_ctrl_xlate))) {
		debug("%s: Could not add modifier tables\n", __func__);
		return -1;
3481093c:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
34810940:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34810944:	348213a8 	.word	0x348213a8
34810948:	34828a50 	.word	0x34828a50

3481094c <input_stdio_register>:

int input_stdio_register(struct stdio_dev *dev)
{
3481094c:	e92d4038 	push	{r3, r4, r5, lr}
34810950:	e1a04000 	mov	r4, r0
	int error;

	error = stdio_register(dev);
34810954:	ebfff78e 	bl	3480e794 <stdio_register>

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
34810958:	e2505000 	subs	r5, r0, #0
		if (OVERWRITE_CONSOLE ||
				console_assign(stdin, dev->name))
			return -1;
	}

	return 0;
3481095c:	13a00000 	movne	r0, #0
	int error;

	error = stdio_register(dev);

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
34810960:	18bd8038 	popne	{r3, r4, r5, pc}
34810964:	e59f0030 	ldr	r0, [pc, #48]	; 3481099c <input_stdio_register+0x50>
34810968:	e2844008 	add	r4, r4, #8
3481096c:	ebffdb0e 	bl	348075ac <getenv>
34810970:	e1a01004 	mov	r1, r4
34810974:	eb002c7e 	bl	3481bb74 <strcmp>
34810978:	e3500000 	cmp	r0, #0
3481097c:	1a000004 	bne	34810994 <input_stdio_register+0x48>
		/* reassign the console */
		if (OVERWRITE_CONSOLE ||
				console_assign(stdin, dev->name))
34810980:	e1a01004 	mov	r1, r4
34810984:	ebffe24a 	bl	348092b4 <console_assign>
	error = stdio_register(dev);

	/* check if this is the standard input device */
	if (!error && strcmp(getenv("stdin"), dev->name) == 0) {
		/* reassign the console */
		if (OVERWRITE_CONSOLE ||
34810988:	e3500000 	cmp	r0, #0
				console_assign(stdin, dev->name))
			return -1;
	}

	return 0;
3481098c:	13e00000 	mvnne	r0, #0
34810990:	e8bd8038 	pop	{r3, r4, r5, pc}
34810994:	e1a00005 	mov	r0, r5
}
34810998:	e8bd8038 	pop	{r3, r4, r5, pc}
3481099c:	3482520d 	.word	0x3482520d

348109a0 <do_pmic>:
	char *cmd;

	struct pmic *p = &pmic;

	/* at least two arguments please */
	if (argc < 2)
348109a0:	e3520001 	cmp	r2, #1
{
	return &pmic;
}

int do_pmic(cmd_tbl_t *cmdtp, int flag, int argc, char * const argv[])
{
348109a4:	e92d44f3 	push	{r0, r1, r4, r5, r6, r7, sl, lr}
348109a8:	e1a04000 	mov	r4, r0
348109ac:	e1a07002 	mov	r7, r2
348109b0:	e1a05003 	mov	r5, r3
	char *cmd;

	struct pmic *p = &pmic;

	/* at least two arguments please */
	if (argc < 2)
348109b4:	da000045 	ble	34810ad0 <do_pmic+0x130>
		return cmd_usage(cmdtp);

	cmd = argv[1];
348109b8:	e5936004 	ldr	r6, [r3, #4]
	if (strcmp(cmd, "dump") == 0) {
348109bc:	e59f1154 	ldr	r1, [pc, #340]	; 34810b18 <do_pmic+0x178>
348109c0:	e1a00006 	mov	r0, r6
348109c4:	eb002c6a 	bl	3481bb74 <strcmp>
348109c8:	e250a000 	subs	sl, r0, #0
348109cc:	1a00001d 	bne	34810a48 <do_pmic+0xa8>

	/* No subcommand found */
	return 1;
}

U_BOOT_CMD(
348109d0:	e59f6144 	ldr	r6, [pc, #324]	; 34810b1c <do_pmic+0x17c>
	return 0;
}

static void pmic_show_info(struct pmic *p)
{
	printf("PMIC: %s\n", p->name);
348109d4:	e59f0144 	ldr	r0, [pc, #324]	; 34810b20 <do_pmic+0x180>
348109d8:	e5961000 	ldr	r1, [r6]
348109dc:	ebffe1e0 	bl	34809164 <printf>
{
	int i, ret;
	u32 val;

	pmic_show_info(p);
	for (i = 0; i < p->number_of_regs; i++) {
348109e0:	e1a0400a 	mov	r4, sl
		ret = pmic_reg_read(p, i, &val);
348109e4:	e1a0500d 	mov	r5, sp
348109e8:	ea000010 	b	34810a30 <do_pmic+0x90>
348109ec:	e59f0128 	ldr	r0, [pc, #296]	; 34810b1c <do_pmic+0x17c>
348109f0:	e1a01004 	mov	r1, r4
348109f4:	e1a0200d 	mov	r2, sp
348109f8:	eb0000a2 	bl	34810c88 <pmic_reg_read>
		if (ret)
348109fc:	e3500000 	cmp	r0, #0
34810a00:	0a000001 	beq	34810a0c <do_pmic+0x6c>
			puts("PMIC: Registers dump failed\n");
34810a04:	e59f0118 	ldr	r0, [pc, #280]	; 34810b24 <do_pmic+0x184>
34810a08:	ebffe1cb 	bl	3480913c <puts>

		if (!(i % 8))
34810a0c:	e3140007 	tst	r4, #7
34810a10:	1a000002 	bne	34810a20 <do_pmic+0x80>
			printf("\n0x%02x: ", i);
34810a14:	e59f010c 	ldr	r0, [pc, #268]	; 34810b28 <do_pmic+0x188>
34810a18:	e1a01004 	mov	r1, r4
34810a1c:	ebffe1d0 	bl	34809164 <printf>

		printf("%08x ", val);
34810a20:	e59f0104 	ldr	r0, [pc, #260]	; 34810b2c <do_pmic+0x18c>
34810a24:	e59d1000 	ldr	r1, [sp]
34810a28:	ebffe1cd 	bl	34809164 <printf>
{
	int i, ret;
	u32 val;

	pmic_show_info(p);
	for (i = 0; i < p->number_of_regs; i++) {
34810a2c:	e2844001 	add	r4, r4, #1
34810a30:	e5d63006 	ldrb	r3, [r6, #6]
34810a34:	e1540003 	cmp	r4, r3
34810a38:	baffffeb 	blt	348109ec <do_pmic+0x4c>
		if (!(i % 8))
			printf("\n0x%02x: ", i);

		printf("%08x ", val);
	}
	puts("\n");
34810a3c:	e59f00ec 	ldr	r0, [pc, #236]	; 34810b30 <do_pmic+0x190>
34810a40:	ebffe1bd 	bl	3480913c <puts>
34810a44:	ea000016 	b	34810aa4 <do_pmic+0x104>
	if (strcmp(cmd, "dump") == 0) {
		pmic_dump(p);
		return 0;
	}

	if (strcmp(cmd, "read") == 0) {
34810a48:	e59f10e4 	ldr	r1, [pc, #228]	; 34810b34 <do_pmic+0x194>
34810a4c:	e1a00006 	mov	r0, r6
34810a50:	eb002c47 	bl	3481bb74 <strcmp>
34810a54:	e2501000 	subs	r1, r0, #0
34810a58:	1a000013 	bne	34810aac <do_pmic+0x10c>
		if (argc < 3)
34810a5c:	e3570002 	cmp	r7, #2
34810a60:	0a000019 	beq	34810acc <do_pmic+0x12c>
			return cmd_usage(cmdtp);

		reg = simple_strtoul(argv[2], NULL, 16);
34810a64:	e3a02010 	mov	r2, #16
34810a68:	e5950008 	ldr	r0, [r5, #8]
34810a6c:	eb003007 	bl	3481ca90 <simple_strtoul>
34810a70:	e1a04000 	mov	r4, r0

		ret = pmic_reg_read(p, reg, &val);
34810a74:	e1a01004 	mov	r1, r4
34810a78:	e59f009c 	ldr	r0, [pc, #156]	; 34810b1c <do_pmic+0x17c>
34810a7c:	e28d2004 	add	r2, sp, #4
34810a80:	eb000080 	bl	34810c88 <pmic_reg_read>

		if (ret)
34810a84:	e3500000 	cmp	r0, #0
34810a88:	0a000001 	beq	34810a94 <do_pmic+0xf4>
			puts("PMIC: Register read failed\n");
34810a8c:	e59f00a4 	ldr	r0, [pc, #164]	; 34810b38 <do_pmic+0x198>
34810a90:	ebffe1a9 	bl	3480913c <puts>

		printf("\n0x%02x: 0x%08x\n", reg, val);
34810a94:	e59f00a0 	ldr	r0, [pc, #160]	; 34810b3c <do_pmic+0x19c>
34810a98:	e1a01004 	mov	r1, r4
34810a9c:	e59d2004 	ldr	r2, [sp, #4]
34810aa0:	ebffe1af 	bl	34809164 <printf>

		return 0;
34810aa4:	e3a00000 	mov	r0, #0
34810aa8:	ea000019 	b	34810b14 <do_pmic+0x174>
	}

	if (strcmp(cmd, "write") == 0) {
34810aac:	e1a00006 	mov	r0, r6
34810ab0:	e59f1088 	ldr	r1, [pc, #136]	; 34810b40 <do_pmic+0x1a0>
34810ab4:	eb002c2e 	bl	3481bb74 <strcmp>
34810ab8:	e2506000 	subs	r6, r0, #0

		return 0;
	}

	/* No subcommand found */
	return 1;
34810abc:	13a00001 	movne	r0, #1
		printf("\n0x%02x: 0x%08x\n", reg, val);

		return 0;
	}

	if (strcmp(cmd, "write") == 0) {
34810ac0:	1a000013 	bne	34810b14 <do_pmic+0x174>
		if (argc < 4)
34810ac4:	e3570003 	cmp	r7, #3
34810ac8:	ca000002 	bgt	34810ad8 <do_pmic+0x138>
			return cmd_usage(cmdtp);
34810acc:	e1a00004 	mov	r0, r4
34810ad0:	ebffe04c 	bl	34808c08 <cmd_usage>
34810ad4:	ea00000e 	b	34810b14 <do_pmic+0x174>

		reg = simple_strtoul(argv[2], NULL, 16);
34810ad8:	e1a01006 	mov	r1, r6
34810adc:	e3a02010 	mov	r2, #16
34810ae0:	e5950008 	ldr	r0, [r5, #8]
34810ae4:	eb002fe9 	bl	3481ca90 <simple_strtoul>
		val = simple_strtoul(argv[3], NULL, 16);
34810ae8:	e1a01006 	mov	r1, r6

	if (strcmp(cmd, "write") == 0) {
		if (argc < 4)
			return cmd_usage(cmdtp);

		reg = simple_strtoul(argv[2], NULL, 16);
34810aec:	e1a04000 	mov	r4, r0
		val = simple_strtoul(argv[3], NULL, 16);
34810af0:	e3a02010 	mov	r2, #16
34810af4:	e595000c 	ldr	r0, [r5, #12]
34810af8:	eb002fe4 	bl	3481ca90 <simple_strtoul>

		pmic_reg_write(p, reg, val);
34810afc:	e1a01004 	mov	r1, r4
	if (strcmp(cmd, "write") == 0) {
		if (argc < 4)
			return cmd_usage(cmdtp);

		reg = simple_strtoul(argv[2], NULL, 16);
		val = simple_strtoul(argv[3], NULL, 16);
34810b00:	e1a02000 	mov	r2, r0
34810b04:	e58d0004 	str	r0, [sp, #4]

		pmic_reg_write(p, reg, val);
34810b08:	e59f000c 	ldr	r0, [pc, #12]	; 34810b1c <do_pmic+0x17c>
34810b0c:	eb000033 	bl	34810be0 <pmic_reg_write>

		return 0;
34810b10:	e1a00006 	mov	r0, r6
	}

	/* No subcommand found */
	return 1;
}
34810b14:	e8bd84fc 	pop	{r2, r3, r4, r5, r6, r7, sl, pc}
34810b18:	34825d06 	.word	0x34825d06
34810b1c:	3482ba08 	.word	0x3482ba08
34810b20:	34826e35 	.word	0x34826e35
34810b24:	34826e3f 	.word	0x34826e3f
34810b28:	34826e5c 	.word	0x34826e5c
34810b2c:	34826e66 	.word	0x34826e66
34810b30:	34826214 	.word	0x34826214
34810b34:	34824149 	.word	0x34824149
34810b38:	34826e6c 	.word	0x34826e6c
34810b3c:	34826e88 	.word	0x34826e88
34810b40:	3482414e 	.word	0x3482414e

34810b44 <check_reg>:
#include <pmic.h>

static struct pmic pmic;

int check_reg(u32 reg)
{
34810b44:	e92d4008 	push	{r3, lr}
	if (reg >= pmic.number_of_regs) {
34810b48:	e59f3024 	ldr	r3, [pc, #36]	; 34810b74 <check_reg+0x30>
#include <pmic.h>

static struct pmic pmic;

int check_reg(u32 reg)
{
34810b4c:	e1a01000 	mov	r1, r0
	if (reg >= pmic.number_of_regs) {
34810b50:	e5d32006 	ldrb	r2, [r3, #6]
34810b54:	e1500002 	cmp	r0, r2
34810b58:	3a000003 	bcc	34810b6c <check_reg+0x28>
		printf("<reg num> = %d is invalid. Should be less than %d\n",
34810b5c:	e59f0014 	ldr	r0, [pc, #20]	; 34810b78 <check_reg+0x34>
34810b60:	ebffe17f 	bl	34809164 <printf>
		       reg, pmic.number_of_regs);
		return -1;
34810b64:	e3e00000 	mvn	r0, #0
34810b68:	e8bd8008 	pop	{r3, pc}
	}
	return 0;
34810b6c:	e3a00000 	mov	r0, #0
}
34810b70:	e8bd8008 	pop	{r3, pc}
34810b74:	3482ba08 	.word	0x3482ba08
34810b78:	34826e99 	.word	0x34826e99

34810b7c <pmic_set_output>:

int pmic_set_output(struct pmic *p, u32 reg, int out, int on)
{
34810b7c:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34810b80:	e1a04002 	mov	r4, r2
	u32 val;

	if (pmic_reg_read(p, reg, &val))
34810b84:	e28d2004 	add	r2, sp, #4
	}
	return 0;
}

int pmic_set_output(struct pmic *p, u32 reg, int out, int on)
{
34810b88:	e1a06000 	mov	r6, r0
34810b8c:	e1a05001 	mov	r5, r1
34810b90:	e1a07003 	mov	r7, r3
	u32 val;

	if (pmic_reg_read(p, reg, &val))
34810b94:	eb00003b 	bl	34810c88 <pmic_reg_read>
34810b98:	e3500000 	cmp	r0, #0
		return -1;
34810b9c:	13e00000 	mvnne	r0, #0

int pmic_set_output(struct pmic *p, u32 reg, int out, int on)
{
	u32 val;

	if (pmic_reg_read(p, reg, &val))
34810ba0:	1a00000a 	bne	34810bd0 <pmic_set_output+0x54>
34810ba4:	e59d3004 	ldr	r3, [sp, #4]
		return -1;

	if (on)
34810ba8:	e3570000 	cmp	r7, #0
		val |= out;
34810bac:	11834004 	orrne	r4, r3, r4
	else
		val &= ~out;
34810bb0:	01c34004 	biceq	r4, r3, r4
34810bb4:	e58d4004 	str	r4, [sp, #4]

	if (pmic_reg_write(p, reg, val))
34810bb8:	e1a00006 	mov	r0, r6
34810bbc:	e1a01005 	mov	r1, r5
34810bc0:	e59d2004 	ldr	r2, [sp, #4]
34810bc4:	eb000005 	bl	34810be0 <pmic_reg_write>
34810bc8:	e3500000 	cmp	r0, #0
		return -1;
34810bcc:	13e00000 	mvnne	r0, #0

	return 0;
}
34810bd0:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34810bd4 <get_pmic>:
}

struct pmic *get_pmic(void)
{
	return &pmic;
}
34810bd4:	e59f0000 	ldr	r0, [pc, #0]	; 34810bdc <get_pmic+0x8>
34810bd8:	e12fff1e 	bx	lr
34810bdc:	3482ba08 	.word	0x3482ba08

34810be0 <pmic_reg_write>:
#include <linux/types.h>
#include <pmic.h>
#include <i2c.h>

int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
34810be0:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	unsigned char buf[4] = { 0 };
34810be4:	e3a03000 	mov	r3, #0
#include <linux/types.h>
#include <pmic.h>
#include <i2c.h>

int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
34810be8:	e1a04000 	mov	r4, r0
	unsigned char buf[4] = { 0 };

	if (check_reg(reg))
34810bec:	e1a00001 	mov	r0, r1
#include <linux/types.h>
#include <pmic.h>
#include <i2c.h>

int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
34810bf0:	e1a05001 	mov	r5, r1
34810bf4:	e1a06002 	mov	r6, r2
	unsigned char buf[4] = { 0 };
34810bf8:	e58d300c 	str	r3, [sp, #12]

	if (check_reg(reg))
34810bfc:	ebffffd0 	bl	34810b44 <check_reg>
34810c00:	e3500000 	cmp	r0, #0
34810c04:	1a00001a 	bne	34810c74 <pmic_reg_write+0x94>
		return -1;

	switch (pmic_i2c_tx_num) {
34810c08:	e5d43010 	ldrb	r3, [r4, #16]
34810c0c:	e3530001 	cmp	r3, #1
34810c10:	0a000007 	beq	34810c34 <pmic_reg_write+0x54>
34810c14:	e3530003 	cmp	r3, #3
34810c18:	1a000007 	bne	34810c3c <pmic_reg_write+0x5c>
	case 3:
		buf[0] = (val >> 16) & 0xff;
34810c1c:	e1a02826 	lsr	r2, r6, #16
34810c20:	e5cd200c 	strb	r2, [sp, #12]
		buf[1] = (val >> 8) & 0xff;
34810c24:	e1a02426 	lsr	r2, r6, #8
34810c28:	e5cd200d 	strb	r2, [sp, #13]
		buf[2] = val & 0xff;
34810c2c:	e5cd600e 	strb	r6, [sp, #14]
		break;
34810c30:	ea000006 	b	34810c50 <pmic_reg_write+0x70>
	case 1:
		buf[0] = val & 0xff;
34810c34:	e5cd600c 	strb	r6, [sp, #12]
		break;
34810c38:	ea000004 	b	34810c50 <pmic_reg_write+0x70>
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
34810c3c:	e59f103c 	ldr	r1, [pc, #60]	; 34810c80 <pmic_reg_write+0xa0>
34810c40:	e1a02003 	mov	r2, r3
34810c44:	e59f0038 	ldr	r0, [pc, #56]	; 34810c84 <pmic_reg_write+0xa4>
34810c48:	ebffe145 	bl	34809164 <printf>
34810c4c:	ea000008 	b	34810c74 <pmic_reg_write+0x94>
		return -1;
	}

	if (i2c_write(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
34810c50:	e58d3000 	str	r3, [sp]
34810c54:	e5d40008 	ldrb	r0, [r4, #8]
34810c58:	e1a01005 	mov	r1, r5
34810c5c:	e3a02001 	mov	r2, #1
34810c60:	e28d300c 	add	r3, sp, #12
34810c64:	ebfffdc2 	bl	34810374 <i2c_write>
34810c68:	e3500000 	cmp	r0, #0
		return -1;
34810c6c:	13e00000 	mvnne	r0, #0
34810c70:	ea000000 	b	34810c78 <pmic_reg_write+0x98>
int pmic_reg_write(struct pmic *p, u32 reg, u32 val)
{
	unsigned char buf[4] = { 0 };

	if (check_reg(reg))
		return -1;
34810c74:	e3e00000 	mvn	r0, #0

	if (i2c_write(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
		return -1;

	return 0;
}
34810c78:	e28dd010 	add	sp, sp, #16
34810c7c:	e8bd8070 	pop	{r4, r5, r6, pc}
34810c80:	3482140c 	.word	0x3482140c
34810c84:	34826f3b 	.word	0x34826f3b

34810c88 <pmic_reg_read>:

int pmic_reg_read(struct pmic *p, u32 reg, u32 *val)
{
34810c88:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
	unsigned char buf[4] = { 0 };
34810c8c:	e3a03000 	mov	r3, #0

	return 0;
}

int pmic_reg_read(struct pmic *p, u32 reg, u32 *val)
{
34810c90:	e1a04000 	mov	r4, r0
	unsigned char buf[4] = { 0 };
	u32 ret_val = 0;

	if (check_reg(reg))
34810c94:	e1a00001 	mov	r0, r1

	return 0;
}

int pmic_reg_read(struct pmic *p, u32 reg, u32 *val)
{
34810c98:	e1a06001 	mov	r6, r1
34810c9c:	e1a05002 	mov	r5, r2
	unsigned char buf[4] = { 0 };
34810ca0:	e58d300c 	str	r3, [sp, #12]
	u32 ret_val = 0;
34810ca4:	e58d3008 	str	r3, [sp, #8]

	if (check_reg(reg))
34810ca8:	ebffffa5 	bl	34810b44 <check_reg>
34810cac:	e3500000 	cmp	r0, #0
34810cb0:	1a00001f 	bne	34810d34 <pmic_reg_read+0xac>
		return -1;

	if (i2c_read(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
34810cb4:	e5d43010 	ldrb	r3, [r4, #16]
34810cb8:	e5d40008 	ldrb	r0, [r4, #8]
34810cbc:	e58d3000 	str	r3, [sp]
34810cc0:	e1a01006 	mov	r1, r6
34810cc4:	e3a02001 	mov	r2, #1
34810cc8:	e28d300c 	add	r3, sp, #12
34810ccc:	ebfffd4b 	bl	34810200 <i2c_read>
34810cd0:	e3500000 	cmp	r0, #0
34810cd4:	1a000016 	bne	34810d34 <pmic_reg_read+0xac>
		return -1;

	switch (pmic_i2c_tx_num) {
34810cd8:	e5d42010 	ldrb	r2, [r4, #16]
34810cdc:	e3520001 	cmp	r2, #1
34810ce0:	0a000008 	beq	34810d08 <pmic_reg_read+0x80>
34810ce4:	e3520003 	cmp	r2, #3
34810ce8:	1a00000e 	bne	34810d28 <pmic_reg_read+0xa0>
	case 3:
		ret_val = buf[0] << 16 | buf[1] << 8 | buf[2];
34810cec:	e5dd300d 	ldrb	r3, [sp, #13]
34810cf0:	e5dd200c 	ldrb	r2, [sp, #12]
34810cf4:	e1a03403 	lsl	r3, r3, #8
34810cf8:	e1833802 	orr	r3, r3, r2, lsl #16
34810cfc:	e5dd200e 	ldrb	r2, [sp, #14]
34810d00:	e1833002 	orr	r3, r3, r2
34810d04:	ea000000 	b	34810d0c <pmic_reg_read+0x84>
		break;
	case 1:
		ret_val = buf[0];
34810d08:	e5dd300c 	ldrb	r3, [sp, #12]
		break;
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
		return -1;
	}
	memcpy(val, &ret_val, sizeof(ret_val));
34810d0c:	e1a00005 	mov	r0, r5
34810d10:	e28d1008 	add	r1, sp, #8
34810d14:	e3a02004 	mov	r2, #4
	switch (pmic_i2c_tx_num) {
	case 3:
		ret_val = buf[0] << 16 | buf[1] << 8 | buf[2];
		break;
	case 1:
		ret_val = buf[0];
34810d18:	e58d3008 	str	r3, [sp, #8]
		break;
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
		return -1;
	}
	memcpy(val, &ret_val, sizeof(ret_val));
34810d1c:	eb002c8c 	bl	3481bf54 <memcpy>

	return 0;
34810d20:	e3a00000 	mov	r0, #0
34810d24:	ea000003 	b	34810d38 <pmic_reg_read+0xb0>
		break;
	case 1:
		ret_val = buf[0];
		break;
	default:
		printf("%s: invalid tx_num: %d", __func__, pmic_i2c_tx_num);
34810d28:	e59f0010 	ldr	r0, [pc, #16]	; 34810d40 <pmic_reg_read+0xb8>
34810d2c:	e59f1010 	ldr	r1, [pc, #16]	; 34810d44 <pmic_reg_read+0xbc>
34810d30:	ebffe10b 	bl	34809164 <printf>

	if (check_reg(reg))
		return -1;

	if (i2c_read(pmic_i2c_addr, reg, 1, buf, pmic_i2c_tx_num))
		return -1;
34810d34:	e3e00000 	mvn	r0, #0
		return -1;
	}
	memcpy(val, &ret_val, sizeof(ret_val));

	return 0;
}
34810d38:	e28dd010 	add	sp, sp, #16
34810d3c:	e8bd8070 	pop	{r4, r5, r6, pc}
34810d40:	34826f3b 	.word	0x34826f3b
34810d44:	3482141c 	.word	0x3482141c

34810d48 <pmic_probe>:

int pmic_probe(struct pmic *p)
{
34810d48:	e92d4010 	push	{r4, lr}
34810d4c:	e1a04000 	mov	r4, r0

static inline void I2C_SET_BUS(unsigned int bus) __attribute__((always_inline));
static inline void I2C_SET_BUS(unsigned int bus)
{
	if (I2C_MULTI_BUS)
		i2c_set_bus_num(bus);
34810d50:	e5d00004 	ldrb	r0, [r0, #4]
34810d54:	ebfffcf7 	bl	34810138 <i2c_set_bus_num>
	I2C_SET_BUS(p->bus);
	debug("PMIC:%s probed!\n", p->name);
	if (i2c_probe(pmic_i2c_addr)) {
34810d58:	e5d40008 	ldrb	r0, [r4, #8]
34810d5c:	ebfffd1c 	bl	348101d4 <i2c_probe>
34810d60:	e3500000 	cmp	r0, #0
34810d64:	08bd8010 	popeq	{r4, pc}
		printf("Can't find PMIC:%s\n", p->name);
34810d68:	e5941000 	ldr	r1, [r4]
34810d6c:	e59f0008 	ldr	r0, [pc, #8]	; 34810d7c <pmic_probe+0x34>
34810d70:	ebffe0fb 	bl	34809164 <printf>
		return -1;
34810d74:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
34810d78:	e8bd8010 	pop	{r4, pc}
34810d7c:	34826f52 	.word	0x34826f52

34810d80 <pmic_init>:
#include <common.h>
#include <pmic.h>
#include <max8998_pmic.h>

int pmic_init(void)
{
34810d80:	e92d4010 	push	{r4, lr}
	struct pmic *p = get_pmic();
34810d84:	ebffff92 	bl	34810bd4 <get_pmic>
34810d88:	e1a04000 	mov	r4, r0
	static const char name[] = "MAX8998_PMIC";

	puts("Board PMIC init\n");
34810d8c:	e59f0030 	ldr	r0, [pc, #48]	; 34810dc4 <pmic_init+0x44>
34810d90:	ebffe0e9 	bl	3480913c <puts>

	p->name = name;
34810d94:	e59f302c 	ldr	r3, [pc, #44]	; 34810dc8 <pmic_init+0x48>
	p->interface = PMIC_I2C;
34810d98:	e3a00000 	mov	r0, #0
	struct pmic *p = get_pmic();
	static const char name[] = "MAX8998_PMIC";

	puts("Board PMIC init\n");

	p->name = name;
34810d9c:	e5843000 	str	r3, [r4]
	p->interface = PMIC_I2C;
	p->number_of_regs = PMIC_NUM_OF_REGS;
34810da0:	e3a0302d 	mov	r3, #45	; 0x2d
34810da4:	e5c43006 	strb	r3, [r4, #6]
	p->hw.i2c.addr = MAX8998_I2C_ADDR;
34810da8:	e2833039 	add	r3, r3, #57	; 0x39
34810dac:	e5c43008 	strb	r3, [r4, #8]
	p->hw.i2c.tx_num = 1;
34810db0:	e3a03001 	mov	r3, #1
	static const char name[] = "MAX8998_PMIC";

	puts("Board PMIC init\n");

	p->name = name;
	p->interface = PMIC_I2C;
34810db4:	e5c40005 	strb	r0, [r4, #5]
	p->number_of_regs = PMIC_NUM_OF_REGS;
	p->hw.i2c.addr = MAX8998_I2C_ADDR;
	p->hw.i2c.tx_num = 1;
34810db8:	e5c43010 	strb	r3, [r4, #16]
	p->bus = I2C_PMIC;
34810dbc:	e5c40004 	strb	r0, [r4, #4]

	return 0;
}
34810dc0:	e8bd8010 	pop	{r4, pc}
34810dc4:	34826f66 	.word	0x34826f66
34810dc8:	3482142c 	.word	0x3482142c

34810dcc <__fswab32>:
34810dcc:	e6bf0f30 	rev	r0, r0
34810dd0:	e12fff1e 	bx	lr

34810dd4 <__board_mmc_getcd>:
static struct list_head mmc_devices;
static int cur_dev_num = -1;

int __board_mmc_getcd(struct mmc *mmc) {
	return -1;
}
34810dd4:	e3e00000 	mvn	r0, #0
34810dd8:	e12fff1e 	bx	lr

34810ddc <mmc_send_cmd>:
static inline void mmc_bounce_buffer_stop(struct mmc_data *backup,
					struct mmc_data *orig) { }
#endif

int mmc_send_cmd(struct mmc *mmc, struct mmc_cmd *cmd, struct mmc_data *data)
{
34810ddc:	e92d407f 	push	{r0, r1, r2, r3, r4, r5, r6, lr}
34810de0:	e1a04000 	mov	r4, r0
34810de4:	e1a06001 	mov	r6, r1
34810de8:	e1a05002 	mov	r5, r2
	struct mmc_data backup;
	int ret;

	memset(&backup, 0, sizeof(backup));
34810dec:	e1a0000d 	mov	r0, sp
34810df0:	e3a01000 	mov	r1, #0
34810df4:	e3a02010 	mov	r2, #16
34810df8:	eb002c31 	bl	3481bec4 <memset>
		default:
			printf("\t\tERROR MMC rsp not supported\n");
			break;
	}
#else
	ret = mmc->send_cmd(mmc, cmd, data);
34810dfc:	e5943110 	ldr	r3, [r4, #272]	; 0x110
34810e00:	e1a00004 	mov	r0, r4
34810e04:	e1a01006 	mov	r1, r6
34810e08:	e1a02005 	mov	r2, r5
34810e0c:	e12fff33 	blx	r3
#endif
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}
34810e10:	e28dd010 	add	sp, sp, #16
34810e14:	e8bd8070 	pop	{r4, r5, r6, pc}

34810e18 <mmc_send_status>:

int mmc_send_status(struct mmc *mmc, int timeout)
{
34810e18:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	int err, retries = 5;
#ifdef CONFIG_MMC_TRACE
	int status;
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
34810e1c:	e3a0300d 	mov	r3, #13
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
34810e20:	e24dd024 	sub	sp, sp, #36	; 0x24
	int err, retries = 5;
#ifdef CONFIG_MMC_TRACE
	int status;
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
34810e24:	e1cd30b4 	strh	r3, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
34810e28:	e3a03015 	mov	r3, #21
34810e2c:	e58d3008 	str	r3, [sp, #8]
	if (!mmc_host_is_spi(mmc))
34810e30:	e5903050 	ldr	r3, [r0, #80]	; 0x50
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
34810e34:	e1a06000 	mov	r6, r0
	int status;
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
	cmd.resp_type = MMC_RSP_R1;
	if (!mmc_host_is_spi(mmc))
34810e38:	e3130b01 	tst	r3, #1024	; 0x400
		cmd.cmdarg = mmc->rca << 16;
34810e3c:	01d038b0 	ldrheq	r3, [r0, #128]	; 0x80
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
34810e40:	e1a04001 	mov	r4, r1
#endif

	cmd.cmdidx = MMC_CMD_SEND_STATUS;
	cmd.resp_type = MMC_RSP_R1;
	if (!mmc_host_is_spi(mmc))
		cmd.cmdarg = mmc->rca << 16;
34810e44:	01a03803 	lsleq	r3, r3, #16
34810e48:	058d300c 	streq	r3, [sp, #12]
	mmc_bounce_buffer_stop(&backup, data);
	return ret;
}

int mmc_send_status(struct mmc *mmc, int timeout)
{
34810e4c:	e3a05005 	mov	r5, #5
	cmd.resp_type = MMC_RSP_R1;
	if (!mmc_host_is_spi(mmc))
		cmd.cmdarg = mmc->rca << 16;

	do {
		err = mmc_send_cmd(mmc, &cmd, NULL);
34810e50:	e28d7004 	add	r7, sp, #4
34810e54:	e1a00006 	mov	r0, r6
34810e58:	e1a01007 	mov	r1, r7
34810e5c:	e3a02000 	mov	r2, #0
34810e60:	ebffffdd 	bl	34810ddc <mmc_send_cmd>
		if (!err) {
34810e64:	e3500000 	cmp	r0, #0
34810e68:	1a00000d 	bne	34810ea4 <mmc_send_status+0x8c>
			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA) &&
34810e6c:	e59d1010 	ldr	r1, [sp, #16]
34810e70:	e3110c01 	tst	r1, #256	; 0x100
34810e74:	0a000002 	beq	34810e84 <mmc_send_status+0x6c>
			    (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
34810e78:	e2013c1e 	and	r3, r1, #7680	; 0x1e00
		cmd.cmdarg = mmc->rca << 16;

	do {
		err = mmc_send_cmd(mmc, &cmd, NULL);
		if (!err) {
			if ((cmd.response[0] & MMC_STATUS_RDY_FOR_DATA) &&
34810e7c:	e3530c0e 	cmp	r3, #3584	; 0xe00
34810e80:	1a00000d 	bne	34810ebc <mmc_send_status+0xa4>
			    (cmd.response[0] & MMC_STATUS_CURR_STATE) !=
			     MMC_STATE_PRG)
				break;
			else if (cmd.response[0] & MMC_STATUS_MASK) {
34810e84:	e59f3050 	ldr	r3, [pc, #80]	; 34810edc <mmc_send_status+0xc4>
34810e88:	e0013003 	and	r3, r1, r3
34810e8c:	e3530000 	cmp	r3, #0
34810e90:	0a000005 	beq	34810eac <mmc_send_status+0x94>
				printf("Status Error: 0x%08X\n",
34810e94:	e59f0044 	ldr	r0, [pc, #68]	; 34810ee0 <mmc_send_status+0xc8>
34810e98:	ebffe0b1 	bl	34809164 <printf>
					cmd.response[0]);
				return COMM_ERR;
34810e9c:	e3e00011 	mvn	r0, #17
34810ea0:	ea00000b 	b	34810ed4 <mmc_send_status+0xbc>
			}
		} else if (--retries < 0)
34810ea4:	e2555001 	subs	r5, r5, #1
34810ea8:	4a000009 	bmi	34810ed4 <mmc_send_status+0xbc>
			return err;

		udelay(1000);
34810eac:	e3a00ffa 	mov	r0, #1000	; 0x3e8
34810eb0:	eb002cb2 	bl	3481c180 <udelay>

	} while (timeout--);
34810eb4:	e2544001 	subs	r4, r4, #1
34810eb8:	2affffe5 	bcs	34810e54 <mmc_send_status+0x3c>

#ifdef CONFIG_MMC_TRACE
	status = (cmd.response[0] & MMC_STATUS_CURR_STATE) >> 9;
	printf("CURR STATE:%d\n", status);
#endif
	if (timeout <= 0) {
34810ebc:	e3540000 	cmp	r4, #0
		printf("Timeout waiting card ready\n");
		return TIMEOUT;
	}

	return 0;
34810ec0:	c3a00000 	movgt	r0, #0

#ifdef CONFIG_MMC_TRACE
	status = (cmd.response[0] & MMC_STATUS_CURR_STATE) >> 9;
	printf("CURR STATE:%d\n", status);
#endif
	if (timeout <= 0) {
34810ec4:	ca000002 	bgt	34810ed4 <mmc_send_status+0xbc>
		printf("Timeout waiting card ready\n");
34810ec8:	e59f0014 	ldr	r0, [pc, #20]	; 34810ee4 <mmc_send_status+0xcc>
34810ecc:	ebffe0a4 	bl	34809164 <printf>
		return TIMEOUT;
34810ed0:	e3e00012 	mvn	r0, #18
	}

	return 0;
}
34810ed4:	e28dd024 	add	sp, sp, #36	; 0x24
34810ed8:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
34810edc:	fdf94080 	.word	0xfdf94080
34810ee0:	34826f77 	.word	0x34826f77
34810ee4:	34826f8d 	.word	0x34826f8d

34810ee8 <mmc_set_blocklen>:

int mmc_set_blocklen(struct mmc *mmc, int len)
{
34810ee8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
34810eec:	e3a03010 	mov	r3, #16

	return 0;
}

int mmc_set_blocklen(struct mmc *mmc, int len)
{
34810ef0:	e24dd024 	sub	sp, sp, #36	; 0x24
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
34810ef4:	e1cd30b4 	strh	r3, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = len;
34810ef8:	e58d100c 	str	r1, [sp, #12]
int mmc_set_blocklen(struct mmc *mmc, int len)
{
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
	cmd.resp_type = MMC_RSP_R1;
34810efc:	e3a03015 	mov	r3, #21
	cmd.cmdarg = len;

	return mmc_send_cmd(mmc, &cmd, NULL);
34810f00:	e28d1004 	add	r1, sp, #4
34810f04:	e3a02000 	mov	r2, #0
int mmc_set_blocklen(struct mmc *mmc, int len)
{
	struct mmc_cmd cmd;

	cmd.cmdidx = MMC_CMD_SET_BLOCKLEN;
	cmd.resp_type = MMC_RSP_R1;
34810f08:	e58d3008 	str	r3, [sp, #8]
	cmd.cmdarg = len;

	return mmc_send_cmd(mmc, &cmd, NULL);
34810f0c:	ebffffb2 	bl	34810ddc <mmc_send_cmd>
}
34810f10:	e28dd024 	add	sp, sp, #36	; 0x24
34810f14:	e8bd8000 	pop	{pc}

34810f18 <find_mmc_device>:
struct mmc *find_mmc_device(int dev_num)
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34810f18:	e59f2038 	ldr	r2, [pc, #56]	; 34810f58 <find_mmc_device+0x40>

	return mmc_send_cmd(mmc, &cmd, NULL);
}

struct mmc *find_mmc_device(int dev_num)
{
34810f1c:	e92d4008 	push	{r3, lr}
34810f20:	e1a01000 	mov	r1, r0
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34810f24:	e5923000 	ldr	r3, [r2]
34810f28:	ea000004 	b	34810f40 <find_mmc_device+0x28>
		m = list_entry(entry, struct mmc, link);

		if (m->block_dev.dev == dev_num)
34810f2c:	e593c0a4 	ldr	ip, [r3, #164]	; 0xa4
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
		m = list_entry(entry, struct mmc, link);
34810f30:	e1a00003 	mov	r0, r3

		if (m->block_dev.dev == dev_num)
34810f34:	e15c0001 	cmp	ip, r1
34810f38:	08bd8008 	popeq	{r3, pc}
struct mmc *find_mmc_device(int dev_num)
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
34810f3c:	e5933000 	ldr	r3, [r3]
34810f40:	e1530002 	cmp	r3, r2
34810f44:	1afffff8 	bne	34810f2c <find_mmc_device+0x14>

		if (m->block_dev.dev == dev_num)
			return m;
	}

	printf("MMC Device %d not found\n", dev_num);
34810f48:	e59f000c 	ldr	r0, [pc, #12]	; 34810f5c <find_mmc_device+0x44>
34810f4c:	ebffe084 	bl	34809164 <printf>

	return NULL;
34810f50:	e3a00000 	mov	r0, #0
}
34810f54:	e8bd8008 	pop	{r3, pc}
34810f58:	3482ba28 	.word	0x3482ba28
34810f5c:	34826fa9 	.word	0x34826fa9

34810f60 <mmc_berase>:
	return err;
}

static unsigned long
mmc_berase(int dev_num, unsigned long start, lbaint_t blkcnt)
{
34810f60:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34810f64:	e24dd028 	sub	sp, sp, #40	; 0x28
34810f68:	e1a05001 	mov	r5, r1
34810f6c:	e1a06002 	mov	r6, r2
	int err = 0;
	struct mmc *mmc = find_mmc_device(dev_num);
34810f70:	ebffffe8 	bl	34810f18 <find_mmc_device>
	lbaint_t blk = 0, blk_r = 0;
	int timeout = 1000;

	if (!mmc)
34810f74:	e2504000 	subs	r4, r0, #0
		return -1;
34810f78:	03e07000 	mvneq	r7, #0
	int err = 0;
	struct mmc *mmc = find_mmc_device(dev_num);
	lbaint_t blk = 0, blk_r = 0;
	int timeout = 1000;

	if (!mmc)
34810f7c:	0a000056 	beq	348110dc <mmc_berase+0x17c>
		return -1;

	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
34810f80:	e5947090 	ldr	r7, [r4, #144]	; 0x90
34810f84:	e1a00005 	mov	r0, r5
34810f88:	e1a01007 	mov	r1, r7
34810f8c:	eb003b7e 	bl	3481fd8c <__aeabi_uidivmod>
34810f90:	e3510000 	cmp	r1, #0
34810f94:	1a000004 	bne	34810fac <mmc_berase+0x4c>
34810f98:	e1a00006 	mov	r0, r6
34810f9c:	e1a01007 	mov	r1, r7
34810fa0:	eb003b79 	bl	3481fd8c <__aeabi_uidivmod>
34810fa4:	e3510000 	cmp	r1, #0
34810fa8:	0a000045 	beq	348110c4 <mmc_berase+0x164>
		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
			"The erase range would be change to 0x%lx~0x%lx\n\n",
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
34810fac:	e0853007 	add	r3, r5, r7
		return -1;

	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
			"The erase range would be change to 0x%lx~0x%lx\n\n",
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
34810fb0:	e2672000 	rsb	r2, r7, #0
		       ((start + blkcnt + mmc->erase_grp_size)
34810fb4:	e0833006 	add	r3, r3, r6
		       & ~(mmc->erase_grp_size - 1)) - 1);
34810fb8:	e0033002 	and	r3, r3, r2

	if (!mmc)
		return -1;

	if ((start % mmc->erase_grp_size) || (blkcnt % mmc->erase_grp_size))
		printf("\n\nCaution! Your devices Erase group is 0x%x\n"
34810fbc:	e1a01007 	mov	r1, r7
34810fc0:	e0052002 	and	r2, r5, r2
34810fc4:	e2433001 	sub	r3, r3, #1
34810fc8:	e59f0118 	ldr	r0, [pc, #280]	; 348110e8 <mmc_berase+0x188>
34810fcc:	ebffe064 	bl	34809164 <printf>
34810fd0:	ea00003b 	b	348110c4 <mmc_berase+0x164>
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
34810fd4:	e5943090 	ldr	r3, [r4, #144]	; 0x90
			mmc->erase_grp_size : (blkcnt - blk);
34810fd8:	e067a006 	rsb	sl, r7, r6
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
34810fdc:	e15a0003 	cmp	sl, r3
34810fe0:	21a0a003 	movcs	sl, r3
{
	struct mmc_cmd cmd;
	ulong end;
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
34810fe4:	e5943040 	ldr	r3, [r4, #64]	; 0x40
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
		blk_r = ((blkcnt - blk) > mmc->erase_grp_size) ?
			mmc->erase_grp_size : (blkcnt - blk);
		err = mmc_erase_t(mmc, start + blk, blk_r);
34810fe8:	e0872005 	add	r2, r7, r5
{
	struct mmc_cmd cmd;
	ulong end;
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
34810fec:	e3530000 	cmp	r3, #0
		end = start + blkcnt - 1;
	else {
		end = (start + blkcnt - 1) * mmc->write_bl_len;
34810ff0:	0594308c 	ldreq	r3, [r4, #140]	; 0x8c
34810ff4:	e242b001 	sub	fp, r2, #1
34810ff8:	008bb00a 	addeq	fp, fp, sl
		start *= mmc->write_bl_len;
34810ffc:	00020293 	muleq	r2, r3, r2
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
		end = start + blkcnt - 1;
	else {
		end = (start + blkcnt - 1) * mmc->write_bl_len;
34811000:	000b0b93 	muleq	fp, r3, fp
		start *= mmc->write_bl_len;
	}

	if (IS_SD(mmc)) {
34811004:	e5943030 	ldr	r3, [r4, #48]	; 0x30
	struct mmc_cmd cmd;
	ulong end;
	int err, start_cmd, end_cmd;

	if (mmc->high_capacity)
		end = start + blkcnt - 1;
34811008:	108bb00a 	addne	fp, fp, sl
	else {
		end = (start + blkcnt - 1) * mmc->write_bl_len;
		start *= mmc->write_bl_len;
	}

	if (IS_SD(mmc)) {
3481100c:	e2033802 	and	r3, r3, #131072	; 0x20000
		start_cmd = SD_CMD_ERASE_WR_BLK_START;
		end_cmd = SD_CMD_ERASE_WR_BLK_END;
34811010:	e3530000 	cmp	r3, #0
34811014:	03a01023 	moveq	r1, #35	; 0x23
34811018:	13a01020 	movne	r1, #32
		start_cmd = MMC_CMD_ERASE_GROUP_START;
		end_cmd = MMC_CMD_ERASE_GROUP_END;
	}

	cmd.cmdidx = start_cmd;
	cmd.cmdarg = start;
3481101c:	e58d2014 	str	r2, [sp, #20]
	cmd.resp_type = MMC_RSP_R1;
34811020:	e3a02015 	mov	r2, #21
		start *= mmc->write_bl_len;
	}

	if (IS_SD(mmc)) {
		start_cmd = SD_CMD_ERASE_WR_BLK_START;
		end_cmd = SD_CMD_ERASE_WR_BLK_END;
34811024:	03a03024 	moveq	r3, #36	; 0x24
34811028:	13a03021 	movne	r3, #33	; 0x21
	} else {
		start_cmd = MMC_CMD_ERASE_GROUP_START;
		end_cmd = MMC_CMD_ERASE_GROUP_END;
	}

	cmd.cmdidx = start_cmd;
3481102c:	e1cd10bc 	strh	r1, [sp, #12]
	cmd.cmdarg = start;
	cmd.resp_type = MMC_RSP_R1;
34811030:	e58d2010 	str	r2, [sp, #16]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811034:	e1a00004 	mov	r0, r4
34811038:	e3a02000 	mov	r2, #0
3481103c:	e1a01009 	mov	r1, r9
34811040:	e58d3004 	str	r3, [sp, #4]
34811044:	ebffff64 	bl	34810ddc <mmc_send_cmd>
	if (err)
34811048:	e2502000 	subs	r2, r0, #0
3481104c:	e59d3004 	ldr	r3, [sp, #4]
34811050:	1a000011 	bne	3481109c <mmc_berase+0x13c>
		goto err_out;

	cmd.cmdidx = end_cmd;
	cmd.cmdarg = end;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811054:	e1a00004 	mov	r0, r4
34811058:	e1a01009 	mov	r1, r9

	err = mmc_send_cmd(mmc, &cmd, NULL);
	if (err)
		goto err_out;

	cmd.cmdidx = end_cmd;
3481105c:	e1cd30bc 	strh	r3, [sp, #12]
	cmd.cmdarg = end;
34811060:	e58db014 	str	fp, [sp, #20]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811064:	ebffff5c 	bl	34810ddc <mmc_send_cmd>
	if (err)
34811068:	e2502000 	subs	r2, r0, #0
3481106c:	1a00000a 	bne	3481109c <mmc_berase+0x13c>
		goto err_out;

	cmd.cmdidx = MMC_CMD_ERASE;
34811070:	e3a03026 	mov	r3, #38	; 0x26
34811074:	e1cd30bc 	strh	r3, [sp, #12]
	cmd.cmdarg = SECURE_ERASE;
34811078:	e3a03102 	mov	r3, #-2147483648	; 0x80000000
3481107c:	e58d3014 	str	r3, [sp, #20]
	cmd.resp_type = MMC_RSP_R1b;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811080:	e1a00004 	mov	r0, r4
	if (err)
		goto err_out;

	cmd.cmdidx = MMC_CMD_ERASE;
	cmd.cmdarg = SECURE_ERASE;
	cmd.resp_type = MMC_RSP_R1b;
34811084:	e2833176 	add	r3, r3, #-2147483619	; 0x8000001d

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811088:	e1a01009 	mov	r1, r9
	if (err)
		goto err_out;

	cmd.cmdidx = MMC_CMD_ERASE;
	cmd.cmdarg = SECURE_ERASE;
	cmd.resp_type = MMC_RSP_R1b;
3481108c:	e58d3010 	str	r3, [sp, #16]

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811090:	ebffff51 	bl	34810ddc <mmc_send_cmd>
	if (err)
34811094:	e250b000 	subs	fp, r0, #0
34811098:	0a000002 	beq	348110a8 <mmc_berase+0x148>
		goto err_out;

	return 0;

err_out:
	puts("mmc erase failed\n");
3481109c:	e59f0048 	ldr	r0, [pc, #72]	; 348110ec <mmc_berase+0x18c>
348110a0:	ebffe025 	bl	3480913c <puts>
348110a4:	ea00000c 	b	348110dc <mmc_berase+0x17c>
			break;

		blk += blk_r;

		/* Waiting for the ready status */
		if (mmc_send_status(mmc, timeout))
348110a8:	e1a00004 	mov	r0, r4
348110ac:	e3a01ffa 	mov	r1, #1000	; 0x3e8
348110b0:	ebffff58 	bl	34810e18 <mmc_send_status>
348110b4:	e3500000 	cmp	r0, #0
348110b8:	1a000006 	bne	348110d8 <mmc_berase+0x178>
			mmc->erase_grp_size : (blkcnt - blk);
		err = mmc_erase_t(mmc, start + blk, blk_r);
		if (err)
			break;

		blk += blk_r;
348110bc:	e087700a 	add	r7, r7, sl
348110c0:	ea000001 	b	348110cc <mmc_berase+0x16c>

	if (IS_SD(mmc)) {
		start_cmd = SD_CMD_ERASE_WR_BLK_START;
		end_cmd = SD_CMD_ERASE_WR_BLK_END;
	} else {
		start_cmd = MMC_CMD_ERASE_GROUP_START;
348110c4:	e3a07000 	mov	r7, #0

	cmd.cmdidx = start_cmd;
	cmd.cmdarg = start;
	cmd.resp_type = MMC_RSP_R1;

	err = mmc_send_cmd(mmc, &cmd, NULL);
348110c8:	e28d900c 	add	r9, sp, #12
			"The erase range would be change to 0x%lx~0x%lx\n\n",
		       mmc->erase_grp_size, start & ~(mmc->erase_grp_size - 1),
		       ((start + blkcnt + mmc->erase_grp_size)
		       & ~(mmc->erase_grp_size - 1)) - 1);

	while (blk < blkcnt) {
348110cc:	e1570006 	cmp	r7, r6
348110d0:	3affffbf 	bcc	34810fd4 <mmc_berase+0x74>
348110d4:	ea000000 	b	348110dc <mmc_berase+0x17c>

		blk += blk_r;

		/* Waiting for the ready status */
		if (mmc_send_status(mmc, timeout))
			return 0;
348110d8:	e1a0700b 	mov	r7, fp
	}

	return blk;
}
348110dc:	e1a00007 	mov	r0, r7
348110e0:	e28dd028 	add	sp, sp, #40	; 0x28
348110e4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348110e8:	34826fc2 	.word	0x34826fc2
348110ec:	3482701f 	.word	0x3482701f

348110f0 <mmc_bwrite>:
	return blkcnt;
}

static ulong
mmc_bwrite(int dev_num, ulong start, lbaint_t blkcnt, const void*src)
{
348110f0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
348110f4:	e24dd030 	sub	sp, sp, #48	; 0x30
348110f8:	e1a04002 	mov	r4, r2
348110fc:	e1a05001 	mov	r5, r1
34811100:	e1a09003 	mov	r9, r3
	lbaint_t cur, blocks_todo = blkcnt;

	struct mmc *mmc = find_mmc_device(dev_num);
34811104:	ebffff83 	bl	34810f18 <find_mmc_device>
	if (!mmc)
34811108:	e2506000 	subs	r6, r0, #0
		return 0;
3481110c:	01a04006 	moveq	r4, r6
mmc_bwrite(int dev_num, ulong start, lbaint_t blkcnt, const void*src)
{
	lbaint_t cur, blocks_todo = blkcnt;

	struct mmc *mmc = find_mmc_device(dev_num);
	if (!mmc)
34811110:	0a000052 	beq	34811260 <mmc_bwrite+0x170>
		return 0;

	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
34811114:	e596108c 	ldr	r1, [r6, #140]	; 0x8c
34811118:	ebffff72 	bl	34810ee8 <mmc_set_blocklen>
3481111c:	e3500000 	cmp	r0, #0
34811120:	1a00004b 	bne	34811254 <mmc_bwrite+0x164>
34811124:	e1a0b004 	mov	fp, r4
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
34811128:	e1a0a004 	mov	sl, r4

	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
3481112c:	e5964120 	ldr	r4, [r6, #288]	; 0x120
{
	struct mmc_cmd cmd;
	struct mmc_data data;
	int timeout = 1000;

	if ((start + blkcnt) > mmc->block_dev.lba) {
34811130:	e59620b0 	ldr	r2, [r6, #176]	; 0xb0

	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34811134:	e15b0004 	cmp	fp, r4
34811138:	31a0400b 	movcc	r4, fp
{
	struct mmc_cmd cmd;
	struct mmc_data data;
	int timeout = 1000;

	if ((start + blkcnt) > mmc->block_dev.lba) {
3481113c:	e0847005 	add	r7, r4, r5
34811140:	e1570002 	cmp	r7, r2
34811144:	9a000003 	bls	34811158 <mmc_bwrite+0x68>
		printf("MMC: block number 0x%lx exceeds max(0x%lx)\n",
34811148:	e1a01007 	mov	r1, r7
3481114c:	e59f0118 	ldr	r0, [pc, #280]	; 3481126c <mmc_bwrite+0x17c>
34811150:	ebffe003 	bl	34809164 <printf>
34811154:	ea000036 	b	34811234 <mmc_bwrite+0x144>
			start + blkcnt, mmc->block_dev.lba);
		return 0;
	}

	if (blkcnt > 1)
34811158:	e3540001 	cmp	r4, #1
		cmd.cmdidx = MMC_CMD_WRITE_MULTIPLE_BLOCK;
3481115c:	83a03019 	movhi	r3, #25
	else
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;
34811160:	93a03018 	movls	r3, #24
34811164:	e1cd30b4 	strh	r3, [sp, #4]

	if (mmc->high_capacity)
34811168:	e5963040 	ldr	r3, [r6, #64]	; 0x40
	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
	data.flags = MMC_DATA_WRITE;

	if (mmc_send_cmd(mmc, &cmd, &data)) {
3481116c:	e1a00006 	mov	r0, r6
	if (blkcnt > 1)
		cmd.cmdidx = MMC_CMD_WRITE_MULTIPLE_BLOCK;
	else
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;

	if (mmc->high_capacity)
34811170:	e3530000 	cmp	r3, #0
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->write_bl_len;
34811174:	0596308c 	ldreq	r3, [r6, #140]	; 0x8c
	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
	data.flags = MMC_DATA_WRITE;

	if (mmc_send_cmd(mmc, &cmd, &data)) {
34811178:	e28d1004 	add	r1, sp, #4
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->write_bl_len;
3481117c:	00050593 	muleq	r5, r3, r5

	cmd.resp_type = MMC_RSP_R1;
34811180:	e3a03015 	mov	r3, #21
34811184:	e58d3008 	str	r3, [sp, #8]

	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
34811188:	e596308c 	ldr	r3, [r6, #140]	; 0x8c
	data.flags = MMC_DATA_WRITE;

	if (mmc_send_cmd(mmc, &cmd, &data)) {
3481118c:	e28d2020 	add	r2, sp, #32

	cmd.resp_type = MMC_RSP_R1;

	data.src = src;
	data.blocks = blkcnt;
	data.blocksize = mmc->write_bl_len;
34811190:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	data.flags = MMC_DATA_WRITE;
34811194:	e3a03002 	mov	r3, #2
		cmd.cmdidx = MMC_CMD_WRITE_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->write_bl_len;
34811198:	e58d500c 	str	r5, [sp, #12]

	cmd.resp_type = MMC_RSP_R1;

	data.src = src;
3481119c:	e58d9020 	str	r9, [sp, #32]
	data.blocks = blkcnt;
348111a0:	e58d4028 	str	r4, [sp, #40]	; 0x28
	data.blocksize = mmc->write_bl_len;
	data.flags = MMC_DATA_WRITE;
348111a4:	e58d3024 	str	r3, [sp, #36]	; 0x24

	if (mmc_send_cmd(mmc, &cmd, &data)) {
348111a8:	ebffff0b 	bl	34810ddc <mmc_send_cmd>
348111ac:	e2505000 	subs	r5, r0, #0
348111b0:	0a000002 	beq	348111c0 <mmc_bwrite+0xd0>
		printf("mmc write failed\n");
348111b4:	e59f00b4 	ldr	r0, [pc, #180]	; 34811270 <mmc_bwrite+0x180>
348111b8:	ebffdfe9 	bl	34809164 <printf>
348111bc:	ea00001c 	b	34811234 <mmc_bwrite+0x144>
	}

	/* SPI multiblock writes terminate using a special
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
348111c0:	e5963050 	ldr	r3, [r6, #80]	; 0x50
348111c4:	e3130b01 	tst	r3, #1024	; 0x400
348111c8:	13a03000 	movne	r3, #0
348111cc:	03a03001 	moveq	r3, #1
348111d0:	e3540001 	cmp	r4, #1
348111d4:	93a03000 	movls	r3, #0
348111d8:	82033001 	andhi	r3, r3, #1
348111dc:	e3530000 	cmp	r3, #0
348111e0:	0a00000e 	beq	34811220 <mmc_bwrite+0x130>
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
348111e4:	e3a0300c 	mov	r3, #12
348111e8:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
348111ec:	e1a00006 	mov	r0, r6
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
348111f0:	e3a0301d 	mov	r3, #29
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
348111f4:	e28d1004 	add	r1, sp, #4
348111f8:	e1a02005 	mov	r2, r5
	/* SPI multiblock writes terminate using a special
	 * token, not a STOP_TRANSMISSION request.
	 */
	if (!mmc_host_is_spi(mmc) && blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
348111fc:	e58d500c 	str	r5, [sp, #12]
		cmd.resp_type = MMC_RSP_R1b;
34811200:	e58d3008 	str	r3, [sp, #8]
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811204:	ebfffef4 	bl	34810ddc <mmc_send_cmd>
34811208:	e3500000 	cmp	r0, #0
3481120c:	0a000003 	beq	34811220 <mmc_bwrite+0x130>
			printf("mmc fail to send stop cmd\n");
34811210:	e59f005c 	ldr	r0, [pc, #92]	; 34811274 <mmc_bwrite+0x184>
34811214:	ebffdfd2 	bl	34809164 <printf>
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
34811218:	e1a04005 	mov	r4, r5
3481121c:	ea00000f 	b	34811260 <mmc_bwrite+0x170>
			return 0;
		}
	}

	/* Waiting for the ready status */
	if (mmc_send_status(mmc, timeout))
34811220:	e1a00006 	mov	r0, r6
34811224:	e3a01ffa 	mov	r1, #1000	; 0x3e8
34811228:	ebfffefa 	bl	34810e18 <mmc_send_status>
3481122c:	e3500000 	cmp	r0, #0
34811230:	0a000001 	beq	3481123c <mmc_bwrite+0x14c>
	if (mmc_set_blocklen(mmc, mmc->write_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
34811234:	e3540000 	cmp	r4, #0
34811238:	1a000005 	bne	34811254 <mmc_bwrite+0x164>
			return 0;
		blocks_todo -= cur;
		start += cur;
		src += cur * mmc->write_bl_len;
	} while (blocks_todo > 0);
3481123c:	e05bb004 	subs	fp, fp, r4
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
		src += cur * mmc->write_bl_len;
34811240:	e596308c 	ldr	r3, [r6, #140]	; 0x8c
	} while (blocks_todo > 0);
34811244:	0a000004 	beq	3481125c <mmc_bwrite+0x16c>
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
		src += cur * mmc->write_bl_len;
34811248:	e0299493 	mla	r9, r3, r4, r9
{
	struct mmc_cmd cmd;
	struct mmc_data data;
	int timeout = 1000;

	if ((start + blkcnt) > mmc->block_dev.lba) {
3481124c:	e1a05007 	mov	r5, r7
34811250:	eaffffb5 	b	3481112c <mmc_bwrite+0x3c>
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_write_blocks(mmc, start, cur, src) != cur)
			return 0;
34811254:	e3a04000 	mov	r4, #0
34811258:	ea000000 	b	34811260 <mmc_bwrite+0x170>
3481125c:	e1a0400a 	mov	r4, sl
		start += cur;
		src += cur * mmc->write_bl_len;
	} while (blocks_todo > 0);

	return blkcnt;
}
34811260:	e1a00004 	mov	r0, r4
34811264:	e28dd030 	add	sp, sp, #48	; 0x30
34811268:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481126c:	34827031 	.word	0x34827031
34811270:	3482705d 	.word	0x3482705d
34811274:	3482706f 	.word	0x3482706f

34811278 <mmc_read_blocks>:

int mmc_read_blocks(struct mmc *mmc, void *dst, ulong start, lbaint_t blkcnt)
{
34811278:	e92d40f0 	push	{r4, r5, r6, r7, lr}
	struct mmc_cmd cmd;
	struct mmc_data data;

	if (blkcnt > 1)
3481127c:	e3530001 	cmp	r3, #1

	return blkcnt;
}

int mmc_read_blocks(struct mmc *mmc, void *dst, ulong start, lbaint_t blkcnt)
{
34811280:	e24dd034 	sub	sp, sp, #52	; 0x34
34811284:	e1a05003 	mov	r5, r3
	struct mmc_cmd cmd;
	struct mmc_data data;

	if (blkcnt > 1)
		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
34811288:	83a03012 	movhi	r3, #18
	else
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;
3481128c:	93a03011 	movls	r3, #17
34811290:	e1cd30b4 	strh	r3, [sp, #4]

	if (mmc->high_capacity)
34811294:	e5903040 	ldr	r3, [r0, #64]	; 0x40
	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
34811298:	e28d7004 	add	r7, sp, #4
	if (blkcnt > 1)
		cmd.cmdidx = MMC_CMD_READ_MULTIPLE_BLOCK;
	else
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;

	if (mmc->high_capacity)
3481129c:	e3530000 	cmp	r3, #0
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->read_bl_len;
348112a0:	05903088 	ldreq	r3, [r0, #136]	; 0x88

	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
348112a4:	e58d1020 	str	r1, [sp, #32]
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->read_bl_len;
348112a8:	00020293 	muleq	r2, r3, r2

	cmd.resp_type = MMC_RSP_R1;
348112ac:	e3a03015 	mov	r3, #21
348112b0:	e58d3008 	str	r3, [sp, #8]

	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
348112b4:	e5903088 	ldr	r3, [r0, #136]	; 0x88
		cmd.cmdidx = MMC_CMD_READ_SINGLE_BLOCK;

	if (mmc->high_capacity)
		cmd.cmdarg = start;
	else
		cmd.cmdarg = start * mmc->read_bl_len;
348112b8:	e58d200c 	str	r2, [sp, #12]

	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
348112bc:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
348112c0:	e1a01007 	mov	r1, r7
	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;
348112c4:	e3a03001 	mov	r3, #1

	if (mmc_send_cmd(mmc, &cmd, &data))
348112c8:	e28d2020 	add	r2, sp, #32

	return blkcnt;
}

int mmc_read_blocks(struct mmc *mmc, void *dst, ulong start, lbaint_t blkcnt)
{
348112cc:	e1a04000 	mov	r4, r0
		cmd.cmdarg = start * mmc->read_bl_len;

	cmd.resp_type = MMC_RSP_R1;

	data.dest = dst;
	data.blocks = blkcnt;
348112d0:	e58d5028 	str	r5, [sp, #40]	; 0x28
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;
348112d4:	e58d3024 	str	r3, [sp, #36]	; 0x24

	if (mmc_send_cmd(mmc, &cmd, &data))
348112d8:	ebfffebf 	bl	34810ddc <mmc_send_cmd>
348112dc:	e2506000 	subs	r6, r0, #0
		return 0;
348112e0:	13a00000 	movne	r0, #0
	data.dest = dst;
	data.blocks = blkcnt;
	data.blocksize = mmc->read_bl_len;
	data.flags = MMC_DATA_READ;

	if (mmc_send_cmd(mmc, &cmd, &data))
348112e4:	1a000011 	bne	34811330 <mmc_read_blocks+0xb8>
		return 0;

	if (blkcnt > 1) {
348112e8:	e3550001 	cmp	r5, #1
348112ec:	9a00000e 	bls	3481132c <mmc_read_blocks+0xb4>
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
348112f0:	e3a0300c 	mov	r3, #12
348112f4:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
348112f8:	e1a00004 	mov	r0, r4
		return 0;

	if (blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
		cmd.resp_type = MMC_RSP_R1b;
348112fc:	e3a0301d 	mov	r3, #29
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811300:	e1a01007 	mov	r1, r7
34811304:	e1a02006 	mov	r2, r6
	if (mmc_send_cmd(mmc, &cmd, &data))
		return 0;

	if (blkcnt > 1) {
		cmd.cmdidx = MMC_CMD_STOP_TRANSMISSION;
		cmd.cmdarg = 0;
34811308:	e58d600c 	str	r6, [sp, #12]
		cmd.resp_type = MMC_RSP_R1b;
3481130c:	e58d3008 	str	r3, [sp, #8]
		if (mmc_send_cmd(mmc, &cmd, NULL)) {
34811310:	ebfffeb1 	bl	34810ddc <mmc_send_cmd>
34811314:	e3500000 	cmp	r0, #0
34811318:	0a000003 	beq	3481132c <mmc_read_blocks+0xb4>
			printf("mmc fail to send stop cmd\n");
3481131c:	e59f0014 	ldr	r0, [pc, #20]	; 34811338 <mmc_read_blocks+0xc0>
34811320:	ebffdf8f 	bl	34809164 <printf>
			return 0;
34811324:	e1a00006 	mov	r0, r6
34811328:	ea000000 	b	34811330 <mmc_read_blocks+0xb8>
		}
	}

	return blkcnt;
3481132c:	e1a00005 	mov	r0, r5
}
34811330:	e28dd034 	add	sp, sp, #52	; 0x34
34811334:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
34811338:	3482706f 	.word	0x3482706f

3481133c <mmc_bread>:

static ulong mmc_bread(int dev_num, ulong start, lbaint_t blkcnt, void *dst)
{
3481133c:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	lbaint_t cur, blocks_todo = blkcnt;

	if (blkcnt == 0)
34811340:	e2524000 	subs	r4, r2, #0

	return blkcnt;
}

static ulong mmc_bread(int dev_num, ulong start, lbaint_t blkcnt, void *dst)
{
34811344:	e1a06001 	mov	r6, r1
34811348:	e1a07003 	mov	r7, r3
	lbaint_t cur, blocks_todo = blkcnt;

	if (blkcnt == 0)
3481134c:	0a000020 	beq	348113d4 <mmc_bread+0x98>
		return 0;

	struct mmc *mmc = find_mmc_device(dev_num);
34811350:	ebfffef0 	bl	34810f18 <find_mmc_device>
	if (!mmc)
34811354:	e2505000 	subs	r5, r0, #0
		return 0;
34811358:	01a04005 	moveq	r4, r5

	if (blkcnt == 0)
		return 0;

	struct mmc *mmc = find_mmc_device(dev_num);
	if (!mmc)
3481135c:	0a00001c 	beq	348113d4 <mmc_bread+0x98>
		return 0;

	if ((start + blkcnt) > mmc->block_dev.lba) {
34811360:	e59520b0 	ldr	r2, [r5, #176]	; 0xb0
34811364:	e0841006 	add	r1, r4, r6
34811368:	e1510002 	cmp	r1, r2
3481136c:	9a000002 	bls	3481137c <mmc_bread+0x40>
		printf("MMC: block number 0x%lx exceeds max(0x%lx)\n",
34811370:	e59f0064 	ldr	r0, [pc, #100]	; 348113dc <mmc_bread+0xa0>
34811374:	ebffdf7a 	bl	34809164 <printf>
34811378:	ea000014 	b	348113d0 <mmc_bread+0x94>
			start + blkcnt, mmc->block_dev.lba);
		return 0;
	}

	if (mmc_set_blocklen(mmc, mmc->read_bl_len))
3481137c:	e5951088 	ldr	r1, [r5, #136]	; 0x88
34811380:	ebfffed8 	bl	34810ee8 <mmc_set_blocklen>
34811384:	e3500000 	cmp	r0, #0
34811388:	1a000010 	bne	348113d0 <mmc_bread+0x94>
3481138c:	e1a0a004 	mov	sl, r4
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34811390:	e5959120 	ldr	r9, [r5, #288]	; 0x120
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
34811394:	e1a00005 	mov	r0, r5

	if (mmc_set_blocklen(mmc, mmc->read_bl_len))
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
34811398:	e15a0009 	cmp	sl, r9
3481139c:	31a0900a 	movcc	r9, sl
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
348113a0:	e1a01007 	mov	r1, r7
348113a4:	e1a02006 	mov	r2, r6
348113a8:	e1a03009 	mov	r3, r9
348113ac:	ebffffb1 	bl	34811278 <mmc_read_blocks>
348113b0:	e1500009 	cmp	r0, r9
348113b4:	1a000005 	bne	348113d0 <mmc_bread+0x94>
			return 0;
		blocks_todo -= cur;
		start += cur;
		dst += cur * mmc->read_bl_len;
	} while (blocks_todo > 0);
348113b8:	e05aa000 	subs	sl, sl, r0
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
		dst += cur * mmc->read_bl_len;
348113bc:	e5953088 	ldr	r3, [r5, #136]	; 0x88
	} while (blocks_todo > 0);
348113c0:	0a000003 	beq	348113d4 <mmc_bread+0x98>
	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
			return 0;
		blocks_todo -= cur;
		start += cur;
348113c4:	e0866000 	add	r6, r6, r0
		dst += cur * mmc->read_bl_len;
348113c8:	e0277093 	mla	r7, r3, r0, r7
348113cc:	eaffffef 	b	34811390 <mmc_bread+0x54>
		return 0;

	do {
		cur = (blocks_todo > mmc->b_max) ?  mmc->b_max : blocks_todo;
		if(mmc_read_blocks(mmc, dst, start, cur) != cur)
			return 0;
348113d0:	e3a04000 	mov	r4, #0
		start += cur;
		dst += cur * mmc->read_bl_len;
	} while (blocks_todo > 0);

	return blkcnt;
}
348113d4:	e1a00004 	mov	r0, r4
348113d8:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
348113dc:	34827031 	.word	0x34827031

348113e0 <mmc_go_idle>:

int mmc_go_idle(struct mmc* mmc)
{
348113e0:	e92d4010 	push	{r4, lr}
348113e4:	e1a04000 	mov	r4, r0
348113e8:	e24dd020 	sub	sp, sp, #32
	struct mmc_cmd cmd;
	int err;

	udelay(1000);
348113ec:	e3a00ffa 	mov	r0, #1000	; 0x3e8
348113f0:	eb002b62 	bl	3481c180 <udelay>

	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
348113f4:	e3a02000 	mov	r2, #0
	cmd.cmdarg = 0;
	cmd.resp_type = MMC_RSP_NONE;

	err = mmc_send_cmd(mmc, &cmd, NULL);
348113f8:	e1a00004 	mov	r0, r4
348113fc:	e28d1004 	add	r1, sp, #4
	struct mmc_cmd cmd;
	int err;

	udelay(1000);

	cmd.cmdidx = MMC_CMD_GO_IDLE_STATE;
34811400:	e1cd20b4 	strh	r2, [sp, #4]
	cmd.cmdarg = 0;
34811404:	e58d200c 	str	r2, [sp, #12]
	cmd.resp_type = MMC_RSP_NONE;
34811408:	e58d2008 	str	r2, [sp, #8]

	err = mmc_send_cmd(mmc, &cmd, NULL);
3481140c:	ebfffe72 	bl	34810ddc <mmc_send_cmd>

	if (err)
34811410:	e2504000 	subs	r4, r0, #0
34811414:	1a000001 	bne	34811420 <mmc_go_idle+0x40>
		return err;

	udelay(2000);
34811418:	e2800e7d 	add	r0, r0, #2000	; 0x7d0
3481141c:	eb002b57 	bl	3481c180 <udelay>

	return 0;
}
34811420:	e1a00004 	mov	r0, r4
34811424:	e28dd020 	add	sp, sp, #32
34811428:	e8bd8010 	pop	{r4, pc}

3481142c <sd_send_op_cond>:

int
sd_send_op_cond(struct mmc *mmc)
{
3481142c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34811430:	e24dd020 	sub	sp, sp, #32
34811434:	e1a04000 	mov	r4, r0
	int timeout = 1000;
34811438:	e3a06ffa 	mov	r6, #1000	; 0x3e8
	int err;
	struct mmc_cmd cmd;

	do {
		cmd.cmdidx = MMC_CMD_APP_CMD;
		cmd.resp_type = MMC_RSP_R1;
3481143c:	e3a09015 	mov	r9, #21
		cmd.cmdarg = 0;
34811440:	e3a07000 	mov	r7, #0

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811444:	e28da004 	add	sl, sp, #4

		if (err)
			return err;

		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
34811448:	e3a0b001 	mov	fp, #1
	int timeout = 1000;
	int err;
	struct mmc_cmd cmd;

	do {
		cmd.cmdidx = MMC_CMD_APP_CMD;
3481144c:	e3a01037 	mov	r1, #55	; 0x37
34811450:	e1cd10b4 	strh	r1, [sp, #4]
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811454:	e1a00004 	mov	r0, r4
34811458:	e1a0100a 	mov	r1, sl
3481145c:	e1a02007 	mov	r2, r7
	int err;
	struct mmc_cmd cmd;

	do {
		cmd.cmdidx = MMC_CMD_APP_CMD;
		cmd.resp_type = MMC_RSP_R1;
34811460:	e58d9008 	str	r9, [sp, #8]
		cmd.cmdarg = 0;
34811464:	e58d700c 	str	r7, [sp, #12]

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811468:	ebfffe5b 	bl	34810ddc <mmc_send_cmd>

		if (err)
3481146c:	e2505000 	subs	r5, r0, #0
34811470:	1a00003a 	bne	34811560 <sd_send_op_cond+0x134>
			return err;

		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
34811474:	e3a03029 	mov	r3, #41	; 0x29
34811478:	e1cd30b4 	strh	r3, [sp, #4]
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
3481147c:	e5943050 	ldr	r3, [r4, #80]	; 0x50
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
34811480:	e59f10e4 	ldr	r1, [pc, #228]	; 3481156c <sd_send_op_cond+0x140>
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
34811484:	e3130b01 	tst	r3, #1024	; 0x400
34811488:	059f30e0 	ldreq	r3, [pc, #224]	; 34811570 <sd_send_op_cond+0x144>
3481148c:	0594202c 	ldreq	r2, [r4, #44]	; 0x2c
34811490:	11a03007 	movne	r3, r7
34811494:	00023003 	andeq	r3, r2, r3
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
34811498:	e5942030 	ldr	r2, [r4, #48]	; 0x30
		 * in the ocr are set. However, Some controller
		 * can set bit 7 (reserved for low voltages), but
		 * how to manage low voltages SD card is not yet
		 * specified.
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
3481149c:	e58d300c 	str	r3, [sp, #12]
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
348114a0:	e1520001 	cmp	r2, r1
			cmd.cmdarg |= OCR_HCS;
348114a4:	03833101 	orreq	r3, r3, #1073741824	; 0x40000000

		err = mmc_send_cmd(mmc, &cmd, NULL);
348114a8:	e1a00004 	mov	r0, r4
348114ac:	e1a0100a 	mov	r1, sl
348114b0:	e3a02000 	mov	r2, #0
		 */
		cmd.cmdarg = mmc_host_is_spi(mmc) ? 0 :
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
			cmd.cmdarg |= OCR_HCS;
348114b4:	058d300c 	streq	r3, [sp, #12]

		if (err)
			return err;

		cmd.cmdidx = SD_CMD_APP_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
348114b8:	e58db008 	str	fp, [sp, #8]
			(mmc->voltages & 0xff8000);

		if (mmc->version == SD_VERSION_2)
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);
348114bc:	ebfffe46 	bl	34810ddc <mmc_send_cmd>

		if (err)
348114c0:	e2505000 	subs	r5, r0, #0
348114c4:	1a000025 	bne	34811560 <sd_send_op_cond+0x134>
			return err;

		udelay(1000);
348114c8:	e2800ffa 	add	r0, r0, #1000	; 0x3e8
348114cc:	eb002b2b 	bl	3481c180 <udelay>
	} while ((!(cmd.response[0] & OCR_BUSY)) && timeout--);
348114d0:	e59d3010 	ldr	r3, [sp, #16]
348114d4:	e3530000 	cmp	r3, #0
348114d8:	ba000002 	blt	348114e8 <sd_send_op_cond+0xbc>
348114dc:	e2566001 	subs	r6, r6, #1
348114e0:	2affffd9 	bcs	3481144c <sd_send_op_cond+0x20>
348114e4:	ea00001c 	b	3481155c <sd_send_op_cond+0x130>

	if (timeout <= 0)
348114e8:	e3560000 	cmp	r6, #0
348114ec:	da00001a 	ble	3481155c <sd_send_op_cond+0x130>
		return UNUSABLE_ERR;

	if (mmc->version != SD_VERSION_2)
348114f0:	e59f3074 	ldr	r3, [pc, #116]	; 3481156c <sd_send_op_cond+0x140>
348114f4:	e5942030 	ldr	r2, [r4, #48]	; 0x30
348114f8:	e1520003 	cmp	r2, r3
		mmc->version = SD_VERSION_1_0;
348114fc:	12433010 	subne	r3, r3, #16
34811500:	15843030 	strne	r3, [r4, #48]	; 0x30

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
34811504:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34811508:	e3130b01 	tst	r3, #1024	; 0x400
3481150c:	0a00000b 	beq	34811540 <sd_send_op_cond+0x114>
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
34811510:	e3a0303a 	mov	r3, #58	; 0x3a
34811514:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = 0;
34811518:	e3a02000 	mov	r2, #0
	if (mmc->version != SD_VERSION_2)
		mmc->version = SD_VERSION_1_0;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
3481151c:	e3a03001 	mov	r3, #1
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811520:	e1a00004 	mov	r0, r4
34811524:	e28d1004 	add	r1, sp, #4
	if (mmc->version != SD_VERSION_2)
		mmc->version = SD_VERSION_1_0;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
34811528:	e58d3008 	str	r3, [sp, #8]
		cmd.cmdarg = 0;
3481152c:	e58d200c 	str	r2, [sp, #12]

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811530:	ebfffe29 	bl	34810ddc <mmc_send_cmd>

		if (err)
34811534:	e3500000 	cmp	r0, #0
34811538:	11a05000 	movne	r5, r0
3481153c:	1a000007 	bne	34811560 <sd_send_op_cond+0x134>
			return err;
	}

	mmc->ocr = cmd.response[0];
34811540:	e59d3010 	ldr	r3, [sp, #16]

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
	mmc->rca = 0;
34811544:	e3a01000 	mov	r1, #0

		if (err)
			return err;
	}

	mmc->ocr = cmd.response[0];
34811548:	e5843054 	str	r3, [r4, #84]	; 0x54

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
3481154c:	e7e03f53 	ubfx	r3, r3, #30, #1
34811550:	e5843040 	str	r3, [r4, #64]	; 0x40
	mmc->rca = 0;
34811554:	e1c418b0 	strh	r1, [r4, #128]	; 0x80

	return 0;
34811558:	ea000000 	b	34811560 <sd_send_op_cond+0x134>

		udelay(1000);
	} while ((!(cmd.response[0] & OCR_BUSY)) && timeout--);

	if (timeout <= 0)
		return UNUSABLE_ERR;
3481155c:	e3e05010 	mvn	r5, #16

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
	mmc->rca = 0;

	return 0;
}
34811560:	e1a00005 	mov	r0, r5
34811564:	e28dd020 	add	sp, sp, #32
34811568:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481156c:	00020020 	.word	0x00020020
34811570:	00ff8000 	.word	0x00ff8000

34811574 <mmc_send_op_cond>:

int mmc_send_op_cond(struct mmc *mmc)
{
34811574:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34811578:	e24dd020 	sub	sp, sp, #32
3481157c:	e1a04000 	mov	r4, r0
 	/* Asking to the card its capabilities */
 	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
 	cmd.resp_type = MMC_RSP_R3;
 	cmd.cmdarg = 0;

 	err = mmc_send_cmd(mmc, &cmd, NULL);
34811580:	e28da004 	add	sl, sp, #4
	int timeout = 10000;
	struct mmc_cmd cmd;
	int err;

	/* Some cards seem to need this */
	mmc_go_idle(mmc);
34811584:	ebffff95 	bl	348113e0 <mmc_go_idle>

 	/* Asking to the card its capabilities */
 	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
34811588:	e3a07001 	mov	r7, #1
 	cmd.resp_type = MMC_RSP_R3;
 	cmd.cmdarg = 0;
3481158c:	e3a02000 	mov	r2, #0

 	err = mmc_send_cmd(mmc, &cmd, NULL);
34811590:	e1a00004 	mov	r0, r4
34811594:	e1a0100a 	mov	r1, sl

	/* Some cards seem to need this */
	mmc_go_idle(mmc);

 	/* Asking to the card its capabilities */
 	cmd.cmdidx = MMC_CMD_SEND_OP_COND;
34811598:	e1cd70b4 	strh	r7, [sp, #4]
 	cmd.resp_type = MMC_RSP_R3;
3481159c:	e58d7008 	str	r7, [sp, #8]
 	cmd.cmdarg = 0;
348115a0:	e58d200c 	str	r2, [sp, #12]

 	err = mmc_send_cmd(mmc, &cmd, NULL);
348115a4:	ebfffe0c 	bl	34810ddc <mmc_send_cmd>

 	if (err)
348115a8:	e2505000 	subs	r5, r0, #0
348115ac:	1a00003d 	bne	348116a8 <mmc_send_op_cond+0x134>
 		return err;

 	udelay(1000);
348115b0:	e2800ffa 	add	r0, r0, #1000	; 0x3e8
348115b4:	eb002af1 	bl	3481c180 <udelay>
	return 0;
}

int mmc_send_op_cond(struct mmc *mmc)
{
	int timeout = 10000;
348115b8:	e3026710 	movw	r6, #10000	; 0x2710
 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
348115bc:	e5941050 	ldr	r1, [r4, #80]	; 0x50
 		return err;

 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
348115c0:	e3a03001 	mov	r3, #1
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
348115c4:	e3110b01 	tst	r1, #1024	; 0x400
 		return err;

 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
348115c8:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
				(mmc->voltages &
348115cc:	0594002c 	ldreq	r0, [r4, #44]	; 0x2c
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
348115d0:	059d3010 	ldreq	r3, [sp, #16]

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
				(mmc->voltages &
348115d4:	059f20d8 	ldreq	r2, [pc, #216]	; 348116b4 <mmc_send_op_cond+0x140>
348115d8:	00030000 	andeq	r0, r3, r0
348115dc:	00002002 	andeq	r2, r0, r2
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));
348115e0:	02033206 	andeq	r3, r3, #1610612736	; 0x60000000
 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
348115e4:	01823003 	orreq	r3, r2, r3
348115e8:	13a03000 	movne	r3, #0
				(mmc->voltages &
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
348115ec:	e3110b02 	tst	r1, #2048	; 0x800
 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = (mmc_host_is_spi(mmc) ? 0 :
348115f0:	e58d300c 	str	r3, [sp, #12]
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);
348115f4:	e1a00004 	mov	r0, r4
				(mmc->voltages &
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;
348115f8:	13833101 	orrne	r3, r3, #1073741824	; 0x40000000

		err = mmc_send_cmd(mmc, &cmd, NULL);
348115fc:	e1a0100a 	mov	r1, sl
34811600:	e3a02000 	mov	r2, #0
				(mmc->voltages &
				(cmd.response[0] & OCR_VOLTAGE_MASK)) |
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;
34811604:	158d300c 	strne	r3, [sp, #12]

 	udelay(1000);

	do {
		cmd.cmdidx = MMC_CMD_SEND_OP_COND;
		cmd.resp_type = MMC_RSP_R3;
34811608:	e58d7008 	str	r7, [sp, #8]
				(cmd.response[0] & OCR_ACCESS_MODE));

		if (mmc->host_caps & MMC_MODE_HC)
			cmd.cmdarg |= OCR_HCS;

		err = mmc_send_cmd(mmc, &cmd, NULL);
3481160c:	ebfffdf2 	bl	34810ddc <mmc_send_cmd>

		if (err)
34811610:	e2505000 	subs	r5, r0, #0
34811614:	1a000023 	bne	348116a8 <mmc_send_op_cond+0x134>
			return err;

		udelay(1000);
34811618:	e2800ffa 	add	r0, r0, #1000	; 0x3e8
3481161c:	eb002ad7 	bl	3481c180 <udelay>
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);
34811620:	e59d3010 	ldr	r3, [sp, #16]
34811624:	e3530000 	cmp	r3, #0
34811628:	aa000002 	bge	34811638 <mmc_send_op_cond+0xc4>

	if (timeout <= 0)
3481162c:	e3560000 	cmp	r6, #0
34811630:	ca000003 	bgt	34811644 <mmc_send_op_cond+0xd0>
34811634:	ea00001a 	b	348116a4 <mmc_send_op_cond+0x130>

		if (err)
			return err;

		udelay(1000);
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);
34811638:	e2566001 	subs	r6, r6, #1
3481163c:	2affffde 	bcs	348115bc <mmc_send_op_cond+0x48>
34811640:	ea000017 	b	348116a4 <mmc_send_op_cond+0x130>

	if (timeout <= 0)
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
34811644:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34811648:	e3130b01 	tst	r3, #1024	; 0x400
3481164c:	0a00000b 	beq	34811680 <mmc_send_op_cond+0x10c>
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
34811650:	e3a0303a 	mov	r3, #58	; 0x3a
34811654:	e1cd30b4 	strh	r3, [sp, #4]
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811658:	e1a02005 	mov	r2, r5
	if (timeout <= 0)
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
3481165c:	e3a03001 	mov	r3, #1
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811660:	e1a00004 	mov	r0, r4
34811664:	e1a0100a 	mov	r1, sl
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
		cmd.cmdarg = 0;
34811668:	e58d500c 	str	r5, [sp, #12]
	if (timeout <= 0)
		return UNUSABLE_ERR;

	if (mmc_host_is_spi(mmc)) { /* read OCR for spi */
		cmd.cmdidx = MMC_CMD_SPI_READ_OCR;
		cmd.resp_type = MMC_RSP_R3;
3481166c:	e58d3008 	str	r3, [sp, #8]
		cmd.cmdarg = 0;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811670:	ebfffdd9 	bl	34810ddc <mmc_send_cmd>

		if (err)
34811674:	e3500000 	cmp	r0, #0
34811678:	11a05000 	movne	r5, r0
3481167c:	1a000009 	bne	348116a8 <mmc_send_op_cond+0x134>
			return err;
	}

	mmc->version = MMC_VERSION_UNKNOWN;
34811680:	e3a03801 	mov	r3, #65536	; 0x10000
34811684:	e5843030 	str	r3, [r4, #48]	; 0x30
	mmc->ocr = cmd.response[0];
34811688:	e59d3010 	ldr	r3, [sp, #16]
3481168c:	e5843054 	str	r3, [r4, #84]	; 0x54

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
34811690:	e7e03f53 	ubfx	r3, r3, #30, #1
34811694:	e5843040 	str	r3, [r4, #64]	; 0x40
	mmc->rca = 0;
34811698:	e3a03000 	mov	r3, #0
3481169c:	e1c438b0 	strh	r3, [r4, #128]	; 0x80

	return 0;
348116a0:	ea000000 	b	348116a8 <mmc_send_op_cond+0x134>

		udelay(1000);
	} while (!(cmd.response[0] & OCR_BUSY) && timeout--);

	if (timeout <= 0)
		return UNUSABLE_ERR;
348116a4:	e3e05010 	mvn	r5, #16

	mmc->high_capacity = ((mmc->ocr & OCR_HCS) == OCR_HCS);
	mmc->rca = 0;

	return 0;
}
348116a8:	e1a00005 	mov	r0, r5
348116ac:	e28dd020 	add	sp, sp, #32
348116b0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
348116b4:	007fff80 	.word	0x007fff80

348116b8 <mmc_send_ext_csd>:


int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
{
348116b8:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct mmc_cmd cmd;
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
348116bc:	e3a03008 	mov	r3, #8
	return 0;
}


int mmc_send_ext_csd(struct mmc *mmc, u8 *ext_csd)
{
348116c0:	e24dd034 	sub	sp, sp, #52	; 0x34
	struct mmc_cmd cmd;
	struct mmc_data data;
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
348116c4:	e1cd30b4 	strh	r3, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
348116c8:	e3a03015 	mov	r3, #21
348116cc:	e58d3008 	str	r3, [sp, #8]
	cmd.cmdarg = 0;

	data.dest = (char *)ext_csd;
	data.blocks = 1;
	data.blocksize = 512;
348116d0:	e3a02c02 	mov	r2, #512	; 0x200
	int err;

	/* Get the Card Status Register */
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;
348116d4:	e3a03000 	mov	r3, #0
348116d8:	e58d300c 	str	r3, [sp, #12]

	data.dest = (char *)ext_csd;
348116dc:	e58d1020 	str	r1, [sp, #32]
	data.blocks = 1;
348116e0:	e2833001 	add	r3, r3, #1
	data.blocksize = 512;
348116e4:	e58d202c 	str	r2, [sp, #44]	; 0x2c
	data.flags = MMC_DATA_READ;

	err = mmc_send_cmd(mmc, &cmd, &data);
348116e8:	e28d1004 	add	r1, sp, #4
348116ec:	e28d2020 	add	r2, sp, #32
	cmd.cmdidx = MMC_CMD_SEND_EXT_CSD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;

	data.dest = (char *)ext_csd;
	data.blocks = 1;
348116f0:	e58d3028 	str	r3, [sp, #40]	; 0x28
	data.blocksize = 512;
	data.flags = MMC_DATA_READ;
348116f4:	e58d3024 	str	r3, [sp, #36]	; 0x24

	err = mmc_send_cmd(mmc, &cmd, &data);
348116f8:	ebfffdb7 	bl	34810ddc <mmc_send_cmd>

	return err;
}
348116fc:	e28dd034 	add	sp, sp, #52	; 0x34
34811700:	e8bd8000 	pop	{pc}

34811704 <mmc_switch>:


int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
{
34811704:	e92d4010 	push	{r4, lr}
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
34811708:	e3a01006 	mov	r1, #6
	return err;
}


int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
{
3481170c:	e24dd020 	sub	sp, sp, #32
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
				 (index << 16) |
34811710:	e1a02802 	lsl	r2, r2, #16
{
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
34811714:	e1cd10b4 	strh	r1, [sp, #4]
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
34811718:	e3822403 	orr	r2, r2, #50331648	; 0x3000000
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
3481171c:	e3a0101d 	mov	r1, #29
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
				 (index << 16) |
34811720:	e1823403 	orr	r3, r2, r3, lsl #8
	struct mmc_cmd cmd;
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
34811724:	e58d1008 	str	r1, [sp, #8]
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
				 (index << 16) |
				 (value << 8);

	ret = mmc_send_cmd(mmc, &cmd, NULL);
34811728:	e3a02000 	mov	r2, #0
3481172c:	e28d1004 	add	r1, sp, #4
	return err;
}


int mmc_switch(struct mmc *mmc, u8 set, u8 index, u8 value)
{
34811730:	e1a04000 	mov	r4, r0
	int timeout = 1000;
	int ret;

	cmd.cmdidx = MMC_CMD_SWITCH;
	cmd.resp_type = MMC_RSP_R1b;
	cmd.cmdarg = (MMC_SWITCH_MODE_WRITE_BYTE << 24) |
34811734:	e58d300c 	str	r3, [sp, #12]
				 (index << 16) |
				 (value << 8);

	ret = mmc_send_cmd(mmc, &cmd, NULL);
34811738:	ebfffda7 	bl	34810ddc <mmc_send_cmd>

	/* Waiting for the ready status */
	if (!ret)
3481173c:	e3500000 	cmp	r0, #0
34811740:	1a000002 	bne	34811750 <mmc_switch+0x4c>
		ret = mmc_send_status(mmc, timeout);
34811744:	e1a00004 	mov	r0, r4
34811748:	e3a01ffa 	mov	r1, #1000	; 0x3e8
3481174c:	ebfffdb1 	bl	34810e18 <mmc_send_status>

	return ret;

}
34811750:	e28dd020 	add	sp, sp, #32
34811754:	e8bd8010 	pop	{r4, pc}

34811758 <mmc_change_freq>:

int mmc_change_freq(struct mmc *mmc)
{
34811758:	e92d4070 	push	{r4, r5, r6, lr}
	char cardtype;
	int err;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
3481175c:	e5902050 	ldr	r2, [r0, #80]	; 0x50
{
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	char cardtype;
	int err;

	mmc->card_caps = 0;
34811760:	e3a03000 	mov	r3, #0

	if (mmc_host_is_spi(mmc))
34811764:	e2122b01 	ands	r2, r2, #1024	; 0x400
	return ret;

}

int mmc_change_freq(struct mmc *mmc)
{
34811768:	e1a04000 	mov	r4, r0
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	char cardtype;
	int err;

	mmc->card_caps = 0;
3481176c:	e580304c 	str	r3, [r0, #76]	; 0x4c
	return ret;

}

int mmc_change_freq(struct mmc *mmc)
{
34811770:	e24ddd09 	sub	sp, sp, #576	; 0x240
	int err;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
		return 0;
34811774:	11a00003 	movne	r0, r3
	char cardtype;
	int err;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
34811778:	1a00001f 	bne	348117fc <mmc_change_freq+0xa4>
		return 0;

	/* Only version 4 supports high-speed */
	if (mmc->version < MMC_VERSION_4)
3481177c:	e5941030 	ldr	r1, [r4, #48]	; 0x30
34811780:	e59f307c 	ldr	r3, [pc, #124]	; 34811804 <mmc_change_freq+0xac>
34811784:	e1510003 	cmp	r1, r3
		return 0;
34811788:	91a00002 	movls	r0, r2

	if (mmc_host_is_spi(mmc))
		return 0;

	/* Only version 4 supports high-speed */
	if (mmc->version < MMC_VERSION_4)
3481178c:	9a00001a 	bls	348117fc <mmc_change_freq+0xa4>

}

int mmc_change_freq(struct mmc *mmc)
{
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
34811790:	e28d503f 	add	r5, sp, #63	; 0x3f
34811794:	e3c5503f 	bic	r5, r5, #63	; 0x3f

	/* Only version 4 supports high-speed */
	if (mmc->version < MMC_VERSION_4)
		return 0;

	err = mmc_send_ext_csd(mmc, ext_csd);
34811798:	e1a01005 	mov	r1, r5
3481179c:	ebffffc5 	bl	348116b8 <mmc_send_ext_csd>

	if (err)
348117a0:	e3500000 	cmp	r0, #0
348117a4:	1a000014 	bne	348117fc <mmc_change_freq+0xa4>
		return err;

	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;

	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
348117a8:	e3a01001 	mov	r1, #1
348117ac:	e1a00004 	mov	r0, r4
348117b0:	e3a020b9 	mov	r2, #185	; 0xb9
348117b4:	e1a03001 	mov	r3, r1
	err = mmc_send_ext_csd(mmc, ext_csd);

	if (err)
		return err;

	cardtype = ext_csd[EXT_CSD_CARD_TYPE] & 0xf;
348117b8:	e5d560c4 	ldrb	r6, [r5, #196]	; 0xc4

	err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_HS_TIMING, 1);
348117bc:	ebffffd0 	bl	34811704 <mmc_switch>

	if (err)
348117c0:	e3500000 	cmp	r0, #0
348117c4:	1a00000c 	bne	348117fc <mmc_change_freq+0xa4>
		return err;

	/* Now check to see that it worked */
	err = mmc_send_ext_csd(mmc, ext_csd);
348117c8:	e1a00004 	mov	r0, r4
348117cc:	e1a01005 	mov	r1, r5
348117d0:	ebffffb8 	bl	348116b8 <mmc_send_ext_csd>

	if (err)
348117d4:	e3500000 	cmp	r0, #0
348117d8:	1a000007 	bne	348117fc <mmc_change_freq+0xa4>
		return err;

	/* No high-speed support */
	if (!ext_csd[EXT_CSD_HS_TIMING])
348117dc:	e5d530b9 	ldrb	r3, [r5, #185]	; 0xb9
348117e0:	e3530000 	cmp	r3, #0
348117e4:	0a000004 	beq	348117fc <mmc_change_freq+0xa4>
348117e8:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
		return 0;

	/* High Speed is set, there are two types: 52MHz and 26MHz */
	if (cardtype & MMC_HS_52MHZ)
348117ec:	e3160002 	tst	r6, #2
		mmc->card_caps |= MMC_MODE_HS_52MHz | MMC_MODE_HS;
348117f0:	13833011 	orrne	r3, r3, #17
	else
		mmc->card_caps |= MMC_MODE_HS;
348117f4:	03833001 	orreq	r3, r3, #1
348117f8:	e584304c 	str	r3, [r4, #76]	; 0x4c

	return 0;
}
348117fc:	e28ddd09 	add	sp, sp, #576	; 0x240
34811800:	e8bd8070 	pop	{r4, r5, r6, pc}
34811804:	0001003f 	.word	0x0001003f

34811808 <mmc_switch_part>:

int mmc_switch_part(int dev_num, unsigned int part_num)
{
34811808:	e92d4010 	push	{r4, lr}
3481180c:	e1a04001 	mov	r4, r1
	struct mmc *mmc = find_mmc_device(dev_num);
34811810:	ebfffdc0 	bl	34810f18 <find_mmc_device>

	if (!mmc)
34811814:	e2503000 	subs	r3, r0, #0
34811818:	0a000007 	beq	3481183c <mmc_switch_part+0x34>
		return -1;

	return mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_PART_CONF,
3481181c:	e5d33082 	ldrb	r3, [r3, #130]	; 0x82
34811820:	e204c007 	and	ip, r4, #7
34811824:	e3c33007 	bic	r3, r3, #7
34811828:	e3a01001 	mov	r1, #1
3481182c:	e3a020b3 	mov	r2, #179	; 0xb3
34811830:	e18c3003 	orr	r3, ip, r3
			  (mmc->part_config & ~PART_ACCESS_MASK)
			  | (part_num & PART_ACCESS_MASK));
}
34811834:	e8bd4010 	pop	{r4, lr}
	struct mmc *mmc = find_mmc_device(dev_num);

	if (!mmc)
		return -1;

	return mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL, EXT_CSD_PART_CONF,
34811838:	eaffffb1 	b	34811704 <mmc_switch>
			  (mmc->part_config & ~PART_ACCESS_MASK)
			  | (part_num & PART_ACCESS_MASK));
}
3481183c:	e3e00000 	mvn	r0, #0
34811840:	e8bd8010 	pop	{r4, pc}

34811844 <mmc_getcd>:

int mmc_getcd(struct mmc *mmc)
{
34811844:	e92d4010 	push	{r4, lr}
34811848:	e1a04000 	mov	r4, r0
	int cd;

	cd = board_mmc_getcd(mmc);
3481184c:	ebfffd60 	bl	34810dd4 <__board_mmc_getcd>

	if ((cd < 0) && mmc->getcd)
34811850:	e3500000 	cmp	r0, #0
34811854:	a8bd8010 	popge	{r4, pc}
34811858:	e594311c 	ldr	r3, [r4, #284]	; 0x11c
3481185c:	e3530000 	cmp	r3, #0
34811860:	08bd8010 	popeq	{r4, pc}
		cd = mmc->getcd(mmc);
34811864:	e1a00004 	mov	r0, r4
34811868:	e12fff33 	blx	r3

	return cd;
}
3481186c:	e8bd8010 	pop	{r4, pc}

34811870 <sd_switch>:

int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u8 *resp)
{
34811870:	e52de004 	push	{lr}		; (str lr, [sp, #-4]!)
	struct mmc_cmd cmd;
	struct mmc_data data;

	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
34811874:	e3a0c006 	mov	ip, #6

	return cd;
}

int sd_switch(struct mmc *mmc, int mode, int group, u8 value, u8 *resp)
{
34811878:	e24dd034 	sub	sp, sp, #52	; 0x34
	struct mmc_cmd cmd;
	struct mmc_data data;

	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
3481187c:	e1cdc0b4 	strh	ip, [sp, #4]
	cmd.resp_type = MMC_RSP_R1;
34811880:	e3a0c015 	mov	ip, #21
34811884:	e58dc008 	str	ip, [sp, #8]
	cmd.cmdarg = (mode << 31) | 0xffffff;
34811888:	e3e0c4ff 	mvn	ip, #-16777216	; 0xff000000
3481188c:	e18c1f81 	orr	r1, ip, r1, lsl #31
	cmd.cmdarg &= ~(0xf << (group * 4));
34811890:	e1a02102 	lsl	r2, r2, #2
34811894:	e3a0c00f 	mov	ip, #15
34811898:	e1c1c21c 	bic	ip, r1, ip, lsl r2
	cmd.cmdarg |= value << (group * 4);
3481189c:	e18c2213 	orr	r2, ip, r3, lsl r2

	data.dest = (char *)resp;
348118a0:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
	/* Switch the frequency */
	cmd.cmdidx = SD_CMD_SWITCH_FUNC;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = (mode << 31) | 0xffffff;
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);
348118a4:	e58d200c 	str	r2, [sp, #12]

	data.dest = (char *)resp;
348118a8:	e58d3020 	str	r3, [sp, #32]
	data.blocksize = 64;
348118ac:	e3a03040 	mov	r3, #64	; 0x40
348118b0:	e58d302c 	str	r3, [sp, #44]	; 0x2c
	data.blocks = 1;
	data.flags = MMC_DATA_READ;

	return mmc_send_cmd(mmc, &cmd, &data);
348118b4:	e28d1004 	add	r1, sp, #4
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);

	data.dest = (char *)resp;
	data.blocksize = 64;
	data.blocks = 1;
348118b8:	e3a03001 	mov	r3, #1
	data.flags = MMC_DATA_READ;

	return mmc_send_cmd(mmc, &cmd, &data);
348118bc:	e28d2020 	add	r2, sp, #32
	cmd.cmdarg &= ~(0xf << (group * 4));
	cmd.cmdarg |= value << (group * 4);

	data.dest = (char *)resp;
	data.blocksize = 64;
	data.blocks = 1;
348118c0:	e58d3028 	str	r3, [sp, #40]	; 0x28
	data.flags = MMC_DATA_READ;
348118c4:	e58d3024 	str	r3, [sp, #36]	; 0x24

	return mmc_send_cmd(mmc, &cmd, &data);
348118c8:	ebfffd43 	bl	34810ddc <mmc_send_cmd>
}
348118cc:	e28dd034 	add	sp, sp, #52	; 0x34
348118d0:	e8bd8000 	pop	{pc}

348118d4 <sd_change_freq>:


int sd_change_freq(struct mmc *mmc)
{
348118d4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct mmc_data data;
	int timeout;

	mmc->card_caps = 0;

	if (mmc_host_is_spi(mmc))
348118d8:	e5902050 	ldr	r2, [r0, #80]	; 0x50
	return mmc_send_cmd(mmc, &cmd, &data);
}


int sd_change_freq(struct mmc *mmc)
{
348118dc:	e24ddd05 	sub	sp, sp, #320	; 0x140
	int err;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(uint, scr, 2);
348118e0:	e28d70d3 	add	r7, sp, #211	; 0xd3
	ALLOC_CACHE_ALIGN_BUFFER(uint, switch_status, 16);
348118e4:	e28d6053 	add	r6, sp, #83	; 0x53
	struct mmc_data data;
	int timeout;

	mmc->card_caps = 0;
348118e8:	e3a05000 	mov	r5, #0

	if (mmc_host_is_spi(mmc))
348118ec:	e2122b01 	ands	r2, r2, #1024	; 0x400
	return mmc_send_cmd(mmc, &cmd, &data);
}


int sd_change_freq(struct mmc *mmc)
{
348118f0:	e1a04000 	mov	r4, r0
	int err;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(uint, scr, 2);
348118f4:	e3c7703f 	bic	r7, r7, #63	; 0x3f
	ALLOC_CACHE_ALIGN_BUFFER(uint, switch_status, 16);
348118f8:	e3c6603f 	bic	r6, r6, #63	; 0x3f
	struct mmc_data data;
	int timeout;

	mmc->card_caps = 0;
348118fc:	e580504c 	str	r5, [r0, #76]	; 0x4c

	if (mmc_host_is_spi(mmc))
34811900:	1a000069 	bne	34811aac <sd_change_freq+0x1d8>
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
34811904:	e3a01037 	mov	r1, #55	; 0x37
34811908:	e28d3c01 	add	r3, sp, #256	; 0x100
3481190c:	e1c311b4 	strh	r1, [r3, #20]
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
34811910:	e1d038b0 	ldrh	r3, [r0, #128]	; 0x80

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811914:	e28dbf45 	add	fp, sp, #276	; 0x114
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = mmc->rca << 16;
34811918:	e1a03803 	lsl	r3, r3, #16
	if (mmc_host_is_spi(mmc))
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
	cmd.resp_type = MMC_RSP_R1;
3481191c:	e3a0a015 	mov	sl, #21
	cmd.cmdarg = mmc->rca << 16;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811920:	e1a0100b 	mov	r1, fp
	if (mmc_host_is_spi(mmc))
		return 0;

	/* Read the SCR to find out if this card supports higher speeds */
	cmd.cmdidx = MMC_CMD_APP_CMD;
	cmd.resp_type = MMC_RSP_R1;
34811924:	e58da118 	str	sl, [sp, #280]	; 0x118
	cmd.cmdarg = mmc->rca << 16;
34811928:	e58d311c 	str	r3, [sp, #284]	; 0x11c

	err = mmc_send_cmd(mmc, &cmd, NULL);
3481192c:	ebfffd2a 	bl	34810ddc <mmc_send_cmd>

	if (err)
34811930:	e2505000 	subs	r5, r0, #0
34811934:	1a00005c 	bne	34811aac <sd_change_freq+0x1d8>
		return err;

	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
34811938:	e3a01033 	mov	r1, #51	; 0x33
3481193c:	e28d2c01 	add	r2, sp, #256	; 0x100
	cmd.resp_type = MMC_RSP_R1;
34811940:	e58da118 	str	sl, [sp, #280]	; 0x118
	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
		return err;

	cmd.cmdidx = SD_CMD_APP_SEND_SCR;
34811944:	e1c211b4 	strh	r1, [r2, #20]
	cmd.resp_type = MMC_RSP_R1;
	cmd.cmdarg = 0;
34811948:	e58d511c 	str	r5, [sp, #284]	; 0x11c

	timeout = 3;
3481194c:	e3a0a003 	mov	sl, #3

retry_scr:
	data.dest = (char *)scr;
	data.blocksize = 8;
34811950:	e3a0c008 	mov	ip, #8
	data.blocks = 1;
34811954:	e3a09001 	mov	r9, #1
	data.flags = MMC_DATA_READ;

	err = mmc_send_cmd(mmc, &cmd, &data);
34811958:	e28d3e13 	add	r3, sp, #304	; 0x130
3481195c:	e1a02003 	mov	r2, r3
34811960:	e1a00004 	mov	r0, r4
34811964:	e1a0100b 	mov	r1, fp

	timeout = 3;

retry_scr:
	data.dest = (char *)scr;
	data.blocksize = 8;
34811968:	e58dc13c 	str	ip, [sp, #316]	; 0x13c
	data.blocks = 1;
	data.flags = MMC_DATA_READ;

	err = mmc_send_cmd(mmc, &cmd, &data);
3481196c:	e58d3008 	str	r3, [sp, #8]
34811970:	e58dc00c 	str	ip, [sp, #12]
	cmd.cmdarg = 0;

	timeout = 3;

retry_scr:
	data.dest = (char *)scr;
34811974:	e58d7130 	str	r7, [sp, #304]	; 0x130
	data.blocksize = 8;
	data.blocks = 1;
34811978:	e58d9138 	str	r9, [sp, #312]	; 0x138
	data.flags = MMC_DATA_READ;
3481197c:	e58d9134 	str	r9, [sp, #308]	; 0x134

	err = mmc_send_cmd(mmc, &cmd, &data);
34811980:	ebfffd15 	bl	34810ddc <mmc_send_cmd>

	if (err) {
34811984:	e2505000 	subs	r5, r0, #0
34811988:	e59d3008 	ldr	r3, [sp, #8]
3481198c:	e59dc00c 	ldr	ip, [sp, #12]
34811990:	0a000003 	beq	348119a4 <sd_change_freq+0xd0>
		if (timeout--)
34811994:	e35a0000 	cmp	sl, #0
34811998:	0a000043 	beq	34811aac <sd_change_freq+0x1d8>
3481199c:	e24aa001 	sub	sl, sl, #1
348119a0:	eaffffed 	b	3481195c <sd_change_freq+0x88>
			goto retry_scr;

		return err;
	}

	mmc->scr[0] = __be32_to_cpu(scr[0]);
348119a4:	e5970000 	ldr	r0, [r7]
348119a8:	ebfffd07 	bl	34810dcc <__fswab32>
348119ac:	e5840058 	str	r0, [r4, #88]	; 0x58
348119b0:	e1a0a000 	mov	sl, r0
	mmc->scr[1] = __be32_to_cpu(scr[1]);
348119b4:	e5970004 	ldr	r0, [r7, #4]
348119b8:	ebfffd03 	bl	34810dcc <__fswab32>

	switch ((mmc->scr[0] >> 24) & 0xf) {
348119bc:	e7e33c5a 	ubfx	r3, sl, #24, #4
348119c0:	e3530001 	cmp	r3, #1

		return err;
	}

	mmc->scr[0] = __be32_to_cpu(scr[0]);
	mmc->scr[1] = __be32_to_cpu(scr[1]);
348119c4:	e584005c 	str	r0, [r4, #92]	; 0x5c
	switch ((mmc->scr[0] >> 24) & 0xf) {
		case 0:
			mmc->version = SD_VERSION_1_0;
			break;
		case 1:
			mmc->version = SD_VERSION_1_10;
348119c8:	059f30e8 	ldreq	r3, [pc, #232]	; 34811ab8 <sd_change_freq+0x1e4>
	}

	mmc->scr[0] = __be32_to_cpu(scr[0]);
	mmc->scr[1] = __be32_to_cpu(scr[1]);

	switch ((mmc->scr[0] >> 24) & 0xf) {
348119cc:	0a000004 	beq	348119e4 <sd_change_freq+0x110>
348119d0:	3a000002 	bcc	348119e0 <sd_change_freq+0x10c>
348119d4:	e3530002 	cmp	r3, #2
			break;
		case 1:
			mmc->version = SD_VERSION_1_10;
			break;
		case 2:
			mmc->version = SD_VERSION_2;
348119d8:	059f30dc 	ldreq	r3, [pc, #220]	; 34811abc <sd_change_freq+0x1e8>
348119dc:	0a000000 	beq	348119e4 <sd_change_freq+0x110>
			break;
		default:
			mmc->version = SD_VERSION_1_0;
348119e0:	e59f30d8 	ldr	r3, [pc, #216]	; 34811ac0 <sd_change_freq+0x1ec>
			break;
	}

	if (mmc->scr[0] & SD_DATA_4BIT)
348119e4:	e31a0701 	tst	sl, #262144	; 0x40000
			break;
		case 2:
			mmc->version = SD_VERSION_2;
			break;
		default:
			mmc->version = SD_VERSION_1_0;
348119e8:	e5843030 	str	r3, [r4, #48]	; 0x30
			break;
	}

	if (mmc->scr[0] & SD_DATA_4BIT)
		mmc->card_caps |= MMC_MODE_4BIT;
348119ec:	1594304c 	ldrne	r3, [r4, #76]	; 0x4c

	/* Version 1.0 doesn't support switching */
	if (mmc->version == SD_VERSION_1_0)
348119f0:	e5942030 	ldr	r2, [r4, #48]	; 0x30
			mmc->version = SD_VERSION_1_0;
			break;
	}

	if (mmc->scr[0] & SD_DATA_4BIT)
		mmc->card_caps |= MMC_MODE_4BIT;
348119f4:	13833c01 	orrne	r3, r3, #256	; 0x100
348119f8:	1584304c 	strne	r3, [r4, #76]	; 0x4c

	/* Version 1.0 doesn't support switching */
	if (mmc->version == SD_VERSION_1_0)
348119fc:	e59f30bc 	ldr	r3, [pc, #188]	; 34811ac0 <sd_change_freq+0x1ec>
34811a00:	e1520003 	cmp	r2, r3
34811a04:	13a07004 	movne	r7, #4
34811a08:	1a00000c 	bne	34811a40 <sd_change_freq+0x16c>
34811a0c:	ea000026 	b	34811aac <sd_change_freq+0x1d8>
		return 0;

	timeout = 4;
	while (timeout--) {
		err = sd_switch(mmc, SD_SWITCH_CHECK, 0, 1,
34811a10:	e3a01000 	mov	r1, #0
34811a14:	e1a00004 	mov	r0, r4
34811a18:	e1a02001 	mov	r2, r1
34811a1c:	e3a03001 	mov	r3, #1
34811a20:	e58d6000 	str	r6, [sp]
34811a24:	ebffff91 	bl	34811870 <sd_switch>
				(u8 *)switch_status);

		if (err)
34811a28:	e3500000 	cmp	r0, #0
34811a2c:	1a00001d 	bne	34811aa8 <sd_change_freq+0x1d4>
			return err;

		/* The high-speed function is busy.  Try again */
		if (!(__be32_to_cpu(switch_status[7]) & SD_HIGHSPEED_BUSY))
34811a30:	e596001c 	ldr	r0, [r6, #28]
34811a34:	ebfffce4 	bl	34810dcc <__fswab32>
34811a38:	e3100802 	tst	r0, #131072	; 0x20000
34811a3c:	0a000001 	beq	34811a48 <sd_change_freq+0x174>
	/* Version 1.0 doesn't support switching */
	if (mmc->version == SD_VERSION_1_0)
		return 0;

	timeout = 4;
	while (timeout--) {
34811a40:	e2577001 	subs	r7, r7, #1
34811a44:	2afffff1 	bcs	34811a10 <sd_change_freq+0x13c>
		if (!(__be32_to_cpu(switch_status[7]) & SD_HIGHSPEED_BUSY))
			break;
	}

	/* If high-speed isn't supported, we return */
	if (!(__be32_to_cpu(switch_status[3]) & SD_HIGHSPEED_SUPPORTED))
34811a48:	e596000c 	ldr	r0, [r6, #12]
34811a4c:	ebfffcde 	bl	34810dcc <__fswab32>
34811a50:	e3100802 	tst	r0, #131072	; 0x20000
34811a54:	0a000014 	beq	34811aac <sd_change_freq+0x1d8>
	 * If the host doesn't support SD_HIGHSPEED, do not switch card to
	 * HIGHSPEED mode even if the card support SD_HIGHSPPED.
	 * This can avoid furthur problem when the card runs in different
	 * mode between the host.
	 */
	if (!((mmc->host_caps & MMC_MODE_HS_52MHz) &&
34811a58:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34811a5c:	e2033011 	and	r3, r3, #17
34811a60:	e3530011 	cmp	r3, #17
34811a64:	1a000010 	bne	34811aac <sd_change_freq+0x1d8>
		(mmc->host_caps & MMC_MODE_HS)))
		return 0;

	err = sd_switch(mmc, SD_SWITCH_SWITCH, 0, 1, (u8 *)switch_status);
34811a68:	e3a01001 	mov	r1, #1
34811a6c:	e1a00004 	mov	r0, r4
34811a70:	e3a02000 	mov	r2, #0
34811a74:	e1a03001 	mov	r3, r1
34811a78:	e58d6000 	str	r6, [sp]
34811a7c:	ebffff7b 	bl	34811870 <sd_switch>

	if (err)
34811a80:	e2505000 	subs	r5, r0, #0
34811a84:	1a000008 	bne	34811aac <sd_change_freq+0x1d8>
		return err;

	if ((__be32_to_cpu(switch_status[4]) & 0x0f000000) == 0x01000000)
34811a88:	e5960010 	ldr	r0, [r6, #16]
34811a8c:	ebfffcce 	bl	34810dcc <__fswab32>
34811a90:	e200040f 	and	r0, r0, #251658240	; 0xf000000
34811a94:	e3500401 	cmp	r0, #16777216	; 0x1000000
		mmc->card_caps |= MMC_MODE_HS;
34811a98:	0594304c 	ldreq	r3, [r4, #76]	; 0x4c
34811a9c:	03833001 	orreq	r3, r3, #1
34811aa0:	0584304c 	streq	r3, [r4, #76]	; 0x4c
34811aa4:	ea000000 	b	34811aac <sd_change_freq+0x1d8>
	if (mmc->version == SD_VERSION_1_0)
		return 0;

	timeout = 4;
	while (timeout--) {
		err = sd_switch(mmc, SD_SWITCH_CHECK, 0, 1,
34811aa8:	e1a05000 	mov	r5, r0

	if ((__be32_to_cpu(switch_status[4]) & 0x0f000000) == 0x01000000)
		mmc->card_caps |= MMC_MODE_HS;

	return 0;
}
34811aac:	e1a00005 	mov	r0, r5
34811ab0:	e28ddd05 	add	sp, sp, #320	; 0x140
34811ab4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34811ab8:	0002001a 	.word	0x0002001a
34811abc:	00020020 	.word	0x00020020
34811ac0:	00020010 	.word	0x00020010

34811ac4 <mmc_set_ios>:
	70,
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
34811ac4:	e92d4008 	push	{r3, lr}
	mmc->set_ios(mmc);
34811ac8:	e5903114 	ldr	r3, [r0, #276]	; 0x114
34811acc:	e12fff33 	blx	r3
}
34811ad0:	e8bd8008 	pop	{r3, pc}

34811ad4 <mmc_set_clock>:

void mmc_set_clock(struct mmc *mmc, uint clock)
{
34811ad4:	e590203c 	ldr	r2, [r0, #60]	; 0x3c
		clock = mmc->f_max;

	if (clock < mmc->f_min)
		clock = mmc->f_min;

	mmc->clock = clock;
34811ad8:	e590c038 	ldr	ip, [r0, #56]	; 0x38
{
	mmc->set_ios(mmc);
}

void mmc_set_clock(struct mmc *mmc, uint clock)
{
34811adc:	e1510002 	cmp	r1, r2
34811ae0:	31a02001 	movcc	r2, r1
34811ae4:	e92d4008 	push	{r3, lr}
		clock = mmc->f_max;

	if (clock < mmc->f_min)
		clock = mmc->f_min;

	mmc->clock = clock;
34811ae8:	e152000c 	cmp	r2, ip
34811aec:	25802048 	strcs	r2, [r0, #72]	; 0x48
34811af0:	3580c048 	strcc	ip, [r0, #72]	; 0x48
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34811af4:	e5903114 	ldr	r3, [r0, #276]	; 0x114
34811af8:	e12fff33 	blx	r3
		clock = mmc->f_min;

	mmc->clock = clock;

	mmc_set_ios(mmc);
}
34811afc:	e8bd8008 	pop	{r3, pc}

34811b00 <mmc_set_bus_width>:

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
34811b00:	e92d4008 	push	{r3, lr}
	mmc->bus_width = width;
34811b04:	e5801044 	str	r1, [r0, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34811b08:	e5903114 	ldr	r3, [r0, #276]	; 0x114
34811b0c:	e12fff33 	blx	r3
void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;

	mmc_set_ios(mmc);
}
34811b10:	e8bd8008 	pop	{r3, pc}

34811b14 <mmc_startup>:

int mmc_startup(struct mmc *mmc)
{
34811b14:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
34811b18:	e5903050 	ldr	r3, [r0, #80]	; 0x50

	mmc_set_ios(mmc);
}

int mmc_startup(struct mmc *mmc)
{
34811b1c:	e24ddd13 	sub	sp, sp, #1216	; 0x4c0
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
34811b20:	e3130b01 	tst	r3, #1024	; 0x400
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811b24:	e28d5e49 	add	r5, sp, #1168	; 0x490
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
34811b28:	03a03002 	moveq	r3, #2
34811b2c:	13a0300a 	movne	r3, #10
34811b30:	e28d1b01 	add	r1, sp, #1024	; 0x400
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811b34:	e285500c 	add	r5, r5, #12
			return err;
	}
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
34811b38:	e1c139bc 	strh	r3, [r1, #156]	; 0x9c
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;
34811b3c:	e3a02000 	mov	r2, #0
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
34811b40:	e3a03007 	mov	r3, #7
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811b44:	e1a01005 	mov	r1, r5

	mmc_set_ios(mmc);
}

int mmc_startup(struct mmc *mmc)
{
34811b48:	e1a04000 	mov	r4, r0
#endif

	/* Put the Card in Identify Mode */
	cmd.cmdidx = mmc_host_is_spi(mmc) ? MMC_CMD_SEND_CID :
		MMC_CMD_ALL_SEND_CID; /* cmd not supported in spi */
	cmd.resp_type = MMC_RSP_R2;
34811b4c:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0
	cmd.cmdarg = 0;
34811b50:	e58d24a4 	str	r2, [sp, #1188]	; 0x4a4

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811b54:	ebfffca0 	bl	34810ddc <mmc_send_cmd>
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, 512);
34811b58:	e28da020 	add	sl, sp, #32
34811b5c:	e28aa03b 	add	sl, sl, #59	; 0x3b
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
34811b60:	e2506000 	subs	r6, r0, #0
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
	ALLOC_CACHE_ALIGN_BUFFER(u8, test_csd, 512);
34811b64:	e3caa03f 	bic	sl, sl, #63	; 0x3f
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = 0;

	err = mmc_send_cmd(mmc, &cmd, NULL);

	if (err)
34811b68:	1a00017b 	bne	3481215c <mmc_startup+0x648>
		return err;

	memcpy(mmc->cid, cmd.response, 16);
34811b6c:	e3a02010 	mov	r2, #16
34811b70:	e2840070 	add	r0, r4, #112	; 0x70
34811b74:	e285100c 	add	r1, r5, #12
34811b78:	eb0028f5 	bl	3481bf54 <memcpy>
	/*
	 * For MMC cards, set the Relative Address.
	 * For SD cards, get the Relatvie Address.
	 * This also puts the cards into Standby State
	 */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
34811b7c:	e5942050 	ldr	r2, [r4, #80]	; 0x50
34811b80:	e2122b01 	ands	r2, r2, #1024	; 0x400
34811b84:	1a000011 	bne	34811bd0 <mmc_startup+0xbc>
		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
34811b88:	e3a03003 	mov	r3, #3
34811b8c:	e28d0b01 	add	r0, sp, #1024	; 0x400
34811b90:	e1c039bc 	strh	r3, [r0, #156]	; 0x9c
		cmd.cmdarg = mmc->rca << 16;
34811b94:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80
		cmd.resp_type = MMC_RSP_R6;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811b98:	e1a00004 	mov	r0, r4
	 * For SD cards, get the Relatvie Address.
	 * This also puts the cards into Standby State
	 */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
		cmd.cmdarg = mmc->rca << 16;
34811b9c:	e1a03803 	lsl	r3, r3, #16
34811ba0:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4
		cmd.resp_type = MMC_RSP_R6;

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811ba4:	e1a01005 	mov	r1, r5
	 * This also puts the cards into Standby State
	 */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = SD_CMD_SEND_RELATIVE_ADDR;
		cmd.cmdarg = mmc->rca << 16;
		cmd.resp_type = MMC_RSP_R6;
34811ba8:	e3a03015 	mov	r3, #21
34811bac:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0

		err = mmc_send_cmd(mmc, &cmd, NULL);
34811bb0:	ebfffc89 	bl	34810ddc <mmc_send_cmd>

		if (err)
34811bb4:	e2506000 	subs	r6, r0, #0
34811bb8:	1a000167 	bne	3481215c <mmc_startup+0x648>
			return err;

		if (IS_SD(mmc))
34811bbc:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34811bc0:	e3130802 	tst	r3, #131072	; 0x20000
			mmc->rca = (cmd.response[0] >> 16) & 0xffff;
34811bc4:	128d1b01 	addne	r1, sp, #1024	; 0x400
34811bc8:	11d11aba 	ldrhne	r1, [r1, #170]	; 0xaa
34811bcc:	11c418b0 	strhne	r1, [r4, #128]	; 0x80
	}

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
34811bd0:	e3a02009 	mov	r2, #9
34811bd4:	e28d3b01 	add	r3, sp, #1024	; 0x400
34811bd8:	e1c329bc 	strh	r2, [r3, #156]	; 0x9c
	cmd.resp_type = MMC_RSP_R2;
34811bdc:	e3a03007 	mov	r3, #7
34811be0:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0
	cmd.cmdarg = mmc->rca << 16;
34811be4:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811be8:	e28d1e49 	add	r1, sp, #1168	; 0x490
	}

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = mmc->rca << 16;
34811bec:	e1a03803 	lsl	r3, r3, #16

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811bf0:	e281100c 	add	r1, r1, #12
34811bf4:	e3a02000 	mov	r2, #0
34811bf8:	e1a00004 	mov	r0, r4
	}

	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = mmc->rca << 16;
34811bfc:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811c00:	ebfffc75 	bl	34810ddc <mmc_send_cmd>

	/* Waiting for the ready status */
	mmc_send_status(mmc, timeout);
34811c04:	e3a01ffa 	mov	r1, #1000	; 0x3e8
	/* Get the Card-Specific Data */
	cmd.cmdidx = MMC_CMD_SEND_CSD;
	cmd.resp_type = MMC_RSP_R2;
	cmd.cmdarg = mmc->rca << 16;

	err = mmc_send_cmd(mmc, &cmd, NULL);
34811c08:	e1a06000 	mov	r6, r0

	/* Waiting for the ready status */
	mmc_send_status(mmc, timeout);
34811c0c:	e1a00004 	mov	r0, r4
34811c10:	ebfffc80 	bl	34810e18 <mmc_send_status>

	if (err)
34811c14:	e3560000 	cmp	r6, #0
34811c18:	1a00014f 	bne	3481215c <mmc_startup+0x648>
		return err;

	mmc->csd[0] = cmd.response[0];
	mmc->csd[1] = cmd.response[1];
	mmc->csd[2] = cmd.response[2];
	mmc->csd[3] = cmd.response[3];
34811c1c:	e59d24b4 	ldr	r2, [sp, #1204]	; 0x4b4
	mmc_send_status(mmc, timeout);

	if (err)
		return err;

	mmc->csd[0] = cmd.response[0];
34811c20:	e59d34a8 	ldr	r3, [sp, #1192]	; 0x4a8
	mmc->csd[1] = cmd.response[1];
	mmc->csd[2] = cmd.response[2];
	mmc->csd[3] = cmd.response[3];
34811c24:	e584206c 	str	r2, [r4, #108]	; 0x6c

	if (mmc->version == MMC_VERSION_UNKNOWN) {
34811c28:	e5942030 	ldr	r2, [r4, #48]	; 0x30

	if (err)
		return err;

	mmc->csd[0] = cmd.response[0];
	mmc->csd[1] = cmd.response[1];
34811c2c:	e59d04ac 	ldr	r0, [sp, #1196]	; 0x4ac
	mmc->csd[2] = cmd.response[2];
34811c30:	e59d64b0 	ldr	r6, [sp, #1200]	; 0x4b0
	mmc->csd[3] = cmd.response[3];

	if (mmc->version == MMC_VERSION_UNKNOWN) {
34811c34:	e3520801 	cmp	r2, #65536	; 0x10000
	mmc_send_status(mmc, timeout);

	if (err)
		return err;

	mmc->csd[0] = cmd.response[0];
34811c38:	e5843060 	str	r3, [r4, #96]	; 0x60
	mmc->csd[1] = cmd.response[1];
34811c3c:	e5840064 	str	r0, [r4, #100]	; 0x64
	mmc->csd[2] = cmd.response[2];
34811c40:	e5846068 	str	r6, [r4, #104]	; 0x68
	mmc->csd[3] = cmd.response[3];

	if (mmc->version == MMC_VERSION_UNKNOWN) {
34811c44:	1a000012 	bne	34811c94 <mmc_startup+0x180>
		int version = (cmd.response[0] >> 26) & 0xf;
34811c48:	e7e32d53 	ubfx	r2, r3, #26, #4

		switch (version) {
34811c4c:	e3520004 	cmp	r2, #4
34811c50:	979ff102 	ldrls	pc, [pc, r2, lsl #2]
34811c54:	ea00000c 	b	34811c8c <mmc_startup+0x178>
34811c58:	34811c8c 	.word	0x34811c8c
34811c5c:	34811c6c 	.word	0x34811c6c
34811c60:	34811c74 	.word	0x34811c74
34811c64:	34811c7c 	.word	0x34811c7c
34811c68:	34811c84 	.word	0x34811c84
			case 0:
				mmc->version = MMC_VERSION_1_2;
				break;
			case 1:
				mmc->version = MMC_VERSION_1_4;
34811c6c:	e59f24f4 	ldr	r2, [pc, #1268]	; 34812168 <mmc_startup+0x654>
34811c70:	ea000006 	b	34811c90 <mmc_startup+0x17c>
				break;
			case 2:
				mmc->version = MMC_VERSION_2_2;
34811c74:	e59f24f0 	ldr	r2, [pc, #1264]	; 3481216c <mmc_startup+0x658>
34811c78:	ea000004 	b	34811c90 <mmc_startup+0x17c>
				break;
			case 3:
				mmc->version = MMC_VERSION_3;
34811c7c:	e59f24ec 	ldr	r2, [pc, #1260]	; 34812170 <mmc_startup+0x65c>
34811c80:	ea000002 	b	34811c90 <mmc_startup+0x17c>
				break;
			case 4:
				mmc->version = MMC_VERSION_4;
34811c84:	e59f24e8 	ldr	r2, [pc, #1256]	; 34812174 <mmc_startup+0x660>
34811c88:	ea000000 	b	34811c90 <mmc_startup+0x17c>
				break;
			default:
				mmc->version = MMC_VERSION_1_2;
34811c8c:	e59f24e4 	ldr	r2, [pc, #1252]	; 34812178 <mmc_startup+0x664>
34811c90:	e5842030 	str	r2, [r4, #48]	; 0x30
		}
	}

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];
34811c94:	e59f24e0 	ldr	r2, [pc, #1248]	; 3481217c <mmc_startup+0x668>
34811c98:	e7e311d3 	ubfx	r1, r3, #3, #4
				break;
		}
	}

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
34811c9c:	e2033007 	and	r3, r3, #7
34811ca0:	e0823103 	add	r3, r2, r3, lsl #2
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;
34811ca4:	e5933040 	ldr	r3, [r3, #64]	; 0x40
34811ca8:	e7922101 	ldr	r2, [r2, r1, lsl #2]

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
34811cac:	e7e35850 	ubfx	r5, r0, #16, #4

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;
34811cb0:	e0030293 	mul	r3, r3, r2

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);

	if (IS_SD(mmc))
34811cb4:	e5942030 	ldr	r2, [r4, #48]	; 0x30

	/* divide frequency by 10, since the mults are 10x bigger */
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;
34811cb8:	e5843084 	str	r3, [r4, #132]	; 0x84

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);

	if (IS_SD(mmc))
34811cbc:	e3120802 	tst	r2, #131072	; 0x20000
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
34811cc0:	059d24b4 	ldreq	r2, [sp, #1204]	; 0x4b4
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
34811cc4:	e3a03001 	mov	r3, #1

	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
34811cc8:	07e32b52 	ubfxeq	r2, r2, #22, #4
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
34811ccc:	e1a05513 	lsl	r5, r3, r5

	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);
34811cd0:	01a03213 	lsleq	r3, r3, r2
34811cd4:	0584308c 	streq	r3, [r4, #140]	; 0x8c

	if (mmc->high_capacity) {
34811cd8:	e5943040 	ldr	r3, [r4, #64]	; 0x40
	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);

	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
34811cdc:	1584508c 	strne	r5, [r4, #140]	; 0x8c
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
34811ce0:	e3530000 	cmp	r3, #0
	freq = fbase[(cmd.response[0] & 0x7)];
	mult = multipliers[((cmd.response[0] >> 3) & 0xf)];

	mmc->tran_speed = freq * mult;

	mmc->read_bl_len = 1 << ((cmd.response[1] >> 16) & 0xf);
34811ce4:	e5845088 	str	r5, [r4, #136]	; 0x88
	if (IS_SD(mmc))
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
34811ce8:	0a000006 	beq	34811d08 <mmc_startup+0x1f4>
		csize = (mmc->csd[1] & 0x3f) << 16
			| (mmc->csd[2] & 0xffff0000) >> 16;
34811cec:	e1a06826 	lsr	r6, r6, #16
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
34811cf0:	e200003f 	and	r0, r0, #63	; 0x3f
			| (mmc->csd[2] & 0xffff0000) >> 16;
34811cf4:	e1860800 	orr	r0, r6, r0, lsl #16
		mmc->write_bl_len = mmc->read_bl_len;
	else
		mmc->write_bl_len = 1 << ((cmd.response[3] >> 22) & 0xf);

	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
34811cf8:	e3a01000 	mov	r1, #0
			| (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
34811cfc:	e3a06008 	mov	r6, #8
34811d00:	e3a07000 	mov	r7, #0
34811d04:	ea000005 	b	34811d20 <mmc_startup+0x20c>
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2
			| (mmc->csd[2] & 0xc0000000) >> 30;
34811d08:	e1a03f26 	lsr	r3, r6, #30
	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
			| (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2
34811d0c:	e1a00b00 	lsl	r0, r0, #22
			| (mmc->csd[2] & 0xc0000000) >> 30;
34811d10:	e1830a20 	orr	r0, r3, r0, lsr #20
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
34811d14:	e7e267d6 	ubfx	r6, r6, #15, #3
	if (mmc->high_capacity) {
		csize = (mmc->csd[1] & 0x3f) << 16
			| (mmc->csd[2] & 0xffff0000) >> 16;
		cmult = 8;
	} else {
		csize = (mmc->csd[1] & 0x3ff) << 2
34811d18:	e3a01000 	mov	r1, #0
			| (mmc->csd[2] & 0xc0000000) >> 30;
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
34811d1c:	e3a07000 	mov	r7, #0
	}

	mmc->capacity = (csize + 1) << (cmult + 2);
34811d20:	e3a02001 	mov	r2, #1
34811d24:	e0900002 	adds	r0, r0, r2
34811d28:	e3a03000 	mov	r3, #0
34811d2c:	e0a11003 	adc	r1, r1, r3
34811d30:	e2862002 	add	r2, r6, #2
34811d34:	eb0038ba 	bl	34820024 <__ashldi3>
	mmc->capacity *= mmc->read_bl_len;
34811d38:	e0832590 	umull	r2, r3, r0, r5
34811d3c:	e0233195 	mla	r3, r5, r1, r3

	if (mmc->read_bl_len > 512)
34811d40:	e3550c02 	cmp	r5, #512	; 0x200
			| (mmc->csd[2] & 0xc0000000) >> 30;
		cmult = (mmc->csd[2] & 0x00038000) >> 15;
	}

	mmc->capacity = (csize + 1) << (cmult + 2);
	mmc->capacity *= mmc->read_bl_len;
34811d44:	e1c429f8 	strd	r2, [r4, #152]	; 0x98

	if (mmc->read_bl_len > 512)
		mmc->read_bl_len = 512;
34811d48:	83a03c02 	movhi	r3, #512	; 0x200
34811d4c:	85843088 	strhi	r3, [r4, #136]	; 0x88

	if (mmc->write_bl_len > 512)
34811d50:	e594308c 	ldr	r3, [r4, #140]	; 0x8c
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
34811d54:	e5942050 	ldr	r2, [r4, #80]	; 0x50
	mmc->capacity *= mmc->read_bl_len;

	if (mmc->read_bl_len > 512)
		mmc->read_bl_len = 512;

	if (mmc->write_bl_len > 512)
34811d58:	e3530c02 	cmp	r3, #512	; 0x200
		mmc->write_bl_len = 512;
34811d5c:	83a03c02 	movhi	r3, #512	; 0x200
34811d60:	8584308c 	strhi	r3, [r4, #140]	; 0x8c

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
34811d64:	e2122b01 	ands	r2, r2, #1024	; 0x400
34811d68:	1a00000d 	bne	34811da4 <mmc_startup+0x290>
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
		cmd.resp_type = MMC_RSP_R1;
34811d6c:	e3a03015 	mov	r3, #21
	if (mmc->write_bl_len > 512)
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
34811d70:	e3a00007 	mov	r0, #7
34811d74:	e28d1b01 	add	r1, sp, #1024	; 0x400
		cmd.resp_type = MMC_RSP_R1;
34811d78:	e58d34a0 	str	r3, [sp, #1184]	; 0x4a0
		cmd.cmdarg = mmc->rca << 16;
34811d7c:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80
	if (mmc->write_bl_len > 512)
		mmc->write_bl_len = 512;

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
34811d80:	e1c109bc 	strh	r0, [r1, #156]	; 0x9c
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = mmc->rca << 16;
		err = mmc_send_cmd(mmc, &cmd, NULL);
34811d84:	e28d1e49 	add	r1, sp, #1168	; 0x490

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = mmc->rca << 16;
34811d88:	e1a03803 	lsl	r3, r3, #16
		err = mmc_send_cmd(mmc, &cmd, NULL);
34811d8c:	e1a00004 	mov	r0, r4
34811d90:	e281100c 	add	r1, r1, #12

	/* Select the card, and put it into Transfer Mode */
	if (!mmc_host_is_spi(mmc)) { /* cmd not supported in spi */
		cmd.cmdidx = MMC_CMD_SELECT_CARD;
		cmd.resp_type = MMC_RSP_R1;
		cmd.cmdarg = mmc->rca << 16;
34811d94:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4
		err = mmc_send_cmd(mmc, &cmd, NULL);
34811d98:	ebfffc0f 	bl	34810ddc <mmc_send_cmd>

		if (err)
34811d9c:	e2506000 	subs	r6, r0, #0
34811da0:	1a0000ed 	bne	3481215c <mmc_startup+0x648>
	}

	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
34811da4:	e3a03001 	mov	r3, #1
34811da8:	e5843090 	str	r3, [r4, #144]	; 0x90
	mmc->part_config = MMCPART_NOAVAILABLE;
34811dac:	e3e03000 	mvn	r3, #0
34811db0:	e5c43082 	strb	r3, [r4, #130]	; 0x82
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
34811db4:	e5943030 	ldr	r3, [r4, #48]	; 0x30
{
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
34811db8:	e28d5fa6 	add	r5, sp, #664	; 0x298
34811dbc:	e2855003 	add	r5, r5, #3
	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
	mmc->part_config = MMCPART_NOAVAILABLE;
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
34811dc0:	e3130802 	tst	r3, #131072	; 0x20000
{
	int err, width;
	uint mult, freq;
	u64 cmult, csize, capacity;
	struct mmc_cmd cmd;
	ALLOC_CACHE_ALIGN_BUFFER(u8, ext_csd, 512);
34811dc4:	e3c5503f 	bic	r5, r5, #63	; 0x3f
	/*
	 * For SD, its erase group is always one sector
	 */
	mmc->erase_grp_size = 1;
	mmc->part_config = MMCPART_NOAVAILABLE;
	if (!IS_SD(mmc) && (mmc->version >= MMC_VERSION_4)) {
34811dc8:	1a000034 	bne	34811ea0 <mmc_startup+0x38c>
34811dcc:	e59f23ac 	ldr	r2, [pc, #940]	; 34812180 <mmc_startup+0x66c>
34811dd0:	e1530002 	cmp	r3, r2
34811dd4:	9a000031 	bls	34811ea0 <mmc_startup+0x38c>
		/* check  ext_csd version and capacity */
		err = mmc_send_ext_csd(mmc, ext_csd);
34811dd8:	e1a00004 	mov	r0, r4
34811ddc:	e1a01005 	mov	r1, r5
34811de0:	ebfffe34 	bl	348116b8 <mmc_send_ext_csd>
		if (!err & (ext_csd[EXT_CSD_REV] >= 2)) {
34811de4:	e5d530c0 	ldrb	r3, [r5, #192]	; 0xc0
34811de8:	e2700001 	rsbs	r0, r0, #1
34811dec:	33a00000 	movcc	r0, #0
34811df0:	e3530001 	cmp	r3, #1
34811df4:	93a00000 	movls	r0, #0
34811df8:	e3500000 	cmp	r0, #0
34811dfc:	0a000014 	beq	34811e54 <mmc_startup+0x340>
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
34811e00:	e5d510d6 	ldrb	r1, [r5, #214]	; 0xd6
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
34811e04:	e5d530d5 	ldrb	r3, [r5, #213]	; 0xd5
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
34811e08:	e1a01801 	lsl	r1, r1, #16
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
34811e0c:	e1811403 	orr	r1, r1, r3, lsl #8
			/*
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
34811e10:	e5d530d4 	ldrb	r3, [r5, #212]	; 0xd4
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
34811e14:	e1811003 	orr	r1, r1, r3
					| ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
34811e18:	e5d530d7 	ldrb	r3, [r5, #215]	; 0xd7
34811e1c:	e1811c03 	orr	r1, r1, r3, lsl #24
			/*
			 * According to the JEDEC Standard, the value of
			 * ext_csd's capacity is valid if the value is more
			 * than 2GB
			 */
			capacity = ext_csd[EXT_CSD_SEC_CNT] << 0
34811e20:	e1a02001 	mov	r2, r1
34811e24:	e1a03fc2 	asr	r3, r2, #31
					| ext_csd[EXT_CSD_SEC_CNT + 1] << 8
					| ext_csd[EXT_CSD_SEC_CNT + 2] << 16
					| ext_csd[EXT_CSD_SEC_CNT + 3] << 24;
			capacity *= 512;
34811e28:	e1a03483 	lsl	r3, r3, #9
34811e2c:	e1833ba1 	orr	r3, r3, r1, lsr #23
34811e30:	e1a01481 	lsl	r1, r1, #9
			if ((capacity >> 20) > 2 * 1024)
34811e34:	e1a02a21 	lsr	r2, r1, #20
34811e38:	e1b00a23 	lsrs	r0, r3, #20
34811e3c:	e1822603 	orr	r2, r2, r3, lsl #12
34811e40:	1a000001 	bne	34811e4c <mmc_startup+0x338>
34811e44:	e3520b02 	cmp	r2, #2048	; 0x800
34811e48:	9a000001 	bls	34811e54 <mmc_startup+0x340>
				mmc->capacity = capacity;
34811e4c:	e5841098 	str	r1, [r4, #152]	; 0x98
34811e50:	e584309c 	str	r3, [r4, #156]	; 0x9c
		/*
		 * Check whether GROUP_DEF is set, if yes, read out
		 * group size from ext_csd directly, or calculate
		 * the group size from the csd value.
		 */
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
34811e54:	e5d530af 	ldrb	r3, [r5, #175]	; 0xaf
34811e58:	e3530000 	cmp	r3, #0
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
34811e5c:	05943068 	ldreq	r3, [r4, #104]	; 0x68
		 * group size from ext_csd directly, or calculate
		 * the group size from the csd value.
		 */
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
34811e60:	15d530e0 	ldrbne	r3, [r5, #224]	; 0xe0
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
34811e64:	07e422d3 	ubfxeq	r2, r3, #5, #5
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
34811e68:	07e43553 	ubfxeq	r3, r3, #10, #5
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
			mmc->erase_grp_size = (erase_gsz + 1)
34811e6c:	02833001 	addeq	r3, r3, #1
				* (erase_gmul + 1);
34811e70:	02822001 	addeq	r2, r2, #1
34811e74:	00030293 	muleq	r3, r3, r2
		 * group size from ext_csd directly, or calculate
		 * the group size from the csd value.
		 */
		if (ext_csd[EXT_CSD_ERASE_GROUP_DEF])
			mmc->erase_grp_size =
			      ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] * 512 * 1024;
34811e78:	11a03983 	lslne	r3, r3, #19
		else {
			int erase_gsz, erase_gmul;
			erase_gsz = (mmc->csd[2] & 0x00007c00) >> 10;
			erase_gmul = (mmc->csd[2] & 0x000003e0) >> 5;
			mmc->erase_grp_size = (erase_gsz + 1)
34811e7c:	e5843090 	str	r3, [r4, #144]	; 0x90
				* (erase_gmul + 1);
		}

		/* store the partition info of emmc */
		if ((ext_csd[EXT_CSD_PARTITIONING_SUPPORT] & PART_SUPPORT) ||
34811e80:	e5d530a0 	ldrb	r3, [r5, #160]	; 0xa0
34811e84:	e3130001 	tst	r3, #1
34811e88:	1a000002 	bne	34811e98 <mmc_startup+0x384>
34811e8c:	e5d530e2 	ldrb	r3, [r5, #226]	; 0xe2
34811e90:	e3530000 	cmp	r3, #0
34811e94:	0a000001 	beq	34811ea0 <mmc_startup+0x38c>
		    ext_csd[EXT_CSD_BOOT_MULT])
			mmc->part_config = ext_csd[EXT_CSD_PART_CONF];
34811e98:	e5d530b3 	ldrb	r3, [r5, #179]	; 0xb3
34811e9c:	e5c43082 	strb	r3, [r4, #130]	; 0x82
	}

	if (IS_SD(mmc))
34811ea0:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34811ea4:	e3130802 	tst	r3, #131072	; 0x20000
34811ea8:	0a000002 	beq	34811eb8 <mmc_startup+0x3a4>
		err = sd_change_freq(mmc);
34811eac:	e1a00004 	mov	r0, r4
34811eb0:	ebfffe87 	bl	348118d4 <sd_change_freq>
34811eb4:	ea000001 	b	34811ec0 <mmc_startup+0x3ac>
	else
		err = mmc_change_freq(mmc);
34811eb8:	e1a00004 	mov	r0, r4
34811ebc:	ebfffe25 	bl	34811758 <mmc_change_freq>

	if (err)
34811ec0:	e3500000 	cmp	r0, #0
	}

	if (IS_SD(mmc))
		err = sd_change_freq(mmc);
	else
		err = mmc_change_freq(mmc);
34811ec4:	e1a06000 	mov	r6, r0

	if (err)
34811ec8:	1a0000a3 	bne	3481215c <mmc_startup+0x648>
		return err;

	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;
34811ecc:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
34811ed0:	e5947050 	ldr	r7, [r4, #80]	; 0x50

	if (IS_SD(mmc)) {
34811ed4:	e5942030 	ldr	r2, [r4, #48]	; 0x30

	if (err)
		return err;

	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;
34811ed8:	e0073003 	and	r3, r7, r3

	if (IS_SD(mmc)) {
34811edc:	e3120802 	tst	r2, #131072	; 0x20000

	if (err)
		return err;

	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;
34811ee0:	e584304c 	str	r3, [r4, #76]	; 0x4c

	if (IS_SD(mmc)) {
34811ee4:	0a000027 	beq	34811f88 <mmc_startup+0x474>
		if (mmc->card_caps & MMC_MODE_4BIT) {
34811ee8:	e3130c01 	tst	r3, #256	; 0x100
34811eec:	0a000020 	beq	34811f74 <mmc_startup+0x460>
			cmd.cmdidx = MMC_CMD_APP_CMD;
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = mmc->rca << 16;
34811ef0:	e1d438b0 	ldrh	r3, [r4, #128]	; 0x80

			err = mmc_send_cmd(mmc, &cmd, NULL);
34811ef4:	e28d5e49 	add	r5, sp, #1168	; 0x490
	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
34811ef8:	e3a01037 	mov	r1, #55	; 0x37
34811efc:	e28d2b01 	add	r2, sp, #1024	; 0x400
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = mmc->rca << 16;

			err = mmc_send_cmd(mmc, &cmd, NULL);
34811f00:	e285500c 	add	r5, r5, #12
	/* Restrict card's capabilities by what the host can do */
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
34811f04:	e1c219bc 	strh	r1, [r2, #156]	; 0x9c
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = mmc->rca << 16;
34811f08:	e1a03803 	lsl	r3, r3, #16
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
			cmd.resp_type = MMC_RSP_R1;
34811f0c:	e3a07015 	mov	r7, #21
			cmd.cmdarg = mmc->rca << 16;

			err = mmc_send_cmd(mmc, &cmd, NULL);
34811f10:	e1a00004 	mov	r0, r4
34811f14:	e1a01005 	mov	r1, r5
34811f18:	e1a02006 	mov	r2, r6
	mmc->card_caps &= mmc->host_caps;

	if (IS_SD(mmc)) {
		if (mmc->card_caps & MMC_MODE_4BIT) {
			cmd.cmdidx = MMC_CMD_APP_CMD;
			cmd.resp_type = MMC_RSP_R1;
34811f1c:	e58d74a0 	str	r7, [sp, #1184]	; 0x4a0
			cmd.cmdarg = mmc->rca << 16;
34811f20:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4

			err = mmc_send_cmd(mmc, &cmd, NULL);
34811f24:	ebfffbac 	bl	34810ddc <mmc_send_cmd>
			if (err)
34811f28:	e3500000 	cmp	r0, #0
34811f2c:	1a000089 	bne	34812158 <mmc_startup+0x644>
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
34811f30:	e3a03006 	mov	r3, #6
34811f34:	e28d0b01 	add	r0, sp, #1024	; 0x400
34811f38:	e1c039bc 	strh	r3, [r0, #156]	; 0x9c
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = 2;
			err = mmc_send_cmd(mmc, &cmd, NULL);
34811f3c:	e1a01005 	mov	r1, r5
			if (err)
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = 2;
34811f40:	e3a03002 	mov	r3, #2
			err = mmc_send_cmd(mmc, &cmd, NULL);
34811f44:	e1a00004 	mov	r0, r4
34811f48:	e1a02006 	mov	r2, r6
			err = mmc_send_cmd(mmc, &cmd, NULL);
			if (err)
				return err;

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
			cmd.resp_type = MMC_RSP_R1;
34811f4c:	e58d74a0 	str	r7, [sp, #1184]	; 0x4a0
			cmd.cmdarg = 2;
34811f50:	e58d34a4 	str	r3, [sp, #1188]	; 0x4a4
			err = mmc_send_cmd(mmc, &cmd, NULL);
34811f54:	ebfffba0 	bl	34810ddc <mmc_send_cmd>
			if (err)
34811f58:	e3500000 	cmp	r0, #0
34811f5c:	1a00007d 	bne	34812158 <mmc_startup+0x644>
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34811f60:	e3a03004 	mov	r3, #4
34811f64:	e5843044 	str	r3, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34811f68:	e1a00004 	mov	r0, r4
34811f6c:	e5943114 	ldr	r3, [r4, #276]	; 0x114
34811f70:	e12fff33 	blx	r3
				return err;

			mmc_set_bus_width(mmc, 4);
		}

		if (mmc->card_caps & MMC_MODE_HS)
34811f74:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
34811f78:	e3130001 	tst	r3, #1
			mmc->tran_speed = 50000000;
34811f7c:	159f3200 	ldrne	r3, [pc, #512]	; 34812184 <mmc_startup+0x670>
		else
			mmc->tran_speed = 25000000;
34811f80:	059f3200 	ldreq	r3, [pc, #512]	; 34812188 <mmc_startup+0x674>
34811f84:	ea00003e 	b	34812084 <mmc_startup+0x570>
	} else {
		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
34811f88:	e7e17457 	ubfx	r7, r7, #8, #2
				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
				 && ext_csd[EXT_CSD_REV] \
				    == test_csd[EXT_CSD_REV]
				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
34811f8c:	e28a10d4 	add	r1, sl, #212	; 0xd4
	mmc->bus_width = width;

	mmc_set_ios(mmc);
}

int mmc_startup(struct mmc *mmc)
34811f90:	e1a09107 	lsl	r9, r7, #2
				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
				 && ext_csd[EXT_CSD_REV] \
				    == test_csd[EXT_CSD_REV]
				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
34811f94:	e285b0d4 	add	fp, r5, #212	; 0xd4
34811f98:	e58d1014 	str	r1, [sp, #20]
	} else {
		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
			 MMC_MODE_WIDTH_BITS_SHIFT);
		for (; width >= 0; width--) {
			/* Set the card to use 4 bit*/
			err = mmc_switch(mmc, EXT_CSD_CMD_SET_NORMAL,
34811f9c:	e1a00004 	mov	r0, r4
34811fa0:	e3a01001 	mov	r1, #1
34811fa4:	e3a020b7 	mov	r2, #183	; 0xb7
34811fa8:	e6ef3077 	uxtb	r3, r7
34811fac:	ebfffdd4 	bl	34811704 <mmc_switch>
					EXT_CSD_BUS_WIDTH, width);

			if (err)
34811fb0:	e3500000 	cmp	r0, #0
34811fb4:	1a000028 	bne	3481205c <mmc_startup+0x548>
				continue;

			if (!width) {
34811fb8:	e3570000 	cmp	r7, #0
34811fbc:	e5943114 	ldr	r3, [r4, #276]	; 0x114
34811fc0:	1a000004 	bne	34811fd8 <mmc_startup+0x4c4>
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34811fc4:	e3a02001 	mov	r2, #1
34811fc8:	e5842044 	str	r2, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34811fcc:	e1a00004 	mov	r0, r4
34811fd0:	e12fff33 	blx	r3
			if (err)
				continue;

			if (!width) {
				mmc_set_bus_width(mmc, 1);
				break;
34811fd4:	ea000024 	b	3481206c <mmc_startup+0x558>
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34811fd8:	e1a00004 	mov	r0, r4
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
34811fdc:	e5849044 	str	r9, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
34811fe0:	e12fff33 	blx	r3
				mmc_set_bus_width(mmc, 1);
				break;
			} else
				mmc_set_bus_width(mmc, 4 * width);

			err = mmc_send_ext_csd(mmc, test_csd);
34811fe4:	e1a00004 	mov	r0, r4
34811fe8:	e1a0100a 	mov	r1, sl
34811fec:	ebfffdb1 	bl	348116b8 <mmc_send_ext_csd>
			if (!err && ext_csd[EXT_CSD_PARTITIONING_SUPPORT] \
34811ff0:	e3500000 	cmp	r0, #0
34811ff4:	1a000018 	bne	3481205c <mmc_startup+0x548>
34811ff8:	e5d520a0 	ldrb	r2, [r5, #160]	; 0xa0
34811ffc:	e5da30a0 	ldrb	r3, [sl, #160]	; 0xa0
34812000:	e1520003 	cmp	r2, r3
34812004:	1a000014 	bne	3481205c <mmc_startup+0x548>
				    == test_csd[EXT_CSD_PARTITIONING_SUPPORT]
				 && ext_csd[EXT_CSD_ERASE_GROUP_DEF] \
34812008:	e5d520af 	ldrb	r2, [r5, #175]	; 0xaf
3481200c:	e5da30af 	ldrb	r3, [sl, #175]	; 0xaf
34812010:	e1520003 	cmp	r2, r3
34812014:	1a000010 	bne	3481205c <mmc_startup+0x548>
				    == test_csd[EXT_CSD_ERASE_GROUP_DEF] \
				 && ext_csd[EXT_CSD_REV] \
34812018:	e5d520c0 	ldrb	r2, [r5, #192]	; 0xc0
3481201c:	e5da30c0 	ldrb	r3, [sl, #192]	; 0xc0
34812020:	e1520003 	cmp	r2, r3
34812024:	1a00000c 	bne	3481205c <mmc_startup+0x548>
				    == test_csd[EXT_CSD_REV]
				 && ext_csd[EXT_CSD_HC_ERASE_GRP_SIZE] \
34812028:	e5d520e0 	ldrb	r2, [r5, #224]	; 0xe0
3481202c:	e5da30e0 	ldrb	r3, [sl, #224]	; 0xe0
34812030:	e1520003 	cmp	r2, r3
34812034:	1a000008 	bne	3481205c <mmc_startup+0x548>
				    == test_csd[EXT_CSD_HC_ERASE_GRP_SIZE]
				 && memcmp(&ext_csd[EXT_CSD_SEC_CNT], \
34812038:	e1a0000b 	mov	r0, fp
3481203c:	e59d1014 	ldr	r1, [sp, #20]
34812040:	e3a02004 	mov	r2, #4
34812044:	eb0027f5 	bl	3481c020 <memcmp>
34812048:	e3500000 	cmp	r0, #0
					&test_csd[EXT_CSD_SEC_CNT], 4) == 0) {

				mmc->card_caps |= width;
3481204c:	0594304c 	ldreq	r3, [r4, #76]	; 0x4c
34812050:	01837007 	orreq	r7, r3, r7
34812054:	0584704c 	streq	r7, [r4, #76]	; 0x4c
				break;
34812058:	0a000003 	beq	3481206c <mmc_startup+0x558>
		else
			mmc->tran_speed = 25000000;
	} else {
		width = ((mmc->host_caps & MMC_MODE_MASK_WIDTH_BITS) >>
			 MMC_MODE_WIDTH_BITS_SHIFT);
		for (; width >= 0; width--) {
3481205c:	e2477001 	sub	r7, r7, #1
34812060:	e3770001 	cmn	r7, #1
34812064:	e2499004 	sub	r9, r9, #4
34812068:	1affffcb 	bne	34811f9c <mmc_startup+0x488>
				mmc->card_caps |= width;
				break;
			}
		}

		if (mmc->card_caps & MMC_MODE_HS) {
3481206c:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
34812070:	e3130001 	tst	r3, #1
34812074:	0a000003 	beq	34812088 <mmc_startup+0x574>
			if (mmc->card_caps & MMC_MODE_HS_52MHz)
34812078:	e3130010 	tst	r3, #16
				mmc->tran_speed = 52000000;
3481207c:	159f3108 	ldrne	r3, [pc, #264]	; 3481218c <mmc_startup+0x678>
			else
				mmc->tran_speed = 26000000;
34812080:	059f3108 	ldreq	r3, [pc, #264]	; 34812190 <mmc_startup+0x67c>
34812084:	e5843084 	str	r3, [r4, #132]	; 0x84
		}
	}

	mmc_set_clock(mmc, mmc->tran_speed);
34812088:	e1a00004 	mov	r0, r4
3481208c:	e5941084 	ldr	r1, [r4, #132]	; 0x84
34812090:	ebfffe8f 	bl	34811ad4 <mmc_set_clock>

	/* fill in device description */
	mmc->block_dev.lun = 0;
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
34812094:	e594509c 	ldr	r5, [r4, #156]	; 0x9c
	}

	mmc_set_clock(mmc, mmc->tran_speed);

	/* fill in device description */
	mmc->block_dev.lun = 0;
34812098:	e3a03000 	mov	r3, #0
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
3481209c:	e5941088 	ldr	r1, [r4, #136]	; 0x88
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
348120a0:	e5940098 	ldr	r0, [r4, #152]	; 0x98
 * the result, not reminder.
 */
static inline uint64_t lldiv(uint64_t dividend, uint32_t divisor)
{
	uint64_t __res = dividend;
	do_div(__res, divisor);
348120a4:	e1550003 	cmp	r5, r3
	}

	mmc_set_clock(mmc, mmc->tran_speed);

	/* fill in device description */
	mmc->block_dev.lun = 0;
348120a8:	e5c430aa 	strb	r3, [r4, #170]	; 0xaa
	mmc->block_dev.type = 0;
348120ac:	e5c430ab 	strb	r3, [r4, #171]	; 0xab
	mmc->block_dev.blksz = mmc->read_bl_len;
348120b0:	e58410b4 	str	r1, [r4, #180]	; 0xb4
/* Wrapper for do_div(). Doesn't modify dividend and returns
 * the result, not reminder.
 */
static inline uint64_t lldiv(uint64_t dividend, uint32_t divisor)
{
	uint64_t __res = dividend;
348120b4:	e58d04b8 	str	r0, [sp, #1208]	; 0x4b8
348120b8:	e58d54bc 	str	r5, [sp, #1212]	; 0x4bc
	do_div(__res, divisor);
348120bc:	1a000003 	bne	348120d0 <mmc_startup+0x5bc>
348120c0:	eb0036b6 	bl	3481fba0 <__udivsi3>
348120c4:	e58d54bc 	str	r5, [sp, #1212]	; 0x4bc
348120c8:	e58d04b8 	str	r0, [sp, #1208]	; 0x4b8
348120cc:	ea000002 	b	348120dc <mmc_startup+0x5c8>
348120d0:	e28d0e4b 	add	r0, sp, #1200	; 0x4b0
348120d4:	e2800008 	add	r0, r0, #8
348120d8:	eb0020d8 	bl	3481a440 <__div64_32>
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
348120dc:	e59d34b8 	ldr	r3, [sp, #1208]	; 0x4b8
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
348120e0:	e594c078 	ldr	ip, [r4, #120]	; 0x78

	/* fill in device description */
	mmc->block_dev.lun = 0;
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
348120e4:	e58430b0 	str	r3, [r4, #176]	; 0xb0
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
348120e8:	e5942070 	ldr	r2, [r4, #112]	; 0x70
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
348120ec:	e5d4307f 	ldrb	r3, [r4, #127]	; 0x7f
	/* fill in device description */
	mmc->block_dev.lun = 0;
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
348120f0:	e28400b8 	add	r0, r4, #184	; 0xb8
348120f4:	e183340c 	orr	r3, r3, ip, lsl #8
348120f8:	e59f1094 	ldr	r1, [pc, #148]	; 34812194 <mmc_startup+0x680>
348120fc:	e1a02422 	lsr	r2, r2, #8
34812100:	eb002b08 	bl	3481cd28 <sprintf>
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
	sprintf(mmc->block_dev.product, "%c%c%c%c%c", mmc->cid[0] & 0xff,
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
34812104:	e5943074 	ldr	r3, [r4, #116]	; 0x74
	mmc->block_dev.type = 0;
	mmc->block_dev.blksz = mmc->read_bl_len;
	mmc->block_dev.lba = lldiv(mmc->capacity, mmc->read_bl_len);
	sprintf(mmc->block_dev.vendor, "Man %06x Snr %08x", mmc->cid[0] >> 8,
			(mmc->cid[2] << 8) | (mmc->cid[3] >> 24));
	sprintf(mmc->block_dev.product, "%c%c%c%c%c", mmc->cid[0] & 0xff,
34812108:	e5d42070 	ldrb	r2, [r4, #112]	; 0x70
3481210c:	e7e71853 	ubfx	r1, r3, #16, #8
34812110:	e58d1000 	str	r1, [sp]
34812114:	e7e71453 	ubfx	r1, r3, #8, #8
34812118:	e58d1004 	str	r1, [sp, #4]
3481211c:	e20310ff 	and	r1, r3, #255	; 0xff
34812120:	e58d1008 	str	r1, [sp, #8]
34812124:	e28400e1 	add	r0, r4, #225	; 0xe1
34812128:	e59f1068 	ldr	r1, [pc, #104]	; 34812198 <mmc_startup+0x684>
3481212c:	e1a03c23 	lsr	r3, r3, #24
34812130:	eb002afc 	bl	3481cd28 <sprintf>
			(mmc->cid[1] >> 24), (mmc->cid[1] >> 16) & 0xff,
			(mmc->cid[1] >> 8) & 0xff, mmc->cid[1] & 0xff);
	sprintf(mmc->block_dev.revision, "%d.%d", mmc->cid[2] >> 28,
34812134:	e5943078 	ldr	r3, [r4, #120]	; 0x78
34812138:	e28400f6 	add	r0, r4, #246	; 0xf6
3481213c:	e1a02e23 	lsr	r2, r3, #28
34812140:	e59f1054 	ldr	r1, [pc, #84]	; 3481219c <mmc_startup+0x688>
34812144:	e7e33c53 	ubfx	r3, r3, #24, #4
34812148:	eb002af6 	bl	3481cd28 <sprintf>
			(mmc->cid[2] >> 24) & 0xf);
#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBDISK_SUPPORT)
	init_part(&mmc->block_dev);
3481214c:	e28400a0 	add	r0, r4, #160	; 0xa0
34812150:	ebfff497 	bl	3480f3b4 <init_part>
#endif

	return 0;
34812154:	ea000000 	b	3481215c <mmc_startup+0x648>

			cmd.cmdidx = SD_CMD_APP_SET_BUS_WIDTH;
			cmd.resp_type = MMC_RSP_R1;
			cmd.cmdarg = 2;
			err = mmc_send_cmd(mmc, &cmd, NULL);
			if (err)
34812158:	e1a06000 	mov	r6, r0
#if !defined(CONFIG_SPL_BUILD) || defined(CONFIG_SPL_LIBDISK_SUPPORT)
	init_part(&mmc->block_dev);
#endif

	return 0;
}
3481215c:	e1a00006 	mov	r0, r6
34812160:	e28ddd13 	add	sp, sp, #1216	; 0x4c0
34812164:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34812168:	00010014 	.word	0x00010014
3481216c:	00010022 	.word	0x00010022
34812170:	00010030 	.word	0x00010030
34812174:	00010040 	.word	0x00010040
34812178:	00010012 	.word	0x00010012
3481217c:	3482143c 	.word	0x3482143c
34812180:	0001003f 	.word	0x0001003f
34812184:	02faf080 	.word	0x02faf080
34812188:	017d7840 	.word	0x017d7840
3481218c:	03197500 	.word	0x03197500
34812190:	018cba80 	.word	0x018cba80
34812194:	3482708a 	.word	0x3482708a
34812198:	3482709c 	.word	0x3482709c
3481219c:	348270a7 	.word	0x348270a7

348121a0 <mmc_send_if_cond>:

int mmc_send_if_cond(struct mmc *mmc)
{
348121a0:	e92d4010 	push	{r4, lr}
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
348121a4:	e3a03008 	mov	r3, #8

	return 0;
}

int mmc_send_if_cond(struct mmc *mmc)
{
348121a8:	e24dd020 	sub	sp, sp, #32
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
348121ac:	e590202c 	ldr	r2, [r0, #44]	; 0x2c
int mmc_send_if_cond(struct mmc *mmc)
{
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
348121b0:	e1cd30b4 	strh	r3, [sp, #4]
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
348121b4:	e59f3050 	ldr	r3, [pc, #80]	; 3481220c <mmc_send_if_cond+0x6c>
	cmd.resp_type = MMC_RSP_R7;

	err = mmc_send_cmd(mmc, &cmd, NULL);
348121b8:	e28d1004 	add	r1, sp, #4
	struct mmc_cmd cmd;
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
348121bc:	e0023003 	and	r3, r2, r3
348121c0:	e3530000 	cmp	r3, #0
348121c4:	e30021aa 	movw	r2, #426	; 0x1aa
348121c8:	11a03002 	movne	r3, r2
348121cc:	03a030aa 	moveq	r3, #170	; 0xaa
348121d0:	e58d300c 	str	r3, [sp, #12]
	cmd.resp_type = MMC_RSP_R7;

	err = mmc_send_cmd(mmc, &cmd, NULL);
348121d4:	e3a02000 	mov	r2, #0
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
	cmd.resp_type = MMC_RSP_R7;
348121d8:	e3a03015 	mov	r3, #21

	return 0;
}

int mmc_send_if_cond(struct mmc *mmc)
{
348121dc:	e1a04000 	mov	r4, r0
	int err;

	cmd.cmdidx = SD_CMD_SEND_IF_COND;
	/* We set the bit if the host supports voltages between 2.7 and 3.6 V */
	cmd.cmdarg = ((mmc->voltages & 0xff8000) != 0) << 8 | 0xaa;
	cmd.resp_type = MMC_RSP_R7;
348121e0:	e58d3008 	str	r3, [sp, #8]

	err = mmc_send_cmd(mmc, &cmd, NULL);
348121e4:	ebfffafc 	bl	34810ddc <mmc_send_cmd>

	if (err)
348121e8:	e3500000 	cmp	r0, #0
348121ec:	1a000004 	bne	34812204 <mmc_send_if_cond+0x64>
		return err;

	if ((cmd.response[0] & 0xff) != 0xaa)
348121f0:	e5dd3010 	ldrb	r3, [sp, #16]
348121f4:	e35300aa 	cmp	r3, #170	; 0xaa
		return UNUSABLE_ERR;
	else
		mmc->version = SD_VERSION_2;
348121f8:	059f3010 	ldreq	r3, [pc, #16]	; 34812210 <mmc_send_if_cond+0x70>

	if (err)
		return err;

	if ((cmd.response[0] & 0xff) != 0xaa)
		return UNUSABLE_ERR;
348121fc:	13e00010 	mvnne	r0, #16
	else
		mmc->version = SD_VERSION_2;
34812200:	05843030 	streq	r3, [r4, #48]	; 0x30

	return 0;
}
34812204:	e28dd020 	add	sp, sp, #32
34812208:	e8bd8010 	pop	{r4, pc}
3481220c:	00ff8000 	.word	0x00ff8000
34812210:	00020020 	.word	0x00020020

34812214 <mmc_register>:

int mmc_register(struct mmc *mmc)
{
	/* Setup the universal parts of the block interface just once */
	mmc->block_dev.if_type = IF_TYPE_MMC;
34812214:	e3a03006 	mov	r3, #6
34812218:	e58030a0 	str	r3, [r0, #160]	; 0xa0
	mmc->block_dev.dev = cur_dev_num++;
3481221c:	e59f305c 	ldr	r3, [pc, #92]	; 34812280 <mmc_register+0x6c>
34812220:	e5932000 	ldr	r2, [r3]
34812224:	e58020a4 	str	r2, [r0, #164]	; 0xa4
34812228:	e2822001 	add	r2, r2, #1
3481222c:	e5832000 	str	r2, [r3]
	mmc->block_dev.removable = 1;
34812230:	e3a03001 	mov	r3, #1
34812234:	e5c030ac 	strb	r3, [r0, #172]	; 0xac
	mmc->block_dev.block_read = mmc_bread;
34812238:	e59f3044 	ldr	r3, [pc, #68]	; 34812284 <mmc_register+0x70>
3481223c:	e5803100 	str	r3, [r0, #256]	; 0x100
	mmc->block_dev.block_write = mmc_bwrite;
34812240:	e59f3040 	ldr	r3, [pc, #64]	; 34812288 <mmc_register+0x74>
34812244:	e5803104 	str	r3, [r0, #260]	; 0x104
	mmc->block_dev.block_erase = mmc_berase;
34812248:	e59f303c 	ldr	r3, [pc, #60]	; 3481228c <mmc_register+0x78>
3481224c:	e5803108 	str	r3, [r0, #264]	; 0x108
	if (!mmc->b_max)
34812250:	e5903120 	ldr	r3, [r0, #288]	; 0x120
34812254:	e3530000 	cmp	r3, #0
		mmc->b_max = CONFIG_SYS_MMC_MAX_BLK_COUNT;
34812258:	030f3fff 	movweq	r3, #65535	; 0xffff
3481225c:	05803120 	streq	r3, [r0, #288]	; 0x120
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34812260:	e59f3028 	ldr	r3, [pc, #40]	; 34812290 <mmc_register+0x7c>
34812264:	e5932004 	ldr	r2, [r3, #4]
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34812268:	e5803000 	str	r3, [r0]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
3481226c:	e5830004 	str	r0, [r3, #4]
	new->next = next;
	new->prev = prev;
	prev->next = new;
34812270:	e5820000 	str	r0, [r2]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
34812274:	e5802004 	str	r2, [r0, #4]
	INIT_LIST_HEAD (&mmc->link);

	list_add_tail (&mmc->link, &mmc_devices);

	return 0;
}
34812278:	e3a00000 	mov	r0, #0
3481227c:	e12fff1e 	bx	lr
34812280:	34828b18 	.word	0x34828b18
34812284:	3481133c 	.word	0x3481133c
34812288:	348110f0 	.word	0x348110f0
3481228c:	34810f60 	.word	0x34810f60
34812290:	3482ba28 	.word	0x3482ba28

34812294 <mmc_init>:
	return &mmc->block_dev;
}
#endif

int mmc_init(struct mmc *mmc)
{
34812294:	e92d4038 	push	{r3, r4, r5, lr}
34812298:	e1a04000 	mov	r4, r0
	int err;

	if (mmc_getcd(mmc) == 0) {
3481229c:	ebfffd68 	bl	34811844 <mmc_getcd>
348122a0:	e3500000 	cmp	r0, #0
348122a4:	1a000004 	bne	348122bc <mmc_init+0x28>
		mmc->has_init = 0;
348122a8:	e5840034 	str	r0, [r4, #52]	; 0x34
		printf("MMC: no card present\n");
348122ac:	e59f00b8 	ldr	r0, [pc, #184]	; 3481236c <mmc_init+0xd8>
348122b0:	ebffdbab 	bl	34809164 <printf>
		return NO_CARD_ERR;
348122b4:	e3e0000f 	mvn	r0, #15
348122b8:	e8bd8038 	pop	{r3, r4, r5, pc}
	}

	if (mmc->has_init)
348122bc:	e5943034 	ldr	r3, [r4, #52]	; 0x34
348122c0:	e3530000 	cmp	r3, #0
348122c4:	1a000026 	bne	34812364 <mmc_init+0xd0>
		return 0;

	err = mmc->init(mmc);
348122c8:	e5943118 	ldr	r3, [r4, #280]	; 0x118
348122cc:	e1a00004 	mov	r0, r4
348122d0:	e12fff33 	blx	r3

	if (err)
348122d4:	e3500000 	cmp	r0, #0
348122d8:	18bd8038 	popne	{r3, r4, r5, pc}
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
348122dc:	e3a05001 	mov	r5, #1
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
348122e0:	e5943114 	ldr	r3, [r4, #276]	; 0x114
348122e4:	e1a00004 	mov	r0, r4
	mmc_set_ios(mmc);
}

void mmc_set_bus_width(struct mmc *mmc, uint width)
{
	mmc->bus_width = width;
348122e8:	e5845044 	str	r5, [r4, #68]	; 0x44
	80,
};

void mmc_set_ios(struct mmc *mmc)
{
	mmc->set_ios(mmc);
348122ec:	e12fff33 	blx	r3

	if (err)
		return err;

	mmc_set_bus_width(mmc, 1);
	mmc_set_clock(mmc, 1);
348122f0:	e1a00004 	mov	r0, r4
348122f4:	e1a01005 	mov	r1, r5
348122f8:	ebfffdf5 	bl	34811ad4 <mmc_set_clock>

	/* Reset the Card */
	err = mmc_go_idle(mmc);
348122fc:	e1a00004 	mov	r0, r4
34812300:	ebfffc36 	bl	348113e0 <mmc_go_idle>

	if (err)
34812304:	e3500000 	cmp	r0, #0
34812308:	18bd8038 	popne	{r3, r4, r5, pc}
		return err;

	/* The internal partition reset to user partition(0) at every CMD0*/
	mmc->part_num = 0;
3481230c:	e5c40083 	strb	r0, [r4, #131]	; 0x83

	/* Test for SD version 2 */
	err = mmc_send_if_cond(mmc);
34812310:	e1a00004 	mov	r0, r4
34812314:	ebffffa1 	bl	348121a0 <mmc_send_if_cond>

	/* Now try to get the SD card's operating condition */
	err = sd_send_op_cond(mmc);
34812318:	e1a00004 	mov	r0, r4
3481231c:	ebfffc42 	bl	3481142c <sd_send_op_cond>

	/* If the command timed out, we check for an MMC card */
	if (err == TIMEOUT) {
34812320:	e3700013 	cmn	r0, #19
34812324:	1a000007 	bne	34812348 <mmc_init+0xb4>
		err = mmc_send_op_cond(mmc);
34812328:	e1a00004 	mov	r0, r4
3481232c:	ebfffc90 	bl	34811574 <mmc_send_op_cond>

		if (err) {
34812330:	e3500000 	cmp	r0, #0
34812334:	0a000003 	beq	34812348 <mmc_init+0xb4>
			printf("Card did not respond to voltage select!\n");
34812338:	e59f0030 	ldr	r0, [pc, #48]	; 34812370 <mmc_init+0xdc>
3481233c:	ebffdb88 	bl	34809164 <printf>
			return UNUSABLE_ERR;
34812340:	e3e00010 	mvn	r0, #16
34812344:	e8bd8038 	pop	{r3, r4, r5, pc}
		}
	}

	err = mmc_startup(mmc);
34812348:	e1a00004 	mov	r0, r4
3481234c:	ebfffdf0 	bl	34811b14 <mmc_startup>
	if (err)
34812350:	e3500000 	cmp	r0, #0
		mmc->has_init = 0;
34812354:	13a03000 	movne	r3, #0
	else
		mmc->has_init = 1;
34812358:	03a03001 	moveq	r3, #1
3481235c:	e5843034 	str	r3, [r4, #52]	; 0x34
34812360:	e8bd8038 	pop	{r3, r4, r5, pc}
		printf("MMC: no card present\n");
		return NO_CARD_ERR;
	}

	if (mmc->has_init)
		return 0;
34812364:	e3a00000 	mov	r0, #0
	if (err)
		mmc->has_init = 0;
	else
		mmc->has_init = 1;
	return err;
}
34812368:	e8bd8038 	pop	{r3, r4, r5, pc}
3481236c:	348270ad 	.word	0x348270ad
34812370:	348270c3 	.word	0x348270c3

34812374 <mmc_get_dev>:
	return 0;
}

#ifdef CONFIG_PARTITIONS
block_dev_desc_t *mmc_get_dev(int dev)
{
34812374:	e92d4010 	push	{r4, lr}
	struct mmc *mmc = find_mmc_device(dev);
34812378:	ebfffae6 	bl	34810f18 <find_mmc_device>
	if (!mmc || mmc_init(mmc))
3481237c:	e2504000 	subs	r4, r0, #0
		return NULL;
34812380:	01a00004 	moveq	r0, r4

#ifdef CONFIG_PARTITIONS
block_dev_desc_t *mmc_get_dev(int dev)
{
	struct mmc *mmc = find_mmc_device(dev);
	if (!mmc || mmc_init(mmc))
34812384:	08bd8010 	popeq	{r4, pc}
34812388:	ebffffc1 	bl	34812294 <mmc_init>
3481238c:	e3500000 	cmp	r0, #0
		return NULL;

	return &mmc->block_dev;
34812390:	028400a0 	addeq	r0, r4, #160	; 0xa0
#ifdef CONFIG_PARTITIONS
block_dev_desc_t *mmc_get_dev(int dev)
{
	struct mmc *mmc = find_mmc_device(dev);
	if (!mmc || mmc_init(mmc))
		return NULL;
34812394:	13a00000 	movne	r0, #0

	return &mmc->block_dev;
}
34812398:	e8bd8010 	pop	{r4, pc}

3481239c <cpu_mmc_init>:
 * signals caller to move on
 */
static int __def_mmc_init(bd_t *bis)
{
	return -1;
}
3481239c:	e3e00000 	mvn	r0, #0
348123a0:	e12fff1e 	bx	lr

348123a4 <print_mmc_devices>:

int cpu_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));
int board_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));

void print_mmc_devices(char separator)
{
348123a4:	e92d4070 	push	{r4, r5, r6, lr}
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
348123a8:	e59f5048 	ldr	r5, [pc, #72]	; 348123f8 <print_mmc_devices+0x54>

int cpu_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));
int board_mmc_init(bd_t *bis) __attribute__((weak, alias("__def_mmc_init")));

void print_mmc_devices(char separator)
{
348123ac:	e1a06000 	mov	r6, r0
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
348123b0:	e5954000 	ldr	r4, [r5]
348123b4:	ea00000a 	b	348123e4 <print_mmc_devices+0x40>
		m = list_entry(entry, struct mmc, link);

		printf("%s: %d", m->name, m->block_dev.dev);
348123b8:	e59f003c 	ldr	r0, [pc, #60]	; 348123fc <print_mmc_devices+0x58>
348123bc:	e2841008 	add	r1, r4, #8
348123c0:	e59420a4 	ldr	r2, [r4, #164]	; 0xa4
348123c4:	ebffdb66 	bl	34809164 <printf>

		if (entry->next != &mmc_devices)
348123c8:	e5943000 	ldr	r3, [r4]
348123cc:	e1530005 	cmp	r3, r5
348123d0:	0a000002 	beq	348123e0 <print_mmc_devices+0x3c>
			printf("%c ", separator);
348123d4:	e59f0024 	ldr	r0, [pc, #36]	; 34812400 <print_mmc_devices+0x5c>
348123d8:	e1a01006 	mov	r1, r6
348123dc:	ebffdb60 	bl	34809164 <printf>
void print_mmc_devices(char separator)
{
	struct mmc *m;
	struct list_head *entry;

	list_for_each(entry, &mmc_devices) {
348123e0:	e5944000 	ldr	r4, [r4]
348123e4:	e1540005 	cmp	r4, r5
348123e8:	1afffff2 	bne	348123b8 <print_mmc_devices+0x14>

		if (entry->next != &mmc_devices)
			printf("%c ", separator);
	}

	printf("\n");
348123ec:	e59f0010 	ldr	r0, [pc, #16]	; 34812404 <print_mmc_devices+0x60>
}
348123f0:	e8bd4070 	pop	{r4, r5, r6, lr}

		if (entry->next != &mmc_devices)
			printf("%c ", separator);
	}

	printf("\n");
348123f4:	eaffdb5a 	b	34809164 <printf>
348123f8:	3482ba28 	.word	0x3482ba28
348123fc:	348270ec 	.word	0x348270ec
34812400:	34823725 	.word	0x34823725
34812404:	34826214 	.word	0x34826214

34812408 <get_mmc_num>:
}

int get_mmc_num(void)
{
	return cur_dev_num;
}
34812408:	e59f3004 	ldr	r3, [pc, #4]	; 34812414 <get_mmc_num+0xc>
3481240c:	e5930000 	ldr	r0, [r3]
34812410:	e12fff1e 	bx	lr
34812414:	34828b18 	.word	0x34828b18

34812418 <mmc_initialize>:
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34812418:	e59f303c 	ldr	r3, [pc, #60]	; 3481245c <mmc_initialize+0x44>

int mmc_initialize(bd_t *bis)
{
3481241c:	e92d4010 	push	{r4, lr}
34812420:	e5833000 	str	r3, [r3]
	list->prev = list;
34812424:	e5833004 	str	r3, [r3, #4]
	INIT_LIST_HEAD (&mmc_devices);
	cur_dev_num = 0;
34812428:	e59f3030 	ldr	r3, [pc, #48]	; 34812460 <mmc_initialize+0x48>
3481242c:	e3a02000 	mov	r2, #0
34812430:	e5832000 	str	r2, [r3]
{
	return cur_dev_num;
}

int mmc_initialize(bd_t *bis)
{
34812434:	e1a04000 	mov	r4, r0
	INIT_LIST_HEAD (&mmc_devices);
	cur_dev_num = 0;

	if (board_mmc_init(bis) < 0)
34812438:	eb003599 	bl	3481faa4 <board_mmc_init>
3481243c:	e3500000 	cmp	r0, #0
34812440:	aa000001 	bge	3481244c <mmc_initialize+0x34>
		cpu_mmc_init(bis);
34812444:	e1a00004 	mov	r0, r4
34812448:	ebffffd3 	bl	3481239c <cpu_mmc_init>

	print_mmc_devices(',');
3481244c:	e3a0002c 	mov	r0, #44	; 0x2c
34812450:	ebffffd3 	bl	348123a4 <print_mmc_devices>

	return 0;
}
34812454:	e3a00000 	mov	r0, #0
34812458:	e8bd8010 	pop	{r4, pc}
3481245c:	3482ba28 	.word	0x3482ba28
34812460:	34828b18 	.word	0x34828b18

34812464 <sdhci_set_ios>:

	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
}

void sdhci_set_ios(struct mmc *mmc)
{
34812464:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	u32 ctrl;
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
34812468:	e5905028 	ldr	r5, [r0, #40]	; 0x28

	sdhci_writeb(host, pwr, SDHCI_POWER_CONTROL);
}

void sdhci_set_ios(struct mmc *mmc)
{
3481246c:	e1a07000 	mov	r7, r0
	u32 ctrl;
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;

	if (host->set_control_reg)
34812470:	e5953024 	ldr	r3, [r5, #36]	; 0x24
34812474:	e3530000 	cmp	r3, #0
34812478:	0a000001 	beq	34812484 <sdhci_set_ios+0x20>
		host->set_control_reg(host);
3481247c:	e1a00005 	mov	r0, r5
34812480:	e12fff33 	blx	r3

	if (mmc->clock != host->clock)
34812484:	e597a048 	ldr	sl, [r7, #72]	; 0x48
34812488:	e5953014 	ldr	r3, [r5, #20]
3481248c:	e15a0003 	cmp	sl, r3
34812490:	0a000040 	beq	34812598 <sdhci_set_ios+0x134>
		return COMM_ERR;
}

static int sdhci_set_clock(struct mmc *mmc, unsigned int clock)
{
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
34812494:	e5976028 	ldr	r6, [r7, #40]	; 0x28
	writel(val, host->ioaddr + reg);
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
34812498:	e5963004 	ldr	r3, [r6, #4]
3481249c:	e3a02000 	mov	r2, #0
	unsigned int div, clk, timeout;

	sdhci_writew(host, 0, SDHCI_CLOCK_CONTROL);

	if (clock == 0)
348124a0:	e35a0000 	cmp	sl, #0
348124a4:	e1c322bc 	strh	r2, [r3, #44]	; 0x2c
348124a8:	0a00003a 	beq	34812598 <sdhci_set_ios+0x134>
		return 0;

	if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300) {
348124ac:	e5d63010 	ldrb	r3, [r6, #16]
348124b0:	e597b03c 	ldr	fp, [r7, #60]	; 0x3c
348124b4:	e3530001 	cmp	r3, #1
348124b8:	9a00000d 	bls	348124f4 <sdhci_set_ios+0x90>
		/* Version 3.00 divisors must be a multiple of 2. */
		if (mmc->f_max <= clock)
348124bc:	e15b000a 	cmp	fp, sl
			div = 1;
348124c0:	93a04001 	movls	r4, #1
	if (clock == 0)
		return 0;

	if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300) {
		/* Version 3.00 divisors must be a multiple of 2. */
		if (mmc->f_max <= clock)
348124c4:	9a000014 	bls	3481251c <sdhci_set_ios+0xb8>
348124c8:	e3a04002 	mov	r4, #2
			div = 1;
		else {
			for (div = 2; div < SDHCI_MAX_DIV_SPEC_300; div += 2) {
348124cc:	e30097fe 	movw	r9, #2046	; 0x7fe
				if ((mmc->f_max / div) <= clock)
348124d0:	e1a0000b 	mov	r0, fp
348124d4:	e1a01004 	mov	r1, r4
348124d8:	eb0035b0 	bl	3481fba0 <__udivsi3>
348124dc:	e150000a 	cmp	r0, sl
348124e0:	9a00000d 	bls	3481251c <sdhci_set_ios+0xb8>
	if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300) {
		/* Version 3.00 divisors must be a multiple of 2. */
		if (mmc->f_max <= clock)
			div = 1;
		else {
			for (div = 2; div < SDHCI_MAX_DIV_SPEC_300; div += 2) {
348124e4:	e2844002 	add	r4, r4, #2
348124e8:	e1540009 	cmp	r4, r9
348124ec:	1afffff7 	bne	348124d0 <sdhci_set_ios+0x6c>
348124f0:	ea000009 	b	3481251c <sdhci_set_ios+0xb8>
			}
		}
	} else {
		/* Version 2.00 divisors must be a power of 2. */
		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
			if ((mmc->f_max / div) <= clock)
348124f4:	e3a09008 	mov	r9, #8
348124f8:	e3a04001 	mov	r4, #1
348124fc:	e1a0000b 	mov	r0, fp
34812500:	e1a01004 	mov	r1, r4
34812504:	eb0035a5 	bl	3481fba0 <__udivsi3>
34812508:	e150000a 	cmp	r0, sl
3481250c:	9a000002 	bls	3481251c <sdhci_set_ios+0xb8>
					break;
			}
		}
	} else {
		/* Version 2.00 divisors must be a power of 2. */
		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
34812510:	e2599001 	subs	r9, r9, #1
34812514:	e1a04084 	lsl	r4, r4, #1
34812518:	1afffff7 	bne	348124fc <sdhci_set_ios+0x98>
				break;
		}
	}
	div >>= 1;

	if (host->set_clock)
3481251c:	e5963028 	ldr	r3, [r6, #40]	; 0x28
		for (div = 1; div < SDHCI_MAX_DIV_SPEC_200; div *= 2) {
			if ((mmc->f_max / div) <= clock)
				break;
		}
	}
	div >>= 1;
34812520:	e1a040a4 	lsr	r4, r4, #1

	if (host->set_clock)
34812524:	e3530000 	cmp	r3, #0
34812528:	0a000002 	beq	34812538 <sdhci_set_ios+0xd4>
		host->set_clock(host->index, div);
3481252c:	e5960020 	ldr	r0, [r6, #32]
34812530:	e1a01004 	mov	r1, r4
34812534:	e12fff33 	blx	r3

	clk = (div & SDHCI_DIV_MASK) << SDHCI_DIVIDER_SHIFT;
34812538:	e1a03c04 	lsl	r3, r4, #24
3481253c:	e1a03823 	lsr	r3, r3, #16
	clk |= ((div & SDHCI_DIV_HI_MASK) >> SDHCI_DIV_MASK_LEN)
34812540:	e3833001 	orr	r3, r3, #1
34812544:	e7e14454 	ubfx	r4, r4, #8, #2
		<< SDHCI_DIVIDER_HI_SHIFT;
	clk |= SDHCI_CLOCK_INT_EN;
	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
34812548:	e1834304 	orr	r4, r3, r4, lsl #6
3481254c:	e5963004 	ldr	r3, [r6, #4]
34812550:	e1c342bc 	strh	r4, [r3, #44]	; 0x2c

	/* Wait max 20 ms */
	timeout = 20;
34812554:	e3a04014 	mov	r4, #20
34812558:	ea000007 	b	3481257c <sdhci_set_ios+0x118>
	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
		& SDHCI_CLOCK_INT_STABLE)) {
		if (timeout == 0) {
3481255c:	e3540000 	cmp	r4, #0
34812560:	1a000002 	bne	34812570 <sdhci_set_ios+0x10c>
			printf("Internal clock never stabilised.\n");
34812564:	e59f00a4 	ldr	r0, [pc, #164]	; 34812610 <sdhci_set_ios+0x1ac>
34812568:	ebffdafd 	bl	34809164 <printf>
3481256c:	ea000009 	b	34812598 <sdhci_set_ios+0x134>
			return -1;
		}
		timeout--;
		udelay(1000);
34812570:	e3a00ffa 	mov	r0, #1000	; 0x3e8
		& SDHCI_CLOCK_INT_STABLE)) {
		if (timeout == 0) {
			printf("Internal clock never stabilised.\n");
			return -1;
		}
		timeout--;
34812574:	e2444001 	sub	r4, r4, #1
		udelay(1000);
34812578:	eb002700 	bl	3481c180 <udelay>
	return readl(host->ioaddr + reg);
}

static inline u16 sdhci_readw(struct sdhci_host *host, int reg)
{
	return readw(host->ioaddr + reg);
3481257c:	e5963004 	ldr	r3, [r6, #4]
34812580:	e1d332bc 	ldrh	r3, [r3, #44]	; 0x2c
	clk |= SDHCI_CLOCK_INT_EN;
	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);

	/* Wait max 20 ms */
	timeout = 20;
	while (!((clk = sdhci_readw(host, SDHCI_CLOCK_CONTROL))
34812584:	e3130002 	tst	r3, #2
34812588:	0afffff3 	beq	3481255c <sdhci_set_ios+0xf8>
		timeout--;
		udelay(1000);
	}

	clk |= SDHCI_CLOCK_CARD_EN;
	sdhci_writew(host, clk, SDHCI_CLOCK_CONTROL);
3481258c:	e3833004 	orr	r3, r3, #4
	writel(val, host->ioaddr + reg);
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
34812590:	e5962004 	ldr	r2, [r6, #4]
34812594:	e1c232bc 	strh	r3, [r2, #44]	; 0x2c
	return readw(host->ioaddr + reg);
}

static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
{
	return readb(host->ioaddr + reg);
34812598:	e5953004 	ldr	r3, [r5, #4]
3481259c:	e5d30028 	ldrb	r0, [r3, #40]	; 0x28
	if (mmc->clock != host->clock)
		sdhci_set_clock(mmc, mmc->clock);

	/* Set bus width */
	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
	if (mmc->bus_width == 8) {
348125a0:	e5972044 	ldr	r2, [r7, #68]	; 0x44

	if (mmc->clock != host->clock)
		sdhci_set_clock(mmc, mmc->clock);

	/* Set bus width */
	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
348125a4:	e1a03000 	mov	r3, r0
	if (mmc->bus_width == 8) {
348125a8:	e3520008 	cmp	r2, #8
348125ac:	e5951010 	ldr	r1, [r5, #16]
348125b0:	1a000004 	bne	348125c8 <sdhci_set_ios+0x164>
		ctrl &= ~SDHCI_CTRL_4BITBUS;
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
348125b4:	e20110ff 	and	r1, r1, #255	; 0xff
		sdhci_set_clock(mmc, mmc->clock);

	/* Set bus width */
	ctrl = sdhci_readb(host, SDHCI_HOST_CONTROL);
	if (mmc->bus_width == 8) {
		ctrl &= ~SDHCI_CTRL_4BITBUS;
348125b8:	e3c03002 	bic	r3, r0, #2
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
348125bc:	e3510001 	cmp	r1, #1
			ctrl |= SDHCI_CTRL_8BITBUS;
348125c0:	83833020 	orrhi	r3, r3, #32
348125c4:	ea000005 	b	348125e0 <sdhci_set_ios+0x17c>
	} else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
348125c8:	e20110ff 	and	r1, r1, #255	; 0xff
348125cc:	e3510001 	cmp	r1, #1
			ctrl &= ~SDHCI_CTRL_8BITBUS;
348125d0:	83c03020 	bichi	r3, r0, #32
		if (mmc->bus_width == 4)
348125d4:	e3520004 	cmp	r2, #4
			ctrl |= SDHCI_CTRL_4BITBUS;
348125d8:	03833002 	orreq	r3, r3, #2
		else
			ctrl &= ~SDHCI_CTRL_4BITBUS;
348125dc:	13c33002 	bicne	r3, r3, #2
	}

	if (mmc->clock > 26000000)
348125e0:	e5971048 	ldr	r1, [r7, #72]	; 0x48
348125e4:	e59f2028 	ldr	r2, [pc, #40]	; 34812614 <sdhci_set_ios+0x1b0>
348125e8:	e1510002 	cmp	r1, r2
		ctrl |= SDHCI_CTRL_HISPD;
	else
		ctrl &= ~SDHCI_CTRL_HISPD;

	if (host->quirks & SDHCI_QUIRK_NO_HISPD_BIT)
348125ec:	e5952008 	ldr	r2, [r5, #8]
		else
			ctrl &= ~SDHCI_CTRL_4BITBUS;
	}

	if (mmc->clock > 26000000)
		ctrl |= SDHCI_CTRL_HISPD;
348125f0:	83833004 	orrhi	r3, r3, #4
	else
		ctrl &= ~SDHCI_CTRL_HISPD;
348125f4:	93c33004 	bicls	r3, r3, #4

	if (host->quirks & SDHCI_QUIRK_NO_HISPD_BIT)
348125f8:	e3120008 	tst	r2, #8
		ctrl &= ~SDHCI_CTRL_HISPD;
348125fc:	13c33004 	bicne	r3, r3, #4

	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
34812600:	e6ef3073 	uxtb	r3, r3
	writew(val, host->ioaddr + reg);
}

static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
{
	writeb(val, host->ioaddr + reg);
34812604:	e5952004 	ldr	r2, [r5, #4]
34812608:	e5c23028 	strb	r3, [r2, #40]	; 0x28
}
3481260c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34812610:	348270f3 	.word	0x348270f3
34812614:	018cba80 	.word	0x018cba80

34812618 <sdhci_init>:

int sdhci_init(struct mmc *mmc)
{
34812618:	e92d4070 	push	{r4, r5, r6, lr}
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
3481261c:	e5904028 	ldr	r4, [r0, #40]	; 0x28

	sdhci_writeb(host, ctrl, SDHCI_HOST_CONTROL);
}

int sdhci_init(struct mmc *mmc)
{
34812620:	e1a05000 	mov	r5, r0
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;

	if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) && !aligned_buffer) {
34812624:	e5943008 	ldr	r3, [r4, #8]
34812628:	e3130001 	tst	r3, #1
3481262c:	0a00000d 	beq	34812668 <sdhci_init+0x50>
34812630:	e59f614c 	ldr	r6, [pc, #332]	; 34812784 <sdhci_init+0x16c>
34812634:	e5963000 	ldr	r3, [r6]
34812638:	e3530000 	cmp	r3, #0
3481263c:	1a000009 	bne	34812668 <sdhci_init+0x50>
		aligned_buffer = memalign(8, 512*1024);
34812640:	e3a00008 	mov	r0, #8
34812644:	e3a01702 	mov	r1, #524288	; 0x80000
34812648:	ebffde31 	bl	34809f14 <memalign>
		if (!aligned_buffer) {
3481264c:	e3500000 	cmp	r0, #0
int sdhci_init(struct mmc *mmc)
{
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;

	if ((host->quirks & SDHCI_QUIRK_32BIT_DMA_ADDR) && !aligned_buffer) {
		aligned_buffer = memalign(8, 512*1024);
34812650:	e5860000 	str	r0, [r6]
		if (!aligned_buffer) {
34812654:	1a000003 	bne	34812668 <sdhci_init+0x50>
			printf("Aligned buffer alloc failed!!!");
34812658:	e59f0128 	ldr	r0, [pc, #296]	; 34812788 <sdhci_init+0x170>
3481265c:	ebffdac0 	bl	34809164 <printf>
			return -1;
34812660:	e3e00000 	mvn	r0, #0
34812664:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
	}

	sdhci_set_power(host, fls(mmc->voltages) - 1);
34812668:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
 */
static inline int generic_fls(int x)
{
	int r = 32;

	if (!x)
3481266c:	e3530000 	cmp	r3, #0
		return 0;
34812670:	01a02003 	moveq	r2, r3
 */
static inline int generic_fls(int x)
{
	int r = 32;

	if (!x)
34812674:	0a000010 	beq	348126bc <sdhci_init+0xa4>
		return 0;
	if (!(x & 0xffff0000u)) {
34812678:	e1a02823 	lsr	r2, r3, #16
3481267c:	e1a02802 	lsl	r2, r2, #16
34812680:	e3520000 	cmp	r2, #0
		x <<= 16;
34812684:	01a03803 	lsleq	r3, r3, #16
		r -= 16;
34812688:	02822010 	addeq	r2, r2, #16
 * This is defined the same way as ffs.
 * Note fls(0) = 0, fls(1) = 1, fls(0x80000000) = 32.
 */
static inline int generic_fls(int x)
{
	int r = 32;
3481268c:	13a02020 	movne	r2, #32
		return 0;
	if (!(x & 0xffff0000u)) {
		x <<= 16;
		r -= 16;
	}
	if (!(x & 0xff000000u)) {
34812690:	e31304ff 	tst	r3, #-16777216	; 0xff000000
		x <<= 8;
34812694:	01a03403 	lsleq	r3, r3, #8
		r -= 8;
34812698:	02422008 	subeq	r2, r2, #8
	}
	if (!(x & 0xf0000000u)) {
3481269c:	e313020f 	tst	r3, #-268435456	; 0xf0000000
		x <<= 4;
348126a0:	01a03203 	lsleq	r3, r3, #4
		r -= 4;
348126a4:	02422004 	subeq	r2, r2, #4
	}
	if (!(x & 0xc0000000u)) {
348126a8:	e3130103 	tst	r3, #-1073741824	; 0xc0000000
		x <<= 2;
348126ac:	01a03103 	lsleq	r3, r3, #2
		r -= 2;
348126b0:	02422002 	subeq	r2, r2, #2
	}
	if (!(x & 0x80000000u)) {
348126b4:	e3530000 	cmp	r3, #0
		x <<= 1;
		r -= 1;
348126b8:	a2422001 	subge	r2, r2, #1
348126bc:	e2422001 	sub	r2, r2, #1
348126c0:	e6ff2072 	uxth	r2, r2

static void sdhci_set_power(struct sdhci_host *host, unsigned short power)
{
	u8 pwr = 0;

	if (power != (unsigned short)-1) {
348126c4:	e30f3fff 	movw	r3, #65535	; 0xffff
348126c8:	e1520003 	cmp	r2, r3
348126cc:	0a00000f 	beq	34812710 <sdhci_init+0xf8>
		switch (1 << power) {
348126d0:	e3a03001 	mov	r3, #1
348126d4:	e1a02213 	lsl	r2, r3, r2
348126d8:	e3520701 	cmp	r2, #262144	; 0x40000
348126dc:	0a000023 	beq	34812770 <sdhci_init+0x158>
348126e0:	ca000004 	bgt	348126f8 <sdhci_init+0xe0>
348126e4:	e3520080 	cmp	r2, #128	; 0x80
348126e8:	0a00001e 	beq	34812768 <sdhci_init+0x150>
348126ec:	e3520802 	cmp	r2, #131072	; 0x20000
348126f0:	1a000006 	bne	34812710 <sdhci_init+0xf8>
348126f4:	ea00001d 	b	34812770 <sdhci_init+0x158>
348126f8:	e3520601 	cmp	r2, #1048576	; 0x100000
348126fc:	0a000001 	beq	34812708 <sdhci_init+0xf0>
34812700:	e3520602 	cmp	r2, #2097152	; 0x200000
34812704:	1a000001 	bne	34812710 <sdhci_init+0xf8>
		case MMC_VDD_30_31:
			pwr = SDHCI_POWER_300;
			break;
		case MMC_VDD_32_33:
		case MMC_VDD_33_34:
			pwr = SDHCI_POWER_330;
34812708:	e3a0300e 	mov	r3, #14
3481270c:	ea000018 	b	34812774 <sdhci_init+0x15c>
34812710:	e5943004 	ldr	r3, [r4, #4]
34812714:	e3a02000 	mov	r2, #0
34812718:	e5c32029 	strb	r2, [r3, #41]	; 0x29
		}
	}

	sdhci_set_power(host, fls(mmc->voltages) - 1);

	if (host->quirks & SDHCI_QUIRK_NO_CD) {
3481271c:	e5943008 	ldr	r3, [r4, #8]
34812720:	e3130020 	tst	r3, #32
34812724:	0a000008 	beq	3481274c <sdhci_init+0x134>

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34812728:	e5943004 	ldr	r3, [r4, #4]
3481272c:	e3a020c0 	mov	r2, #192	; 0xc0
34812730:	e5832028 	str	r2, [r3, #40]	; 0x28
34812734:	ea000000 	b	3481273c <sdhci_init+0x124>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34812738:	e5943004 	ldr	r3, [r4, #4]
3481273c:	e5933024 	ldr	r3, [r3, #36]	; 0x24
		sdhci_writel(host, SDHCI_CTRL_CD_TEST_INS | SDHCI_CTRL_CD_TEST,
			SDHCI_HOST_CONTROL);

		status = sdhci_readl(host, SDHCI_PRESENT_STATE);
		while ((!(status & SDHCI_CARD_PRESENT)) ||
		    (!(status & SDHCI_CARD_STATE_STABLE)) ||
34812740:	e2033807 	and	r3, r3, #458752	; 0x70000

		sdhci_writel(host, SDHCI_CTRL_CD_TEST_INS | SDHCI_CTRL_CD_TEST,
			SDHCI_HOST_CONTROL);

		status = sdhci_readl(host, SDHCI_PRESENT_STATE);
		while ((!(status & SDHCI_CARD_PRESENT)) ||
34812744:	e3530807 	cmp	r3, #458752	; 0x70000
34812748:	1afffffa 	bne	34812738 <sdhci_init+0x120>

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
3481274c:	e5942004 	ldr	r2, [r4, #4]
34812750:	e3e03000 	mvn	r3, #0
34812754:	e5823034 	str	r3, [r2, #52]	; 0x34
34812758:	e5942004 	ldr	r2, [r4, #4]

	/* Eable all state */
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_ENABLE);
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_SIGNAL_ENABLE);

	return 0;
3481275c:	e3a00000 	mov	r0, #0
34812760:	e5823038 	str	r3, [r2, #56]	; 0x38
}
34812764:	e8bd8070 	pop	{r4, r5, r6, pc}
	u8 pwr = 0;

	if (power != (unsigned short)-1) {
		switch (1 << power) {
		case MMC_VDD_165_195:
			pwr = SDHCI_POWER_180;
34812768:	e3a0300a 	mov	r3, #10
3481276c:	ea000000 	b	34812774 <sdhci_init+0x15c>
			break;
		case MMC_VDD_29_30:
		case MMC_VDD_30_31:
			pwr = SDHCI_POWER_300;
34812770:	e3a0300c 	mov	r3, #12
	if (pwr == 0) {
		sdhci_writeb(host, 0, SDHCI_POWER_CONTROL);
		return;
	}

	pwr |= SDHCI_POWER_ON;
34812774:	e3833001 	orr	r3, r3, #1
	writew(val, host->ioaddr + reg);
}

static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
{
	writeb(val, host->ioaddr + reg);
34812778:	e5942004 	ldr	r2, [r4, #4]
3481277c:	e5c23029 	strb	r3, [r2, #41]	; 0x29
34812780:	eaffffe5 	b	3481271c <sdhci_init+0x104>
34812784:	3482ba30 	.word	0x3482ba30
34812788:	34827115 	.word	0x34827115

3481278c <sdhci_reset.clone.9>:
#include <mmc.h>
#include <sdhci.h>

void *aligned_buffer;

static void sdhci_reset(struct sdhci_host *host, u8 mask)
3481278c:	e92d4070 	push	{r4, r5, r6, lr}
34812790:	e1a04000 	mov	r4, r0
34812794:	e1a05001 	mov	r5, r1
34812798:	e5903000 	ldr	r3, [r0]
{
	unsigned long timeout;

	/* Wait max 100 ms */
	timeout = 100;
3481279c:	e3a06064 	mov	r6, #100	; 0x64
348127a0:	e5c3102f 	strb	r1, [r3, #47]	; 0x2f
348127a4:	ea000008 	b	348127cc <sdhci_reset.clone.9+0x40>
	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
		if (timeout == 0) {
348127a8:	e3560000 	cmp	r6, #0
348127ac:	1a000003 	bne	348127c0 <sdhci_reset.clone.9+0x34>
			printf("Reset 0x%x never completed.\n", (int)mask);
348127b0:	e59f0028 	ldr	r0, [pc, #40]	; 348127e0 <sdhci_reset.clone.9+0x54>
348127b4:	e1a01005 	mov	r1, r5
			return;
		}
		timeout--;
		udelay(1000);
	}
}
348127b8:	e8bd4070 	pop	{r4, r5, r6, lr}
	/* Wait max 100 ms */
	timeout = 100;
	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
		if (timeout == 0) {
			printf("Reset 0x%x never completed.\n", (int)mask);
348127bc:	eaffda68 	b	34809164 <printf>
			return;
		}
		timeout--;
		udelay(1000);
348127c0:	e3a00ffa 	mov	r0, #1000	; 0x3e8
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
		if (timeout == 0) {
			printf("Reset 0x%x never completed.\n", (int)mask);
			return;
		}
		timeout--;
348127c4:	e2466001 	sub	r6, r6, #1
		udelay(1000);
348127c8:	eb00266c 	bl	3481c180 <udelay>
	return readw(host->ioaddr + reg);
}

static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
{
	return readb(host->ioaddr + reg);
348127cc:	e5943000 	ldr	r3, [r4]
348127d0:	e5d3302f 	ldrb	r3, [r3, #47]	; 0x2f
	unsigned long timeout;

	/* Wait max 100 ms */
	timeout = 100;
	sdhci_writeb(host, mask, SDHCI_SOFTWARE_RESET);
	while (sdhci_readb(host, SDHCI_SOFTWARE_RESET) & mask) {
348127d4:	e1130005 	tst	r3, r5
348127d8:	1afffff2 	bne	348127a8 <sdhci_reset.clone.9+0x1c>
			return;
		}
		timeout--;
		udelay(1000);
	}
}
348127dc:	e8bd8070 	pop	{r4, r5, r6, pc}
348127e0:	34827134 	.word	0x34827134

348127e4 <sdhci_send_command>:
	return 0;
}

int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
		       struct mmc_data *data)
{
348127e4:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
348127e8:	e5904028 	ldr	r4, [r0, #40]	; 0x28
	return 0;
}

int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
		       struct mmc_data *data)
{
348127ec:	e1a05001 	mov	r5, r1
348127f0:	e1a06002 	mov	r6, r2
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
	mask = SDHCI_CMD_INHIBIT | SDHCI_DATA_INHIBIT;

	/* We shouldn't wait for data inihibit for stop commands, even
	   though they might use busy signaling */
	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
348127f4:	e1d1a0b0 	ldrh	sl, [r1]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
348127f8:	e5943004 	ldr	r3, [r4, #4]

	/* Wait max 10 ms */
	timeout = 10;

	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
	mask = SDHCI_CMD_INHIBIT | SDHCI_DATA_INHIBIT;
348127fc:	e35a000c 	cmp	sl, #12
34812800:	e3e02000 	mvn	r2, #0
34812804:	e5832030 	str	r2, [r3, #48]	; 0x30
34812808:	03a0a001 	moveq	sl, #1
3481280c:	13a0a003 	movne	sl, #3
34812810:	e3a0700a 	mov	r7, #10
34812814:	ea000008 	b	3481283c <sdhci_send_command+0x58>
	   though they might use busy signaling */
	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
		mask &= ~SDHCI_DATA_INHIBIT;

	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
		if (timeout == 0) {
34812818:	e3570000 	cmp	r7, #0
3481281c:	1a000003 	bne	34812830 <sdhci_send_command+0x4c>
			printf("Controller never released inhibit bit(s).\n");
34812820:	e59f0300 	ldr	r0, [pc, #768]	; 34812b28 <sdhci_send_command+0x344>
34812824:	ebffda4e 	bl	34809164 <printf>
			return COMM_ERR;
34812828:	e3e00011 	mvn	r0, #17
3481282c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		}
		timeout--;
		udelay(1000);
34812830:	e3a00ffa 	mov	r0, #1000	; 0x3e8
	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
		if (timeout == 0) {
			printf("Controller never released inhibit bit(s).\n");
			return COMM_ERR;
		}
		timeout--;
34812834:	e2477001 	sub	r7, r7, #1
		udelay(1000);
34812838:	eb002650 	bl	3481c180 <udelay>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
3481283c:	e5943004 	ldr	r3, [r4, #4]
34812840:	e5933024 	ldr	r3, [r3, #36]	; 0x24
	/* We shouldn't wait for data inihibit for stop commands, even
	   though they might use busy signaling */
	if (cmd->cmdidx == MMC_CMD_STOP_TRANSMISSION)
		mask &= ~SDHCI_DATA_INHIBIT;

	while (sdhci_readl(host, SDHCI_PRESENT_STATE) & mask) {
34812844:	e11a0003 	tst	sl, r3
34812848:	1afffff2 	bne	34812818 <sdhci_send_command+0x34>
		timeout--;
		udelay(1000);
	}

	mask = SDHCI_INT_RESPONSE;
	if (!(cmd->resp_type & MMC_RSP_PRESENT))
3481284c:	e5951004 	ldr	r1, [r5, #4]
34812850:	e2113001 	ands	r3, r1, #1
34812854:	0a000008 	beq	3481287c <sdhci_send_command+0x98>
		flags = SDHCI_CMD_RESP_NONE;
	else if (cmd->resp_type & MMC_RSP_136)
34812858:	e3110002 	tst	r1, #2
		flags = SDHCI_CMD_RESP_LONG;
3481285c:	13a03001 	movne	r3, #1
	}

	mask = SDHCI_INT_RESPONSE;
	if (!(cmd->resp_type & MMC_RSP_PRESENT))
		flags = SDHCI_CMD_RESP_NONE;
	else if (cmd->resp_type & MMC_RSP_136)
34812860:	1a000002 	bne	34812870 <sdhci_send_command+0x8c>
		flags = SDHCI_CMD_RESP_LONG;
	else if (cmd->resp_type & MMC_RSP_BUSY) {
34812864:	e3110008 	tst	r1, #8
		flags = SDHCI_CMD_RESP_SHORT_BUSY;
34812868:	13a03003 	movne	r3, #3
	mask = SDHCI_INT_RESPONSE;
	if (!(cmd->resp_type & MMC_RSP_PRESENT))
		flags = SDHCI_CMD_RESP_NONE;
	else if (cmd->resp_type & MMC_RSP_136)
		flags = SDHCI_CMD_RESP_LONG;
	else if (cmd->resp_type & MMC_RSP_BUSY) {
3481286c:	0a000001 	beq	34812878 <sdhci_send_command+0x94>
		}
		timeout--;
		udelay(1000);
	}

	mask = SDHCI_INT_RESPONSE;
34812870:	e1a02003 	mov	r2, r3
34812874:	ea000001 	b	34812880 <sdhci_send_command+0x9c>
		flags = SDHCI_CMD_RESP_LONG;
	else if (cmd->resp_type & MMC_RSP_BUSY) {
		flags = SDHCI_CMD_RESP_SHORT_BUSY;
		mask |= SDHCI_INT_DATA_END;
	} else
		flags = SDHCI_CMD_RESP_SHORT;
34812878:	e3a03002 	mov	r3, #2
		}
		timeout--;
		udelay(1000);
	}

	mask = SDHCI_INT_RESPONSE;
3481287c:	e3a02001 	mov	r2, #1
		flags = SDHCI_CMD_RESP_SHORT_BUSY;
		mask |= SDHCI_INT_DATA_END;
	} else
		flags = SDHCI_CMD_RESP_SHORT;

	if (cmd->resp_type & MMC_RSP_CRC)
34812880:	e3110004 	tst	r1, #4
		flags |= SDHCI_CMD_CRC;
34812884:	13833008 	orrne	r3, r3, #8
	if (cmd->resp_type & MMC_RSP_OPCODE)
34812888:	e3110010 	tst	r1, #16
		flags |= SDHCI_CMD_INDEX;
3481288c:	13833010 	orrne	r3, r3, #16
	if (data)
34812890:	e3560000 	cmp	r6, #0
34812894:	0a000014 	beq	348128ec <sdhci_send_command+0x108>
		flags |= SDHCI_CMD_DATA;
34812898:	e3833020 	orr	r3, r3, #32
	writew(val, host->ioaddr + reg);
}

static inline void sdhci_writeb(struct sdhci_host *host, u8 val, int reg)
{
	writeb(val, host->ioaddr + reg);
3481289c:	e5941004 	ldr	r1, [r4, #4]
348128a0:	e3a0000e 	mov	r0, #14
348128a4:	e5c1002e 	strb	r0, [r1, #46]	; 0x2e
	/*Set Transfer mode regarding to data flag*/
	if (data != 0) {
		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
		mode = SDHCI_TRNS_BLK_CNT_EN;
		trans_bytes = data->blocks * data->blocksize;
		if (data->blocks > 1)
348128a8:	e9961003 	ldmib	r6, {r0, r1, ip}
		flags |= SDHCI_CMD_DATA;

	/*Set Transfer mode regarding to data flag*/
	if (data != 0) {
		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
		mode = SDHCI_TRNS_BLK_CNT_EN;
348128ac:	e3510001 	cmp	r1, #1
		}

		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		mode |= SDHCI_TRNS_DMA;
#endif
		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
348128b0:	e1a0ca0c 	lsl	ip, ip, #20
		flags |= SDHCI_CMD_DATA;

	/*Set Transfer mode regarding to data flag*/
	if (data != 0) {
		sdhci_writeb(host, 0xe, SDHCI_TIMEOUT_CONTROL);
		mode = SDHCI_TRNS_BLK_CNT_EN;
348128b4:	83a01022 	movhi	r1, #34	; 0x22
348128b8:	93a01002 	movls	r1, #2
		}

		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		mode |= SDHCI_TRNS_DMA;
#endif
		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
348128bc:	e1a0ca2c 	lsr	ip, ip, #20
		mode = SDHCI_TRNS_BLK_CNT_EN;
		trans_bytes = data->blocks * data->blocksize;
		if (data->blocks > 1)
			mode |= SDHCI_TRNS_MULTI;

		if (data->flags == MMC_DATA_READ)
348128c0:	e3500001 	cmp	r0, #1
			mode |= SDHCI_TRNS_READ;
348128c4:	03811010 	orreq	r1, r1, #16
		}

		sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		mode |= SDHCI_TRNS_DMA;
#endif
		sdhci_writew(host, SDHCI_MAKE_BLKSZ(SDHCI_DEFAULT_BOUNDARY_ARG,
348128c8:	e38cca07 	orr	ip, ip, #28672	; 0x7000
	writel(val, host->ioaddr + reg);
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
348128cc:	e5940004 	ldr	r0, [r4, #4]
348128d0:	e1c0c0b4 	strh	ip, [r0, #4]
				data->blocksize),
				SDHCI_BLOCK_SIZE);
		sdhci_writew(host, data->blocks, SDHCI_BLOCK_COUNT);
348128d4:	e1d6c0b8 	ldrh	ip, [r6, #8]
348128d8:	e5940004 	ldr	r0, [r4, #4]
		sdhci_writew(host, mode, SDHCI_TRANSFER_MODE);
348128dc:	e6ff1071 	uxth	r1, r1
348128e0:	e1c0c0b6 	strh	ip, [r0, #6]
348128e4:	e5940004 	ldr	r0, [r4, #4]
348128e8:	e1c010bc 	strh	r1, [r0, #12]
	}

	sdhci_writel(host, cmd->cmdarg, SDHCI_ARGUMENT);
348128ec:	e5950008 	ldr	r0, [r5, #8]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
348128f0:	e5941004 	ldr	r1, [r4, #4]
#ifdef CONFIG_MMC_SDMA
	flush_cache(start_addr, trans_bytes);
#endif
	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->cmdidx, flags), SDHCI_COMMAND);
348128f4:	e20330ff 	and	r3, r3, #255	; 0xff
348128f8:	e5810008 	str	r0, [r1, #8]
348128fc:	e1d510b0 	ldrh	r1, [r5]
34812900:	e1833401 	orr	r3, r3, r1, lsl #8
34812904:	e6ff3073 	uxth	r3, r3
}

static inline void sdhci_writew(struct sdhci_host *host, u16 val, int reg)
{
	writew(val, host->ioaddr + reg);
34812908:	e5941004 	ldr	r1, [r4, #4]
3481290c:	e1c130be 	strh	r3, [r1, #14]
	unsigned int stat = 0;
	int ret = 0;
	int trans_bytes = 0, is_aligned = 1;
	u32 mask, flags, mode;
	unsigned int timeout, start_addr = 0;
	unsigned int retry = 10000;
34812910:	e3023710 	movw	r3, #10000	; 0x2710
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34812914:	e5941004 	ldr	r1, [r4, #4]
34812918:	e5911030 	ldr	r1, [r1, #48]	; 0x30
	flush_cache(start_addr, trans_bytes);
#endif
	sdhci_writew(host, SDHCI_MAKE_CMD(cmd->cmdidx, flags), SDHCI_COMMAND);
	do {
		stat = sdhci_readl(host, SDHCI_INT_STATUS);
		if (stat & SDHCI_INT_ERROR)
3481291c:	e3110902 	tst	r1, #32768	; 0x8000
34812920:	1a000005 	bne	3481293c <sdhci_send_command+0x158>
			break;
		if (--retry == 0)
34812924:	e2533001 	subs	r3, r3, #1
34812928:	0a000005 	beq	34812944 <sdhci_send_command+0x160>
			break;
	} while ((stat & mask) != mask);
3481292c:	e0020001 	and	r0, r2, r1
34812930:	e1500002 	cmp	r0, r2
34812934:	1afffff6 	bne	34812914 <sdhci_send_command+0x130>
34812938:	ea000008 	b	34812960 <sdhci_send_command+0x17c>

	if (retry == 0) {
3481293c:	e3530000 	cmp	r3, #0
34812940:	1a000006 	bne	34812960 <sdhci_send_command+0x17c>
		if (host->quirks & SDHCI_QUIRK_BROKEN_R1B)
34812944:	e5943008 	ldr	r3, [r4, #8]
34812948:	e3130004 	tst	r3, #4
3481294c:	1a000073 	bne	34812b20 <sdhci_send_command+0x33c>
			return 0;
		else {
			printf("Timeout for status update!\n");
34812950:	e59f01d4 	ldr	r0, [pc, #468]	; 34812b2c <sdhci_send_command+0x348>
34812954:	ebffda02 	bl	34809164 <printf>
			return TIMEOUT;
34812958:	e3e00012 	mvn	r0, #18
3481295c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		}
	}

	if ((stat & (SDHCI_INT_ERROR | mask)) == mask) {
34812960:	e3823902 	orr	r3, r2, #32768	; 0x8000
34812964:	e0011003 	and	r1, r1, r3
34812968:	e1510002 	cmp	r1, r2
		sdhci_cmd_done(host, cmd);
		sdhci_writel(host, mask, SDHCI_INT_STATUS);
	} else
		ret = -1;
3481296c:	13e00000 	mvnne	r0, #0
			printf("Timeout for status update!\n");
			return TIMEOUT;
		}
	}

	if ((stat & (SDHCI_INT_ERROR | mask)) == mask) {
34812970:	1a00001b 	bne	348129e4 <sdhci_send_command+0x200>
}

static void sdhci_cmd_done(struct sdhci_host *host, struct mmc_cmd *cmd)
{
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
34812974:	e5953004 	ldr	r3, [r5, #4]
34812978:	e3130002 	tst	r3, #2
3481297c:	0a000012 	beq	348129cc <sdhci_send_command+0x1e8>
		}
	} while (!(stat & SDHCI_INT_DATA_END));
	return 0;
}

int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
34812980:	e285500c 	add	r5, r5, #12
34812984:	e3a0201c 	mov	r2, #28
34812988:	e3a03000 	mov	r3, #0
3481298c:	e5940004 	ldr	r0, [r4, #4]
34812990:	e7900002 	ldr	r0, [r0, r2]
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
		/* CRC is stripped so we need to do some shifting. */
		for (i = 0; i < 4; i++) {
			cmd->response[i] = sdhci_readl(host,
					SDHCI_RESPONSE + (3-i)*4) << 8;
34812994:	e1a00400 	lsl	r0, r0, #8
			if (i != 3)
34812998:	e3530003 	cmp	r3, #3
{
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
		/* CRC is stripped so we need to do some shifting. */
		for (i = 0; i < 4; i++) {
			cmd->response[i] = sdhci_readl(host,
3481299c:	e4850004 	str	r0, [r5], #4
					SDHCI_RESPONSE + (3-i)*4) << 8;
			if (i != 3)
348129a0:	0a000004 	beq	348129b8 <sdhci_send_command+0x1d4>
	return readw(host->ioaddr + reg);
}

static inline u8 sdhci_readb(struct sdhci_host *host, int reg)
{
	return readb(host->ioaddr + reg);
348129a4:	e5947004 	ldr	r7, [r4, #4]
348129a8:	e242c001 	sub	ip, r2, #1
348129ac:	e7d7c00c 	ldrb	ip, [r7, ip]
				cmd->response[i] |= sdhci_readb(host,
348129b0:	e18c0000 	orr	r0, ip, r0
348129b4:	e5050004 	str	r0, [r5, #-4]
static void sdhci_cmd_done(struct sdhci_host *host, struct mmc_cmd *cmd)
{
	int i;
	if (cmd->resp_type & MMC_RSP_136) {
		/* CRC is stripped so we need to do some shifting. */
		for (i = 0; i < 4; i++) {
348129b8:	e2833001 	add	r3, r3, #1
348129bc:	e3530004 	cmp	r3, #4
348129c0:	e2422004 	sub	r2, r2, #4
348129c4:	1afffff0 	bne	3481298c <sdhci_send_command+0x1a8>
348129c8:	ea000002 	b	348129d8 <sdhci_send_command+0x1f4>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
348129cc:	e5943004 	ldr	r3, [r4, #4]
348129d0:	e5933010 	ldr	r3, [r3, #16]
			if (i != 3)
				cmd->response[i] |= sdhci_readb(host,
						SDHCI_RESPONSE + (3-i)*4-1);
		}
	} else {
		cmd->response[0] = sdhci_readl(host, SDHCI_RESPONSE);
348129d4:	e585300c 	str	r3, [r5, #12]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
348129d8:	e5943004 	ldr	r3, [r4, #4]
int sdhci_send_command(struct mmc *mmc, struct mmc_cmd *cmd,
		       struct mmc_data *data)
{
	struct sdhci_host *host = (struct sdhci_host *)mmc->priv;
	unsigned int stat = 0;
	int ret = 0;
348129dc:	e3a00000 	mov	r0, #0
348129e0:	e5831030 	str	r1, [r3, #48]	; 0x30
		sdhci_cmd_done(host, cmd);
		sdhci_writel(host, mask, SDHCI_INT_STATUS);
	} else
		ret = -1;

	if (!ret && data)
348129e4:	e2803001 	add	r3, r0, #1
348129e8:	e3560000 	cmp	r6, #0
348129ec:	03a03000 	moveq	r3, #0
348129f0:	12033001 	andne	r3, r3, #1
348129f4:	e3530000 	cmp	r3, #0
348129f8:	0a000036 	beq	34812ad8 <sdhci_send_command+0x2f4>

	sdhci_reset(host, SDHCI_RESET_ALL);
	mmc_register(mmc);

	return 0;
}
348129fc:	e2847004 	add	r7, r4, #4
}

static int sdhci_transfer_data(struct sdhci_host *host, struct mmc_data *data,
				unsigned int start_addr)
{
	unsigned int stat, rdy, mask, timeout, block = 0;
34812a00:	e3a09000 	mov	r9, #0

	timeout = 10000;
34812a04:	e302a710 	movw	sl, #10000	; 0x2710
34812a08:	e3a0b030 	mov	fp, #48	; 0x30
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34812a0c:	e5973000 	ldr	r3, [r7]
34812a10:	e5935030 	ldr	r5, [r3, #48]	; 0x30
	rdy = SDHCI_INT_SPACE_AVAIL | SDHCI_INT_DATA_AVAIL;
	mask = SDHCI_DATA_AVAILABLE | SDHCI_SPACE_AVAILABLE;
	do {
		stat = sdhci_readl(host, SDHCI_INT_STATUS);
		if (stat & SDHCI_INT_ERROR) {
34812a14:	e2153902 	ands	r3, r5, #32768	; 0x8000
34812a18:	0a000003 	beq	34812a2c <sdhci_send_command+0x248>
			printf("Error detected in status(0x%X)!\n", stat);
34812a1c:	e1a01005 	mov	r1, r5
34812a20:	e59f0108 	ldr	r0, [pc, #264]	; 34812b30 <sdhci_send_command+0x34c>
34812a24:	ebffd9ce 	bl	34809164 <printf>
34812a28:	ea000025 	b	34812ac4 <sdhci_send_command+0x2e0>
			return -1;
		}
		if (stat & rdy) {
34812a2c:	e3150030 	tst	r5, #48	; 0x30
34812a30:	0a00001b 	beq	34812aa4 <sdhci_send_command+0x2c0>
34812a34:	e5972000 	ldr	r2, [r7]
34812a38:	e5922024 	ldr	r2, [r2, #36]	; 0x24
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
34812a3c:	e3120b03 	tst	r2, #3072	; 0xc00
34812a40:	0a000021 	beq	34812acc <sdhci_send_command+0x2e8>

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34812a44:	e5972000 	ldr	r2, [r7]
34812a48:	e582b030 	str	fp, [r2, #48]	; 0x30
34812a4c:	ea00000a 	b	34812a7c <sdhci_send_command+0x298>
{
	int i;
	char *offs;
	for (i = 0; i < data->blocksize; i += 4) {
		offs = data->dest + i;
		if (data->flags == MMC_DATA_READ)
34812a50:	e5961004 	ldr	r1, [r6, #4]
34812a54:	e3510001 	cmp	r1, #1
34812a58:	1a000003 	bne	34812a6c <sdhci_send_command+0x288>
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34812a5c:	e5971000 	ldr	r1, [r7]
34812a60:	e5911020 	ldr	r1, [r1, #32]
			*(u32 *)offs = sdhci_readl(host, SDHCI_BUFFER);
34812a64:	e7821003 	str	r1, [r2, r3]
34812a68:	ea000002 	b	34812a78 <sdhci_send_command+0x294>
		else
			sdhci_writel(host, *(u32 *)offs, SDHCI_BUFFER);
34812a6c:	e7921003 	ldr	r1, [r2, r3]

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34812a70:	e5972000 	ldr	r2, [r7]
34812a74:	e5821020 	str	r1, [r2, #32]

static void sdhci_transfer_pio(struct sdhci_host *host, struct mmc_data *data)
{
	int i;
	char *offs;
	for (i = 0; i < data->blocksize; i += 4) {
34812a78:	e2833004 	add	r3, r3, #4
34812a7c:	e596100c 	ldr	r1, [r6, #12]
34812a80:	e5962000 	ldr	r2, [r6]
34812a84:	e1530001 	cmp	r3, r1
34812a88:	3afffff0 	bcc	34812a50 <sdhci_send_command+0x26c>
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
				continue;
			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
			sdhci_transfer_pio(host, data);
			data->dest += data->blocksize;
			if (++block >= data->blocks)
34812a8c:	e5963008 	ldr	r3, [r6, #8]
34812a90:	e2899001 	add	r9, r9, #1
		if (stat & rdy) {
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
				continue;
			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
			sdhci_transfer_pio(host, data);
			data->dest += data->blocksize;
34812a94:	e0822001 	add	r2, r2, r1
			if (++block >= data->blocks)
34812a98:	e1590003 	cmp	r9, r3
		if (stat & rdy) {
			if (!(sdhci_readl(host, SDHCI_PRESENT_STATE) & mask))
				continue;
			sdhci_writel(host, rdy, SDHCI_INT_STATUS);
			sdhci_transfer_pio(host, data);
			data->dest += data->blocksize;
34812a9c:	e5862000 	str	r2, [r6]
			if (++block >= data->blocks)
34812aa0:	2a00000b 	bcs	34812ad4 <sdhci_send_command+0x2f0>
			start_addr &= ~(SDHCI_DEFAULT_BOUNDARY_SIZE - 1);
			start_addr += SDHCI_DEFAULT_BOUNDARY_SIZE;
			sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		}
#endif
		if (timeout-- > 0)
34812aa4:	e35a0000 	cmp	sl, #0
34812aa8:	0a000003 	beq	34812abc <sdhci_send_command+0x2d8>
			udelay(10);
34812aac:	e3a0000a 	mov	r0, #10
			start_addr &= ~(SDHCI_DEFAULT_BOUNDARY_SIZE - 1);
			start_addr += SDHCI_DEFAULT_BOUNDARY_SIZE;
			sdhci_writel(host, start_addr, SDHCI_DMA_ADDRESS);
		}
#endif
		if (timeout-- > 0)
34812ab0:	e24aa001 	sub	sl, sl, #1
			udelay(10);
34812ab4:	eb0025b1 	bl	3481c180 <udelay>
34812ab8:	ea000003 	b	34812acc <sdhci_send_command+0x2e8>
		else {
			printf("Transfer data timeout\n");
34812abc:	e59f0070 	ldr	r0, [pc, #112]	; 34812b34 <sdhci_send_command+0x350>
34812ac0:	ebffd9a7 	bl	34809164 <printf>
			return -1;
34812ac4:	e3e00000 	mvn	r0, #0
34812ac8:	ea000002 	b	34812ad8 <sdhci_send_command+0x2f4>
		}
	} while (!(stat & SDHCI_INT_DATA_END));
34812acc:	e3150002 	tst	r5, #2
34812ad0:	0affffcd 	beq	34812a0c <sdhci_send_command+0x228>
	return 0;
34812ad4:	e3a00000 	mov	r0, #0
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34812ad8:	e5943004 	ldr	r3, [r4, #4]
34812adc:	e5935030 	ldr	r5, [r3, #48]	; 0x30

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34812ae0:	e5943004 	ldr	r3, [r4, #4]
34812ae4:	e3e02000 	mvn	r2, #0
	if (!ret && data)
		ret = sdhci_transfer_data(host, data, start_addr);

	stat = sdhci_readl(host, SDHCI_INT_STATUS);
	sdhci_writel(host, SDHCI_INT_ALL_MASK, SDHCI_INT_STATUS);
	if (!ret) {
34812ae8:	e3500000 	cmp	r0, #0
34812aec:	e5832030 	str	r2, [r3, #48]	; 0x30
34812af0:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}

	sdhci_reset(host, SDHCI_RESET_ALL);
	mmc_register(mmc);

	return 0;
}
34812af4:	e2844004 	add	r4, r4, #4
				!is_aligned && (data->flags == MMC_DATA_READ))
			memcpy(data->dest, aligned_buffer, trans_bytes);
		return 0;
	}

	sdhci_reset(host, SDHCI_RESET_CMD);
34812af8:	e1a00004 	mov	r0, r4
34812afc:	e3a01002 	mov	r1, #2
34812b00:	ebffff21 	bl	3481278c <sdhci_reset.clone.9>
	sdhci_reset(host, SDHCI_RESET_DATA);
34812b04:	e1a00004 	mov	r0, r4
34812b08:	e3a01004 	mov	r1, #4
34812b0c:	ebffff1e 	bl	3481278c <sdhci_reset.clone.9>
	if (stat & SDHCI_INT_TIMEOUT)
		return TIMEOUT;
34812b10:	e3150801 	tst	r5, #65536	; 0x10000
34812b14:	03e00011 	mvneq	r0, #17
34812b18:	13e00012 	mvnne	r0, #18
34812b1c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
			break;
	} while ((stat & mask) != mask);

	if (retry == 0) {
		if (host->quirks & SDHCI_QUIRK_BROKEN_R1B)
			return 0;
34812b20:	e3a00000 	mov	r0, #0
	sdhci_reset(host, SDHCI_RESET_DATA);
	if (stat & SDHCI_INT_TIMEOUT)
		return TIMEOUT;
	else
		return COMM_ERR;
}
34812b24:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34812b28:	34827151 	.word	0x34827151
34812b2c:	3482717c 	.word	0x3482717c
34812b30:	34827198 	.word	0x34827198
34812b34:	348271b9 	.word	0x348271b9

34812b38 <add_sdhci>:

	return 0;
}

int add_sdhci(struct sdhci_host *host, u32 max_clk, u32 min_clk)
{
34812b38:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
34812b3c:	e1a05000 	mov	r5, r0
	struct mmc *mmc;
	unsigned int caps;

	mmc = malloc(sizeof(struct mmc));
34812b40:	e3a00f4a 	mov	r0, #296	; 0x128

	return 0;
}

int add_sdhci(struct sdhci_host *host, u32 max_clk, u32 min_clk)
{
34812b44:	e1a07001 	mov	r7, r1
34812b48:	e1a06002 	mov	r6, r2
	struct mmc *mmc;
	unsigned int caps;

	mmc = malloc(sizeof(struct mmc));
34812b4c:	ebffdb4b 	bl	34809880 <malloc>
	if (!mmc) {
34812b50:	e2504000 	subs	r4, r0, #0
		printf("mmc malloc fail!\n");
34812b54:	059f0144 	ldreq	r0, [pc, #324]	; 34812ca0 <add_sdhci+0x168>
{
	struct mmc *mmc;
	unsigned int caps;

	mmc = malloc(sizeof(struct mmc));
	if (!mmc) {
34812b58:	0a00001f 	beq	34812bdc <add_sdhci+0xa4>
		printf("mmc malloc fail!\n");
		return -1;
	}

	mmc->priv = host;
34812b5c:	e5845028 	str	r5, [r4, #40]	; 0x28
	host->mmc = mmc;

	sprintf(mmc->name, "%s", host->name);
34812b60:	e2840008 	add	r0, r4, #8
		printf("mmc malloc fail!\n");
		return -1;
	}

	mmc->priv = host;
	host->mmc = mmc;
34812b64:	e5854018 	str	r4, [r5, #24]

	sprintf(mmc->name, "%s", host->name);
34812b68:	e59f1134 	ldr	r1, [pc, #308]	; 34812ca4 <add_sdhci+0x16c>
34812b6c:	e5952000 	ldr	r2, [r5]
34812b70:	eb00286c 	bl	3481cd28 <sprintf>
	mmc->send_cmd = sdhci_send_command;
34812b74:	e59f312c 	ldr	r3, [pc, #300]	; 34812ca8 <add_sdhci+0x170>
34812b78:	e5843110 	str	r3, [r4, #272]	; 0x110
	mmc->set_ios = sdhci_set_ios;
34812b7c:	e59f3128 	ldr	r3, [pc, #296]	; 34812cac <add_sdhci+0x174>
34812b80:	e5843114 	str	r3, [r4, #276]	; 0x114
	mmc->init = sdhci_init;
34812b84:	e59f3124 	ldr	r3, [pc, #292]	; 34812cb0 <add_sdhci+0x178>
34812b88:	e5843118 	str	r3, [r4, #280]	; 0x118
	mmc->getcd = NULL;
34812b8c:	e3a03000 	mov	r3, #0
34812b90:	e584311c 	str	r3, [r4, #284]	; 0x11c
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34812b94:	e5953004 	ldr	r3, [r5, #4]
34812b98:	e593a040 	ldr	sl, [r3, #64]	; 0x40
		printf("Your controller don't support sdma!!\n");
		return -1;
	}
#endif

	if (max_clk)
34812b9c:	e3570000 	cmp	r7, #0
		mmc->f_max = max_clk;
34812ba0:	1584703c 	strne	r7, [r4, #60]	; 0x3c
		printf("Your controller don't support sdma!!\n");
		return -1;
	}
#endif

	if (max_clk)
34812ba4:	1a000008 	bne	34812bcc <add_sdhci+0x94>
		mmc->f_max = max_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34812ba8:	e5d53010 	ldrb	r3, [r5, #16]
			mmc->f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
		else
			mmc->f_max = (caps & SDHCI_CLOCK_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
		mmc->f_max *= 1000000;
34812bac:	e59f2100 	ldr	r2, [pc, #256]	; 34812cb4 <add_sdhci+0x17c>
#endif

	if (max_clk)
		mmc->f_max = max_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34812bb0:	e3530001 	cmp	r3, #1
			mmc->f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
34812bb4:	87e7345a 	ubfxhi	r3, sl, #8, #8
		else
			mmc->f_max = (caps & SDHCI_CLOCK_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
34812bb8:	97e5345a 	ubfxls	r3, sl, #8, #6
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
			mmc->f_max = (caps & SDHCI_CLOCK_V3_BASE_MASK)
				>> SDHCI_CLOCK_BASE_SHIFT;
		else
			mmc->f_max = (caps & SDHCI_CLOCK_BASE_MASK)
34812bbc:	e584303c 	str	r3, [r4, #60]	; 0x3c
				>> SDHCI_CLOCK_BASE_SHIFT;
		mmc->f_max *= 1000000;
34812bc0:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
34812bc4:	e0030392 	mul	r3, r2, r3
34812bc8:	e584303c 	str	r3, [r4, #60]	; 0x3c
	}
	if (mmc->f_max == 0) {
34812bcc:	e594003c 	ldr	r0, [r4, #60]	; 0x3c
34812bd0:	e3500000 	cmp	r0, #0
34812bd4:	1a000003 	bne	34812be8 <add_sdhci+0xb0>
		printf("Hardware doesn't specify base clock frequency\n");
34812bd8:	e59f00d8 	ldr	r0, [pc, #216]	; 34812cb8 <add_sdhci+0x180>
34812bdc:	ebffd960 	bl	34809164 <printf>
		return -1;
34812be0:	e3e00000 	mvn	r0, #0
34812be4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	}
	if (min_clk)
34812be8:	e3560000 	cmp	r6, #0
		mmc->f_min = min_clk;
34812bec:	15846038 	strne	r6, [r4, #56]	; 0x38
	}
	if (mmc->f_max == 0) {
		printf("Hardware doesn't specify base clock frequency\n");
		return -1;
	}
	if (min_clk)
34812bf0:	1a000006 	bne	34812c10 <add_sdhci+0xd8>
		mmc->f_min = min_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34812bf4:	e5d53010 	ldrb	r3, [r5, #16]
34812bf8:	e3530001 	cmp	r3, #1
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_300;
		else
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_200;
34812bfc:	91a00420 	lsrls	r0, r0, #8
		return -1;
	}
	if (min_clk)
		mmc->f_min = min_clk;
	else {
		if ((host->version & SDHCI_SPEC_VER_MASK) >= SDHCI_SPEC_300)
34812c00:	9a000001 	bls	34812c0c <add_sdhci+0xd4>
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_300;
34812c04:	e30017fe 	movw	r1, #2046	; 0x7fe
34812c08:	eb0033e4 	bl	3481fba0 <__udivsi3>
		else
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_200;
34812c0c:	e5840038 	str	r0, [r4, #56]	; 0x38
	}

	mmc->voltages = 0;
34812c10:	e3a03000 	mov	r3, #0
	if (caps & SDHCI_CAN_VDD_330)
34812c14:	e31a0401 	tst	sl, #16777216	; 0x1000000
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_300;
		else
			mmc->f_min = mmc->f_max / SDHCI_MAX_DIV_SPEC_200;
	}

	mmc->voltages = 0;
34812c18:	e584302c 	str	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_VDD_330)
		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
34812c1c:	12833603 	addne	r3, r3, #3145728	; 0x300000
34812c20:	1584302c 	strne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_VDD_300)
34812c24:	e31a0402 	tst	sl, #33554432	; 0x2000000
		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
34812c28:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_DO_8BIT)
		mmc->host_caps |= MMC_MODE_8BIT;
	if (host->host_caps)
		mmc->host_caps |= host->host_caps;

	sdhci_reset(host, SDHCI_RESET_ALL);
34812c2c:	e2850004 	add	r0, r5, #4

	mmc->voltages = 0;
	if (caps & SDHCI_CAN_VDD_330)
		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
	if (caps & SDHCI_CAN_VDD_300)
		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
34812c30:	13833806 	orrne	r3, r3, #393216	; 0x60000
34812c34:	1584302c 	strne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_VDD_180)
34812c38:	e31a0301 	tst	sl, #67108864	; 0x4000000
		mmc->voltages |= MMC_VDD_165_195;
34812c3c:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
	if (caps & SDHCI_CAN_DO_8BIT)
		mmc->host_caps |= MMC_MODE_8BIT;
	if (host->host_caps)
		mmc->host_caps |= host->host_caps;

	sdhci_reset(host, SDHCI_RESET_ALL);
34812c40:	e3a01001 	mov	r1, #1
	if (caps & SDHCI_CAN_VDD_330)
		mmc->voltages |= MMC_VDD_32_33 | MMC_VDD_33_34;
	if (caps & SDHCI_CAN_VDD_300)
		mmc->voltages |= MMC_VDD_29_30 | MMC_VDD_30_31;
	if (caps & SDHCI_CAN_VDD_180)
		mmc->voltages |= MMC_VDD_165_195;
34812c44:	13833080 	orrne	r3, r3, #128	; 0x80
34812c48:	1584302c 	strne	r3, [r4, #44]	; 0x2c

	if (host->quirks & SDHCI_QUIRK_BROKEN_VOLTAGE)
34812c4c:	e5953008 	ldr	r3, [r5, #8]
34812c50:	e3130010 	tst	r3, #16
		mmc->voltages |= host->voltages;
34812c54:	1595302c 	ldrne	r3, [r5, #44]	; 0x2c
34812c58:	1594202c 	ldrne	r2, [r4, #44]	; 0x2c
34812c5c:	11823003 	orrne	r3, r2, r3
34812c60:	1584302c 	strne	r3, [r4, #44]	; 0x2c

	mmc->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
34812c64:	e3003111 	movw	r3, #273	; 0x111
	if (caps & SDHCI_CAN_DO_8BIT)
34812c68:	e31a0701 	tst	sl, #262144	; 0x40000
		mmc->voltages |= MMC_VDD_165_195;

	if (host->quirks & SDHCI_QUIRK_BROKEN_VOLTAGE)
		mmc->voltages |= host->voltages;

	mmc->host_caps = MMC_MODE_HS | MMC_MODE_HS_52MHz | MMC_MODE_4BIT;
34812c6c:	e5843050 	str	r3, [r4, #80]	; 0x50
	if (caps & SDHCI_CAN_DO_8BIT)
		mmc->host_caps |= MMC_MODE_8BIT;
34812c70:	12833c02 	addne	r3, r3, #512	; 0x200
34812c74:	15843050 	strne	r3, [r4, #80]	; 0x50
	if (host->host_caps)
34812c78:	e595300c 	ldr	r3, [r5, #12]
34812c7c:	e3530000 	cmp	r3, #0
		mmc->host_caps |= host->host_caps;
34812c80:	15942050 	ldrne	r2, [r4, #80]	; 0x50
34812c84:	11823003 	orrne	r3, r2, r3
34812c88:	15843050 	strne	r3, [r4, #80]	; 0x50

	sdhci_reset(host, SDHCI_RESET_ALL);
34812c8c:	ebfffebe 	bl	3481278c <sdhci_reset.clone.9>
	mmc_register(mmc);
34812c90:	e1a00004 	mov	r0, r4
34812c94:	ebfffd5e 	bl	34812214 <mmc_register>

	return 0;
34812c98:	e3a00000 	mov	r0, #0
}
34812c9c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34812ca0:	348271d0 	.word	0x348271d0
34812ca4:	34824a4b 	.word	0x34824a4b
34812ca8:	348127e4 	.word	0x348127e4
34812cac:	34812464 	.word	0x34812464
34812cb0:	34812618 	.word	0x34812618
34812cb4:	000f4240 	.word	0x000f4240
34812cb8:	348271e2 	.word	0x348271e2

34812cbc <s5p_sdhci_set_control_reg>:

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34812cbc:	e5903004 	ldr	r3, [r0, #4]
34812cc0:	e3a02803 	mov	r2, #196608	; 0x30000
34812cc4:	e583208c 	str	r2, [r3, #140]	; 0x8c
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34812cc8:	e5932080 	ldr	r2, [r3, #128]	; 0x80
	 * 11 = 9mA
	 */
	sdhci_writel(host, SDHCI_CTRL4_DRIVE_MASK(0x3), SDHCI_CONTROL4);

	val = sdhci_readl(host, SDHCI_CONTROL2);
	val &= SDHCI_CTRL2_SELBASECLK_SHIFT;
34812ccc:	e2022004 	and	r2, r2, #4

	val |=	SDHCI_CTRL2_ENSTAASYNCCLR |
34812cd0:	e3822103 	orr	r2, r2, #-1073741824	; 0xc0000000
34812cd4:	e3822c41 	orr	r2, r2, #16640	; 0x4100

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34812cd8:	e5903004 	ldr	r3, [r0, #4]
34812cdc:	e5832080 	str	r2, [r3, #128]	; 0x80
34812ce0:	e5903004 	ldr	r3, [r0, #4]
34812ce4:	e3082080 	movw	r2, #32896	; 0x8080
34812ce8:	e5832084 	str	r2, [r3, #132]	; 0x84
{
	writeb(val, host->ioaddr + reg);
}
static inline u32 sdhci_readl(struct sdhci_host *host, int reg)
{
	return readl(host->ioaddr + reg);
34812cec:	e5932080 	ldr	r2, [r3, #128]	; 0x80
	 * 00/01 = HCLK
	 * 10 = EPLL
	 * 11 = XTI or XEXTCLK
	 */
	ctrl = sdhci_readl(host, SDHCI_CONTROL2);
	ctrl &= ~SDHCI_CTRL2_SELBASECLK_MASK(0x3);
34812cf0:	e3c22030 	bic	r2, r2, #48	; 0x30
	ctrl |= SDHCI_CTRL2_SELBASECLK_MASK(0x2);
34812cf4:	e3822020 	orr	r2, r2, #32

#else

static inline void sdhci_writel(struct sdhci_host *host, u32 val, int reg)
{
	writel(val, host->ioaddr + reg);
34812cf8:	e5903004 	ldr	r3, [r0, #4]
34812cfc:	e5832080 	str	r2, [r3, #128]	; 0x80
	sdhci_writel(host, ctrl, SDHCI_CONTROL2);
}
34812d00:	e12fff1e 	bx	lr

34812d04 <s5p_sdhci_init>:

int s5p_sdhci_init(u32 regbase, int index, int bus_width)
{
34812d04:	e92d4038 	push	{r3, r4, r5, lr}
34812d08:	e1a04000 	mov	r4, r0
	struct sdhci_host *host = NULL;
	host = (struct sdhci_host *)malloc(sizeof(struct sdhci_host));
34812d0c:	e3a00030 	mov	r0, #48	; 0x30
	ctrl |= SDHCI_CTRL2_SELBASECLK_MASK(0x2);
	sdhci_writel(host, ctrl, SDHCI_CONTROL2);
}

int s5p_sdhci_init(u32 regbase, int index, int bus_width)
{
34812d10:	e1a05001 	mov	r5, r1
	struct sdhci_host *host = NULL;
	host = (struct sdhci_host *)malloc(sizeof(struct sdhci_host));
34812d14:	ebffdad9 	bl	34809880 <malloc>
	if (!host) {
34812d18:	e2503000 	subs	r3, r0, #0
34812d1c:	1a000003 	bne	34812d30 <s5p_sdhci_init+0x2c>
		printf("sdhci__host malloc fail!\n");
34812d20:	e59f0058 	ldr	r0, [pc, #88]	; 34812d80 <s5p_sdhci_init+0x7c>
34812d24:	ebffd90e 	bl	34809164 <printf>
		return 1;
34812d28:	e3a00001 	mov	r0, #1
34812d2c:	e8bd8038 	pop	{r3, r4, r5, pc}
	}

	host->name = S5P_NAME;
34812d30:	e59f204c 	ldr	r2, [pc, #76]	; 34812d84 <s5p_sdhci_init+0x80>
	host->ioaddr = (void *)regbase;
34812d34:	e8830014 	stm	r3, {r2, r4}

	host->quirks = SDHCI_QUIRK_NO_HISPD_BIT | SDHCI_QUIRK_BROKEN_VOLTAGE |
34812d38:	e3a0201d 	mov	r2, #29
34812d3c:	e5832008 	str	r2, [r3, #8]
		SDHCI_QUIRK_BROKEN_R1B | SDHCI_QUIRK_32BIT_DMA_ADDR;
	host->voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
34812d40:	e59f2040 	ldr	r2, [pc, #64]	; 34812d88 <s5p_sdhci_init+0x84>
34812d44:	e583202c 	str	r2, [r3, #44]	; 0x2c
	return readl(host->ioaddr + reg);
}

static inline u16 sdhci_readw(struct sdhci_host *host, int reg)
{
	return readw(host->ioaddr + reg);
34812d48:	e1d42fbe 	ldrh	r2, [r4, #254]	; 0xfe
	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);
34812d4c:	e5832010 	str	r2, [r3, #16]

	host->set_control_reg = &s5p_sdhci_set_control_reg;
34812d50:	e59f2034 	ldr	r2, [pc, #52]	; 34812d8c <s5p_sdhci_init+0x88>
	host->set_clock = set_mmc_clk;
	host->index = index;
34812d54:	e5835020 	str	r5, [r3, #32]
	host->quirks = SDHCI_QUIRK_NO_HISPD_BIT | SDHCI_QUIRK_BROKEN_VOLTAGE |
		SDHCI_QUIRK_BROKEN_R1B | SDHCI_QUIRK_32BIT_DMA_ADDR;
	host->voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);

	host->set_control_reg = &s5p_sdhci_set_control_reg;
34812d58:	e5832024 	str	r2, [r3, #36]	; 0x24
	host->set_clock = set_mmc_clk;
34812d5c:	e59f202c 	ldr	r2, [pc, #44]	; 34812d90 <s5p_sdhci_init+0x8c>
	host->index = index;

	host->host_caps = MMC_MODE_HC;

	add_sdhci(host, 52000000, 400000);
34812d60:	e59f102c 	ldr	r1, [pc, #44]	; 34812d94 <s5p_sdhci_init+0x90>
		SDHCI_QUIRK_BROKEN_R1B | SDHCI_QUIRK_32BIT_DMA_ADDR;
	host->voltages = MMC_VDD_32_33 | MMC_VDD_33_34 | MMC_VDD_165_195;
	host->version = sdhci_readw(host, SDHCI_HOST_VERSION);

	host->set_control_reg = &s5p_sdhci_set_control_reg;
	host->set_clock = set_mmc_clk;
34812d64:	e5832028 	str	r2, [r3, #40]	; 0x28
	host->index = index;

	host->host_caps = MMC_MODE_HC;
34812d68:	e3a02b02 	mov	r2, #2048	; 0x800
34812d6c:	e583200c 	str	r2, [r3, #12]

	add_sdhci(host, 52000000, 400000);
34812d70:	e59f2020 	ldr	r2, [pc, #32]	; 34812d98 <s5p_sdhci_init+0x94>
34812d74:	ebffff6f 	bl	34812b38 <add_sdhci>
	return 0;
34812d78:	e3a00000 	mov	r0, #0
}
34812d7c:	e8bd8038 	pop	{r3, r4, r5, pc}
34812d80:	34827211 	.word	0x34827211
34812d84:	3482722b 	.word	0x3482722b
34812d88:	00300080 	.word	0x00300080
34812d8c:	34812cbc 	.word	0x34812cbc
34812d90:	34800fb8 	.word	0x34800fb8
34812d94:	03197500 	.word	0x03197500
34812d98:	00061a80 	.word	0x00061a80

34812d9c <add_mtd_device>:

int add_mtd_device(struct mtd_info *mtd)
{
	int i;

	BUG_ON(mtd->writesize == 0);
34812d9c:	e5903014 	ldr	r3, [r0, #20]
#include <ubi_uboot.h>

struct mtd_info *mtd_table[MAX_MTD_DEVICES];

int add_mtd_device(struct mtd_info *mtd)
{
34812da0:	e92d4010 	push	{r4, lr}
	int i;

	BUG_ON(mtd->writesize == 0);
34812da4:	e3530000 	cmp	r3, #0
#include <ubi_uboot.h>

struct mtd_info *mtd_table[MAX_MTD_DEVICES];

int add_mtd_device(struct mtd_info *mtd)
{
34812da8:	e1a04000 	mov	r4, r0
	int i;

	BUG_ON(mtd->writesize == 0);
34812dac:	1a000003 	bne	34812dc0 <add_mtd_device+0x24>
34812db0:	e59f0044 	ldr	r0, [pc, #68]	; 34812dfc <add_mtd_device+0x60>
34812db4:	e59f1044 	ldr	r1, [pc, #68]	; 34812e00 <add_mtd_device+0x64>
34812db8:	e3a02014 	mov	r2, #20
34812dbc:	ebffd8e8 	bl	34809164 <printf>
34812dc0:	e59f203c 	ldr	r2, [pc, #60]	; 34812e04 <add_mtd_device+0x68>

	for (i = 0; i < MAX_MTD_DEVICES; i++)
34812dc4:	e3a03000 	mov	r3, #0
		if (!mtd_table[i]) {
34812dc8:	e5b20004 	ldr	r0, [r2, #4]!
34812dcc:	e3500000 	cmp	r0, #0
34812dd0:	1a000004 	bne	34812de8 <add_mtd_device+0x4c>
			mtd_table[i] = mtd;
34812dd4:	e59f202c 	ldr	r2, [pc, #44]	; 34812e08 <add_mtd_device+0x6c>
34812dd8:	e7824103 	str	r4, [r2, r3, lsl #2]
			mtd->index = i;
34812ddc:	e5843024 	str	r3, [r4, #36]	; 0x24
			mtd->usecount = 0;
34812de0:	e584009c 	str	r0, [r4, #156]	; 0x9c

			/* We _know_ we aren't being removed, because
			   our caller is still holding us here. So none
			   of this try_ nonsense, and no bitching about it
			   either. :) */
			return 0;
34812de4:	e8bd8010 	pop	{r4, pc}
{
	int i;

	BUG_ON(mtd->writesize == 0);

	for (i = 0; i < MAX_MTD_DEVICES; i++)
34812de8:	e2833001 	add	r3, r3, #1
34812dec:	e3530020 	cmp	r3, #32
34812df0:	1afffff4 	bne	34812dc8 <add_mtd_device+0x2c>
			   of this try_ nonsense, and no bitching about it
			   either. :) */
			return 0;
		}

	return 1;
34812df4:	e3a00001 	mov	r0, #1
}
34812df8:	e8bd8010 	pop	{r4, pc}
34812dfc:	34827239 	.word	0x34827239
34812e00:	3482724f 	.word	0x3482724f
34812e04:	3482ba30 	.word	0x3482ba30
34812e08:	3482ba34 	.word	0x3482ba34

34812e0c <del_mtd_device>:
 */
int del_mtd_device(struct mtd_info *mtd)
{
	int ret;

	if (mtd_table[mtd->index] != mtd) {
34812e0c:	e5901024 	ldr	r1, [r0, #36]	; 0x24
34812e10:	e59fc03c 	ldr	ip, [pc, #60]	; 34812e54 <del_mtd_device+0x48>
 *      and notify each currently active MTD 'user' of its departure.
 *      Returns zero on success or 1 on failure, which currently will happen
 *      if the requested device does not appear to be present in the list.
 */
int del_mtd_device(struct mtd_info *mtd)
{
34812e14:	e92d4008 	push	{r3, lr}
	int ret;

	if (mtd_table[mtd->index] != mtd) {
34812e18:	e79c2101 	ldr	r2, [ip, r1, lsl #2]
34812e1c:	e1520000 	cmp	r2, r0
34812e20:	1a000009 	bne	34812e4c <del_mtd_device+0x40>
		ret = -ENODEV;
	} else if (mtd->usecount) {
34812e24:	e592309c 	ldr	r3, [r2, #156]	; 0x9c
34812e28:	e3530000 	cmp	r3, #0
				mtd->index, mtd->name, mtd->usecount);
		ret = -EBUSY;
	} else {
		/* No need to get a refcount on the module containing
		 * the notifier, since we hold the mtd_table_mutex */
		mtd_table[mtd->index] = NULL;
34812e2c:	078c3101 	streq	r3, [ip, r1, lsl #2]

		ret = 0;
34812e30:	01a00003 	moveq	r0, r3
{
	int ret;

	if (mtd_table[mtd->index] != mtd) {
		ret = -ENODEV;
	} else if (mtd->usecount) {
34812e34:	08bd8008 	popeq	{r3, pc}
		printk(KERN_NOTICE "Removing MTD device #%d (%s)"
34812e38:	e59f0018 	ldr	r0, [pc, #24]	; 34812e58 <del_mtd_device+0x4c>
34812e3c:	e5922020 	ldr	r2, [r2, #32]
34812e40:	ebffd8c7 	bl	34809164 <printf>
				" with use count %d\n",
				mtd->index, mtd->name, mtd->usecount);
		ret = -EBUSY;
34812e44:	e3e0000f 	mvn	r0, #15
34812e48:	e8bd8008 	pop	{r3, pc}
int del_mtd_device(struct mtd_info *mtd)
{
	int ret;

	if (mtd_table[mtd->index] != mtd) {
		ret = -ENODEV;
34812e4c:	e3e00012 	mvn	r0, #18

		ret = 0;
	}

	return ret;
}
34812e50:	e8bd8008 	pop	{r3, pc}
34812e54:	3482ba34 	.word	0x3482ba34
34812e58:	34827259 	.word	0x34827259

34812e5c <get_mtd_device>:
struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
{
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
34812e5c:	e3710001 	cmn	r1, #1
 *      for a device with that address and return if it's still present. Given
 *      both, return the num'th driver only if its address matches. Return
 *      error code if not.
 */
struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
{
34812e60:	e1a03000 	mov	r3, r0
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
34812e64:	1a000008 	bne	34812e8c <get_mtd_device+0x30>
34812e68:	e59f2060 	ldr	r2, [pc, #96]	; 34812ed0 <get_mtd_device+0x74>
 *      table, if any.  Given an address and num == -1, search the device table
 *      for a device with that address and return if it's still present. Given
 *      both, return the num'th driver only if its address matches. Return
 *      error code if not.
 */
struct mtd_info *get_mtd_device(struct mtd_info *mtd, int num)
34812e6c:	e3a00000 	mov	r0, #0
34812e70:	e2821080 	add	r1, r2, #128	; 0x80
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
		for (i = 0; i < MAX_MTD_DEVICES; i++)
			if (mtd_table[i] == mtd)
34812e74:	e5b2c004 	ldr	ip, [r2, #4]!
34812e78:	e15c0003 	cmp	ip, r3
34812e7c:	01a00003 	moveq	r0, r3
{
	struct mtd_info *ret = NULL;
	int i, err = -ENODEV;

	if (num == -1) {
		for (i = 0; i < MAX_MTD_DEVICES; i++)
34812e80:	e1520001 	cmp	r2, r1
34812e84:	1afffffa 	bne	34812e74 <get_mtd_device+0x18>
34812e88:	ea000006 	b	34812ea8 <get_mtd_device+0x4c>
			if (mtd_table[i] == mtd)
				ret = mtd_table[i];
	} else if (num < MAX_MTD_DEVICES) {
34812e8c:	e351001f 	cmp	r1, #31
34812e90:	ca00000a 	bgt	34812ec0 <get_mtd_device+0x64>
		ret = mtd_table[num];
34812e94:	e59f2038 	ldr	r2, [pc, #56]	; 34812ed4 <get_mtd_device+0x78>
34812e98:	e7920101 	ldr	r0, [r2, r1, lsl #2]
		if (mtd && mtd != ret)
34812e9c:	e1530000 	cmp	r3, r0
34812ea0:	13530000 	cmpne	r3, #0
34812ea4:	1a000005 	bne	34812ec0 <get_mtd_device+0x64>
			ret = NULL;
	}

	if (!ret)
34812ea8:	e3500000 	cmp	r0, #0
		goto out_unlock;

	ret->usecount++;
34812eac:	1590309c 	ldrne	r3, [r0, #156]	; 0x9c
34812eb0:	12833001 	addne	r3, r3, #1
34812eb4:	1580309c 	strne	r3, [r0, #156]	; 0x9c
		ret = mtd_table[num];
		if (mtd && mtd != ret)
			ret = NULL;
	}

	if (!ret)
34812eb8:	112fff1e 	bxne	lr
34812ebc:	ea000001 	b	34812ec8 <get_mtd_device+0x6c>

	ret->usecount++;
	return ret;

out_unlock:
	return ERR_PTR(err);
34812ec0:	e3e00012 	mvn	r0, #18
34812ec4:	e12fff1e 	bx	lr
34812ec8:	e3e00012 	mvn	r0, #18
}
34812ecc:	e12fff1e 	bx	lr
34812ed0:	3482ba30 	.word	0x3482ba30
34812ed4:	3482ba34 	.word	0x3482ba34

34812ed8 <get_mtd_device_nm>:
 *
 *      This function returns MTD device description structure in case of
 *      success and an error code in case of failure.
 */
struct mtd_info *get_mtd_device_nm(const char *name)
{
34812ed8:	e92d4070 	push	{r4, r5, r6, lr}

	mtd->usecount++;
	return mtd;

out_unlock:
	return ERR_PTR(err);
34812edc:	e59f5060 	ldr	r5, [pc, #96]	; 34812f44 <get_mtd_device_nm+0x6c>
 *
 *      This function returns MTD device description structure in case of
 *      success and an error code in case of failure.
 */
struct mtd_info *get_mtd_device_nm(const char *name)
{
34812ee0:	e1a06000 	mov	r6, r0
	int i, err = -ENODEV;
	struct mtd_info *mtd = NULL;

	for (i = 0; i < MAX_MTD_DEVICES; i++) {
34812ee4:	e3a04000 	mov	r4, #0
		if (mtd_table[i] && !strcmp(name, mtd_table[i]->name)) {
34812ee8:	e5b53004 	ldr	r3, [r5, #4]!
34812eec:	e3530000 	cmp	r3, #0
34812ef0:	0a00000c 	beq	34812f28 <get_mtd_device_nm+0x50>
34812ef4:	e1a00006 	mov	r0, r6
34812ef8:	e5931020 	ldr	r1, [r3, #32]
34812efc:	eb00231c 	bl	3481bb74 <strcmp>
34812f00:	e3500000 	cmp	r0, #0
34812f04:	1a000007 	bne	34812f28 <get_mtd_device_nm+0x50>
			mtd = mtd_table[i];
34812f08:	e59f3038 	ldr	r3, [pc, #56]	; 34812f48 <get_mtd_device_nm+0x70>
34812f0c:	e7930104 	ldr	r0, [r3, r4, lsl #2]
			break;
		}
	}

	if (!mtd)
34812f10:	e3500000 	cmp	r0, #0
		goto out_unlock;

	mtd->usecount++;
34812f14:	1590309c 	ldrne	r3, [r0, #156]	; 0x9c
34812f18:	12833001 	addne	r3, r3, #1
34812f1c:	1580309c 	strne	r3, [r0, #156]	; 0x9c
			mtd = mtd_table[i];
			break;
		}
	}

	if (!mtd)
34812f20:	18bd8070 	popne	{r4, r5, r6, pc}
34812f24:	ea000004 	b	34812f3c <get_mtd_device_nm+0x64>
struct mtd_info *get_mtd_device_nm(const char *name)
{
	int i, err = -ENODEV;
	struct mtd_info *mtd = NULL;

	for (i = 0; i < MAX_MTD_DEVICES; i++) {
34812f28:	e2844001 	add	r4, r4, #1
34812f2c:	e3540020 	cmp	r4, #32
34812f30:	1affffec 	bne	34812ee8 <get_mtd_device_nm+0x10>

	mtd->usecount++;
	return mtd;

out_unlock:
	return ERR_PTR(err);
34812f34:	e3e00012 	mvn	r0, #18
34812f38:	e8bd8070 	pop	{r4, r5, r6, pc}
34812f3c:	e3e00012 	mvn	r0, #18
}
34812f40:	e8bd8070 	pop	{r4, r5, r6, pc}
34812f44:	3482ba30 	.word	0x3482ba30
34812f48:	3482ba34 	.word	0x3482ba34

34812f4c <put_mtd_device>:

void put_mtd_device(struct mtd_info *mtd)
{
	int c;

	c = --mtd->usecount;
34812f4c:	e590309c 	ldr	r3, [r0, #156]	; 0x9c
34812f50:	e2433001 	sub	r3, r3, #1
	BUG_ON(c < 0);
34812f54:	e3530000 	cmp	r3, #0

void put_mtd_device(struct mtd_info *mtd)
{
	int c;

	c = --mtd->usecount;
34812f58:	e580309c 	str	r3, [r0, #156]	; 0x9c
	BUG_ON(c < 0);
34812f5c:	a12fff1e 	bxge	lr
34812f60:	e59f0008 	ldr	r0, [pc, #8]	; 34812f70 <put_mtd_device+0x24>
34812f64:	e59f1008 	ldr	r1, [pc, #8]	; 34812f74 <put_mtd_device+0x28>
34812f68:	e3a0208f 	mov	r2, #143	; 0x8f
34812f6c:	eaffd87c 	b	34809164 <printf>
34812f70:	34827239 	.word	0x34827239
34812f74:	3482724f 	.word	0x3482724f

34812f78 <part_read_user_prot_reg>:
	return res;
}

static int part_read_user_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len, size_t *retlen, u_char *buf)
{
34812f78:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->read_user_prot_reg(part->master, from,
34812f7c:	e59d1018 	ldr	r1, [sp, #24]
34812f80:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
34812f84:	e58d1000 	str	r1, [sp]
34812f88:	e59d101c 	ldr	r1, [sp, #28]
34812f8c:	e58d1004 	str	r1, [sp, #4]
34812f90:	e59d1020 	ldr	r1, [sp, #32]
34812f94:	e58d1008 	str	r1, [sp, #8]
34812f98:	e5901060 	ldr	r1, [r0, #96]	; 0x60
34812f9c:	e12fff31 	blx	r1
					len, retlen, buf);
}
34812fa0:	e28dd014 	add	sp, sp, #20
34812fa4:	e8bd8000 	pop	{pc}

34812fa8 <part_get_user_prot_info>:

static int part_get_user_prot_info(struct mtd_info *mtd,
		struct otp_info *buf, size_t len)
{
	struct mtd_part *part = PART(mtd);
	return part->master->get_user_prot_info(part->master, buf, len);
34812fa8:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
					len, retlen, buf);
}

static int part_get_user_prot_info(struct mtd_info *mtd,
		struct otp_info *buf, size_t len)
{
34812fac:	e92d4008 	push	{r3, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->get_user_prot_info(part->master, buf, len);
34812fb0:	e590305c 	ldr	r3, [r0, #92]	; 0x5c
34812fb4:	e12fff33 	blx	r3
}
34812fb8:	e8bd8008 	pop	{r3, pc}

34812fbc <part_read_fact_prot_reg>:

static int part_read_fact_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len, size_t *retlen, u_char *buf)
{
34812fbc:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->read_fact_prot_reg(part->master, from,
34812fc0:	e59d1018 	ldr	r1, [sp, #24]
34812fc4:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
34812fc8:	e58d1000 	str	r1, [sp]
34812fcc:	e59d101c 	ldr	r1, [sp, #28]
34812fd0:	e58d1004 	str	r1, [sp, #4]
34812fd4:	e59d1020 	ldr	r1, [sp, #32]
34812fd8:	e58d1008 	str	r1, [sp, #8]
34812fdc:	e5901058 	ldr	r1, [r0, #88]	; 0x58
34812fe0:	e12fff31 	blx	r1
					len, retlen, buf);
}
34812fe4:	e28dd014 	add	sp, sp, #20
34812fe8:	e8bd8000 	pop	{pc}

34812fec <part_get_fact_prot_info>:

static int part_get_fact_prot_info(struct mtd_info *mtd, struct otp_info *buf,
		size_t len)
{
	struct mtd_part *part = PART(mtd);
	return part->master->get_fact_prot_info(part->master, buf, len);
34812fec:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
					len, retlen, buf);
}

static int part_get_fact_prot_info(struct mtd_info *mtd, struct otp_info *buf,
		size_t len)
{
34812ff0:	e92d4008 	push	{r3, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->get_fact_prot_info(part->master, buf, len);
34812ff4:	e5903054 	ldr	r3, [r0, #84]	; 0x54
34812ff8:	e12fff33 	blx	r3
}
34812ffc:	e8bd8008 	pop	{r3, pc}

34813000 <part_write>:

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34813000:	e92d4030 	push	{r4, r5, lr}
34813004:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34813008:	e5900004 	ldr	r0, [r0, #4]
	return part->master->get_fact_prot_info(part->master, buf, len);
}

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
3481300c:	e24dd014 	sub	sp, sp, #20
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
34813010:	e3100b01 	tst	r0, #1024	; 0x400
	return part->master->get_fact_prot_info(part->master, buf, len);
}

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34813014:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
34813018:	03e0001d 	mvneq	r0, #29

static int part_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
3481301c:	0a00001b 	beq	34813090 <part_write+0x90>
		return -EROFS;
	if (to >= mtd->size)
34813020:	e591e00c 	ldr	lr, [r1, #12]
34813024:	e5910008 	ldr	r0, [r1, #8]
34813028:	e15e0003 	cmp	lr, r3
3481302c:	8a000002 	bhi	3481303c <part_write+0x3c>
34813030:	1a00000a 	bne	34813060 <part_write+0x60>
34813034:	e1500002 	cmp	r0, r2
34813038:	9a000008 	bls	34813060 <part_write+0x60>
		len = 0;
	else if (to + len > mtd->size)
3481303c:	e092400c 	adds	r4, r2, ip
34813040:	e2a35000 	adc	r5, r3, #0
34813044:	e155000e 	cmp	r5, lr
34813048:	8a000002 	bhi	34813058 <part_write+0x58>
3481304c:	1a000004 	bne	34813064 <part_write+0x64>
34813050:	e1540000 	cmp	r4, r0
34813054:	9a000002 	bls	34813064 <part_write+0x64>
		len = mtd->size - to;
34813058:	e062c000 	rsb	ip, r2, r0
3481305c:	ea000000 	b	34813064 <part_write+0x64>
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (to >= mtd->size)
		len = 0;
34813060:	e3a0c000 	mov	ip, #0
	else if (to + len > mtd->size)
		len = mtd->size - to;
	return part->master->write(part->master, to + part->offset,
34813064:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
34813068:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
3481306c:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
34813070:	e58dc000 	str	ip, [sp]
34813074:	e58d1004 	str	r1, [sp, #4]
34813078:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3481307c:	e0922004 	adds	r2, r2, r4
34813080:	e58d1008 	str	r1, [sp, #8]
34813084:	e5901044 	ldr	r1, [r0, #68]	; 0x44
34813088:	e0a33005 	adc	r3, r3, r5
3481308c:	e12fff31 	blx	r1
				    len, retlen, buf);
}
34813090:	e28dd014 	add	sp, sp, #20
34813094:	e8bd8030 	pop	{r4, r5, pc}

34813098 <part_panic_write>:

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
34813098:	e92d4030 	push	{r4, r5, lr}
3481309c:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
348130a0:	e5900004 	ldr	r0, [r0, #4]
				    len, retlen, buf);
}

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
348130a4:	e24dd014 	sub	sp, sp, #20
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
348130a8:	e3100b01 	tst	r0, #1024	; 0x400
				    len, retlen, buf);
}

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
348130ac:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
348130b0:	03e0001d 	mvneq	r0, #29

static int part_panic_write(struct mtd_info *mtd, loff_t to, size_t len,
		size_t *retlen, const u_char *buf)
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
348130b4:	0a00001b 	beq	34813128 <part_panic_write+0x90>
		return -EROFS;
	if (to >= mtd->size)
348130b8:	e591e00c 	ldr	lr, [r1, #12]
348130bc:	e5910008 	ldr	r0, [r1, #8]
348130c0:	e15e0003 	cmp	lr, r3
348130c4:	8a000002 	bhi	348130d4 <part_panic_write+0x3c>
348130c8:	1a00000a 	bne	348130f8 <part_panic_write+0x60>
348130cc:	e1500002 	cmp	r0, r2
348130d0:	9a000008 	bls	348130f8 <part_panic_write+0x60>
		len = 0;
	else if (to + len > mtd->size)
348130d4:	e092400c 	adds	r4, r2, ip
348130d8:	e2a35000 	adc	r5, r3, #0
348130dc:	e155000e 	cmp	r5, lr
348130e0:	8a000002 	bhi	348130f0 <part_panic_write+0x58>
348130e4:	1a000004 	bne	348130fc <part_panic_write+0x64>
348130e8:	e1540000 	cmp	r4, r0
348130ec:	9a000002 	bls	348130fc <part_panic_write+0x64>
		len = mtd->size - to;
348130f0:	e062c000 	rsb	ip, r2, r0
348130f4:	ea000000 	b	348130fc <part_panic_write+0x64>
{
	struct mtd_part *part = PART(mtd);
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (to >= mtd->size)
		len = 0;
348130f8:	e3a0c000 	mov	ip, #0
	else if (to + len > mtd->size)
		len = mtd->size - to;
	return part->master->panic_write(part->master, to + part->offset,
348130fc:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
34813100:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34813104:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
34813108:	e58dc000 	str	ip, [sp]
3481310c:	e58d1004 	str	r1, [sp, #4]
34813110:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
34813114:	e0922004 	adds	r2, r2, r4
34813118:	e58d1008 	str	r1, [sp, #8]
3481311c:	e5901048 	ldr	r1, [r0, #72]	; 0x48
34813120:	e0a33005 	adc	r3, r3, r5
34813124:	e12fff31 	blx	r1
				    len, retlen, buf);
}
34813128:	e28dd014 	add	sp, sp, #20
3481312c:	e8bd8030 	pop	{r4, r5, pc}

34813130 <part_write_oob>:

static int part_write_oob(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
34813130:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34813134:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);

	if (!(mtd->flags & MTD_WRITEABLE))
34813138:	e5900004 	ldr	r0, [r0, #4]
				    len, retlen, buf);
}

static int part_write_oob(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
3481313c:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);

	if (!(mtd->flags & MTD_WRITEABLE))
34813140:	e3100b01 	tst	r0, #1024	; 0x400
		return -EROFS;
34813144:	03e0001d 	mvneq	r0, #29
static int part_write_oob(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct mtd_part *part = PART(mtd);

	if (!(mtd->flags & MTD_WRITEABLE))
34813148:	0a00001a 	beq	348131b8 <part_write_oob+0x88>
		return -EROFS;

	if (to >= mtd->size)
3481314c:	e591600c 	ldr	r6, [r1, #12]
34813150:	e5910008 	ldr	r0, [r1, #8]
34813154:	e1560003 	cmp	r6, r3
34813158:	8a000002 	bhi	34813168 <part_write_oob+0x38>
3481315c:	1a000014 	bne	348131b4 <part_write_oob+0x84>
34813160:	e1500002 	cmp	r0, r2
34813164:	9a000012 	bls	348131b4 <part_write_oob+0x84>
		return -EINVAL;
	if (ops->datbuf && to + ops->len > mtd->size)
34813168:	e59c4018 	ldr	r4, [ip, #24]
3481316c:	e3540000 	cmp	r4, #0
34813170:	0a000007 	beq	34813194 <part_write_oob+0x64>
34813174:	e59c7004 	ldr	r7, [ip, #4]
34813178:	e0924007 	adds	r4, r2, r7
3481317c:	e2a35000 	adc	r5, r3, #0
34813180:	e1550006 	cmp	r5, r6
34813184:	8a00000a 	bhi	348131b4 <part_write_oob+0x84>
34813188:	1a000001 	bne	34813194 <part_write_oob+0x64>
3481318c:	e1540000 	cmp	r4, r0
34813190:	8a000007 	bhi	348131b4 <part_write_oob+0x84>
		return -EINVAL;
	return part->master->write_oob(part->master, to + part->offset, ops);
34813194:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34813198:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
3481319c:	e58dc000 	str	ip, [sp]
348131a0:	e0922004 	adds	r2, r2, r4
348131a4:	e5901050 	ldr	r1, [r0, #80]	; 0x50
348131a8:	e0a33005 	adc	r3, r3, r5
348131ac:	e12fff31 	blx	r1
348131b0:	ea000000 	b	348131b8 <part_write_oob+0x88>
		return -EROFS;

	if (to >= mtd->size)
		return -EINVAL;
	if (ops->datbuf && to + ops->len > mtd->size)
		return -EINVAL;
348131b4:	e3e00015 	mvn	r0, #21
	return part->master->write_oob(part->master, to + part->offset, ops);
}
348131b8:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

348131bc <part_write_user_prot_reg>:

static int part_write_user_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len, size_t *retlen, u_char *buf)
{
348131bc:	e92d401f 	push	{r0, r1, r2, r3, r4, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->write_user_prot_reg(part->master, from,
348131c0:	e59d1018 	ldr	r1, [sp, #24]
348131c4:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
348131c8:	e58d1000 	str	r1, [sp]
348131cc:	e59d101c 	ldr	r1, [sp, #28]
348131d0:	e58d1004 	str	r1, [sp, #4]
348131d4:	e59d1020 	ldr	r1, [sp, #32]
348131d8:	e58d1008 	str	r1, [sp, #8]
348131dc:	e5901064 	ldr	r1, [r0, #100]	; 0x64
348131e0:	e12fff31 	blx	r1
					len, retlen, buf);
}
348131e4:	e28dd014 	add	sp, sp, #20
348131e8:	e8bd8000 	pop	{pc}

348131ec <part_lock_user_prot_reg>:

static int part_lock_user_prot_reg(struct mtd_info *mtd, loff_t from,
		size_t len)
{
348131ec:	e92d4007 	push	{r0, r1, r2, lr}
	struct mtd_part *part = PART(mtd);
	return part->master->lock_user_prot_reg(part->master, from, len);
348131f0:	e59d1010 	ldr	r1, [sp, #16]
348131f4:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
348131f8:	e58d1000 	str	r1, [sp]
348131fc:	e5901068 	ldr	r1, [r0, #104]	; 0x68
34813200:	e12fff31 	blx	r1
}
34813204:	e8bd800e 	pop	{r1, r2, r3, pc}

34813208 <part_erase>:

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
34813208:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
3481320c:	e5903004 	ldr	r3, [r0, #4]
	struct mtd_part *part = PART(mtd);
	return part->master->lock_user_prot_reg(part->master, from, len);
}

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
34813210:	e1a07000 	mov	r7, r0
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
34813214:	e3130b01 	tst	r3, #1024	; 0x400
	struct mtd_part *part = PART(mtd);
	return part->master->lock_user_prot_reg(part->master, from, len);
}

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
34813218:	e1a06001 	mov	r6, r1
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
3481321c:	03e0001d 	mvneq	r0, #29

static int part_erase(struct mtd_info *mtd, struct erase_info *instr)
{
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
34813220:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return -EROFS;
	if (instr->addr >= mtd->size)
34813224:	e1c120d8 	ldrd	r2, [r1, #8]
34813228:	e597100c 	ldr	r1, [r7, #12]
3481322c:	e1510003 	cmp	r1, r3
34813230:	8a000003 	bhi	34813244 <part_erase+0x3c>
34813234:	1a00001b 	bne	348132a8 <part_erase+0xa0>
34813238:	e5971008 	ldr	r1, [r7, #8]
3481323c:	e1510002 	cmp	r1, r2
34813240:	9a000018 	bls	348132a8 <part_erase+0xa0>
		return -EINVAL;
	instr->addr += part->offset;
34813244:	e1c70bd0 	ldrd	r0, [r7, #176]	; 0xb0
34813248:	e0900002 	adds	r0, r0, r2
3481324c:	e0a11003 	adc	r1, r1, r3
34813250:	e1c600f8 	strd	r0, [r6, #8]
	ret = part->master->erase(part->master, instr);
34813254:	e59700a8 	ldr	r0, [r7, #168]	; 0xa8
34813258:	e1a01006 	mov	r1, r6
3481325c:	e5903034 	ldr	r3, [r0, #52]	; 0x34
34813260:	e12fff33 	blx	r3
	if (ret) {
34813264:	e3500000 	cmp	r0, #0
34813268:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
3481326c:	e1c621d8 	ldrd	r2, [r6, #24]
34813270:	e3720001 	cmn	r2, #1
34813274:	1a000001 	bne	34813280 <part_erase+0x78>
34813278:	e3730001 	cmn	r3, #1
3481327c:	0a000003 	beq	34813290 <part_erase+0x88>
			instr->fail_addr -= part->offset;
34813280:	e1c74bd0 	ldrd	r4, [r7, #176]	; 0xb0
34813284:	e0522004 	subs	r2, r2, r4
34813288:	e0c33005 	sbc	r3, r3, r5
3481328c:	e1c621f8 	strd	r2, [r6, #24]
		instr->addr -= part->offset;
34813290:	e1c620d8 	ldrd	r2, [r6, #8]
34813294:	e1c74bd0 	ldrd	r4, [r7, #176]	; 0xb0
34813298:	e0522004 	subs	r2, r2, r4
3481329c:	e0c33005 	sbc	r3, r3, r5
348132a0:	e1c620f8 	strd	r2, [r6, #8]
348132a4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
	struct mtd_part *part = PART(mtd);
	int ret;
	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (instr->addr >= mtd->size)
		return -EINVAL;
348132a8:	e3e00015 	mvn	r0, #21
		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
			instr->fail_addr -= part->offset;
		instr->addr -= part->offset;
	}
	return ret;
}
348132ac:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

348132b0 <part_lock>:
	if (instr->callback)
		instr->callback(instr);
}

static int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
348132b0:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
348132b4:	e1cd62d0 	ldrd	r6, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
348132b8:	e1a04002 	mov	r4, r2
348132bc:	e0962004 	adds	r2, r6, r4
	if (instr->callback)
		instr->callback(instr);
}

static int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
348132c0:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
348132c4:	e1a05003 	mov	r5, r3
348132c8:	e590000c 	ldr	r0, [r0, #12]
348132cc:	e0a73005 	adc	r3, r7, r5
348132d0:	e1500003 	cmp	r0, r3
348132d4:	3a00000b 	bcc	34813308 <part_lock+0x58>
348132d8:	1a000002 	bne	348132e8 <part_lock+0x38>
348132dc:	e5910008 	ldr	r0, [r1, #8]
348132e0:	e1500002 	cmp	r0, r2
348132e4:	3a000007 	bcc	34813308 <part_lock+0x58>
		return -EINVAL;
	return part->master->lock(part->master, ofs + part->offset, len);
348132e8:	e1c12bd0 	ldrd	r2, [r1, #176]	; 0xb0
348132ec:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
348132f0:	e1cd60f0 	strd	r6, [sp]
348132f4:	e0922004 	adds	r2, r2, r4
348132f8:	e5901070 	ldr	r1, [r0, #112]	; 0x70
348132fc:	e0a33005 	adc	r3, r3, r5
34813300:	e12fff31 	blx	r1
34813304:	ea000000 	b	3481330c <part_lock+0x5c>

static int part_lock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
		return -EINVAL;
34813308:	e3e00015 	mvn	r0, #21
	return part->master->lock(part->master, ofs + part->offset, len);
}
3481330c:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34813310 <part_unlock>:

static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
34813310:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
34813314:	e1cd62d0 	ldrd	r6, [sp, #32]
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
34813318:	e1a04002 	mov	r4, r2
3481331c:	e0962004 	adds	r2, r6, r4
		return -EINVAL;
	return part->master->lock(part->master, ofs + part->offset, len);
}

static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
34813320:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
34813324:	e1a05003 	mov	r5, r3
34813328:	e590000c 	ldr	r0, [r0, #12]
3481332c:	e0a73005 	adc	r3, r7, r5
34813330:	e1500003 	cmp	r0, r3
34813334:	3a00000b 	bcc	34813368 <part_unlock+0x58>
34813338:	1a000002 	bne	34813348 <part_unlock+0x38>
3481333c:	e5910008 	ldr	r0, [r1, #8]
34813340:	e1500002 	cmp	r0, r2
34813344:	3a000007 	bcc	34813368 <part_unlock+0x58>
		return -EINVAL;
	return part->master->unlock(part->master, ofs + part->offset, len);
34813348:	e1c12bd0 	ldrd	r2, [r1, #176]	; 0xb0
3481334c:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
34813350:	e1cd60f0 	strd	r6, [sp]
34813354:	e0922004 	adds	r2, r2, r4
34813358:	e5901074 	ldr	r1, [r0, #116]	; 0x74
3481335c:	e0a33005 	adc	r3, r3, r5
34813360:	e12fff31 	blx	r1
34813364:	ea000000 	b	3481336c <part_unlock+0x5c>

static int part_unlock(struct mtd_info *mtd, loff_t ofs, uint64_t len)
{
	struct mtd_part *part = PART(mtd);
	if ((len + ofs) > mtd->size)
		return -EINVAL;
34813368:	e3e00015 	mvn	r0, #21
	return part->master->unlock(part->master, ofs + part->offset, len);
}
3481336c:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

34813370 <part_sync>:

static void part_sync(struct mtd_info *mtd)
{
	struct mtd_part *part = PART(mtd);
	part->master->sync(part->master);
34813370:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8
		return -EINVAL;
	return part->master->unlock(part->master, ofs + part->offset, len);
}

static void part_sync(struct mtd_info *mtd)
{
34813374:	e92d4008 	push	{r3, lr}
	struct mtd_part *part = PART(mtd);
	part->master->sync(part->master);
34813378:	e590306c 	ldr	r3, [r0, #108]	; 0x6c
3481337c:	e12fff33 	blx	r3
}
34813380:	e8bd8008 	pop	{r3, pc}

34813384 <part_block_isbad>:

static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
34813384:	e92d4038 	push	{r3, r4, r5, lr}
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
34813388:	e1a05003 	mov	r5, r3
3481338c:	e590300c 	ldr	r3, [r0, #12]
	struct mtd_part *part = PART(mtd);
	part->master->sync(part->master);
}

static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
34813390:	e1a01000 	mov	r1, r0
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
34813394:	e1530005 	cmp	r3, r5
34813398:	e1a04002 	mov	r4, r2
3481339c:	8a000003 	bhi	348133b0 <part_block_isbad+0x2c>
348133a0:	1a000009 	bne	348133cc <part_block_isbad+0x48>
348133a4:	e5903008 	ldr	r3, [r0, #8]
348133a8:	e1530002 	cmp	r3, r2
348133ac:	9a000006 	bls	348133cc <part_block_isbad+0x48>
		return -EINVAL;
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
348133b0:	e59100a8 	ldr	r0, [r1, #168]	; 0xa8
static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
		return -EINVAL;
	ofs += part->offset;
348133b4:	e1c12bd0 	ldrd	r2, [r1, #176]	; 0xb0
	return part->master->block_isbad(part->master, ofs);
348133b8:	e0922004 	adds	r2, r2, r4
348133bc:	e5901078 	ldr	r1, [r0, #120]	; 0x78
348133c0:	e0a33005 	adc	r3, r3, r5
348133c4:	e12fff31 	blx	r1
348133c8:	e8bd8038 	pop	{r3, r4, r5, pc}

static int part_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	if (ofs >= mtd->size)
		return -EINVAL;
348133cc:	e3e00015 	mvn	r0, #21
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
}
348133d0:	e8bd8038 	pop	{r3, r4, r5, pc}

348133d4 <part_block_markbad>:
static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
348133d4:	e5901004 	ldr	r1, [r0, #4]
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
}

static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
348133d8:	e92d4070 	push	{r4, r5, r6, lr}
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
348133dc:	e3110b01 	tst	r1, #1024	; 0x400
	ofs += part->offset;
	return part->master->block_isbad(part->master, ofs);
}

static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
348133e0:	e1a06000 	mov	r6, r0
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
348133e4:	03e0001d 	mvneq	r0, #29
static int part_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
	struct mtd_part *part = PART(mtd);
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
348133e8:	08bd8070 	popeq	{r4, r5, r6, pc}
		return -EROFS;
	if (ofs >= mtd->size)
348133ec:	e1a05003 	mov	r5, r3
348133f0:	e596300c 	ldr	r3, [r6, #12]
348133f4:	e1a04002 	mov	r4, r2
348133f8:	e1530005 	cmp	r3, r5
348133fc:	8a000003 	bhi	34813410 <part_block_markbad+0x3c>
34813400:	1a00000d 	bne	3481343c <part_block_markbad+0x68>
34813404:	e5963008 	ldr	r3, [r6, #8]
34813408:	e1530002 	cmp	r3, r2
3481340c:	9a00000a 	bls	3481343c <part_block_markbad+0x68>
		return -EINVAL;
	ofs += part->offset;
	res = part->master->block_markbad(part->master, ofs);
34813410:	e59600a8 	ldr	r0, [r6, #168]	; 0xa8

	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (ofs >= mtd->size)
		return -EINVAL;
	ofs += part->offset;
34813414:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
	res = part->master->block_markbad(part->master, ofs);
34813418:	e0922004 	adds	r2, r2, r4
3481341c:	e0a33005 	adc	r3, r3, r5
34813420:	e590107c 	ldr	r1, [r0, #124]	; 0x7c
34813424:	e12fff31 	blx	r1
	if (!res)
34813428:	e3500000 	cmp	r0, #0
		mtd->ecc_stats.badblocks++;
3481342c:	05963088 	ldreq	r3, [r6, #136]	; 0x88
34813430:	02833001 	addeq	r3, r3, #1
34813434:	05863088 	streq	r3, [r6, #136]	; 0x88
34813438:	e8bd8070 	pop	{r4, r5, r6, pc}
	int res;

	if (!(mtd->flags & MTD_WRITEABLE))
		return -EROFS;
	if (ofs >= mtd->size)
		return -EINVAL;
3481343c:	e3e00015 	mvn	r0, #21
	ofs += part->offset;
	res = part->master->block_markbad(part->master, ofs);
	if (!res)
		mtd->ecc_stats.badblocks++;
	return res;
}
34813440:	e8bd8070 	pop	{r4, r5, r6, pc}

34813444 <part_read_oob>:
	return res;
}

static int part_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34813444:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	struct mtd_part *part = PART(mtd);
	int res;

	if (from >= mtd->size)
34813448:	e590500c 	ldr	r5, [r0, #12]
	return res;
}

static int part_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
3481344c:	e1a04000 	mov	r4, r0
	struct mtd_part *part = PART(mtd);
	int res;

	if (from >= mtd->size)
34813450:	e1550003 	cmp	r5, r3
	return res;
}

static int part_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34813454:	e59dc020 	ldr	ip, [sp, #32]
	struct mtd_part *part = PART(mtd);
	int res;

	if (from >= mtd->size)
34813458:	e5906008 	ldr	r6, [r0, #8]
3481345c:	8a000002 	bhi	3481346c <part_read_oob+0x28>
34813460:	1a00001f 	bne	348134e4 <part_read_oob+0xa0>
34813464:	e1560002 	cmp	r6, r2
34813468:	9a00001d 	bls	348134e4 <part_read_oob+0xa0>
		return -EINVAL;
	if (ops->datbuf && from + ops->len > mtd->size)
3481346c:	e59c1018 	ldr	r1, [ip, #24]
34813470:	e3510000 	cmp	r1, #0
34813474:	0a000007 	beq	34813498 <part_read_oob+0x54>
34813478:	e59c7004 	ldr	r7, [ip, #4]
3481347c:	e0920007 	adds	r0, r2, r7
34813480:	e2a31000 	adc	r1, r3, #0
34813484:	e1510005 	cmp	r1, r5
34813488:	8a000015 	bhi	348134e4 <part_read_oob+0xa0>
3481348c:	1a000001 	bne	34813498 <part_read_oob+0x54>
34813490:	e1500006 	cmp	r0, r6
34813494:	8a000012 	bhi	348134e4 <part_read_oob+0xa0>
		return -EINVAL;
	res = part->master->read_oob(part->master, from + part->offset, ops);
34813498:	e59400a8 	ldr	r0, [r4, #168]	; 0xa8
3481349c:	e1c46bd0 	ldrd	r6, [r4, #176]	; 0xb0
348134a0:	e58dc000 	str	ip, [sp]
348134a4:	e0922006 	adds	r2, r2, r6
348134a8:	e0a33007 	adc	r3, r3, r7
348134ac:	e590104c 	ldr	r1, [r0, #76]	; 0x4c
348134b0:	e12fff31 	blx	r1

	if (unlikely(res)) {
348134b4:	e3500000 	cmp	r0, #0
348134b8:	0a00000a 	beq	348134e8 <part_read_oob+0xa4>
		if (res == -EUCLEAN)
348134bc:	e3700075 	cmn	r0, #117	; 0x75
			mtd->ecc_stats.corrected++;
348134c0:	05943080 	ldreq	r3, [r4, #128]	; 0x80
348134c4:	02833001 	addeq	r3, r3, #1
348134c8:	05843080 	streq	r3, [r4, #128]	; 0x80
	if (ops->datbuf && from + ops->len > mtd->size)
		return -EINVAL;
	res = part->master->read_oob(part->master, from + part->offset, ops);

	if (unlikely(res)) {
		if (res == -EUCLEAN)
348134cc:	0a000005 	beq	348134e8 <part_read_oob+0xa4>
			mtd->ecc_stats.corrected++;
		if (res == -EBADMSG)
348134d0:	e370004a 	cmn	r0, #74	; 0x4a
			mtd->ecc_stats.failed++;
348134d4:	05943084 	ldreq	r3, [r4, #132]	; 0x84
348134d8:	02833001 	addeq	r3, r3, #1
348134dc:	05843084 	streq	r3, [r4, #132]	; 0x84
348134e0:	ea000000 	b	348134e8 <part_read_oob+0xa4>
	int res;

	if (from >= mtd->size)
		return -EINVAL;
	if (ops->datbuf && from + ops->len > mtd->size)
		return -EINVAL;
348134e4:	e3e00015 	mvn	r0, #21
			mtd->ecc_stats.corrected++;
		if (res == -EBADMSG)
			mtd->ecc_stats.failed++;
	}
	return res;
}
348134e8:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

348134ec <part_read>:
 * to the _real_ device.
 */

static int part_read(struct mtd_info *mtd, loff_t from, size_t len,
		size_t *retlen, u_char *buf)
{
348134ec:	e92d4c7f 	push	{r0, r1, r2, r3, r4, r5, r6, sl, fp, lr}
348134f0:	e1a04000 	mov	r4, r0
	struct mtd_ecc_stats stats;
	int res;

	stats = part->master->ecc_stats;

	if (from >= mtd->size)
348134f4:	e594e00c 	ldr	lr, [r4, #12]
{
	struct mtd_part *part = PART(mtd);
	struct mtd_ecc_stats stats;
	int res;

	stats = part->master->ecc_stats;
348134f8:	e59000a8 	ldr	r0, [r0, #168]	; 0xa8

	if (from >= mtd->size)
348134fc:	e15e0003 	cmp	lr, r3
 * to the _real_ device.
 */

static int part_read(struct mtd_info *mtd, loff_t from, size_t len,
		size_t *retlen, u_char *buf)
{
34813500:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
	struct mtd_part *part = PART(mtd);
	struct mtd_ecc_stats stats;
	int res;

	stats = part->master->ecc_stats;
34813504:	e5905080 	ldr	r5, [r0, #128]	; 0x80
34813508:	e5906084 	ldr	r6, [r0, #132]	; 0x84

	if (from >= mtd->size)
3481350c:	e594c008 	ldr	ip, [r4, #8]
34813510:	8a000002 	bhi	34813520 <part_read+0x34>
34813514:	1a00000a 	bne	34813544 <part_read+0x58>
34813518:	e15c0002 	cmp	ip, r2
3481351c:	9a000008 	bls	34813544 <part_read+0x58>
		len = 0;
	else if (from + len > mtd->size)
34813520:	e092a001 	adds	sl, r2, r1
34813524:	e2a3b000 	adc	fp, r3, #0
34813528:	e15b000e 	cmp	fp, lr
3481352c:	8a000002 	bhi	3481353c <part_read+0x50>
34813530:	1a000004 	bne	34813548 <part_read+0x5c>
34813534:	e15a000c 	cmp	sl, ip
34813538:	9a000002 	bls	34813548 <part_read+0x5c>
		len = mtd->size - from;
3481353c:	e062100c 	rsb	r1, r2, ip
34813540:	ea000000 	b	34813548 <part_read+0x5c>
	int res;

	stats = part->master->ecc_stats;

	if (from >= mtd->size)
		len = 0;
34813544:	e3a01000 	mov	r1, #0
	else if (from + len > mtd->size)
		len = mtd->size - from;
	res = part->master->read(part->master, from + part->offset,
34813548:	e58d1000 	str	r1, [sp]
3481354c:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
34813550:	e1c4abd0 	ldrd	sl, [r4, #176]	; 0xb0
34813554:	e58d1004 	str	r1, [sp, #4]
34813558:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
3481355c:	e092200a 	adds	r2, r2, sl
34813560:	e58d1008 	str	r1, [sp, #8]
34813564:	e0a3300b 	adc	r3, r3, fp
34813568:	e5901040 	ldr	r1, [r0, #64]	; 0x40
3481356c:	e12fff31 	blx	r1
				   len, retlen, buf);
	if (unlikely(res)) {
34813570:	e3500000 	cmp	r0, #0
34813574:	0a000010 	beq	348135bc <part_read+0xd0>
		if (res == -EUCLEAN)
34813578:	e3700075 	cmn	r0, #117	; 0x75
3481357c:	1a000006 	bne	3481359c <part_read+0xb0>
			mtd->ecc_stats.corrected += part->master->ecc_stats.corrected - stats.corrected;
34813580:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
34813584:	e5932080 	ldr	r2, [r3, #128]	; 0x80
34813588:	e5943080 	ldr	r3, [r4, #128]	; 0x80
3481358c:	e0823003 	add	r3, r2, r3
34813590:	e0655003 	rsb	r5, r5, r3
34813594:	e5845080 	str	r5, [r4, #128]	; 0x80
34813598:	ea000007 	b	348135bc <part_read+0xd0>
		if (res == -EBADMSG)
3481359c:	e370004a 	cmn	r0, #74	; 0x4a
348135a0:	1a000005 	bne	348135bc <part_read+0xd0>
			mtd->ecc_stats.failed += part->master->ecc_stats.failed - stats.failed;
348135a4:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
348135a8:	e5932084 	ldr	r2, [r3, #132]	; 0x84
348135ac:	e5943084 	ldr	r3, [r4, #132]	; 0x84
348135b0:	e0823003 	add	r3, r2, r3
348135b4:	e0666003 	rsb	r6, r6, r3
348135b8:	e5846084 	str	r6, [r4, #132]	; 0x84
	}
	return res;
}
348135bc:	e28dd010 	add	sp, sp, #16
348135c0:	e8bd8c70 	pop	{r4, r5, r6, sl, fp, pc}

348135c4 <mtd_erase_callback>:
	return ret;
}

void mtd_erase_callback(struct erase_info *instr)
{
	if (instr->mtd->erase == part_erase) {
348135c4:	e5901000 	ldr	r1, [r0]
	}
	return ret;
}

void mtd_erase_callback(struct erase_info *instr)
{
348135c8:	e92d4038 	push	{r3, r4, r5, lr}
	if (instr->mtd->erase == part_erase) {
348135cc:	e5912034 	ldr	r2, [r1, #52]	; 0x34
348135d0:	e59f3050 	ldr	r3, [pc, #80]	; 34813628 <mtd_erase_callback+0x64>
348135d4:	e1520003 	cmp	r2, r3
348135d8:	1a00000d 	bne	34813614 <mtd_erase_callback+0x50>
		struct mtd_part *part = PART(instr->mtd);

		if (instr->fail_addr != MTD_FAIL_ADDR_UNKNOWN)
348135dc:	e1c021d8 	ldrd	r2, [r0, #24]
348135e0:	e3720001 	cmn	r2, #1
348135e4:	1a000001 	bne	348135f0 <mtd_erase_callback+0x2c>
348135e8:	e3730001 	cmn	r3, #1
348135ec:	0a000003 	beq	34813600 <mtd_erase_callback+0x3c>
			instr->fail_addr -= part->offset;
348135f0:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
348135f4:	e0522004 	subs	r2, r2, r4
348135f8:	e0c33005 	sbc	r3, r3, r5
348135fc:	e1c021f8 	strd	r2, [r0, #24]
		instr->addr -= part->offset;
34813600:	e1c020d8 	ldrd	r2, [r0, #8]
34813604:	e1c14bd0 	ldrd	r4, [r1, #176]	; 0xb0
34813608:	e0522004 	subs	r2, r2, r4
3481360c:	e0c33005 	sbc	r3, r3, r5
34813610:	e1c020f8 	strd	r2, [r0, #8]
	}
	if (instr->callback)
34813614:	e5903030 	ldr	r3, [r0, #48]	; 0x30
34813618:	e3530000 	cmp	r3, #0
3481361c:	08bd8038 	popeq	{r3, r4, r5, pc}
		instr->callback(instr);
34813620:	e12fff33 	blx	r3
34813624:	e8bd8038 	pop	{r3, r4, r5, pc}
34813628:	34813208 	.word	0x34813208

3481362c <del_mtd_partitions>:
 * This function unregisters and destroy all slave MTD objects which are
 * attached to the given master MTD object.
 */

int del_mtd_partitions(struct mtd_info *master)
{
3481362c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	struct mtd_part *slave, *next;

	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
34813630:	e59f7074 	ldr	r7, [pc, #116]	; 348136ac <del_mtd_partitions+0x80>
 * This function unregisters and destroy all slave MTD objects which are
 * attached to the given master MTD object.
 */

int del_mtd_partitions(struct mtd_info *master)
{
34813634:	e1a0a000 	mov	sl, r0
	struct mtd_part *slave, *next;

	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
34813638:	e5974000 	ldr	r4, [r7]
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
3481363c:	e3a06000 	mov	r6, #0
34813640:	e41450bc 	ldr	r5, [r4], #-188	; 0xbc
34813644:	e24550bc 	sub	r5, r5, #188	; 0xbc
34813648:	ea000012 	b	34813698 <del_mtd_partitions+0x6c>
		if (slave->master == master) {
3481364c:	e59430a8 	ldr	r3, [r4, #168]	; 0xa8
34813650:	e153000a 	cmp	r3, sl
34813654:	1a00000c 	bne	3481368c <del_mtd_partitions+0x60>
 * Note: list_empty() on entry does not return true after this, the entry is
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34813658:	e59430c0 	ldr	r3, [r4, #192]	; 0xc0
3481365c:	e59420bc 	ldr	r2, [r4, #188]	; 0xbc
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
34813660:	e5823004 	str	r3, [r2, #4]
	prev->next = next;
34813664:	e5832000 	str	r2, [r3]
			list_del(&slave->list);
			if (slave->registered)
34813668:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
 * in an undefined state.
 */
static inline void list_del(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
	entry->next = LIST_POISON1;
3481366c:	e58460bc 	str	r6, [r4, #188]	; 0xbc
34813670:	e3530000 	cmp	r3, #0
	entry->prev = LIST_POISON2;
34813674:	e58460c0 	str	r6, [r4, #192]	; 0xc0
34813678:	0a000001 	beq	34813684 <del_mtd_partitions+0x58>
				del_mtd_device(&slave->mtd);
3481367c:	e1a00004 	mov	r0, r4
34813680:	ebfffde1 	bl	34812e0c <del_mtd_device>
			kfree(slave);
34813684:	e1a00004 	mov	r0, r4
34813688:	ebffd7f3 	bl	3480965c <free>

int del_mtd_partitions(struct mtd_info *master)
{
	struct mtd_part *slave, *next;

	list_for_each_entry_safe(slave, next, &mtd_partitions, list)
3481368c:	e59530bc 	ldr	r3, [r5, #188]	; 0xbc
34813690:	e1a04005 	mov	r4, r5
34813694:	e24350bc 	sub	r5, r3, #188	; 0xbc
34813698:	e28430bc 	add	r3, r4, #188	; 0xbc
3481369c:	e1570003 	cmp	r7, r3
348136a0:	1affffe9 	bne	3481364c <del_mtd_partitions+0x20>
				del_mtd_device(&slave->mtd);
			kfree(slave);
		}

	return 0;
}
348136a4:	e3a00000 	mov	r0, #0
348136a8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
348136ac:	3482bab4 	.word	0x3482bab4

348136b0 <add_mtd_partitions>:
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
348136b0:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	/*
	 * Need to init the list here, since LIST_INIT() does not
	 * work on platforms where relocation has problems (like MIPS
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
348136b4:	e59f35d4 	ldr	r3, [pc, #1492]	; 34813c90 <add_mtd_partitions+0x5e0>
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
348136b8:	e24dd028 	sub	sp, sp, #40	; 0x28
348136bc:	e58d201c 	str	r2, [sp, #28]
	/*
	 * Need to init the list here, since LIST_INIT() does not
	 * work on platforms where relocation has problems (like MIPS
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
348136c0:	e5932000 	ldr	r2, [r3]
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
348136c4:	e1a04000 	mov	r4, r0
	/*
	 * Need to init the list here, since LIST_INIT() does not
	 * work on platforms where relocation has problems (like MIPS
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
348136c8:	e3520000 	cmp	r2, #0
 */

int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
348136cc:	e1a05001 	mov	r5, r1
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
348136d0:	05833000 	streq	r3, [r3]
	list->prev = list;
348136d4:	05833004 	streq	r3, [r3, #4]
	 * & PPC).
	 */
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);
348136d8:	e59f05b4 	ldr	r0, [pc, #1460]	; 34813c94 <add_mtd_partitions+0x5e4>
348136dc:	e59d101c 	ldr	r1, [sp, #28]
348136e0:	e5942020 	ldr	r2, [r4, #32]
348136e4:	ebffd69e 	bl	34809164 <printf>
 *
 * We don't register the master, or expect the caller to have done so,
 * for reasons of data integrity.
 */

int add_mtd_partitions(struct mtd_info *master,
348136e8:	e2855020 	add	r5, r5, #32
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
348136ec:	e3a07000 	mov	r7, #0
int add_mtd_partitions(struct mtd_info *master,
		       const struct mtd_partition *parts,
		       int nbparts)
{
	struct mtd_part *slave;
	uint64_t cur_offset = 0;
348136f0:	e3a0a000 	mov	sl, #0
348136f4:	e3a0b000 	mov	fp, #0
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
348136f8:	ea00015e 	b	34813c78 <add_mtd_partitions+0x5c8>
		uint64_t cur_offset)
{
	struct mtd_part *slave;

	/* allocate the partition structure */
	slave = kzalloc(sizeof(*slave), GFP_KERNEL);
348136fc:	e3a000c8 	mov	r0, #200	; 0xc8
34813700:	e3a01001 	mov	r1, #1
34813704:	ebffd9ca 	bl	34809e34 <calloc>
	if (!slave) {
34813708:	e2506000 	subs	r6, r0, #0
3481370c:	1a000006 	bne	3481372c <add_mtd_partitions+0x7c>
		printk(KERN_ERR"memory allocation error while creating partitions for \"%s\"\n",
34813710:	e5941020 	ldr	r1, [r4, #32]
34813714:	e59f057c 	ldr	r0, [pc, #1404]	; 34813c98 <add_mtd_partitions+0x5e8>
34813718:	ebffd691 	bl	34809164 <printf>
			master->name);
		del_mtd_partitions(master);
3481371c:	e1a00004 	mov	r0, r4
34813720:	ebffffc1 	bl	3481362c <del_mtd_partitions>
	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
		slave = add_one_partition(master, parts + i, i, cur_offset);
		if (!slave)
			return -ENOMEM;
34813724:	e3e0000b 	mvn	r0, #11
34813728:	ea000156 	b	34813c88 <add_mtd_partitions+0x5d8>
 * Insert a new entry after the specified head.
 * This is good for implementing stacks.
 */
static inline void list_add(struct list_head *new, struct list_head *head)
{
	__list_add(new, head, head->next);
3481372c:	e59f055c 	ldr	r0, [pc, #1372]	; 34813c90 <add_mtd_partitions+0x5e0>
		printk(KERN_ERR"memory allocation error while creating partitions for \"%s\"\n",
			master->name);
		del_mtd_partitions(master);
		return NULL;
	}
	list_add(&slave->list, &mtd_partitions);
34813730:	e28630bc 	add	r3, r6, #188	; 0xbc
34813734:	e5902000 	ldr	r2, [r0]
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
	prev->next = new;
34813738:	e5803000 	str	r3, [r0]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
3481373c:	e5823004 	str	r3, [r2, #4]
	new->next = next;
34813740:	e58620bc 	str	r2, [r6, #188]	; 0xbc
	new->prev = prev;
34813744:	e58600c0 	str	r0, [r6, #192]	; 0xc0

	/* set up the MTD object for this partition */
	slave->mtd.type = master->type;
34813748:	e5d43000 	ldrb	r3, [r4]
	slave->mtd.subpage_sft = master->subpage_sft;

	slave->mtd.name = part->name;
	slave->mtd.owner = master->owner;

	slave->mtd.read = part_read;
3481374c:	e59f1548 	ldr	r1, [pc, #1352]	; 34813c9c <add_mtd_partitions+0x5ec>
		return NULL;
	}
	list_add(&slave->list, &mtd_partitions);

	/* set up the MTD object for this partition */
	slave->mtd.type = master->type;
34813750:	e5c63000 	strb	r3, [r6]
	slave->mtd.flags = master->flags & ~part->mask_flags;
34813754:	e5152008 	ldr	r2, [r5, #-8]
34813758:	e5943004 	ldr	r3, [r4, #4]
3481375c:	e1c33002 	bic	r3, r3, r2
34813760:	e5863004 	str	r3, [r6, #4]
	slave->mtd.size = part->size;
34813764:	e14521d8 	ldrd	r2, [r5, #-24]	; 0xffffffe8
34813768:	e1c620f8 	strd	r2, [r6, #8]
	slave->mtd.writesize = master->writesize;
3481376c:	e5943014 	ldr	r3, [r4, #20]

	slave->mtd.name = part->name;
	slave->mtd.owner = master->owner;

	slave->mtd.read = part_read;
	slave->mtd.write = part_write;
34813770:	e59f2528 	ldr	r2, [pc, #1320]	; 34813ca0 <add_mtd_partitions+0x5f0>

	/* set up the MTD object for this partition */
	slave->mtd.type = master->type;
	slave->mtd.flags = master->flags & ~part->mask_flags;
	slave->mtd.size = part->size;
	slave->mtd.writesize = master->writesize;
34813774:	e5863014 	str	r3, [r6, #20]
	slave->mtd.oobsize = master->oobsize;
34813778:	e5943018 	ldr	r3, [r4, #24]
3481377c:	e5863018 	str	r3, [r6, #24]
	slave->mtd.oobavail = master->oobavail;
34813780:	e594301c 	ldr	r3, [r4, #28]
34813784:	e586301c 	str	r3, [r6, #28]
	slave->mtd.subpage_sft = master->subpage_sft;
34813788:	e5943090 	ldr	r3, [r4, #144]	; 0x90
3481378c:	e5863090 	str	r3, [r6, #144]	; 0x90

	slave->mtd.name = part->name;
34813790:	e5153020 	ldr	r3, [r5, #-32]
	slave->mtd.owner = master->owner;

	slave->mtd.read = part_read;
34813794:	e5861040 	str	r1, [r6, #64]	; 0x40
	slave->mtd.writesize = master->writesize;
	slave->mtd.oobsize = master->oobsize;
	slave->mtd.oobavail = master->oobavail;
	slave->mtd.subpage_sft = master->subpage_sft;

	slave->mtd.name = part->name;
34813798:	e5863020 	str	r3, [r6, #32]
	slave->mtd.owner = master->owner;
3481379c:	e5943098 	ldr	r3, [r4, #152]	; 0x98

	slave->mtd.read = part_read;
	slave->mtd.write = part_write;
348137a0:	e5862044 	str	r2, [r6, #68]	; 0x44
	slave->mtd.oobsize = master->oobsize;
	slave->mtd.oobavail = master->oobavail;
	slave->mtd.subpage_sft = master->subpage_sft;

	slave->mtd.name = part->name;
	slave->mtd.owner = master->owner;
348137a4:	e5863098 	str	r3, [r6, #152]	; 0x98

	slave->mtd.read = part_read;
	slave->mtd.write = part_write;

	if (master->panic_write)
348137a8:	e5943048 	ldr	r3, [r4, #72]	; 0x48
348137ac:	e3530000 	cmp	r3, #0
		slave->mtd.panic_write = part_panic_write;
348137b0:	159f34ec 	ldrne	r3, [pc, #1260]	; 34813ca4 <add_mtd_partitions+0x5f4>
348137b4:	15863048 	strne	r3, [r6, #72]	; 0x48

	if (master->read_oob)
348137b8:	e594304c 	ldr	r3, [r4, #76]	; 0x4c
348137bc:	e3530000 	cmp	r3, #0
		slave->mtd.read_oob = part_read_oob;
348137c0:	159f04e0 	ldrne	r0, [pc, #1248]	; 34813ca8 <add_mtd_partitions+0x5f8>
	if (master->write_oob)
348137c4:	e5943050 	ldr	r3, [r4, #80]	; 0x50

	if (master->panic_write)
		slave->mtd.panic_write = part_panic_write;

	if (master->read_oob)
		slave->mtd.read_oob = part_read_oob;
348137c8:	1586004c 	strne	r0, [r6, #76]	; 0x4c
	if (master->write_oob)
348137cc:	e3530000 	cmp	r3, #0
		slave->mtd.write_oob = part_write_oob;
348137d0:	159f14d4 	ldrne	r1, [pc, #1236]	; 34813cac <add_mtd_partitions+0x5fc>
	if (master->read_user_prot_reg)
348137d4:	e5943060 	ldr	r3, [r4, #96]	; 0x60
		slave->mtd.panic_write = part_panic_write;

	if (master->read_oob)
		slave->mtd.read_oob = part_read_oob;
	if (master->write_oob)
		slave->mtd.write_oob = part_write_oob;
348137d8:	15861050 	strne	r1, [r6, #80]	; 0x50
	if (master->read_user_prot_reg)
348137dc:	e3530000 	cmp	r3, #0
		slave->mtd.read_user_prot_reg = part_read_user_prot_reg;
348137e0:	159f24c8 	ldrne	r2, [pc, #1224]	; 34813cb0 <add_mtd_partitions+0x600>
348137e4:	15862060 	strne	r2, [r6, #96]	; 0x60
	if (master->read_fact_prot_reg)
348137e8:	e5943058 	ldr	r3, [r4, #88]	; 0x58
		slave->mtd.block_isbad = part_block_isbad;
	if (master->block_markbad)
		slave->mtd.block_markbad = part_block_markbad;
	slave->mtd.erase = part_erase;
	slave->master = master;
	slave->offset = part->offset;
348137ec:	e5152010 	ldr	r2, [r5, #-16]
		slave->mtd.read_oob = part_read_oob;
	if (master->write_oob)
		slave->mtd.write_oob = part_write_oob;
	if (master->read_user_prot_reg)
		slave->mtd.read_user_prot_reg = part_read_user_prot_reg;
	if (master->read_fact_prot_reg)
348137f0:	e3530000 	cmp	r3, #0
		slave->mtd.read_fact_prot_reg = part_read_fact_prot_reg;
348137f4:	159f34b8 	ldrne	r3, [pc, #1208]	; 34813cb4 <add_mtd_partitions+0x604>
348137f8:	15863058 	strne	r3, [r6, #88]	; 0x58
	if (master->write_user_prot_reg)
348137fc:	e5943064 	ldr	r3, [r4, #100]	; 0x64
34813800:	e3530000 	cmp	r3, #0
		slave->mtd.write_user_prot_reg = part_write_user_prot_reg;
34813804:	159f34ac 	ldrne	r3, [pc, #1196]	; 34813cb8 <add_mtd_partitions+0x608>
34813808:	15863064 	strne	r3, [r6, #100]	; 0x64
	if (master->lock_user_prot_reg)
3481380c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34813810:	e3530000 	cmp	r3, #0
		slave->mtd.lock_user_prot_reg = part_lock_user_prot_reg;
34813814:	159f34a0 	ldrne	r3, [pc, #1184]	; 34813cbc <add_mtd_partitions+0x60c>
34813818:	15863068 	strne	r3, [r6, #104]	; 0x68
	if (master->get_user_prot_info)
3481381c:	e594305c 	ldr	r3, [r4, #92]	; 0x5c
34813820:	e3530000 	cmp	r3, #0
		slave->mtd.get_user_prot_info = part_get_user_prot_info;
34813824:	159f3494 	ldrne	r3, [pc, #1172]	; 34813cc0 <add_mtd_partitions+0x610>
34813828:	1586305c 	strne	r3, [r6, #92]	; 0x5c
	if (master->get_fact_prot_info)
3481382c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34813830:	e3530000 	cmp	r3, #0
		slave->mtd.get_fact_prot_info = part_get_fact_prot_info;
34813834:	159f3488 	ldrne	r3, [pc, #1160]	; 34813cc4 <add_mtd_partitions+0x614>
34813838:	15863054 	strne	r3, [r6, #84]	; 0x54
	if (master->sync)
3481383c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34813840:	e3530000 	cmp	r3, #0
		slave->mtd.sync = part_sync;
34813844:	159f347c 	ldrne	r3, [pc, #1148]	; 34813cc8 <add_mtd_partitions+0x618>
34813848:	1586306c 	strne	r3, [r6, #108]	; 0x6c
	if (master->lock)
3481384c:	e5943070 	ldr	r3, [r4, #112]	; 0x70
34813850:	e3530000 	cmp	r3, #0
		slave->mtd.lock = part_lock;
34813854:	159f3470 	ldrne	r3, [pc, #1136]	; 34813ccc <add_mtd_partitions+0x61c>
34813858:	15863070 	strne	r3, [r6, #112]	; 0x70
	if (master->unlock)
3481385c:	e5943074 	ldr	r3, [r4, #116]	; 0x74
34813860:	e3530000 	cmp	r3, #0
		slave->mtd.unlock = part_unlock;
34813864:	159f3464 	ldrne	r3, [pc, #1124]	; 34813cd0 <add_mtd_partitions+0x620>
34813868:	15863074 	strne	r3, [r6, #116]	; 0x74
	if (master->block_isbad)
3481386c:	e5943078 	ldr	r3, [r4, #120]	; 0x78
34813870:	e3530000 	cmp	r3, #0
		slave->mtd.block_isbad = part_block_isbad;
34813874:	159f3458 	ldrne	r3, [pc, #1112]	; 34813cd4 <add_mtd_partitions+0x624>
34813878:	15863078 	strne	r3, [r6, #120]	; 0x78
	if (master->block_markbad)
3481387c:	e594307c 	ldr	r3, [r4, #124]	; 0x7c
		slave->mtd.block_markbad = part_block_markbad;
	slave->mtd.erase = part_erase;
	slave->master = master;
34813880:	e58640a8 	str	r4, [r6, #168]	; 0xa8
		slave->mtd.lock = part_lock;
	if (master->unlock)
		slave->mtd.unlock = part_unlock;
	if (master->block_isbad)
		slave->mtd.block_isbad = part_block_isbad;
	if (master->block_markbad)
34813884:	e3530000 	cmp	r3, #0
		slave->mtd.block_markbad = part_block_markbad;
34813888:	159f3448 	ldrne	r3, [pc, #1096]	; 34813cd8 <add_mtd_partitions+0x628>
3481388c:	1586307c 	strne	r3, [r6, #124]	; 0x7c
	slave->mtd.erase = part_erase;
34813890:	e59f3444 	ldr	r3, [pc, #1092]	; 34813cdc <add_mtd_partitions+0x62c>
	slave->master = master;
	slave->offset = part->offset;
	slave->index = partno;

	if (slave->offset == MTDPART_OFS_APPEND)
34813894:	e3720001 	cmn	r2, #1
		slave->mtd.unlock = part_unlock;
	if (master->block_isbad)
		slave->mtd.block_isbad = part_block_isbad;
	if (master->block_markbad)
		slave->mtd.block_markbad = part_block_markbad;
	slave->mtd.erase = part_erase;
34813898:	e5863034 	str	r3, [r6, #52]	; 0x34
	slave->master = master;
	slave->offset = part->offset;
3481389c:	e515300c 	ldr	r3, [r5, #-12]
348138a0:	e58620b0 	str	r2, [r6, #176]	; 0xb0
348138a4:	e58630b4 	str	r3, [r6, #180]	; 0xb4
	slave->index = partno;
348138a8:	e58670b8 	str	r7, [r6, #184]	; 0xb8

	if (slave->offset == MTDPART_OFS_APPEND)
348138ac:	1a000001 	bne	348138b8 <add_mtd_partitions+0x208>
348138b0:	e3730001 	cmn	r3, #1
		slave->offset = cur_offset;
348138b4:	01c6abf0 	strdeq	sl, [r6, #176]	; 0xb0
	if (slave->offset == MTDPART_OFS_NXTBLK) {
348138b8:	e59630b0 	ldr	r3, [r6, #176]	; 0xb0
348138bc:	e3730002 	cmn	r3, #2
348138c0:	1a000027 	bne	34813964 <add_mtd_partitions+0x2b4>
348138c4:	e59630b4 	ldr	r3, [r6, #180]	; 0xb4
348138c8:	e3730001 	cmn	r3, #1
348138cc:	1a000024 	bne	34813964 <add_mtd_partitions+0x2b4>
	return sz;
}

static inline uint32_t mtd_mod_by_eb(uint64_t sz, struct mtd_info *mtd)
{
	return do_div(sz, mtd->erasesize);
348138d0:	e25b9000 	subs	r9, fp, #0
		slave->offset = cur_offset;
348138d4:	e1c6abf0 	strd	sl, [r6, #176]	; 0xb0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
348138d8:	e5941010 	ldr	r1, [r4, #16]
348138dc:	e1cda2f0 	strd	sl, [sp, #32]
348138e0:	1a000002 	bne	348138f0 <add_mtd_partitions+0x240>
348138e4:	e1a0000a 	mov	r0, sl
348138e8:	eb003127 	bl	3481fd8c <__aeabi_uidivmod>
348138ec:	ea000002 	b	348138fc <add_mtd_partitions+0x24c>
348138f0:	e28d0020 	add	r0, sp, #32
348138f4:	eb001ad1 	bl	3481a440 <__div64_32>
348138f8:	e1a01000 	mov	r1, r0

	if (slave->offset == MTDPART_OFS_APPEND)
		slave->offset = cur_offset;
	if (slave->offset == MTDPART_OFS_NXTBLK) {
		slave->offset = cur_offset;
		if (mtd_mod_by_eb(cur_offset, master) != 0) {
348138fc:	e3510000 	cmp	r1, #0
34813900:	0a000017 	beq	34813964 <add_mtd_partitions+0x2b4>
	void (*put_device) (struct mtd_info *mtd);
};

static inline uint32_t mtd_div_by_eb(uint64_t sz, struct mtd_info *mtd)
{
	do_div(sz, mtd->erasesize);
34813904:	e3590000 	cmp	r9, #0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
34813908:	e5941010 	ldr	r1, [r4, #16]
3481390c:	e1cda2f0 	strd	sl, [sp, #32]
34813910:	1a000004 	bne	34813928 <add_mtd_partitions+0x278>
34813914:	e1a0000a 	mov	r0, sl
34813918:	eb0030a0 	bl	3481fba0 <__udivsi3>
3481391c:	e58d9024 	str	r9, [sp, #36]	; 0x24
34813920:	e58d0020 	str	r0, [sp, #32]
34813924:	ea000001 	b	34813930 <add_mtd_partitions+0x280>
34813928:	e28d0020 	add	r0, sp, #32
3481392c:	eb001ac3 	bl	3481a440 <__div64_32>
		slave->offset = cur_offset;
	if (slave->offset == MTDPART_OFS_NXTBLK) {
		slave->offset = cur_offset;
		if (mtd_mod_by_eb(cur_offset, master) != 0) {
			/* Round up to next erasesize */
			slave->offset = (mtd_div_by_eb(cur_offset, master) + 1) * master->erasesize;
34813930:	e59d2020 	ldr	r2, [sp, #32]
34813934:	e5943010 	ldr	r3, [r4, #16]
34813938:	e2822001 	add	r2, r2, #1
3481393c:	e0020293 	mul	r2, r3, r2
34813940:	e3a03000 	mov	r3, #0
34813944:	e58620b0 	str	r2, [r6, #176]	; 0xb0
34813948:	e58630b4 	str	r3, [r6, #180]	; 0xb4
			printk(KERN_NOTICE "Moving partition %d: "
3481394c:	e59f038c 	ldr	r0, [pc, #908]	; 34813ce0 <add_mtd_partitions+0x630>
34813950:	e88d000c 	stm	sp, {r2, r3}
34813954:	e1a01007 	mov	r1, r7
34813958:	e1a0200a 	mov	r2, sl
3481395c:	e1a0300b 	mov	r3, fp
34813960:	ebffd5ff 	bl	34809164 <printf>
			       "0x%012llx -> 0x%012llx\n", partno,
			       (unsigned long long)cur_offset, (unsigned long long)slave->offset);
		}
	}
	if (slave->mtd.size == MTDPART_SIZ_FULL)
34813964:	e5962008 	ldr	r2, [r6, #8]
34813968:	e596300c 	ldr	r3, [r6, #12]
3481396c:	e1923003 	orrs	r3, r2, r3
34813970:	1a000004 	bne	34813988 <add_mtd_partitions+0x2d8>
		slave->mtd.size = master->size - slave->offset;
34813974:	e1c400d8 	ldrd	r0, [r4, #8]
34813978:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
3481397c:	e0500002 	subs	r0, r0, r2
34813980:	e0c11003 	sbc	r1, r1, r3
34813984:	e1c600f8 	strd	r0, [r6, #8]

	printk(KERN_NOTICE "0x%012llx-0x%012llx : \"%s\"\n", (unsigned long long)slave->offset,
		(unsigned long long)(slave->offset + slave->mtd.size), slave->mtd.name);
34813988:	e1c6abd0 	ldrd	sl, [r6, #176]	; 0xb0
		}
	}
	if (slave->mtd.size == MTDPART_SIZ_FULL)
		slave->mtd.size = master->size - slave->offset;

	printk(KERN_NOTICE "0x%012llx-0x%012llx : \"%s\"\n", (unsigned long long)slave->offset,
3481398c:	e1c620d8 	ldrd	r2, [r6, #8]
34813990:	e092200a 	adds	r2, r2, sl
34813994:	e0a3300b 	adc	r3, r3, fp
34813998:	e1cd20f0 	strd	r2, [sp]
3481399c:	e5963020 	ldr	r3, [r6, #32]
348139a0:	e1a0200a 	mov	r2, sl
348139a4:	e58d3008 	str	r3, [sp, #8]
348139a8:	e59f0334 	ldr	r0, [pc, #820]	; 34813ce4 <add_mtd_partitions+0x634>
348139ac:	e1a0300b 	mov	r3, fp
348139b0:	ebffd5eb 	bl	34809164 <printf>
		(unsigned long long)(slave->offset + slave->mtd.size), slave->mtd.name);

	/* let's do some sanity checks */
	if (slave->offset >= master->size) {
348139b4:	e1c6abd0 	ldrd	sl, [r6, #176]	; 0xb0
348139b8:	e1c400d8 	ldrd	r0, [r4, #8]
348139bc:	e151000b 	cmp	r1, fp
348139c0:	8a00000a 	bhi	348139f0 <add_mtd_partitions+0x340>
348139c4:	1a000001 	bne	348139d0 <add_mtd_partitions+0x320>
348139c8:	e150000a 	cmp	r0, sl
348139cc:	8a000007 	bhi	348139f0 <add_mtd_partitions+0x340>
		/* let's register it anyway to preserve ordering */
		slave->offset = 0;
348139d0:	e3a02000 	mov	r2, #0
348139d4:	e3a03000 	mov	r3, #0
348139d8:	e1c62bf0 	strd	r2, [r6, #176]	; 0xb0
		slave->mtd.size = 0;
348139dc:	e1c620f8 	strd	r2, [r6, #8]
		printk(KERN_ERR"mtd: partition \"%s\" is out of reach -- disabled\n",
348139e0:	e5151020 	ldr	r1, [r5, #-32]
348139e4:	e59f02fc 	ldr	r0, [pc, #764]	; 34813ce8 <add_mtd_partitions+0x638>
348139e8:	ebffd5dd 	bl	34809164 <printf>
348139ec:	ea000092 	b	34813c3c <add_mtd_partitions+0x58c>
			part->name);
		goto out_register;
	}
	if (slave->offset + slave->mtd.size > master->size) {
348139f0:	e1c620d8 	ldrd	r2, [r6, #8]
348139f4:	e092200a 	adds	r2, r2, sl
348139f8:	e0a3300b 	adc	r3, r3, fp
348139fc:	e1530001 	cmp	r3, r1
34813a00:	8a000002 	bhi	34813a10 <add_mtd_partitions+0x360>
34813a04:	1a000009 	bne	34813a30 <add_mtd_partitions+0x380>
34813a08:	e1520000 	cmp	r2, r0
34813a0c:	9a000007 	bls	34813a30 <add_mtd_partitions+0x380>
		slave->mtd.size = master->size - slave->offset;
34813a10:	e050000a 	subs	r0, r0, sl
34813a14:	e0c1100b 	sbc	r1, r1, fp
34813a18:	e1c600f8 	strd	r0, [r6, #8]
		printk(KERN_WARNING"mtd: partition \"%s\" extends beyond the end of device \"%s\" -- size truncated to %#llx\n",
34813a1c:	e1cd00f0 	strd	r0, [sp]
34813a20:	e5942020 	ldr	r2, [r4, #32]
34813a24:	e59f02c0 	ldr	r0, [pc, #704]	; 34813cec <add_mtd_partitions+0x63c>
34813a28:	e5151020 	ldr	r1, [r5, #-32]
34813a2c:	ebffd5cc 	bl	34809164 <printf>
			part->name, master->name, (unsigned long long)slave->mtd.size);
	}
	if (master->numeraseregions > 1) {
34813a30:	e594a02c 	ldr	sl, [r4, #44]	; 0x2c
34813a34:	e35a0001 	cmp	sl, #1
34813a38:	da000033 	ble	34813b0c <add_mtd_partitions+0x45c>
		/* Deal with variable erase size stuff */
		int i, max = master->numeraseregions;
		u64 end = slave->offset + slave->mtd.size;
34813a3c:	e1c60bd0 	ldrd	r0, [r6, #176]	; 0xb0
34813a40:	e1c620d8 	ldrd	r2, [r6, #8]
34813a44:	e1cd01f0 	strd	r0, [sp, #16]
34813a48:	e0922000 	adds	r2, r2, r0
		struct mtd_erase_region_info *regions = master->eraseregions;
34813a4c:	e3a00000 	mov	r0, #0
			part->name, master->name, (unsigned long long)slave->mtd.size);
	}
	if (master->numeraseregions > 1) {
		/* Deal with variable erase size stuff */
		int i, max = master->numeraseregions;
		u64 end = slave->offset + slave->mtd.size;
34813a50:	e0a33001 	adc	r3, r3, r1
		struct mtd_erase_region_info *regions = master->eraseregions;
34813a54:	e594c030 	ldr	ip, [r4, #48]	; 0x30

		/* Find the first erase regions which is part of this
		 * partition. */
		for (i = 0; i < max && regions[i].offset <= slave->offset; i++)
34813a58:	e1a01000 	mov	r1, r0
34813a5c:	ea000003 	b	34813a70 <add_mtd_partitions+0x3c0>
34813a60:	e2811001 	add	r1, r1, #1
34813a64:	e151000a 	cmp	r1, sl
34813a68:	e2800018 	add	r0, r0, #24
34813a6c:	aa000009 	bge	34813a98 <add_mtd_partitions+0x3e8>
34813a70:	e08c9000 	add	r9, ip, r0
34813a74:	e5999004 	ldr	r9, [r9, #4]
34813a78:	e59db014 	ldr	fp, [sp, #20]
34813a7c:	e159000b 	cmp	r9, fp
34813a80:	8a000004 	bhi	34813a98 <add_mtd_partitions+0x3e8>
34813a84:	1afffff5 	bne	34813a60 <add_mtd_partitions+0x3b0>
34813a88:	e79c9000 	ldr	r9, [ip, r0]
34813a8c:	e59db010 	ldr	fp, [sp, #16]
34813a90:	e159000b 	cmp	r9, fp
34813a94:	9afffff1 	bls	34813a60 <add_mtd_partitions+0x3b0>
 *
 * We don't register the master, or expect the caller to have done so,
 * for reasons of data integrity.
 */

int add_mtd_partitions(struct mtd_info *master,
34813a98:	e3a09018 	mov	r9, #24
		/* Find the first erase regions which is part of this
		 * partition. */
		for (i = 0; i < max && regions[i].offset <= slave->offset; i++)
			;
		/* The loop searched for the region _behind_ the first one */
		i--;
34813a9c:	e2410001 	sub	r0, r1, #1
 *
 * We don't register the master, or expect the caller to have done so,
 * for reasons of data integrity.
 */

int add_mtd_partitions(struct mtd_info *master,
34813aa0:	e021c199 	mla	r1, r9, r1, ip
34813aa4:	ea000005 	b	34813ac0 <add_mtd_partitions+0x410>
		/* The loop searched for the region _behind_ the first one */
		i--;

		/* Pick biggest erasesize */
		for (; i < max && regions[i].offset < end; i++) {
			if (slave->mtd.erasesize < regions[i].erasesize) {
34813aa8:	e511c010 	ldr	ip, [r1, #-16]
34813aac:	e5969010 	ldr	r9, [r6, #16]
			;
		/* The loop searched for the region _behind_ the first one */
		i--;

		/* Pick biggest erasesize */
		for (; i < max && regions[i].offset < end; i++) {
34813ab0:	e2800001 	add	r0, r0, #1
			if (slave->mtd.erasesize < regions[i].erasesize) {
34813ab4:	e159000c 	cmp	r9, ip
				slave->mtd.erasesize = regions[i].erasesize;
34813ab8:	3586c010 	strcc	ip, [r6, #16]
			;
		/* The loop searched for the region _behind_ the first one */
		i--;

		/* Pick biggest erasesize */
		for (; i < max && regions[i].offset < end; i++) {
34813abc:	e2811018 	add	r1, r1, #24
34813ac0:	e150000a 	cmp	r0, sl
34813ac4:	aa000006 	bge	34813ae4 <add_mtd_partitions+0x434>
34813ac8:	e511c014 	ldr	ip, [r1, #-20]
34813acc:	e15c0003 	cmp	ip, r3
34813ad0:	3afffff4 	bcc	34813aa8 <add_mtd_partitions+0x3f8>
34813ad4:	1a000002 	bne	34813ae4 <add_mtd_partitions+0x434>
34813ad8:	e511c018 	ldr	ip, [r1, #-24]
34813adc:	e15c0002 	cmp	ip, r2
34813ae0:	3afffff0 	bcc	34813aa8 <add_mtd_partitions+0x3f8>
			if (slave->mtd.erasesize < regions[i].erasesize) {
				slave->mtd.erasesize = regions[i].erasesize;
			}
		}
		BUG_ON(slave->mtd.erasesize == 0);
34813ae4:	e5963010 	ldr	r3, [r6, #16]
34813ae8:	e3530000 	cmp	r3, #0
34813aec:	1a000008 	bne	34813b14 <add_mtd_partitions+0x464>
34813af0:	e59f01f8 	ldr	r0, [pc, #504]	; 34813cf0 <add_mtd_partitions+0x640>
34813af4:	e59f11f8 	ldr	r1, [pc, #504]	; 34813cf4 <add_mtd_partitions+0x644>
34813af8:	e300218a 	movw	r2, #394	; 0x18a
34813afc:	e59f31f4 	ldr	r3, [pc, #500]	; 34813cf8 <add_mtd_partitions+0x648>
34813b00:	ebffd597 	bl	34809164 <printf>
34813b04:	e59f01f0 	ldr	r0, [pc, #496]	; 34813cfc <add_mtd_partitions+0x64c>
34813b08:	eb00248f 	bl	3481cd4c <panic>
	} else {
		/* Single erase size */
		slave->mtd.erasesize = master->erasesize;
34813b0c:	e5943010 	ldr	r3, [r4, #16]
34813b10:	e5863010 	str	r3, [r6, #16]
	}

	if ((slave->mtd.flags & MTD_WRITEABLE) &&
34813b14:	e5963004 	ldr	r3, [r6, #4]
34813b18:	e3130b01 	tst	r3, #1024	; 0x400
34813b1c:	0a000013 	beq	34813b70 <add_mtd_partitions+0x4c0>
	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
34813b20:	e59630b4 	ldr	r3, [r6, #180]	; 0xb4
34813b24:	e59600b0 	ldr	r0, [r6, #176]	; 0xb0
	return sz;
}

static inline uint32_t mtd_mod_by_eb(uint64_t sz, struct mtd_info *mtd)
{
	return do_div(sz, mtd->erasesize);
34813b28:	e3530000 	cmp	r3, #0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
34813b2c:	e5961010 	ldr	r1, [r6, #16]
34813b30:	e58d0020 	str	r0, [sp, #32]
34813b34:	e58d3024 	str	r3, [sp, #36]	; 0x24
34813b38:	1a000001 	bne	34813b44 <add_mtd_partitions+0x494>
34813b3c:	eb003092 	bl	3481fd8c <__aeabi_uidivmod>
34813b40:	ea000002 	b	34813b50 <add_mtd_partitions+0x4a0>
34813b44:	e28d0020 	add	r0, sp, #32
34813b48:	eb001a3c 	bl	3481a440 <__div64_32>
34813b4c:	e1a01000 	mov	r1, r0
	} else {
		/* Single erase size */
		slave->mtd.erasesize = master->erasesize;
	}

	if ((slave->mtd.flags & MTD_WRITEABLE) &&
34813b50:	e3510000 	cmp	r1, #0
34813b54:	0a000005 	beq	34813b70 <add_mtd_partitions+0x4c0>
	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
		/* Doesn't start on a boundary of major erase size */
		/* FIXME: Let it be writable if it is on a boundary of
		 * _minor_ erase size though */
		slave->mtd.flags &= ~MTD_WRITEABLE;
34813b58:	e5963004 	ldr	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
34813b5c:	e59f019c 	ldr	r0, [pc, #412]	; 34813d00 <add_mtd_partitions+0x650>
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
	    mtd_mod_by_eb(slave->offset, &slave->mtd)) {
		/* Doesn't start on a boundary of major erase size */
		/* FIXME: Let it be writable if it is on a boundary of
		 * _minor_ erase size though */
		slave->mtd.flags &= ~MTD_WRITEABLE;
34813b60:	e3c33b01 	bic	r3, r3, #1024	; 0x400
34813b64:	e5863004 	str	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
34813b68:	e5151020 	ldr	r1, [r5, #-32]
34813b6c:	ebffd57c 	bl	34809164 <printf>
			part->name);
	}
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
34813b70:	e5963004 	ldr	r3, [r6, #4]
34813b74:	e3130b01 	tst	r3, #1024	; 0x400
34813b78:	0a000013 	beq	34813bcc <add_mtd_partitions+0x51c>
	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
34813b7c:	e596300c 	ldr	r3, [r6, #12]
34813b80:	e5960008 	ldr	r0, [r6, #8]
34813b84:	e3530000 	cmp	r3, #0
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
}
34813b88:	e5961010 	ldr	r1, [r6, #16]
34813b8c:	e58d0020 	str	r0, [sp, #32]
34813b90:	e58d3024 	str	r3, [sp, #36]	; 0x24
34813b94:	1a000001 	bne	34813ba0 <add_mtd_partitions+0x4f0>
34813b98:	eb00307b 	bl	3481fd8c <__aeabi_uidivmod>
34813b9c:	ea000002 	b	34813bac <add_mtd_partitions+0x4fc>
34813ba0:	e28d0020 	add	r0, sp, #32
34813ba4:	eb001a25 	bl	3481a440 <__div64_32>
34813ba8:	e1a01000 	mov	r1, r0
		 * _minor_ erase size though */
		slave->mtd.flags &= ~MTD_WRITEABLE;
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
			part->name);
	}
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
34813bac:	e3510000 	cmp	r1, #0
34813bb0:	0a000005 	beq	34813bcc <add_mtd_partitions+0x51c>
	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
		slave->mtd.flags &= ~MTD_WRITEABLE;
34813bb4:	e5963004 	ldr	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
34813bb8:	e59f0144 	ldr	r0, [pc, #324]	; 34813d04 <add_mtd_partitions+0x654>
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't start on an erase block boundary -- force read-only\n",
			part->name);
	}
	if ((slave->mtd.flags & MTD_WRITEABLE) &&
	    mtd_mod_by_eb(slave->mtd.size, &slave->mtd)) {
		slave->mtd.flags &= ~MTD_WRITEABLE;
34813bbc:	e3c33b01 	bic	r3, r3, #1024	; 0x400
34813bc0:	e5863004 	str	r3, [r6, #4]
		printk(KERN_WARNING"mtd: partition \"%s\" doesn't end on an erase block -- force read-only\n",
34813bc4:	e5151020 	ldr	r1, [r5, #-32]
34813bc8:	ebffd565 	bl	34809164 <printf>
			part->name);
	}

	slave->mtd.ecclayout = master->ecclayout;
34813bcc:	e5943028 	ldr	r3, [r4, #40]	; 0x28
34813bd0:	e5863028 	str	r3, [r6, #40]	; 0x28
	if (master->block_isbad) {
34813bd4:	e5943078 	ldr	r3, [r4, #120]	; 0x78
34813bd8:	e3530000 	cmp	r3, #0
34813bdc:	13a0a000 	movne	sl, #0
34813be0:	13a0b000 	movne	fp, #0
34813be4:	1a00000d 	bne	34813c20 <add_mtd_partitions+0x570>
34813be8:	ea000013 	b	34813c3c <add_mtd_partitions+0x58c>
		uint64_t offs = 0;

		while (offs < slave->mtd.size) {
			if (master->block_isbad(master,
						offs + slave->offset))
34813bec:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
	slave->mtd.ecclayout = master->ecclayout;
	if (master->block_isbad) {
		uint64_t offs = 0;

		while (offs < slave->mtd.size) {
			if (master->block_isbad(master,
34813bf0:	e092200a 	adds	r2, r2, sl
34813bf4:	e0a3300b 	adc	r3, r3, fp
34813bf8:	e5941078 	ldr	r1, [r4, #120]	; 0x78
34813bfc:	e1a00004 	mov	r0, r4
34813c00:	e12fff31 	blx	r1
34813c04:	e3500000 	cmp	r0, #0
						offs + slave->offset))
				slave->mtd.ecc_stats.badblocks++;
34813c08:	15963088 	ldrne	r3, [r6, #136]	; 0x88
34813c0c:	12833001 	addne	r3, r3, #1
34813c10:	15863088 	strne	r3, [r6, #136]	; 0x88
			offs += slave->mtd.erasesize;
34813c14:	e5963010 	ldr	r3, [r6, #16]
34813c18:	e09aa003 	adds	sl, sl, r3
34813c1c:	e2abb000 	adc	fp, fp, #0

	slave->mtd.ecclayout = master->ecclayout;
	if (master->block_isbad) {
		uint64_t offs = 0;

		while (offs < slave->mtd.size) {
34813c20:	e596300c 	ldr	r3, [r6, #12]
34813c24:	e153000b 	cmp	r3, fp
34813c28:	8affffef 	bhi	34813bec <add_mtd_partitions+0x53c>
34813c2c:	1a000002 	bne	34813c3c <add_mtd_partitions+0x58c>
34813c30:	e5963008 	ldr	r3, [r6, #8]
34813c34:	e153000a 	cmp	r3, sl
34813c38:	8affffeb 	bhi	34813bec <add_mtd_partitions+0x53c>
			offs += slave->mtd.erasesize;
		}
	}

out_register:
	if (part->mtdp) {
34813c3c:	e5953000 	ldr	r3, [r5]
34813c40:	e3530000 	cmp	r3, #0
		/* store the object pointer (caller may or may not register it*/
		*part->mtdp = &slave->mtd;
34813c44:	15836000 	strne	r6, [r3]
		slave->registered = 0;
34813c48:	13a03000 	movne	r3, #0
			offs += slave->mtd.erasesize;
		}
	}

out_register:
	if (part->mtdp) {
34813c4c:	1a000002 	bne	34813c5c <add_mtd_partitions+0x5ac>
		/* store the object pointer (caller may or may not register it*/
		*part->mtdp = &slave->mtd;
		slave->registered = 0;
	} else {
		/* register our partition */
		add_mtd_device(&slave->mtd);
34813c50:	e1a00006 	mov	r0, r6
34813c54:	ebfffc50 	bl	34812d9c <add_mtd_device>
		slave->registered = 1;
34813c58:	e3a03001 	mov	r3, #1

	for (i = 0; i < nbparts; i++) {
		slave = add_one_partition(master, parts + i, i, cur_offset);
		if (!slave)
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
34813c5c:	e1c6a0d8 	ldrd	sl, [r6, #8]
		*part->mtdp = &slave->mtd;
		slave->registered = 0;
	} else {
		/* register our partition */
		add_mtd_device(&slave->mtd);
		slave->registered = 1;
34813c60:	e58630c4 	str	r3, [r6, #196]	; 0xc4

	for (i = 0; i < nbparts; i++) {
		slave = add_one_partition(master, parts + i, i, cur_offset);
		if (!slave)
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
34813c64:	e1c62bd0 	ldrd	r2, [r6, #176]	; 0xb0
34813c68:	e09aa002 	adds	sl, sl, r2
34813c6c:	e0abb003 	adc	fp, fp, r3
	if (mtd_partitions.next == NULL)
		INIT_LIST_HEAD(&mtd_partitions);

	printk(KERN_NOTICE "Creating %d MTD partitions on \"%s\":\n", nbparts, master->name);

	for (i = 0; i < nbparts; i++) {
34813c70:	e2877001 	add	r7, r7, #1
34813c74:	e2855028 	add	r5, r5, #40	; 0x28
34813c78:	e59d001c 	ldr	r0, [sp, #28]
34813c7c:	e1570000 	cmp	r7, r0
34813c80:	bafffe9d 	blt	348136fc <add_mtd_partitions+0x4c>
		if (!slave)
			return -ENOMEM;
		cur_offset = slave->offset + slave->mtd.size;
	}

	return 0;
34813c84:	e3a00000 	mov	r0, #0
}
34813c88:	e28dd028 	add	sp, sp, #40	; 0x28
34813c8c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34813c90:	3482bab4 	.word	0x3482bab4
34813c94:	34827289 	.word	0x34827289
34813c98:	348272ae 	.word	0x348272ae
34813c9c:	348134ec 	.word	0x348134ec
34813ca0:	34813000 	.word	0x34813000
34813ca4:	34813098 	.word	0x34813098
34813ca8:	34813444 	.word	0x34813444
34813cac:	34813130 	.word	0x34813130
34813cb0:	34812f78 	.word	0x34812f78
34813cb4:	34812fbc 	.word	0x34812fbc
34813cb8:	348131bc 	.word	0x348131bc
34813cbc:	348131ec 	.word	0x348131ec
34813cc0:	34812fa8 	.word	0x34812fa8
34813cc4:	34812fec 	.word	0x34812fec
34813cc8:	34813370 	.word	0x34813370
34813ccc:	348132b0 	.word	0x348132b0
34813cd0:	34813310 	.word	0x34813310
34813cd4:	34813384 	.word	0x34813384
34813cd8:	348133d4 	.word	0x348133d4
34813cdc:	34813208 	.word	0x34813208
34813ce0:	348272ea 	.word	0x348272ea
34813ce4:	34827317 	.word	0x34827317
34813ce8:	34827333 	.word	0x34827333
34813cec:	34827364 	.word	0x34827364
34813cf0:	348273ba 	.word	0x348273ba
34813cf4:	348273d7 	.word	0x348273d7
34813cf8:	3482148c 	.word	0x3482148c
34813cfc:	348273e1 	.word	0x348273e1
34813d00:	348273e6 	.word	0x348273e6
34813d04:	34827437 	.word	0x34827437

34813d08 <onenand_init>:
struct mtd_info onenand_mtd;
struct onenand_chip onenand_chip;
static __attribute__((unused)) char dev_name[] = "onenand0";

void onenand_init(void)
{
34813d08:	e92d4070 	push	{r4, r5, r6, lr}
	memset(&onenand_mtd, 0, sizeof(struct mtd_info));
34813d0c:	e59f407c 	ldr	r4, [pc, #124]	; 34813d90 <onenand_init+0x88>
34813d10:	e3a01000 	mov	r1, #0
34813d14:	e3a020a8 	mov	r2, #168	; 0xa8
	memset(&onenand_chip, 0, sizeof(struct onenand_chip));
34813d18:	e28450a8 	add	r5, r4, #168	; 0xa8
struct onenand_chip onenand_chip;
static __attribute__((unused)) char dev_name[] = "onenand0";

void onenand_init(void)
{
	memset(&onenand_mtd, 0, sizeof(struct mtd_info));
34813d1c:	e1a00004 	mov	r0, r4
34813d20:	eb002067 	bl	3481bec4 <memset>
	memset(&onenand_chip, 0, sizeof(struct onenand_chip));
34813d24:	e3a01000 	mov	r1, #0
34813d28:	e3a020a8 	mov	r2, #168	; 0xa8
34813d2c:	e1a00005 	mov	r0, r5
34813d30:	eb002063 	bl	3481bec4 <memset>

#ifdef CONFIG_USE_ONENAND_BOARD_INIT
	/*
	 * It's used for some board init required
	 */
	onenand_board_init(&onenand_mtd);
34813d34:	e1a00004 	mov	r0, r4
void onenand_init(void)
{
	memset(&onenand_mtd, 0, sizeof(struct mtd_info));
	memset(&onenand_chip, 0, sizeof(struct onenand_chip));

	onenand_mtd.priv = &onenand_chip;
34813d38:	e5845094 	str	r5, [r4, #148]	; 0x94

#ifdef CONFIG_USE_ONENAND_BOARD_INIT
	/*
	 * It's used for some board init required
	 */
	onenand_board_init(&onenand_mtd);
34813d3c:	eb002f84 	bl	3481fb54 <onenand_board_init>
#else
	onenand_chip.base = (void *) CONFIG_SYS_ONENAND_BASE;
#endif

	onenand_scan(&onenand_mtd, 1);
34813d40:	e1a00004 	mov	r0, r4
34813d44:	e3a01001 	mov	r1, #1
34813d48:	eb000b47 	bl	34816a6c <onenand_scan>

	if (onenand_chip.device_id & DEVICE_IS_FLEXONENAND)
34813d4c:	e59430c4 	ldr	r3, [r4, #196]	; 0xc4
34813d50:	e3130c02 	tst	r3, #512	; 0x200
34813d54:	0a000001 	beq	34813d60 <onenand_init+0x58>
		puts("Flex-");
34813d58:	e59f0034 	ldr	r0, [pc, #52]	; 34813d94 <onenand_init+0x8c>
34813d5c:	ebffd4f6 	bl	3480913c <puts>
	puts("OneNAND: ");
	print_size(onenand_chip.chipsize, "\n");
34813d60:	e59f4028 	ldr	r4, [pc, #40]	; 34813d90 <onenand_init+0x88>

	onenand_scan(&onenand_mtd, 1);

	if (onenand_chip.device_id & DEVICE_IS_FLEXONENAND)
		puts("Flex-");
	puts("OneNAND: ");
34813d64:	e59f002c 	ldr	r0, [pc, #44]	; 34813d98 <onenand_init+0x90>
34813d68:	ebffd4f3 	bl	3480913c <puts>
	print_size(onenand_chip.chipsize, "\n");
34813d6c:	e59400c0 	ldr	r0, [r4, #192]	; 0xc0
34813d70:	e3a01000 	mov	r1, #0
34813d74:	e59f2020 	ldr	r2, [pc, #32]	; 34813d9c <onenand_init+0x94>
34813d78:	eb00190b 	bl	3481a1ac <print_size>
#ifdef CONFIG_MTD_DEVICE
	/*
	 * Add MTD device so that we can reference it later
	 * via the mtdcore infrastructure (e.g. ubi).
	 */
	onenand_mtd.name = dev_name;
34813d7c:	e59f301c 	ldr	r3, [pc, #28]	; 34813da0 <onenand_init+0x98>
	add_mtd_device(&onenand_mtd);
34813d80:	e1a00004 	mov	r0, r4
#ifdef CONFIG_MTD_DEVICE
	/*
	 * Add MTD device so that we can reference it later
	 * via the mtdcore infrastructure (e.g. ubi).
	 */
	onenand_mtd.name = dev_name;
34813d84:	e5843020 	str	r3, [r4, #32]
	add_mtd_device(&onenand_mtd);
#endif
}
34813d88:	e8bd4070 	pop	{r4, r5, r6, lr}
	/*
	 * Add MTD device so that we can reference it later
	 * via the mtdcore infrastructure (e.g. ubi).
	 */
	onenand_mtd.name = dev_name;
	add_mtd_device(&onenand_mtd);
34813d8c:	eafffc02 	b	34812d9c <add_mtd_device>
34813d90:	3482bac0 	.word	0x3482bac0
34813d94:	3482747d 	.word	0x3482747d
34813d98:	34827483 	.word	0x34827483
34813d9c:	34826214 	.word	0x34826214
34813da0:	34828b1c 	.word	0x34828b1c

34813da4 <generic_ffs>:

static inline int generic_ffs(int x)
{
	int r = 1;

	if (!x)
34813da4:	e2503000 	subs	r3, r0, #0
34813da8:	0a000010 	beq	34813df0 <generic_ffs+0x4c>
		return 0;
	if (!(x & 0xffff)) {
34813dac:	e6ff2073 	uxth	r2, r3
34813db0:	e3520000 	cmp	r2, #0
		x >>= 16;
34813db4:	01a03843 	asreq	r3, r3, #16
		r += 16;
34813db8:	03a00011 	moveq	r0, #17
 * differs in spirit from the above ffz (man ffs).
 */

static inline int generic_ffs(int x)
{
	int r = 1;
34813dbc:	13a00001 	movne	r0, #1
		return 0;
	if (!(x & 0xffff)) {
		x >>= 16;
		r += 16;
	}
	if (!(x & 0xff)) {
34813dc0:	e31300ff 	tst	r3, #255	; 0xff
		x >>= 8;
34813dc4:	01a03443 	asreq	r3, r3, #8
		r += 8;
34813dc8:	02800008 	addeq	r0, r0, #8
	}
	if (!(x & 0xf)) {
34813dcc:	e313000f 	tst	r3, #15
		x >>= 4;
34813dd0:	01a03243 	asreq	r3, r3, #4
		r += 4;
34813dd4:	02800004 	addeq	r0, r0, #4
	}
	if (!(x & 3)) {
34813dd8:	e3130003 	tst	r3, #3
		x >>= 2;
34813ddc:	01a03143 	asreq	r3, r3, #2
		r += 2;
34813de0:	02800002 	addeq	r0, r0, #2
	}
	if (!(x & 1)) {
34813de4:	e3130001 	tst	r3, #1
		x >>= 1;
		r += 1;
34813de8:	02800001 	addeq	r0, r0, #1
34813dec:	e12fff1e 	bx	lr
static inline int generic_ffs(int x)
{
	int r = 1;

	if (!x)
		return 0;
34813df0:	e1a00003 	mov	r0, r3
	if (!(x & 1)) {
		x >>= 1;
		r += 1;
	}
	return r;
}
34813df4:	e12fff1e 	bx	lr

34813df8 <memcpy_16>:
{
	void *ret = dst;
	short *d = dst;
	const short *s = src;

	len >>= 1;
34813df8:	e1a020a2 	lsr	r2, r2, #1
	while (len-- > 0)
34813dfc:	e3a03000 	mov	r3, #0
34813e00:	ea000003 	b	34813e14 <memcpy_16+0x1c>
		*d++ = *s++;
34813e04:	e191c0b3 	ldrh	ip, [r1, r3]
34813e08:	e2422001 	sub	r2, r2, #1
34813e0c:	e180c0b3 	strh	ip, [r0, r3]
34813e10:	e2833002 	add	r3, r3, #2
	void *ret = dst;
	short *d = dst;
	const short *s = src;

	len >>= 1;
	while (len-- > 0)
34813e14:	e3520000 	cmp	r2, #0
34813e18:	1afffff9 	bne	34813e04 <memcpy_16+0xc>
		*d++ = *s++;
	return ret;
}
34813e1c:	e12fff1e 	bx	lr

34813e20 <onenand_readw>:
 *
 * Read OneNAND register
 */
static unsigned short onenand_readw(void __iomem * addr)
{
	return readw(addr);
34813e20:	e1d000b0 	ldrh	r0, [r0]
}
34813e24:	e12fff1e 	bx	lr

34813e28 <onenand_writew>:
 *
 * Write OneNAND register with value
 */
static void onenand_writew(unsigned short value, void __iomem * addr)
{
	writew(value, addr);
34813e28:	e1c100b0 	strh	r0, [r1]
}
34813e2c:	e12fff1e 	bx	lr

34813e30 <onenand_read_bufferram>:
 */
static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				  unsigned char *buffer, int offset,
				  size_t count)
{
	struct onenand_chip *this = mtd->priv;
34813e30:	e5902094 	ldr	r2, [r0, #148]	; 0x94
 * Read the BufferRAM area
 */
static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				  unsigned char *buffer, int offset,
				  size_t count)
{
34813e34:	e92d4008 	push	{r3, lr}
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34813e38:	e5921044 	ldr	r1, [r2, #68]	; 0x44
 * Read the BufferRAM area
 */
static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				  unsigned char *buffer, int offset,
				  size_t count)
{
34813e3c:	e59d3008 	ldr	r3, [sp, #8]
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
34813e40:	e592c000 	ldr	ip, [r2]
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34813e44:	e3510000 	cmp	r1, #0
				  size_t count)
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
34813e48:	e08cc003 	add	ip, ip, r3
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34813e4c:	0a000006 	beq	34813e6c <onenand_read_bufferram+0x3c>
		if (area == ONENAND_DATARAM)
34813e50:	e3530b01 	cmp	r3, #1024	; 0x400
			return mtd->writesize;
34813e54:	05901014 	ldreq	r1, [r0, #20]
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
		if (area == ONENAND_DATARAM)
34813e58:	0a000003 	beq	34813e6c <onenand_read_bufferram+0x3c>
			return mtd->writesize;
		if (area == ONENAND_SPARERAM)
34813e5c:	e59f2028 	ldr	r2, [pc, #40]	; 34813e8c <onenand_read_bufferram+0x5c>
34813e60:	e1530002 	cmp	r3, r2
			return mtd->oobsize;
34813e64:	05901018 	ldreq	r1, [r0, #24]
	}

	return 0;
34813e68:	13a01000 	movne	r1, #0
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);

	memcpy_16(buffer, bufferram + offset, count);
34813e6c:	e59d3010 	ldr	r3, [sp, #16]
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);
34813e70:	e08c1001 	add	r1, ip, r1

	memcpy_16(buffer, bufferram + offset, count);
34813e74:	e59d000c 	ldr	r0, [sp, #12]
34813e78:	e0811003 	add	r1, r1, r3
34813e7c:	e59d2014 	ldr	r2, [sp, #20]
34813e80:	ebffffdc 	bl	34813df8 <memcpy_16>

	return 0;
}
34813e84:	e3a00000 	mov	r0, #0
34813e88:	e8bd8008 	pop	{r3, pc}
34813e8c:	00010020 	.word	0x00010020

34813e90 <onenand_sync_read_bufferram>:
 * Read the BufferRAM area with Sync. Burst Mode
 */
static int onenand_sync_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				       unsigned char *buffer, int offset,
				       size_t count)
{
34813e90:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct onenand_chip *this = mtd->priv;
34813e94:	e5905094 	ldr	r5, [r0, #148]	; 0x94
 * Read the BufferRAM area with Sync. Burst Mode
 */
static int onenand_sync_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				       unsigned char *buffer, int offset,
				       size_t count)
{
34813e98:	e59d3018 	ldr	r3, [sp, #24]
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34813e9c:	e5956044 	ldr	r6, [r5, #68]	; 0x44
				       size_t count)
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
34813ea0:	e5957000 	ldr	r7, [r5]
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34813ea4:	e3560000 	cmp	r6, #0
 * Read the BufferRAM area with Sync. Burst Mode
 */
static int onenand_sync_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				       unsigned char *buffer, int offset,
				       size_t count)
{
34813ea8:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
34813eac:	e0877003 	add	r7, r7, r3
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34813eb0:	0a000006 	beq	34813ed0 <onenand_sync_read_bufferram+0x40>
		if (area == ONENAND_DATARAM)
34813eb4:	e3530b01 	cmp	r3, #1024	; 0x400
			return mtd->writesize;
34813eb8:	05906014 	ldreq	r6, [r0, #20]
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
		if (area == ONENAND_DATARAM)
34813ebc:	0a000003 	beq	34813ed0 <onenand_sync_read_bufferram+0x40>
			return mtd->writesize;
		if (area == ONENAND_SPARERAM)
34813ec0:	e59f2048 	ldr	r2, [pc, #72]	; 34813f10 <onenand_sync_read_bufferram+0x80>
34813ec4:	e1530002 	cmp	r3, r2
			return mtd->oobsize;
34813ec8:	05906018 	ldreq	r6, [r0, #24]
	}

	return 0;
34813ecc:	13a06000 	movne	r6, #0
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);

	this->mmcontrol(mtd, ONENAND_SYS_CFG1_SYNC_READ);
34813ed0:	e5953074 	ldr	r3, [r5, #116]	; 0x74
34813ed4:	e1a00004 	mov	r0, r4
34813ed8:	e3a01902 	mov	r1, #32768	; 0x8000
34813edc:	e12fff33 	blx	r3

	memcpy_16(buffer, bufferram + offset, count);
34813ee0:	e59d3020 	ldr	r3, [sp, #32]
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);
34813ee4:	e0876006 	add	r6, r7, r6

	this->mmcontrol(mtd, ONENAND_SYS_CFG1_SYNC_READ);

	memcpy_16(buffer, bufferram + offset, count);
34813ee8:	e0861003 	add	r1, r6, r3
34813eec:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
34813ef0:	e59d001c 	ldr	r0, [sp, #28]
34813ef4:	ebffffbf 	bl	34813df8 <memcpy_16>

	this->mmcontrol(mtd, 0);
34813ef8:	e1a00004 	mov	r0, r4
34813efc:	e5953074 	ldr	r3, [r5, #116]	; 0x74
34813f00:	e3a01000 	mov	r1, #0
34813f04:	e12fff33 	blx	r3

	return 0;
}
34813f08:	e3a00000 	mov	r0, #0
34813f0c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34813f10:	00010020 	.word	0x00010020

34813f14 <onenand_write_bufferram>:
 */
static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				   const unsigned char *buffer, int offset,
				   size_t count)
{
	struct onenand_chip *this = mtd->priv;
34813f14:	e5901094 	ldr	r1, [r0, #148]	; 0x94
 * Write the BufferRAM area
 */
static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				   const unsigned char *buffer, int offset,
				   size_t count)
{
34813f18:	e92d4008 	push	{r3, lr}
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34813f1c:	e5913044 	ldr	r3, [r1, #68]	; 0x44
 * Write the BufferRAM area
 */
static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				   const unsigned char *buffer, int offset,
				   size_t count)
{
34813f20:	e59d2008 	ldr	r2, [sp, #8]
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
34813f24:	e591c000 	ldr	ip, [r1]
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34813f28:	e3530000 	cmp	r3, #0
				   size_t count)
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
34813f2c:	e08cc002 	add	ip, ip, r2
 */
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
34813f30:	0a000006 	beq	34813f50 <onenand_write_bufferram+0x3c>
		if (area == ONENAND_DATARAM)
34813f34:	e3520b01 	cmp	r2, #1024	; 0x400
			return mtd->writesize;
34813f38:	05903014 	ldreq	r3, [r0, #20]
static inline int onenand_bufferram_offset(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;

	if (ONENAND_CURRENT_BUFFERRAM(this)) {
		if (area == ONENAND_DATARAM)
34813f3c:	0a000003 	beq	34813f50 <onenand_write_bufferram+0x3c>
			return mtd->writesize;
		if (area == ONENAND_SPARERAM)
34813f40:	e59f3028 	ldr	r3, [pc, #40]	; 34813f70 <onenand_write_bufferram+0x5c>
34813f44:	e1520003 	cmp	r2, r3
			return mtd->oobsize;
34813f48:	05903018 	ldreq	r3, [r0, #24]
	}

	return 0;
34813f4c:	13a03000 	movne	r3, #0
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);

	memcpy_16(bufferram + offset, buffer, count);
34813f50:	e59d2010 	ldr	r2, [sp, #16]
{
	struct onenand_chip *this = mtd->priv;
	void __iomem *bufferram;

	bufferram = this->base + area;
	bufferram += onenand_bufferram_offset(mtd, area);
34813f54:	e08c3003 	add	r3, ip, r3

	memcpy_16(bufferram + offset, buffer, count);
34813f58:	e0830002 	add	r0, r3, r2
34813f5c:	e59d100c 	ldr	r1, [sp, #12]
34813f60:	e59d2014 	ldr	r2, [sp, #20]
34813f64:	ebffffa3 	bl	34813df8 <memcpy_16>

	return 0;
}
34813f68:	e3a00000 	mov	r0, #0
34813f6c:	e8bd8008 	pop	{r3, pc}
34813f70:	00010020 	.word	0x00010020

34813f74 <onenand_sync>:
	/* Grab the lock and see if the device is available */
	onenand_get_device(mtd, FL_SYNCING);

	/* Release it and go back */
	onenand_release_device(mtd);
}
34813f74:	e12fff1e 	bx	lr

34813f78 <onenand_block_isbad>:
 * @param ofs		offset relative to mtd start
 *
 * Check whether the block is bad
 */
int onenand_block_isbad(struct mtd_info *mtd, loff_t ofs)
{
34813f78:	e92d4007 	push	{r0, r1, r2, lr}
	int ret;

	/* Check for invalid offset */
	if (ofs > mtd->size)
34813f7c:	e590100c 	ldr	r1, [r0, #12]
34813f80:	e1510003 	cmp	r1, r3
34813f84:	3a00000a 	bcc	34813fb4 <onenand_block_isbad+0x3c>
34813f88:	1a000002 	bne	34813f98 <onenand_block_isbad+0x20>
34813f8c:	e5901008 	ldr	r1, [r0, #8]
34813f90:	e1510002 	cmp	r1, r2
34813f94:	3a000006 	bcc	34813fb4 <onenand_block_isbad+0x3c>
 * calling of the scan function.
 */
static int onenand_block_isbad_nolock(struct mtd_info *mtd, loff_t ofs, int allowbbt)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
34813f98:	e5901094 	ldr	r1, [r0, #148]	; 0x94

	/* Return info from the table */
	return bbm->isbad_bbt(mtd, ofs, allowbbt);
34813f9c:	e3a0c000 	mov	ip, #0
34813fa0:	e59110a0 	ldr	r1, [r1, #160]	; 0xa0
34813fa4:	e58dc000 	str	ip, [sp]
34813fa8:	e5911010 	ldr	r1, [r1, #16]
34813fac:	e12fff31 	blx	r1
		return -EINVAL;

	onenand_get_device(mtd, FL_READING);
	ret = onenand_block_isbad_nolock(mtd,ofs, 0);
	onenand_release_device(mtd);
	return ret;
34813fb0:	ea000000 	b	34813fb8 <onenand_block_isbad+0x40>
{
	int ret;

	/* Check for invalid offset */
	if (ofs > mtd->size)
		return -EINVAL;
34813fb4:	e3e00015 	mvn	r0, #21

	onenand_get_device(mtd, FL_READING);
	ret = onenand_block_isbad_nolock(mtd,ofs, 0);
	onenand_release_device(mtd);
	return ret;
}
34813fb8:	e8bd800e 	pop	{r1, r2, r3, pc}

34813fbc <onenand_block_markbad>:
 * @param ofs		offset relative to mtd start
 *
 * Mark the block as bad
 */
int onenand_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
34813fbc:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34813fc0:	e1a06000 	mov	r6, r0
34813fc4:	e1a04002 	mov	r4, r2
34813fc8:	e1a05003 	mov	r5, r3
	struct onenand_chip *this = mtd->priv;
34813fcc:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	int ret;

	ret = onenand_block_isbad(mtd, ofs);
34813fd0:	ebffffe8 	bl	34813f78 <onenand_block_isbad>
	if (ret) {
34813fd4:	e3500000 	cmp	r0, #0
34813fd8:	10000fc0 	andne	r0, r0, r0, asr #31
34813fdc:	18bd80f8 	popne	{r3, r4, r5, r6, r7, pc}
		if (ret > 0)
			return 0;
		return ret;
	}

	ret = this->block_markbad(mtd, ofs);
34813fe0:	e5971078 	ldr	r1, [r7, #120]	; 0x78
34813fe4:	e1a00006 	mov	r0, r6
34813fe8:	e1a02004 	mov	r2, r4
34813fec:	e1a03005 	mov	r3, r5
34813ff0:	e12fff31 	blx	r1
	return ret;
}
34813ff4:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

34813ff8 <onenand_chip_probe>:
 *
 * OneNAND detection method:
 *   Compare the the values from command with ones from register
 */
static int onenand_chip_probe(struct mtd_info *mtd)
{
34813ff8:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	struct onenand_chip *this = mtd->priv;
34813ffc:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 *
 * OneNAND detection method:
 *   Compare the the values from command with ones from register
 */
static int onenand_chip_probe(struct mtd_info *mtd)
{
34814000:	e1a0a000 	mov	sl, r0
	struct onenand_chip *this = mtd->priv;
	int bram_maf_id, bram_dev_id, maf_id, dev_id;
	int syscfg;

	/* Save system configuration 1 */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
34814004:	e5940000 	ldr	r0, [r4]
34814008:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481400c:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814010:	e2800042 	add	r0, r0, #66	; 0x42
34814014:	e12fff33 	blx	r3

	/* Clear Sync. Burst Read mode to read BootRAM */
	this->write_word((syscfg & ~ONENAND_SYS_CFG1_SYNC_READ),
34814018:	e5941000 	ldr	r1, [r4]
	struct onenand_chip *this = mtd->priv;
	int bram_maf_id, bram_dev_id, maf_id, dev_id;
	int syscfg;

	/* Save system configuration 1 */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
3481401c:	e1a07000 	mov	r7, r0

	/* Clear Sync. Burst Read mode to read BootRAM */
	this->write_word((syscfg & ~ONENAND_SYS_CFG1_SYNC_READ),
34814020:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34814024:	e1a00880 	lsl	r0, r0, #17
34814028:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
3481402c:	e1a008a0 	lsr	r0, r0, #17
34814030:	e2811042 	add	r1, r1, #66	; 0x42
34814034:	e12fff33 	blx	r3
			 this->base + ONENAND_REG_SYS_CFG1);

	/* Send the command for reading device ID from BootRAM */
	this->write_word(ONENAND_CMD_READID, this->base + ONENAND_BOOTRAM);
34814038:	e5941000 	ldr	r1, [r4]
3481403c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814040:	e3a00090 	mov	r0, #144	; 0x90
34814044:	e12fff33 	blx	r3

	/* Read manufacturer and device IDs from BootRAM */
	bram_maf_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x0);
34814048:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481404c:	e5940000 	ldr	r0, [r4]
34814050:	e12fff33 	blx	r3
34814054:	e1a05000 	mov	r5, r0
	bram_dev_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x2);
34814058:	e5940000 	ldr	r0, [r4]
3481405c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814060:	e2800002 	add	r0, r0, #2
34814064:	e12fff33 	blx	r3

	/* Reset OneNAND to read default register values */
	this->write_word(ONENAND_CMD_RESET, this->base + ONENAND_BOOTRAM);
34814068:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
3481406c:	e5941000 	ldr	r1, [r4]
	/* Send the command for reading device ID from BootRAM */
	this->write_word(ONENAND_CMD_READID, this->base + ONENAND_BOOTRAM);

	/* Read manufacturer and device IDs from BootRAM */
	bram_maf_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x0);
	bram_dev_id = this->read_word(this->base + ONENAND_BOOTRAM + 0x2);
34814070:	e1a06000 	mov	r6, r0

	/* Reset OneNAND to read default register values */
	this->write_word(ONENAND_CMD_RESET, this->base + ONENAND_BOOTRAM);
34814074:	e3a000f0 	mov	r0, #240	; 0xf0
34814078:	e12fff33 	blx	r3

	/* Wait reset */
	this->wait(mtd, FL_RESETING);
3481407c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34814080:	e3a01006 	mov	r1, #6
34814084:	e1a0000a 	mov	r0, sl
34814088:	e12fff33 	blx	r3

	/* Restore system configuration 1 */
	this->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);
3481408c:	e5941000 	ldr	r1, [r4]
34814090:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814094:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34814098:	e1a00007 	mov	r0, r7
3481409c:	e2811042 	add	r1, r1, #66	; 0x42
348140a0:	e12fff33 	blx	r3
#ifdef ONENAND_DEBUG
	char *name;
#endif

	for (i = 0; i < size; i++)
		if (manuf == onenand_manuf_ids[i].id)
348140a4:	e3550020 	cmp	r5, #32
348140a8:	0a000001 	beq	348140b4 <onenand_chip_probe+0xbc>
348140ac:	e35500ec 	cmp	r5, #236	; 0xec
348140b0:	1a00000f 	bne	348140f4 <onenand_chip_probe+0xfc>
	/* Check manufacturer ID */
	if (onenand_check_maf(bram_maf_id))
		return -ENXIO;

	/* Read manufacturer and device IDs from Register */
	maf_id = this->read_word(this->base + ONENAND_REG_MANUFACTURER_ID);
348140b4:	e5940000 	ldr	r0, [r4]
348140b8:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348140bc:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
348140c0:	e12fff33 	blx	r3
348140c4:	e1a07000 	mov	r7, r0
	dev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);
348140c8:	e5940000 	ldr	r0, [r4]
348140cc:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348140d0:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
348140d4:	e2800002 	add	r0, r0, #2
348140d8:	e12fff33 	blx	r3

	/* Check OneNAND device */
	if (maf_id != bram_maf_id || dev_id != bram_dev_id)
348140dc:	e1570005 	cmp	r7, r5
348140e0:	01500006 	cmpeq	r0, r6
348140e4:	03a00000 	moveq	r0, #0
348140e8:	13a00001 	movne	r0, #1
		return -ENXIO;
348140ec:	13e00005 	mvnne	r0, #5
348140f0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	/* Restore system configuration 1 */
	this->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);

	/* Check manufacturer ID */
	if (onenand_check_maf(bram_maf_id))
		return -ENXIO;
348140f4:	e3e00005 	mvn	r0, #5
	/* Check OneNAND device */
	if (maf_id != bram_maf_id || dev_id != bram_dev_id)
		return -ENXIO;

	return 0;
}
348140f8:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

348140fc <flexonenand_get_size>:
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
{
348140fc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34814100:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	int die, i, eraseshift, density;
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
34814104:	e3a01010 	mov	r1, #16
	struct onenand_chip *this = mtd->priv;
	int die, i, eraseshift, density;
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
34814108:	e594701c 	ldr	r7, [r4, #28]
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
3481410c:	e5946030 	ldr	r6, [r4, #48]	; 0x30
 * Get OneNAND density from device ID
 */
static inline int onenand_get_density(int dev_id)
{
	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34814110:	e7e33257 	ubfx	r3, r7, #4, #4
	int die, i, eraseshift, density;
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
34814114:	e1a01311 	lsl	r1, r1, r3
34814118:	e1a02001 	mov	r2, r1
3481411c:	e1a03fc2 	asr	r3, r2, #31
34814120:	e1a03a03 	lsl	r3, r3, #20
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
{
34814124:	e24dd018 	sub	sp, sp, #24
	int die, i, eraseshift, density;
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
34814128:	e1a02006 	mov	r2, r6
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
{
3481412c:	e1a05000 	mov	r5, r0
	int die, i, eraseshift, density;
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
34814130:	e1a00a01 	lsl	r0, r1, #20
34814134:	e1831621 	orr	r1, r3, r1, lsr #12
34814138:	eb002fb2 	bl	34820008 <__ashrdi3>
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
3481413c:	e7e071d7 	ubfx	r7, r7, #3, #1
34814140:	e1a07750 	asr	r7, r0, r7
	maxbdry = blksperdie - 1;
34814144:	e2473001 	sub	r3, r7, #1
34814148:	e58d300c 	str	r3, [sp, #12]
	struct onenand_chip *this = mtd->priv;
	unsigned int die, bdry;
	int syscfg, locked;

	/* Disable ECC */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
3481414c:	e8940009 	ldm	r4, {r0, r3}
34814150:	e2800b79 	add	r0, r0, #123904	; 0x1e400
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
	maxbdry = blksperdie - 1;
	eraseshift = this->erase_shift - 1;

	mtd->numeraseregions = this->dies << 1;
34814154:	e1a03083 	lsl	r3, r3, #1
	int blksperdie, maxbdry;
	loff_t ofs;

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
34814158:	e58d7010 	str	r7, [sp, #16]
	maxbdry = blksperdie - 1;
	eraseshift = this->erase_shift - 1;

	mtd->numeraseregions = this->dies << 1;
3481415c:	e585302c 	str	r3, [r5, #44]	; 0x2c
	struct onenand_chip *this = mtd->priv;
	unsigned int die, bdry;
	int syscfg, locked;

	/* Disable ECC */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
34814160:	e2800042 	add	r0, r0, #66	; 0x42
34814164:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34814168:	e12fff33 	blx	r3
	this->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);
3481416c:	e5941000 	ldr	r1, [r4]
	struct onenand_chip *this = mtd->priv;
	unsigned int die, bdry;
	int syscfg, locked;

	/* Disable ECC */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
34814170:	e58d0008 	str	r0, [sp, #8]
	this->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);
34814174:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34814178:	e3800c01 	orr	r0, r0, #256	; 0x100
3481417c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814180:	e6ff0070 	uxth	r0, r0
34814184:	e2811042 	add	r1, r1, #66	; 0x42

	for (die = 0; die < this->dies; die++) {
34814188:	e3a07000 	mov	r7, #0

	density = onenand_get_density(this->device_id);
	blksperdie = ((loff_t)(16 << density) << 20) >> (this->erase_shift);
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
	maxbdry = blksperdie - 1;
	eraseshift = this->erase_shift - 1;
3481418c:	e2466001 	sub	r6, r6, #1
	unsigned int die, bdry;
	int syscfg, locked;

	/* Disable ECC */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
	this->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);
34814190:	e12fff33 	blx	r3

	for (die = 0; die < this->dies; die++) {
		this->command(mtd, FLEXONENAND_CMD_PI_ACCESS, die, 0);
34814194:	e1a0a007 	mov	sl, r7
34814198:	ea000034 	b	34814270 <flexonenand_get_size+0x174>
3481419c:	e58da000 	str	sl, [sp]
348141a0:	e1a02007 	mov	r2, r7
348141a4:	e594c050 	ldr	ip, [r4, #80]	; 0x50
348141a8:	e3a01066 	mov	r1, #102	; 0x66
348141ac:	e1a0300a 	mov	r3, sl
348141b0:	e1a00005 	mov	r0, r5
348141b4:	e12fff3c 	blx	ip
		this->wait(mtd, FL_SYNCING);
348141b8:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348141bc:	e3a01004 	mov	r1, #4
348141c0:	e1a00005 	mov	r0, r5
348141c4:	e12fff33 	blx	r3

		this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
348141c8:	e58da000 	str	sl, [sp]
348141cc:	e1a02007 	mov	r2, r7
348141d0:	e594c050 	ldr	ip, [r4, #80]	; 0x50
348141d4:	e3011985 	movw	r1, #6533	; 0x1985
348141d8:	e1a0300a 	mov	r3, sl
348141dc:	e1a00005 	mov	r0, r5
348141e0:	e12fff3c 	blx	ip
		this->wait(mtd, FL_READING);
348141e4:	e3a01001 	mov	r1, #1
348141e8:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348141ec:	e1a00005 	mov	r0, r5
348141f0:	e12fff33 	blx	r3

		bdry = this->read_word(this->base + ONENAND_DATARAM);
348141f4:	e5940000 	ldr	r0, [r4]
348141f8:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348141fc:	e2800b01 	add	r0, r0, #1024	; 0x400
34814200:	e12fff33 	blx	r3
		if ((bdry >> FLEXONENAND_PI_UNLOCK_SHIFT) == 3)
			locked = 0;
		else
			locked = 1;
		this->boundary[die] = bdry & FLEXONENAND_PI_MASK;
34814204:	e1a03b00 	lsl	r3, r0, #22
34814208:	e287b002 	add	fp, r7, #2
3481420c:	e1a03b23 	lsr	r3, r3, #22
34814210:	e784310b 	str	r3, [r4, fp, lsl #2]

		this->command(mtd, ONENAND_CMD_RESET, 0, 0);
34814214:	e58da000 	str	sl, [sp]
		this->wait(mtd, FL_SYNCING);

		this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
		this->wait(mtd, FL_READING);

		bdry = this->read_word(this->base + ONENAND_DATARAM);
34814218:	e1a09000 	mov	r9, r0
			locked = 0;
		else
			locked = 1;
		this->boundary[die] = bdry & FLEXONENAND_PI_MASK;

		this->command(mtd, ONENAND_CMD_RESET, 0, 0);
3481421c:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34814220:	e3a02000 	mov	r2, #0
34814224:	e3a010f0 	mov	r1, #240	; 0xf0
34814228:	e3a03000 	mov	r3, #0
3481422c:	e1a00005 	mov	r0, r5
34814230:	e12fff3c 	blx	ip
		this->wait(mtd, FL_RESETING);
34814234:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34814238:	e3a01006 	mov	r1, #6
3481423c:	e1a00005 	mov	r0, r5
34814240:	e12fff33 	blx	r3

		this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
		this->wait(mtd, FL_READING);

		bdry = this->read_word(this->base + ONENAND_DATARAM);
		if ((bdry >> FLEXONENAND_PI_UNLOCK_SHIFT) == 3)
34814244:	e1a03729 	lsr	r3, r9, #14
		this->boundary[die] = bdry & FLEXONENAND_PI_MASK;

		this->command(mtd, ONENAND_CMD_RESET, 0, 0);
		this->wait(mtd, FL_RESETING);

		printk(KERN_INFO "Die %d boundary: %d%s\n", die,
34814248:	e794210b 	ldr	r2, [r4, fp, lsl #2]
3481424c:	e59fb240 	ldr	fp, [pc, #576]	; 34814494 <flexonenand_get_size+0x398>
34814250:	e3530003 	cmp	r3, #3
34814254:	e59f923c 	ldr	r9, [pc, #572]	; 34814498 <flexonenand_get_size+0x39c>
34814258:	11a0900b 	movne	r9, fp
3481425c:	e1a01007 	mov	r1, r7
34814260:	e59f0234 	ldr	r0, [pc, #564]	; 3481449c <flexonenand_get_size+0x3a0>
34814264:	e1a03009 	mov	r3, r9
34814268:	ebffd3bd 	bl	34809164 <printf>

	/* Disable ECC */
	syscfg = this->read_word(this->base + ONENAND_REG_SYS_CFG1);
	this->write_word((syscfg | 0x0100), this->base + ONENAND_REG_SYS_CFG1);

	for (die = 0; die < this->dies; die++) {
3481426c:	e2877001 	add	r7, r7, #1
34814270:	e5943004 	ldr	r3, [r4, #4]
34814274:	e1570003 	cmp	r7, r3
34814278:	3affffc7 	bcc	3481419c <flexonenand_get_size+0xa0>
		printk(KERN_INFO "Die %d boundary: %d%s\n", die,
		       this->boundary[die], locked ? "(Locked)" : "(Unlocked)");
	}

	/* Enable ECC */
	this->write_word(syscfg, this->base + ONENAND_REG_SYS_CFG1);
3481427c:	e5941000 	ldr	r1, [r4]
34814280:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34814284:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34814288:	e59d0008 	ldr	r0, [sp, #8]
3481428c:	e2811042 	add	r1, r1, #66	; 0x42
34814290:	e12fff33 	blx	r3
 * flexonenand_get_size - Fill up fields in onenand_chip and mtd_info
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
34814294:	e594c004 	ldr	ip, [r4, #4]
34814298:	e2847004 	add	r7, r4, #4
3481429c:	e58dc014 	str	ip, [sp, #20]
	/* This fills up the device boundary */
	flexonenand_get_boundary(mtd);
	die = 0;
	ofs = 0;
	i = -1;
	for (; die < this->dies; die++) {
348142a0:	e1a00007 	mov	r0, r7
	mtd->numeraseregions = this->dies << 1;

	/* This fills up the device boundary */
	flexonenand_get_boundary(mtd);
	die = 0;
	ofs = 0;
348142a4:	e3a02000 	mov	r2, #0
348142a8:	e3a03000 	mov	r3, #0
	i = -1;
348142ac:	e3e01000 	mvn	r1, #0

	mtd->numeraseregions = this->dies << 1;

	/* This fills up the device boundary */
	flexonenand_get_boundary(mtd);
	die = 0;
348142b0:	e3a0c000 	mov	ip, #0
	ofs = 0;
	i = -1;
	for (; die < this->dies; die++) {
		if (!die || this->boundary[die-1] != maxbdry) {
			i++;
			mtd->eraseregions[i].offset = ofs;
348142b4:	e3a0e018 	mov	lr, #24
348142b8:	e58d4008 	str	r4, [sp, #8]
	/* This fills up the device boundary */
	flexonenand_get_boundary(mtd);
	die = 0;
	ofs = 0;
	i = -1;
	for (; die < this->dies; die++) {
348142bc:	ea00003c 	b	348143b4 <flexonenand_get_size+0x2b8>
		if (!die || this->boundary[die-1] != maxbdry) {
348142c0:	e35c0000 	cmp	ip, #0
348142c4:	0a000003 	beq	348142d8 <flexonenand_get_size+0x1dc>
348142c8:	e590a000 	ldr	sl, [r0]
348142cc:	e59d400c 	ldr	r4, [sp, #12]
348142d0:	e15a0004 	cmp	sl, r4
348142d4:	0a00000f 	beq	34814318 <flexonenand_get_size+0x21c>
			i++;
348142d8:	e2811001 	add	r1, r1, #1
			mtd->eraseregions[i].offset = ofs;
348142dc:	e009019e 	mul	r9, lr, r1
348142e0:	e595b030 	ldr	fp, [r5, #48]	; 0x30
348142e4:	e08ba009 	add	sl, fp, r9
348142e8:	e18b20f9 	strd	r2, [fp, r9]
			mtd->eraseregions[i].erasesize = 1 << eraseshift;
348142ec:	e3a0b001 	mov	fp, #1
348142f0:	e1a0961b 	lsl	r9, fp, r6
348142f4:	e58a9008 	str	r9, [sl, #8]
			mtd->eraseregions[i].numblocks =
							this->boundary[die] + 1;
348142f8:	e5909004 	ldr	r9, [r0, #4]
348142fc:	e089900b 	add	r9, r9, fp
	for (; die < this->dies; die++) {
		if (!die || this->boundary[die-1] != maxbdry) {
			i++;
			mtd->eraseregions[i].offset = ofs;
			mtd->eraseregions[i].erasesize = 1 << eraseshift;
			mtd->eraseregions[i].numblocks =
34814300:	e58a900c 	str	r9, [sl, #12]
							this->boundary[die] + 1;
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
34814304:	e1a09619 	lsl	r9, r9, r6
34814308:	e0922009 	adds	r2, r2, r9
3481430c:	e2a33000 	adc	r3, r3, #0
			eraseshift++;
34814310:	e086600b 	add	r6, r6, fp
34814314:	ea00000e 	b	34814354 <flexonenand_get_size+0x258>
		} else {
			mtd->numeraseregions -= 1;
			mtd->eraseregions[i].numblocks +=
34814318:	e5959030 	ldr	r9, [r5, #48]	; 0x30
			mtd->eraseregions[i].numblocks =
							this->boundary[die] + 1;
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
			eraseshift++;
		} else {
			mtd->numeraseregions -= 1;
3481431c:	e595a02c 	ldr	sl, [r5, #44]	; 0x2c
			mtd->eraseregions[i].numblocks +=
34814320:	e029919e 	mla	r9, lr, r1, r9
			mtd->eraseregions[i].numblocks =
							this->boundary[die] + 1;
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
			eraseshift++;
		} else {
			mtd->numeraseregions -= 1;
34814324:	e24aa001 	sub	sl, sl, #1
34814328:	e585a02c 	str	sl, [r5, #44]	; 0x2c
			mtd->eraseregions[i].numblocks +=
							this->boundary[die] + 1;
3481432c:	e590a004 	ldr	sl, [r0, #4]
							this->boundary[die] + 1;
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
			eraseshift++;
		} else {
			mtd->numeraseregions -= 1;
			mtd->eraseregions[i].numblocks +=
34814330:	e599b00c 	ldr	fp, [r9, #12]
34814334:	e08ab00b 	add	fp, sl, fp
34814338:	e28bb001 	add	fp, fp, #1
3481433c:	e589b00c 	str	fp, [r9, #12]
							this->boundary[die] + 1;
			ofs += (this->boundary[die] + 1) << (eraseshift - 1);
34814340:	e28aa001 	add	sl, sl, #1
34814344:	e2469001 	sub	r9, r6, #1
34814348:	e1a0a91a 	lsl	sl, sl, r9
3481434c:	e092200a 	adds	r2, r2, sl
34814350:	e2a33000 	adc	r3, r3, #0
		}
		if (this->boundary[die] != maxbdry) {
34814354:	e5b09004 	ldr	r9, [r0, #4]!
34814358:	e59d400c 	ldr	r4, [sp, #12]
3481435c:	e1590004 	cmp	r9, r4
34814360:	0a00000f 	beq	348143a4 <flexonenand_get_size+0x2a8>
			i++;
34814364:	e2811001 	add	r1, r1, #1
			mtd->eraseregions[i].offset = ofs;
34814368:	e00b019e 	mul	fp, lr, r1
3481436c:	e5954030 	ldr	r4, [r5, #48]	; 0x30
34814370:	e084a00b 	add	sl, r4, fp
34814374:	e18420fb 	strd	r2, [r4, fp]
			mtd->eraseregions[i].erasesize = 1 << eraseshift;
34814378:	e3a04001 	mov	r4, #1
3481437c:	e1a0b614 	lsl	fp, r4, r6
34814380:	e58ab008 	str	fp, [sl, #8]
			mtd->eraseregions[i].numblocks = maxbdry ^
34814384:	e59db00c 	ldr	fp, [sp, #12]
34814388:	e02b9009 	eor	r9, fp, r9
3481438c:	e58a900c 	str	r9, [sl, #12]
							 this->boundary[die];
			ofs += mtd->eraseregions[i].numblocks << eraseshift;
34814390:	e1a09619 	lsl	r9, r9, r6
34814394:	e0922009 	adds	r2, r2, r9
34814398:	e2a33000 	adc	r3, r3, #0
			eraseshift--;
3481439c:	e2466001 	sub	r6, r6, #1
348143a0:	ea000002 	b	348143b0 <flexonenand_get_size+0x2b4>
		} else
			mtd->numeraseregions -= 1;
348143a4:	e595a02c 	ldr	sl, [r5, #44]	; 0x2c
348143a8:	e24aa001 	sub	sl, sl, #1
348143ac:	e585a02c 	str	sl, [r5, #44]	; 0x2c
	/* This fills up the device boundary */
	flexonenand_get_boundary(mtd);
	die = 0;
	ofs = 0;
	i = -1;
	for (; die < this->dies; die++) {
348143b0:	e28cc001 	add	ip, ip, #1
348143b4:	e59d4014 	ldr	r4, [sp, #20]
348143b8:	e15c0004 	cmp	ip, r4
348143bc:	1affffbf 	bne	348142c0 <flexonenand_get_size+0x1c4>
348143c0:	e59d4008 	ldr	r4, [sp, #8]
		} else
			mtd->numeraseregions -= 1;
	}

	/* Expose MLC erase size except when all blocks are SLC */
	mtd->erasesize = 1 << this->erase_shift;
348143c4:	e3a02001 	mov	r2, #1
348143c8:	e5943030 	ldr	r3, [r4, #48]	; 0x30
	if (mtd->numeraseregions == 1)
348143cc:	e595102c 	ldr	r1, [r5, #44]	; 0x2c
		} else
			mtd->numeraseregions -= 1;
	}

	/* Expose MLC erase size except when all blocks are SLC */
	mtd->erasesize = 1 << this->erase_shift;
348143d0:	e1a03312 	lsl	r3, r2, r3
	if (mtd->numeraseregions == 1)
348143d4:	e1510002 	cmp	r1, r2
		} else
			mtd->numeraseregions -= 1;
	}

	/* Expose MLC erase size except when all blocks are SLC */
	mtd->erasesize = 1 << this->erase_shift;
348143d8:	e5853010 	str	r3, [r5, #16]
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;
348143dc:	01a03233 	lsreq	r3, r3, r2

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
348143e0:	e59f00b8 	ldr	r0, [pc, #184]	; 348144a0 <flexonenand_get_size+0x3a4>
	}

	/* Expose MLC erase size except when all blocks are SLC */
	mtd->erasesize = 1 << this->erase_shift;
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;
348143e4:	05853010 	streq	r3, [r5, #16]

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
	for (i = 0; i < mtd->numeraseregions; i++)
348143e8:	e3a06000 	mov	r6, #0
	/* Expose MLC erase size except when all blocks are SLC */
	mtd->erasesize = 1 << this->erase_shift;
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
348143ec:	ebffd35c 	bl	34809164 <printf>
	for (i = 0; i < mtd->numeraseregions; i++)
348143f0:	e1a0a006 	mov	sl, r6
348143f4:	ea00000a 	b	34814424 <flexonenand_get_size+0x328>
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
348143f8:	e5953030 	ldr	r3, [r5, #48]	; 0x30
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
	for (i = 0; i < mtd->numeraseregions; i++)
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
348143fc:	e59f00a0 	ldr	r0, [pc, #160]	; 348144a4 <flexonenand_get_size+0x3a8>
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
34814400:	e0832006 	add	r2, r3, r6
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
	for (i = 0; i < mtd->numeraseregions; i++)
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
34814404:	e5921008 	ldr	r1, [r2, #8]
	mtd->erasesize = 1 << this->erase_shift;
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
	for (i = 0; i < mtd->numeraseregions; i++)
34814408:	e28aa001 	add	sl, sl, #1
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
3481440c:	e58d1000 	str	r1, [sp]
34814410:	e592200c 	ldr	r2, [r2, #12]
34814414:	e58d2004 	str	r2, [sp, #4]
34814418:	e18320d6 	ldrd	r2, [r3, r6]
3481441c:	ebffd350 	bl	34809164 <printf>
	mtd->erasesize = 1 << this->erase_shift;
	if (mtd->numeraseregions == 1)
		mtd->erasesize >>= 1;

	printk(KERN_INFO "Device has %d eraseregions\n", mtd->numeraseregions);
	for (i = 0; i < mtd->numeraseregions; i++)
34814420:	e2866018 	add	r6, r6, #24
34814424:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
34814428:	e15a0003 	cmp	sl, r3
3481442c:	bafffff1 	blt	348143f8 <flexonenand_get_size+0x2fc>
 * flexonenand_get_size - Fill up fields in onenand_chip and mtd_info
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
34814430:	e5946004 	ldr	r6, [r4, #4]
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
34814434:	e3a02000 	mov	r2, #0
34814438:	e3a03000 	mov	r3, #0
 * flexonenand_get_size - Fill up fields in onenand_chip and mtd_info
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
3481443c:	e0846106 	add	r6, r4, r6, lsl #2
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
34814440:	e1c520f8 	strd	r2, [r5, #8]
 * flexonenand_get_size - Fill up fields in onenand_chip and mtd_info
 * 			  boundary[], diesize[], mtd->size, mtd->erasesize,
 * 			  mtd->eraseregions
 * @param mtd		- MTD device structure
 */
static void flexonenand_get_size(struct mtd_info *mtd)
34814444:	e2866004 	add	r6, r6, #4
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
34814448:	ea00000d 	b	34814484 <flexonenand_get_size+0x388>
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
3481444c:	e5942030 	ldr	r2, [r4, #48]	; 0x30
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
34814450:	e5b70004 	ldr	r0, [r7, #4]!
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
34814454:	e59d9010 	ldr	r9, [sp, #16]
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
						 << (this->erase_shift - 1);
34814458:	e2800001 	add	r0, r0, #1
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
3481445c:	e1a0a219 	lsl	sl, r9, r2
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
						 << (this->erase_shift - 1);
34814460:	e3a01000 	mov	r1, #0
34814464:	e2422001 	sub	r2, r2, #1
34814468:	eb002eed 	bl	34820024 <__ashldi3>
		mtd->size += this->diesize[die];
3481446c:	e1c520d8 	ldrd	r2, [r5, #8]
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
34814470:	e060000a 	rsb	r0, r0, sl
						 << (this->erase_shift - 1);
		mtd->size += this->diesize[die];
34814474:	e0922000 	adds	r2, r2, r0
34814478:	e2a33000 	adc	r3, r3, #0
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
3481447c:	e5870008 	str	r0, [r7, #8]
						 << (this->erase_shift - 1);
		mtd->size += this->diesize[die];
34814480:	e1c520f8 	strd	r2, [r5, #8]
		printk(KERN_INFO "[offset: 0x%08llx, erasesize: 0x%05x,"
			" numblocks: %04u]\n", mtd->eraseregions[i].offset,
			mtd->eraseregions[i].erasesize,
			mtd->eraseregions[i].numblocks);

	for (die = 0, mtd->size = 0; die < this->dies; die++) {
34814484:	e1570006 	cmp	r7, r6
34814488:	1affffef 	bne	3481444c <flexonenand_get_size+0x350>
		this->diesize[die] = (loff_t) (blksperdie << this->erase_shift);
		this->diesize[die] -= (loff_t) (this->boundary[die] + 1)
						 << (this->erase_shift - 1);
		mtd->size += this->diesize[die];
	}
}
3481448c:	e28dd018 	add	sp, sp, #24
34814490:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34814494:	3482748d 	.word	0x3482748d
34814498:	34827496 	.word	0x34827496
3481449c:	348274a1 	.word	0x348274a1
348144a0:	348274b8 	.word	0x348274b8
348144a4:	348274d4 	.word	0x348274d4

348144a8 <onenand_read_ecc>:
 */
static int onenand_read_ecc(struct onenand_chip *this)
{
	int ecc, i;

	if (!FLEXONENAND(this))
348144a8:	e590301c 	ldr	r3, [r0, #28]
/**
 * onenand_read_ecc - return ecc status
 * @param this		onenand chip structure
 */
static int onenand_read_ecc(struct onenand_chip *this)
{
348144ac:	e92d4070 	push	{r4, r5, r6, lr}
	int ecc, i;

	if (!FLEXONENAND(this))
348144b0:	e3130c02 	tst	r3, #512	; 0x200
/**
 * onenand_read_ecc - return ecc status
 * @param this		onenand chip structure
 */
static int onenand_read_ecc(struct onenand_chip *this)
{
348144b4:	e1a04000 	mov	r4, r0
	int ecc, i;

	if (!FLEXONENAND(this))
348144b8:	1a000005 	bne	348144d4 <onenand_read_ecc+0x2c>
		return this->read_word(this->base + ONENAND_REG_ECC_STATUS);
348144bc:	e5900000 	ldr	r0, [r0]
348144c0:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348144c4:	e2800b7f 	add	r0, r0, #130048	; 0x1fc00
348144c8:	e2800c02 	add	r0, r0, #512	; 0x200
348144cc:	e12fff33 	blx	r3
348144d0:	e8bd8070 	pop	{r4, r5, r6, pc}
 */
static int onenand_read_ecc(struct onenand_chip *this)
{
	int ecc, i;

	if (!FLEXONENAND(this))
348144d4:	e59f5044 	ldr	r5, [pc, #68]	; 34814520 <onenand_read_ecc+0x78>
		return this->read_word(this->base + ONENAND_REG_ECC_STATUS);

	for (i = 0; i < 4; i++) {
348144d8:	e59f6044 	ldr	r6, [pc, #68]	; 34814524 <onenand_read_ecc+0x7c>
		ecc = this->read_word(this->base
348144dc:	e5940000 	ldr	r0, [r4]
348144e0:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348144e4:	e0800085 	add	r0, r0, r5, lsl #1
348144e8:	e12fff33 	blx	r3
				+ ((ONENAND_REG_ECC_STATUS + i) << 1));
		if (likely(!ecc))
348144ec:	e3500000 	cmp	r0, #0
348144f0:	0a000003 	beq	34814504 <onenand_read_ecc+0x5c>
			continue;
		if (ecc & FLEXONENAND_UNCORRECTABLE_ERROR)
348144f4:	e3013010 	movw	r3, #4112	; 0x1010
348144f8:	e0003003 	and	r3, r0, r3
348144fc:	e3530000 	cmp	r3, #0
34814500:	1a000004 	bne	34814518 <onenand_read_ecc+0x70>
34814504:	e2855001 	add	r5, r5, #1
	int ecc, i;

	if (!FLEXONENAND(this))
		return this->read_word(this->base + ONENAND_REG_ECC_STATUS);

	for (i = 0; i < 4; i++) {
34814508:	e1550006 	cmp	r5, r6
3481450c:	1afffff2 	bne	348144dc <onenand_read_ecc+0x34>
			continue;
		if (ecc & FLEXONENAND_UNCORRECTABLE_ERROR)
			return ONENAND_ECC_2BIT_ALL;
	}

	return 0;
34814510:	e3a00000 	mov	r0, #0
34814514:	e8bd8070 	pop	{r4, r5, r6, pc}
		ecc = this->read_word(this->base
				+ ((ONENAND_REG_ECC_STATUS + i) << 1));
		if (likely(!ecc))
			continue;
		if (ecc & FLEXONENAND_UNCORRECTABLE_ERROR)
			return ONENAND_ECC_2BIT_ALL;
34814518:	e30a0aaa 	movw	r0, #43690	; 0xaaaa
	}

	return 0;
}
3481451c:	e8bd8070 	pop	{r4, r5, r6, pc}
34814520:	0001fe00 	.word	0x0001fe00
34814524:	0001fe04 	.word	0x0001fe04

34814528 <onenand_bbt_wait>:
 * @param state		state to select the max. timeout value
 *
 * Wait for command done.
 */
static int onenand_bbt_wait(struct mtd_info *mtd, int state)
{
34814528:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = mtd->priv;
3481452c:	e5906094 	ldr	r6, [r0, #148]	; 0x94
	unsigned int flags = ONENAND_INT_MASTER;
	unsigned int interrupt;
	unsigned int ctrl;

	while (1) {
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
34814530:	e5960000 	ldr	r0, [r6]
34814534:	e5963068 	ldr	r3, [r6, #104]	; 0x68
34814538:	e2800b79 	add	r0, r0, #123904	; 0x1e400
3481453c:	e2800082 	add	r0, r0, #130	; 0x82
34814540:	e12fff33 	blx	r3
		if (interrupt & flags)
34814544:	e3100902 	tst	r0, #32768	; 0x8000
34814548:	0afffff8 	beq	34814530 <onenand_bbt_wait+0x8>
			break;
	}

	/* To get correct interrupt status in timeout case */
	interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
3481454c:	e5960000 	ldr	r0, [r6]
34814550:	e5963068 	ldr	r3, [r6, #104]	; 0x68
34814554:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814558:	e2800082 	add	r0, r0, #130	; 0x82
3481455c:	e12fff33 	blx	r3
34814560:	e1a05000 	mov	r5, r0
	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
34814564:	e5960000 	ldr	r0, [r6]
34814568:	e5963068 	ldr	r3, [r6, #104]	; 0x68
3481456c:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814570:	e2800080 	add	r0, r0, #128	; 0x80
34814574:	e12fff33 	blx	r3

	if (interrupt & ONENAND_INT_READ) {
34814578:	e3150080 	tst	r5, #128	; 0x80
			break;
	}

	/* To get correct interrupt status in timeout case */
	interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
3481457c:	e1a04000 	mov	r4, r0

	if (interrupt & ONENAND_INT_READ) {
34814580:	0a00000b 	beq	348145b4 <onenand_bbt_wait+0x8c>
		int ecc = onenand_read_ecc(this);
34814584:	e1a00006 	mov	r0, r6
34814588:	ebffffc6 	bl	348144a8 <onenand_read_ecc>
		if (ecc & ONENAND_ECC_2BIT_ALL) {
3481458c:	e30a3aaa 	movw	r3, #43690	; 0xaaaa
34814590:	e0003003 	and	r3, r0, r3
34814594:	e3530000 	cmp	r3, #0
	/* To get correct interrupt status in timeout case */
	interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);

	if (interrupt & ONENAND_INT_READ) {
		int ecc = onenand_read_ecc(this);
34814598:	e1a01000 	mov	r1, r0
		if (ecc & ONENAND_ECC_2BIT_ALL) {
3481459c:	0a00000a 	beq	348145cc <onenand_bbt_wait+0xa4>
			printk(KERN_INFO "onenand_bbt_wait: ecc error = 0x%04x"
348145a0:	e59f0040 	ldr	r0, [pc, #64]	; 348145e8 <onenand_bbt_wait+0xc0>
348145a4:	e1a02004 	mov	r2, r4
348145a8:	ebffd2ed 	bl	34809164 <printf>
				", controller = 0x%04x\n", ecc, ctrl);
			return ONENAND_BBT_READ_ERROR;
348145ac:	e3a00001 	mov	r0, #1
348145b0:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
	} else {
		printk(KERN_ERR "onenand_bbt_wait: read timeout!"
348145b4:	e59f0030 	ldr	r0, [pc, #48]	; 348145ec <onenand_bbt_wait+0xc4>
348145b8:	e1a01004 	mov	r1, r4
348145bc:	e1a02005 	mov	r2, r5
348145c0:	ebffd2e7 	bl	34809164 <printf>
				"ctrl=0x%04x intr=0x%04x\n", ctrl, interrupt);
		return ONENAND_BBT_READ_FATAL_ERROR;
348145c4:	e3a00004 	mov	r0, #4
348145c8:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	/* Initial bad block case: 0x2400 or 0x0400 */
	if (ctrl & ONENAND_CTRL_ERROR) {
348145cc:	e2140b01 	ands	r0, r4, #1024	; 0x400
348145d0:	08bd8070 	popeq	{r4, r5, r6, pc}
		printk(KERN_DEBUG "onenand_bbt_wait: controller error = 0x%04x\n", ctrl);
348145d4:	e1a01004 	mov	r1, r4
348145d8:	e59f0010 	ldr	r0, [pc, #16]	; 348145f0 <onenand_bbt_wait+0xc8>
348145dc:	ebffd2e0 	bl	34809164 <printf>
		return ONENAND_BBT_READ_ERROR;
348145e0:	e3a00001 	mov	r0, #1
	}

	return 0;
}
348145e4:	e8bd8070 	pop	{r4, r5, r6, pc}
348145e8:	3482750c 	.word	0x3482750c
348145ec:	34827547 	.word	0x34827547
348145f0:	3482757f 	.word	0x3482757f

348145f4 <onenand_wait>:
 * Wait for command done. This applies to all OneNAND command
 * Read can take up to 30us, erase up to 2ms and program up to 350us
 * according to general OneNAND specs
 */
static int onenand_wait(struct mtd_info *mtd, int state)
{
348145f4:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = mtd->priv;
348145f8:	e5905094 	ldr	r5, [r0, #148]	; 0x94
	unsigned int flags = ONENAND_INT_MASTER;
	unsigned int interrupt = 0;
	unsigned int ctrl;

	while (1) {
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
348145fc:	e5950000 	ldr	r0, [r5]
34814600:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34814604:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814608:	e2800082 	add	r0, r0, #130	; 0x82
3481460c:	e12fff33 	blx	r3
		if (interrupt & flags)
34814610:	e3100902 	tst	r0, #32768	; 0x8000
	unsigned int flags = ONENAND_INT_MASTER;
	unsigned int interrupt = 0;
	unsigned int ctrl;

	while (1) {
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
34814614:	e1a06000 	mov	r6, r0
		if (interrupt & flags)
34814618:	0afffff7 	beq	348145fc <onenand_wait+0x8>
			break;
	}

	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
3481461c:	e5950000 	ldr	r0, [r5]
34814620:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34814624:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34814628:	e2800080 	add	r0, r0, #128	; 0x80
3481462c:	e12fff33 	blx	r3

	if (interrupt & ONENAND_INT_READ) {
34814630:	e3160080 	tst	r6, #128	; 0x80
		interrupt = this->read_word(this->base + ONENAND_REG_INTERRUPT);
		if (interrupt & flags)
			break;
	}

	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);
34814634:	e1a04000 	mov	r4, r0

	if (interrupt & ONENAND_INT_READ) {
34814638:	0a00000a 	beq	34814668 <onenand_wait+0x74>
		int ecc = onenand_read_ecc(this);
3481463c:	e1a00005 	mov	r0, r5
34814640:	ebffff98 	bl	348144a8 <onenand_read_ecc>
		if (ecc & ONENAND_ECC_2BIT_ALL) {
34814644:	e30a3aaa 	movw	r3, #43690	; 0xaaaa
34814648:	e0003003 	and	r3, r0, r3
3481464c:	e3530000 	cmp	r3, #0
	}

	ctrl = this->read_word(this->base + ONENAND_REG_CTRL_STATUS);

	if (interrupt & ONENAND_INT_READ) {
		int ecc = onenand_read_ecc(this);
34814650:	e1a01000 	mov	r1, r0
		if (ecc & ONENAND_ECC_2BIT_ALL) {
34814654:	0a000003 	beq	34814668 <onenand_wait+0x74>
			printk("onenand_wait: ECC error = 0x%04x\n", ecc);
34814658:	e59f0040 	ldr	r0, [pc, #64]	; 348146a0 <onenand_wait+0xac>
3481465c:	ebffd2c0 	bl	34809164 <printf>
			return -EBADMSG;
34814660:	e3e00049 	mvn	r0, #73	; 0x49
34814664:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
	}

	if (ctrl & ONENAND_CTRL_ERROR) {
34814668:	e2140b01 	ands	r0, r4, #1024	; 0x400
3481466c:	08bd8070 	popeq	{r4, r5, r6, pc}
		printk("onenand_wait: controller error = 0x%04x\n", ctrl);
34814670:	e59f002c 	ldr	r0, [pc, #44]	; 348146a4 <onenand_wait+0xb0>
34814674:	e1a01004 	mov	r1, r4
34814678:	ebffd2b9 	bl	34809164 <printf>
		if (ctrl & ONENAND_CTRL_LOCK)
3481467c:	e3140901 	tst	r4, #16384	; 0x4000
34814680:	0a000004 	beq	34814698 <onenand_wait+0xa4>
			printk("onenand_wait: it's locked error = 0x%04x\n",
34814684:	e59f001c 	ldr	r0, [pc, #28]	; 348146a8 <onenand_wait+0xb4>
34814688:	e1a01004 	mov	r1, r4
3481468c:	ebffd2b4 	bl	34809164 <printf>
				ctrl);

		return -EIO;
34814690:	e3e00004 	mvn	r0, #4
34814694:	e8bd8070 	pop	{r4, r5, r6, pc}
34814698:	e3e00004 	mvn	r0, #4
	}


	return 0;
}
3481469c:	e8bd8070 	pop	{r4, r5, r6, pc}
348146a0:	348275ac 	.word	0x348275ac
348146a4:	348275ce 	.word	0x348275ce
348146a8:	348275f7 	.word	0x348275f7

348146ac <onenand_transfer_auto_oob>:
 * @param column	oob offset to read from
 * @param thislen	oob length to read
 */
static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
					int column, int thislen)
{
348146ac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
348146b0:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	struct nand_oobfree *free;
	int readcol = column;
	int readend = column + thislen;
348146b4:	e0835002 	add	r5, r3, r2
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;
348146b8:	e5973090 	ldr	r3, [r7, #144]	; 0x90
 * @param column	oob offset to read from
 * @param thislen	oob length to read
 */
static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
					int column, int thislen)
{
348146bc:	e24dd018 	sub	sp, sp, #24
348146c0:	e1a09001 	mov	r9, r1
	int readend = column + thislen;
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;

	free = this->ecclayout->oobfree;
348146c4:	e597109c 	ldr	r1, [r7, #156]	; 0x9c
	struct nand_oobfree *free;
	int readcol = column;
	int readend = column + thislen;
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;
348146c8:	e58d3014 	str	r3, [sp, #20]

	free = this->ecclayout->oobfree;
348146cc:	e3a03000 	mov	r3, #0
 * @param column	oob offset to read from
 * @param thislen	oob length to read
 */
static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
					int column, int thislen)
{
348146d0:	e1a06002 	mov	r6, r2
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int readcol = column;
348146d4:	e1a04002 	mov	r4, r2
	int readend = column + thislen;
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;

	free = this->ecclayout->oobfree;
348146d8:	e2811f82 	add	r1, r1, #520	; 0x208
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int readcol = column;
	int readend = column + thislen;
	int lastgap = 0;
348146dc:	e1a02003 	mov	r2, r3
348146e0:	ea00000c 	b	34814718 <onenand_transfer_auto_oob+0x6c>
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
		if (readcol >= lastgap)
348146e4:	e1540002 	cmp	r4, r2
			readcol += free->offset - lastgap;
348146e8:	a791e003 	ldrge	lr, [r1, r3]
348146ec:	a084400e 	addge	r4, r4, lr
348146f0:	a0624004 	rsbge	r4, r2, r4
		if (readend >= lastgap)
348146f4:	e1550002 	cmp	r5, r2
			readend += free->offset - lastgap;
348146f8:	a791e003 	ldrge	lr, [r1, r3]
348146fc:	a085500e 	addge	r5, r5, lr
34814700:	a0625005 	rsbge	r5, r2, r5
		lastgap = free->offset + free->length;
34814704:	e7912003 	ldr	r2, [r1, r3]
34814708:	e2833008 	add	r3, r3, #8
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
3481470c:	e3530040 	cmp	r3, #64	; 0x40
34814710:	0a000004 	beq	34814728 <onenand_transfer_auto_oob+0x7c>
		if (readcol >= lastgap)
			readcol += free->offset - lastgap;
		if (readend >= lastgap)
			readend += free->offset - lastgap;
		lastgap = free->offset + free->length;
34814714:	e082200c 	add	r2, r2, ip
 * @param mtd		MTD device structure
 * @param buf		destination address
 * @param column	oob offset to read from
 * @param thislen	oob length to read
 */
static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
34814718:	e081c003 	add	ip, r1, r3
	int lastgap = 0;
	unsigned int i;
	uint8_t *oob_buf = this->oob_buf;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
3481471c:	e59cc004 	ldr	ip, [ip, #4]
34814720:	e35c0000 	cmp	ip, #0
34814724:	1affffee 	bne	348146e4 <onenand_transfer_auto_oob+0x38>
			readcol += free->offset - lastgap;
		if (readend >= lastgap)
			readend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
34814728:	e59f30bc 	ldr	r3, [pc, #188]	; 348147ec <onenand_transfer_auto_oob+0x140>
3481472c:	e3a0a000 	mov	sl, #0
34814730:	e58d3000 	str	r3, [sp]
34814734:	e59d3014 	ldr	r3, [sp, #20]
34814738:	e98d0408 	stmib	sp, {r3, sl}
3481473c:	e5903018 	ldr	r3, [r0, #24]
34814740:	e3a02000 	mov	r2, #0
34814744:	e58d300c 	str	r3, [sp, #12]
34814748:	e5971060 	ldr	r1, [r7, #96]	; 0x60
3481474c:	e3a03000 	mov	r3, #0
34814750:	e12fff31 	blx	r1
	free = this->ecclayout->oobfree;
34814754:	e597b09c 	ldr	fp, [r7, #156]	; 0x9c
34814758:	e1a0700a 	mov	r7, sl
3481475c:	e28bbf82 	add	fp, fp, #520	; 0x208
34814760:	ea00001a 	b	348147d0 <onenand_transfer_auto_oob+0x124>
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
		int free_end = free->offset + free->length;
34814764:	e79b1007 	ldr	r1, [fp, r7]
34814768:	e081a00a 	add	sl, r1, sl
		if (free->offset < readend && free_end > readcol) {
3481476c:	e1510005 	cmp	r1, r5
34814770:	23a03000 	movcs	r3, #0
34814774:	33a03001 	movcc	r3, #1
34814778:	e15a0004 	cmp	sl, r4
3481477c:	d3a03000 	movle	r3, #0
34814780:	e3530000 	cmp	r3, #0
34814784:	0a00000c 	beq	348147bc <onenand_transfer_auto_oob+0x110>
			int st = max_t(int,free->offset,readcol);
34814788:	e1540001 	cmp	r4, r1
3481478c:	a1a01004 	movge	r1, r4
34814790:	b1a01001 	movlt	r1, r1
			int ed = min_t(int,free_end,readend);
			int n = ed - st;
			memcpy(buf, oob_buf + st, n);
34814794:	e59d3014 	ldr	r3, [sp, #20]
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
		int free_end = free->offset + free->length;
		if (free->offset < readend && free_end > readcol) {
			int st = max_t(int,free->offset,readcol);
			int ed = min_t(int,free_end,readend);
			int n = ed - st;
34814798:	e155000a 	cmp	r5, sl
3481479c:	d061a005 	rsble	sl, r1, r5
348147a0:	c061a00a 	rsbgt	sl, r1, sl
			memcpy(buf, oob_buf + st, n);
348147a4:	e1a00009 	mov	r0, r9
348147a8:	e0831001 	add	r1, r3, r1
348147ac:	e1a0200a 	mov	r2, sl
348147b0:	eb001de7 	bl	3481bf54 <memcpy>
			buf += n;
348147b4:	e089900a 	add	r9, r9, sl
348147b8:	ea000001 	b	348147c4 <onenand_transfer_auto_oob+0x118>
		} else if (column == 0)
348147bc:	e3560000 	cmp	r6, #0
348147c0:	0a000006 	beq	348147e0 <onenand_transfer_auto_oob+0x134>
348147c4:	e2877008 	add	r7, r7, #8
			readend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
348147c8:	e3570040 	cmp	r7, #64	; 0x40
348147cc:	0a000003 	beq	348147e0 <onenand_transfer_auto_oob+0x134>
 * @param mtd		MTD device structure
 * @param buf		destination address
 * @param column	oob offset to read from
 * @param thislen	oob length to read
 */
static int onenand_transfer_auto_oob(struct mtd_info *mtd, uint8_t *buf,
348147d0:	e08b3007 	add	r3, fp, r7
			readend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oob_buf, 0, mtd->oobsize);
	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
348147d4:	e593a004 	ldr	sl, [r3, #4]
348147d8:	e35a0000 	cmp	sl, #0
348147dc:	1affffe0 	bne	34814764 <onenand_transfer_auto_oob+0xb8>
			buf += n;
		} else if (column == 0)
			break;
	}
	return 0;
}
348147e0:	e3a00000 	mov	r0, #0
348147e4:	e28dd018 	add	sp, sp, #24
348147e8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348147ec:	00010020 	.word	0x00010020

348147f0 <onenand_update_bufferram.clone.2>:
 * @param addr		address to update
 * @param valid		valid flag
 *
 * Update BufferRAM information
 */
static int onenand_update_bufferram(struct mtd_info *mtd, loff_t addr,
348147f0:	e92d4010 	push	{r4, lr}
348147f4:	e1a04000 	mov	r4, r0
	unsigned int i;

	if (ONENAND_IS_2PLANE(this))
		blockpage = onenand_get_2x_blockpage(mtd, addr);
	else
		blockpage = (int)(addr >> this->page_shift);
348147f8:	e1a01003 	mov	r1, r3
348147fc:	e1a00002 	mov	r0, r2
34814800:	e5942034 	ldr	r2, [r4, #52]	; 0x34
34814804:	eb002dff 	bl	34820008 <__ashrdi3>

	/* Invalidate another BufferRAM */
	i = ONENAND_NEXT_BUFFERRAM(this);
34814808:	e5943044 	ldr	r3, [r4, #68]	; 0x44
3481480c:	e2232001 	eor	r2, r3, #1
	if (this->bufferram[i].blockpage == blockpage)
34814810:	e2822012 	add	r2, r2, #18
34814814:	e7941102 	ldr	r1, [r4, r2, lsl #2]
34814818:	e2833012 	add	r3, r3, #18
3481481c:	e1510000 	cmp	r1, r0
		this->bufferram[i].blockpage = -1;
34814820:	03e01000 	mvneq	r1, #0
34814824:	07841102 	streq	r1, [r4, r2, lsl #2]

	/* Update BufferRAM */
	i = ONENAND_CURRENT_BUFFERRAM(this);
	if (valid)
34814828:	e59d2008 	ldr	r2, [sp, #8]
3481482c:	e3520000 	cmp	r2, #0
		this->bufferram[i].blockpage = blockpage;
	else
		this->bufferram[i].blockpage = -1;
34814830:	03e02000 	mvneq	r2, #0
		this->bufferram[i].blockpage = -1;

	/* Update BufferRAM */
	i = ONENAND_CURRENT_BUFFERRAM(this);
	if (valid)
		this->bufferram[i].blockpage = blockpage;
34814834:	17840103 	strne	r0, [r4, r3, lsl #2]
	else
		this->bufferram[i].blockpage = -1;
34814838:	07842103 	streq	r2, [r4, r3, lsl #2]

	return 0;
}
3481483c:	e3a00000 	mov	r0, #0
34814840:	e8bd8010 	pop	{r4, pc}

34814844 <onenand_fill_auto_oob.clone.7>:
 * @param oob_buf       oob buffer
 * @param buf           source address
 * @param column        oob offset to write to
 * @param thislen       oob length to write
 */
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
34814844:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
		const u_char *buf, int column, int thislen)
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int writecol = column;
	int writeend = column + thislen;
34814848:	e59d7028 	ldr	r7, [sp, #40]	; 0x28
	int lastgap = 0;
	unsigned int i;

	free = this->ecclayout->oobfree;
3481484c:	e590409c 	ldr	r4, [r0, #156]	; 0x9c
 * @param oob_buf       oob buffer
 * @param buf           source address
 * @param column        oob offset to write to
 * @param thislen       oob length to write
 */
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
34814850:	e1a09003 	mov	r9, r3
		const u_char *buf, int column, int thislen)
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int writecol = column;
	int writeend = column + thislen;
34814854:	e0877003 	add	r7, r7, r3
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
		const u_char *buf, int column, int thislen)
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int writecol = column;
34814858:	e1a06003 	mov	r6, r3
	int writeend = column + thislen;
	int lastgap = 0;
	unsigned int i;

	free = this->ecclayout->oobfree;
3481485c:	e3a03000 	mov	r3, #0
 * @param oob_buf       oob buffer
 * @param buf           source address
 * @param column        oob offset to write to
 * @param thislen       oob length to write
 */
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
34814860:	e1a0b002 	mov	fp, r2
34814864:	e1a0c001 	mov	ip, r1
	int writecol = column;
	int writeend = column + thislen;
	int lastgap = 0;
	unsigned int i;

	free = this->ecclayout->oobfree;
34814868:	e2844f82 	add	r4, r4, #520	; 0x208
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int writecol = column;
	int writeend = column + thislen;
	int lastgap = 0;
3481486c:	e1a02003 	mov	r2, r3
34814870:	ea00000c 	b	348148a8 <onenand_fill_auto_oob.clone.7+0x64>
	unsigned int i;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
		if (writecol >= lastgap)
34814874:	e1560002 	cmp	r6, r2
			writecol += free->offset - lastgap;
34814878:	a7940003 	ldrge	r0, [r4, r3]
3481487c:	a0866000 	addge	r6, r6, r0
34814880:	a0626006 	rsbge	r6, r2, r6
		if (writeend >= lastgap)
34814884:	e1570002 	cmp	r7, r2
			writeend += free->offset - lastgap;
34814888:	a7940003 	ldrge	r0, [r4, r3]
3481488c:	a0877000 	addge	r7, r7, r0
34814890:	a0627007 	rsbge	r7, r2, r7
		lastgap = free->offset + free->length;
34814894:	e7942003 	ldr	r2, [r4, r3]
34814898:	e2833008 	add	r3, r3, #8
	int writeend = column + thislen;
	int lastgap = 0;
	unsigned int i;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
3481489c:	e3530040 	cmp	r3, #64	; 0x40
348148a0:	0a000004 	beq	348148b8 <onenand_fill_auto_oob.clone.7+0x74>
		if (writecol >= lastgap)
			writecol += free->offset - lastgap;
		if (writeend >= lastgap)
			writeend += free->offset - lastgap;
		lastgap = free->offset + free->length;
348148a4:	e0812002 	add	r2, r1, r2
 * @param oob_buf       oob buffer
 * @param buf           source address
 * @param column        oob offset to write to
 * @param thislen       oob length to write
 */
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
348148a8:	e0841003 	add	r1, r4, r3
	int writeend = column + thislen;
	int lastgap = 0;
	unsigned int i;

	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
348148ac:	e5911004 	ldr	r1, [r1, #4]
348148b0:	e3510000 	cmp	r1, #0
348148b4:	1affffee 	bne	34814874 <onenand_fill_auto_oob.clone.7+0x30>
{
	struct onenand_chip *this = mtd->priv;
	struct nand_oobfree *free;
	int writecol = column;
	int writeend = column + thislen;
	int lastgap = 0;
348148b8:	e3a05000 	mov	r5, #0
348148bc:	ea00001b 	b	34814930 <onenand_fill_auto_oob.clone.7+0xec>
			writeend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
		int free_end = free->offset + free->length;
348148c0:	e7940005 	ldr	r0, [r4, r5]
348148c4:	e08aa000 	add	sl, sl, r0
		if (free->offset < writeend && free_end > writecol) {
348148c8:	e1500007 	cmp	r0, r7
348148cc:	23a03000 	movcs	r3, #0
348148d0:	33a03001 	movcc	r3, #1
348148d4:	e15a0006 	cmp	sl, r6
348148d8:	d3a03000 	movle	r3, #0
348148dc:	e3530000 	cmp	r3, #0
348148e0:	0a00000d 	beq	3481491c <onenand_fill_auto_oob.clone.7+0xd8>
			int st = max_t(int,free->offset,writecol);
348148e4:	e1560000 	cmp	r6, r0
348148e8:	a1a00006 	movge	r0, r6
348148ec:	b1a00000 	movlt	r0, r0
			int ed = min_t(int,free_end,writeend);
			int n = ed - st;
348148f0:	e157000a 	cmp	r7, sl
348148f4:	d060a007 	rsble	sl, r0, r7
348148f8:	c060a00a 	rsbgt	sl, r0, sl
			memcpy(oob_buf + st, buf, n);
348148fc:	e1a0100b 	mov	r1, fp
34814900:	e08c0000 	add	r0, ip, r0
34814904:	e1a0200a 	mov	r2, sl
34814908:	e58dc004 	str	ip, [sp, #4]
			buf += n;
3481490c:	e08bb00a 	add	fp, fp, sl
		int free_end = free->offset + free->length;
		if (free->offset < writeend && free_end > writecol) {
			int st = max_t(int,free->offset,writecol);
			int ed = min_t(int,free_end,writeend);
			int n = ed - st;
			memcpy(oob_buf + st, buf, n);
34814910:	eb001d8f 	bl	3481bf54 <memcpy>
34814914:	e59dc004 	ldr	ip, [sp, #4]
34814918:	ea000001 	b	34814924 <onenand_fill_auto_oob.clone.7+0xe0>
			buf += n;
		} else if (column == 0)
3481491c:	e3590000 	cmp	r9, #0
34814920:	0a000006 	beq	34814940 <onenand_fill_auto_oob.clone.7+0xfc>
34814924:	e2855008 	add	r5, r5, #8
		if (writeend >= lastgap)
			writeend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34814928:	e3550040 	cmp	r5, #64	; 0x40
3481492c:	0a000003 	beq	34814940 <onenand_fill_auto_oob.clone.7+0xfc>
 * @param oob_buf       oob buffer
 * @param buf           source address
 * @param column        oob offset to write to
 * @param thislen       oob length to write
 */
static int onenand_fill_auto_oob(struct mtd_info *mtd, u_char *oob_buf,
34814930:	e0843005 	add	r3, r4, r5
		if (writeend >= lastgap)
			writeend += free->offset - lastgap;
		lastgap = free->offset + free->length;
	}
	free = this->ecclayout->oobfree;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES && free->length; i++, free++) {
34814934:	e593a004 	ldr	sl, [r3, #4]
34814938:	e35a0000 	cmp	sl, #0
3481493c:	1affffdf 	bne	348148c0 <onenand_fill_auto_oob.clone.7+0x7c>
			buf += n;
		} else if (column == 0)
			break;
	}
	return 0;
}
34814940:	e3a00000 	mov	r0, #0
34814944:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

34814948 <onenand_write_oob_nolock>:
 *
 * OneNAND write out-of-band
 */
static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
34814948:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481494c:	e24dd038 	sub	sp, sp, #56	; 0x38
34814950:	e59db058 	ldr	fp, [sp, #88]	; 0x58
	struct onenand_chip *this = mtd->priv;
34814954:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
	u_char *oobbuf;
	size_t len = ops->ooblen;
	const u_char *buf = ops->oobbuf;
34814958:	e59b101c 	ldr	r1, [fp, #28]
	mtd_oob_mode_t mode = ops->mode;
3481495c:	e59b4000 	ldr	r4, [fp]
	struct onenand_chip *this = mtd->priv;
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
	u_char *oobbuf;
	size_t len = ops->ooblen;
	const u_char *buf = ops->oobbuf;
34814960:	e58d1028 	str	r1, [sp, #40]	; 0x28
	mtd_oob_mode_t mode = ops->mode;

	to += ops->ooboffs;
34814964:	e59b1014 	ldr	r1, [fp, #20]
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
	u_char *oobbuf;
	size_t len = ops->ooblen;
	const u_char *buf = ops->oobbuf;
	mtd_oob_mode_t mode = ops->mode;
34814968:	e58d4030 	str	r4, [sp, #48]	; 0x30

	to += ops->ooboffs;
3481496c:	e0924001 	adds	r4, r2, r1
34814970:	e2a35000 	adc	r5, r3, #0
34814974:	e1cd41f8 	strd	r4, [sp, #24]
	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
34814978:	e59d5030 	ldr	r5, [sp, #48]	; 0x30
 *
 * OneNAND write out-of-band
 */
static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
3481497c:	e1a06000 	mov	r6, r0
	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
34814980:	e3550001 	cmp	r5, #1
	to += ops->ooboffs;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;
34814984:	e3a03000 	mov	r3, #0
{
	struct onenand_chip *this = mtd->priv;
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
	u_char *oobbuf;
	size_t len = ops->ooblen;
34814988:	e59b000c 	ldr	r0, [fp, #12]
	to += ops->ooboffs;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_oob_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;
3481498c:	e58b3010 	str	r3, [fp, #16]
	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	column = to & (mtd->oobsize - 1);
34814990:	e5969018 	ldr	r9, [r6, #24]

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
34814994:	0597309c 	ldreq	r3, [r7, #156]	; 0x9c
{
	struct onenand_chip *this = mtd->priv;
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
	u_char *oobbuf;
	size_t len = ops->ooblen;
34814998:	e58d002c 	str	r0, [sp, #44]	; 0x2c
	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	column = to & (mtd->oobsize - 1);
3481499c:	e59d0018 	ldr	r0, [sp, #24]

	/* Initialize retlen, in case of early exit */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
348149a0:	0593a204 	ldreq	sl, [r3, #516]	; 0x204
	else
		oobsize = mtd->oobsize;
348149a4:	1596a018 	ldrne	sl, [r6, #24]

	column = to & (mtd->oobsize - 1);
348149a8:	e2499001 	sub	r9, r9, #1
348149ac:	e0099000 	and	r9, r9, r0

	if (unlikely(column >= oobsize)) {
348149b0:	e159000a 	cmp	r9, sl
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to start write outside oob\n");
348149b4:	a59f0280 	ldrge	r0, [pc, #640]	; 34814c3c <onenand_write_oob_nolock+0x2f4>
	else
		oobsize = mtd->oobsize;

	column = to & (mtd->oobsize - 1);

	if (unlikely(column >= oobsize)) {
348149b8:	aa000004 	bge	348149d0 <onenand_write_oob_nolock+0x88>
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to start write outside oob\n");
		return -EINVAL;
	}

	/* For compatibility with NAND: Do not allow write past end of page */
	if (unlikely(column + len > oobsize)) {
348149bc:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
348149c0:	e089c001 	add	ip, r9, r1
348149c4:	e15c000a 	cmp	ip, sl
348149c8:	9a000003 	bls	348149dc <onenand_write_oob_nolock+0x94>
		printk(KERN_ERR "onenand_write_oob_nolock: "
348149cc:	e59f026c 	ldr	r0, [pc, #620]	; 34814c40 <onenand_write_oob_nolock+0x2f8>
348149d0:	ebffd1e3 	bl	34809164 <printf>
				"Attempt to write past end of page\n");
		return -EINVAL;
348149d4:	e3e09015 	mvn	r9, #21
348149d8:	ea000094 	b	34814c30 <onenand_write_oob_nolock+0x2e8>
	}

	/* Do not allow reads past end of device */
	if (unlikely(to >= mtd->size ||
348149dc:	e596100c 	ldr	r1, [r6, #12]
348149e0:	e59d201c 	ldr	r2, [sp, #28]
348149e4:	e5960008 	ldr	r0, [r6, #8]
348149e8:	e1510002 	cmp	r1, r2
348149ec:	8a000003 	bhi	34814a00 <onenand_write_oob_nolock+0xb8>
348149f0:	1a00001c 	bne	34814a68 <onenand_write_oob_nolock+0x120>
348149f4:	e59d3018 	ldr	r3, [sp, #24]
348149f8:	e1500003 	cmp	r0, r3
348149fc:	9a000019 	bls	34814a68 <onenand_write_oob_nolock+0x120>
34814a00:	e5973034 	ldr	r3, [r7, #52]	; 0x34
34814a04:	e1a0400a 	mov	r4, sl
34814a08:	e1a05fc4 	asr	r5, r4, #31
34814a0c:	e1a02003 	mov	r2, r3
34814a10:	e1cd42f0 	strd	r4, [sp, #32]
34814a14:	e58dc010 	str	ip, [sp, #16]
34814a18:	e58d3014 	str	r3, [sp, #20]
34814a1c:	eb002d72 	bl	3481ffec <__lshrdi3>
34814a20:	e59d3014 	ldr	r3, [sp, #20]
34814a24:	e1a04000 	mov	r4, r0
34814a28:	e1a05001 	mov	r5, r1
34814a2c:	e1a02003 	mov	r2, r3
34814a30:	e1cd01d8 	ldrd	r0, [sp, #24]
34814a34:	eb002d73 	bl	34820008 <__ashrdi3>
34814a38:	e0544000 	subs	r4, r4, r0
34814a3c:	e0c55001 	sbc	r5, r5, r1
34814a40:	e003059a 	mul	r3, sl, r5
34814a44:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
34814a48:	e59dc010 	ldr	ip, [sp, #16]
34814a4c:	e0233094 	mla	r3, r4, r0, r3
34814a50:	e085449a 	umull	r4, r5, sl, r4
34814a54:	e0835005 	add	r5, r3, r5
34814a58:	e3550000 	cmp	r5, #0
34814a5c:	1a000003 	bne	34814a70 <onenand_write_oob_nolock+0x128>
34814a60:	e15c0004 	cmp	ip, r4
34814a64:	9a000001 	bls	34814a70 <onenand_write_oob_nolock+0x128>
				column + len > ((mtd->size >> this->page_shift) -
					(to >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to write past end of device\n");
34814a68:	e59f01d4 	ldr	r0, [pc, #468]	; 34814c44 <onenand_write_oob_nolock+0x2fc>
34814a6c:	eaffffd7 	b	348149d0 <onenand_write_oob_nolock+0x88>
		return -EINVAL;
	}

	oobbuf = this->oob_buf;

	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
34814a70:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
					(to >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to write past end of device\n");
		return -EINVAL;
	}

	oobbuf = this->oob_buf;
34814a74:	e5971090 	ldr	r1, [r7, #144]	; 0x90

	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;
34814a78:	e3130008 	tst	r3, #8
34814a7c:	03a0201a 	moveq	r2, #26
34814a80:	13a02080 	movne	r2, #128	; 0x80
					(to >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_write_oob_nolock: Attempted to write past end of device\n");
		return -EINVAL;
	}

	oobbuf = this->oob_buf;
34814a84:	e58d1020 	str	r1, [sp, #32]

	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;
34814a88:	e58d2034 	str	r2, [sp, #52]	; 0x34
static int onenand_write_oob_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int column, ret = 0, oobsize;
	int written = 0, oobcmd;
34814a8c:	e3a04000 	mov	r4, #0

	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;

	/* Loop until all data write */
	while (written < len) {
34814a90:	ea000061 	b	34814c1c <onenand_write_oob_nolock+0x2d4>
		int thislen = min_t(int, oobsize, len - written);
34814a94:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c

		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, mtd->oobsize);
34814a98:	e3011978 	movw	r1, #6520	; 0x1978
	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;

	/* Loop until all data write */
	while (written < len) {
		int thislen = min_t(int, oobsize, len - written);
34814a9c:	e0645003 	rsb	r5, r4, r3

		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, mtd->oobsize);
34814aa0:	e5963018 	ldr	r3, [r6, #24]
34814aa4:	e1a00006 	mov	r0, r6
34814aa8:	e58d3000 	str	r3, [sp]
34814aac:	e597c050 	ldr	ip, [r7, #80]	; 0x50
34814ab0:	e1cd21d8 	ldrd	r2, [sp, #24]
34814ab4:	e12fff3c 	blx	ip

		/* We send data to spare ram with oobsize
		 * to prevent byte access */
		memset(oobbuf, 0xff, mtd->oobsize);
34814ab8:	e59d0020 	ldr	r0, [sp, #32]
34814abc:	e3a010ff 	mov	r1, #255	; 0xff
34814ac0:	e5962018 	ldr	r2, [r6, #24]
34814ac4:	eb001cfe 	bl	3481bec4 <memset>
		if (mode == MTD_OOB_AUTO)
34814ac8:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;

	/* Loop until all data write */
	while (written < len) {
		int thislen = min_t(int, oobsize, len - written);
34814acc:	e155000a 	cmp	r5, sl
34814ad0:	a1a0500a 	movge	r5, sl
		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, mtd->oobsize);

		/* We send data to spare ram with oobsize
		 * to prevent byte access */
		memset(oobbuf, 0xff, mtd->oobsize);
		if (mode == MTD_OOB_AUTO)
34814ad4:	e3500001 	cmp	r0, #1
34814ad8:	1a000006 	bne	34814af8 <onenand_write_oob_nolock+0x1b0>
			onenand_fill_auto_oob(mtd, oobbuf, buf, column, thislen);
34814adc:	e5960094 	ldr	r0, [r6, #148]	; 0x94
34814ae0:	e59d1020 	ldr	r1, [sp, #32]
34814ae4:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
34814ae8:	e1a03009 	mov	r3, r9
34814aec:	e58d5000 	str	r5, [sp]
34814af0:	ebffff53 	bl	34814844 <onenand_fill_auto_oob.clone.7>
34814af4:	ea000004 	b	34814b0c <onenand_write_oob_nolock+0x1c4>
		else
			memcpy(oobbuf + column, buf, thislen);
34814af8:	e59d1020 	ldr	r1, [sp, #32]
34814afc:	e1a02005 	mov	r2, r5
34814b00:	e0810009 	add	r0, r1, r9
34814b04:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
34814b08:	eb001d11 	bl	3481bf54 <memcpy>
		this->write_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
34814b0c:	e59d3020 	ldr	r3, [sp, #32]
34814b10:	e59f2130 	ldr	r2, [pc, #304]	; 34814c48 <onenand_write_oob_nolock+0x300>
34814b14:	e58d3004 	str	r3, [sp, #4]
34814b18:	e5963018 	ldr	r3, [r6, #24]
34814b1c:	e3a00000 	mov	r0, #0
34814b20:	e58d2000 	str	r2, [sp]
34814b24:	e58d0008 	str	r0, [sp, #8]
34814b28:	e58d300c 	str	r3, [sp, #12]
34814b2c:	e5971064 	ldr	r1, [r7, #100]	; 0x64
34814b30:	e3a03000 	mov	r3, #0
34814b34:	e1a00006 	mov	r0, r6
34814b38:	e3a02000 	mov	r2, #0
34814b3c:	e12fff31 	blx	r1

		if (ONENAND_IS_4KB_PAGE(this)) {
34814b40:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34814b44:	e3130008 	tst	r3, #8
34814b48:	0a000010 	beq	34814b90 <onenand_write_oob_nolock+0x248>
			/* Set main area of DataRAM to 0xff*/
			memset(this->page_buf, 0xff, mtd->writesize);
34814b4c:	e3a010ff 	mov	r1, #255	; 0xff
34814b50:	e5962014 	ldr	r2, [r6, #20]
34814b54:	e597008c 	ldr	r0, [r7, #140]	; 0x8c
34814b58:	eb001cd9 	bl	3481bec4 <memset>
			this->write_bufferram(mtd, 0, ONENAND_DATARAM,
34814b5c:	e3a01b01 	mov	r1, #1024	; 0x400
34814b60:	e58d1000 	str	r1, [sp]
34814b64:	e597308c 	ldr	r3, [r7, #140]	; 0x8c
34814b68:	e3a02000 	mov	r2, #0
34814b6c:	e58d3004 	str	r3, [sp, #4]
34814b70:	e5963014 	ldr	r3, [r6, #20]
34814b74:	e58d2008 	str	r2, [sp, #8]
34814b78:	e58d300c 	str	r3, [sp, #12]
34814b7c:	e5971064 	ldr	r1, [r7, #100]	; 0x64
34814b80:	e1a00006 	mov	r0, r6
34814b84:	e3a02000 	mov	r2, #0
34814b88:	e3a03000 	mov	r3, #0
34814b8c:	e12fff31 	blx	r1
				this->page_buf,	0, mtd->writesize);
		}

		this->command(mtd, oobcmd, to, mtd->oobsize);
34814b90:	e5963018 	ldr	r3, [r6, #24]
34814b94:	e59d1034 	ldr	r1, [sp, #52]	; 0x34
34814b98:	e58d3000 	str	r3, [sp]
34814b9c:	e597c050 	ldr	ip, [r7, #80]	; 0x50
34814ba0:	e1cd21d8 	ldrd	r2, [sp, #24]
34814ba4:	e1a00006 	mov	r0, r6
34814ba8:	e12fff3c 	blx	ip

		onenand_update_bufferram(mtd, to, 0);
34814bac:	e3a03000 	mov	r3, #0
34814bb0:	e58d3000 	str	r3, [sp]
34814bb4:	e5960094 	ldr	r0, [r6, #148]	; 0x94
34814bb8:	e1cd21d8 	ldrd	r2, [sp, #24]
34814bbc:	ebffff0b 	bl	348147f0 <onenand_update_bufferram.clone.2>
		if (ONENAND_IS_2PLANE(this)) {
			ONENAND_SET_BUFFERRAM1(this);
			onenand_update_bufferram(mtd, to + this->writesize, 0);
		}

		ret = this->wait(mtd, FL_WRITING);
34814bc0:	e5973054 	ldr	r3, [r7, #84]	; 0x54
34814bc4:	e1a00006 	mov	r0, r6
34814bc8:	e3a01002 	mov	r1, #2
34814bcc:	e12fff33 	blx	r3
		if (ret) {
34814bd0:	e2509000 	subs	r9, r0, #0
34814bd4:	0a000003 	beq	34814be8 <onenand_write_oob_nolock+0x2a0>
			printk(KERN_ERR "onenand_write_oob_nolock: write failed %d\n", ret);
34814bd8:	e1a01009 	mov	r1, r9
34814bdc:	e59f0068 	ldr	r0, [pc, #104]	; 34814c4c <onenand_write_oob_nolock+0x304>
34814be0:	ebffd15f 	bl	34809164 <printf>
			break;
34814be4:	ea000010 	b	34814c2c <onenand_write_oob_nolock+0x2e4>
			printk(KERN_ERR "onenand_write_oob_nolock: verify failed %d\n", ret);
			break;
		}

		written += thislen;
		if (written == len)
34814be8:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
		if (ret) {
			printk(KERN_ERR "onenand_write_oob_nolock: verify failed %d\n", ret);
			break;
		}

		written += thislen;
34814bec:	e0844005 	add	r4, r4, r5
		if (written == len)
34814bf0:	e1540000 	cmp	r4, r0
34814bf4:	0a00000c 	beq	34814c2c <onenand_write_oob_nolock+0x2e4>
			break;

		to += mtd->writesize;
34814bf8:	e5963014 	ldr	r3, [r6, #20]
34814bfc:	e1cd01d8 	ldrd	r0, [sp, #24]
34814c00:	e0900003 	adds	r0, r0, r3
34814c04:	e2a11000 	adc	r1, r1, #0
34814c08:	e1cd01f8 	strd	r0, [sp, #24]
		buf += thislen;
34814c0c:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
		column = 0;
34814c10:	e3a09000 	mov	r9, #0
		written += thislen;
		if (written == len)
			break;

		to += mtd->writesize;
		buf += thislen;
34814c14:	e0811005 	add	r1, r1, r5
34814c18:	e58d1028 	str	r1, [sp, #40]	; 0x28

	oobcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_PROG : ONENAND_CMD_PROGOOB;

	/* Loop until all data write */
	while (written < len) {
34814c1c:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
34814c20:	e1540002 	cmp	r4, r2
34814c24:	3affff9a 	bcc	34814a94 <onenand_write_oob_nolock+0x14c>
34814c28:	e3a09000 	mov	r9, #0
		to += mtd->writesize;
		buf += thislen;
		column = 0;
	}

	ops->oobretlen = written;
34814c2c:	e58b4010 	str	r4, [fp, #16]

	return ret;
}
34814c30:	e1a00009 	mov	r0, r9
34814c34:	e28dd038 	add	sp, sp, #56	; 0x38
34814c38:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34814c3c:	34827621 	.word	0x34827621
34814c40:	34827661 	.word	0x34827661
34814c44:	3482769e 	.word	0x3482769e
34814c48:	00010020 	.word	0x00010020
34814c4c:	348276df 	.word	0x348276df

34814c50 <onenand_write_ops_nolock>:
 *
 * Write main and/or oob with ECC
 */
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
34814c50:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34814c54:	e24dd038 	sub	sp, sp, #56	; 0x38
34814c58:	e59d6058 	ldr	r6, [sp, #88]	; 0x58
34814c5c:	e1cd21f0 	strd	r2, [sp, #16]
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
	const u_char *buf = ops->datbuf;
	const u_char *oob = ops->oobbuf;
34814c60:	e596301c 	ldr	r3, [r6, #28]
 * Write main and/or oob with ECC
 */
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
34814c64:	e5905094 	ldr	r5, [r0, #148]	; 0x94
 *
 * Write main and/or oob with ECC
 */
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
34814c68:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
34814c6c:	e596100c 	ldr	r1, [r6, #12]
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
	size_t len = ops->len;
34814c70:	e5960004 	ldr	r0, [r6, #4]
	size_t ooblen = ops->ooblen;
	const u_char *buf = ops->datbuf;
34814c74:	e5962018 	ldr	r2, [r6, #24]
	const u_char *oob = ops->oobbuf;
34814c78:	e58d301c 	str	r3, [sp, #28]
	int ret = 0;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_ops_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->retlen = 0;
34814c7c:	e3a03000 	mov	r3, #0
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
34814c80:	e58d1034 	str	r1, [sp, #52]	; 0x34
	const u_char *buf = ops->datbuf;
34814c84:	e58d2028 	str	r2, [sp, #40]	; 0x28
	int ret = 0;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_write_ops_nolock: to = 0x%08x, len = %i\n", (unsigned int) to, (int) len);

	/* Initialize retlen, in case of early exit */
	ops->retlen = 0;
34814c88:	e5863008 	str	r3, [r6, #8]
	ops->oobretlen = 0;
34814c8c:	e5863010 	str	r3, [r6, #16]

	/* Do not allow writes past end of device */
	if (unlikely((to + len) > mtd->size)) {
34814c90:	e594100c 	ldr	r1, [r4, #12]
34814c94:	e1cd21d0 	ldrd	r2, [sp, #16]
34814c98:	e0922000 	adds	r2, r2, r0
34814c9c:	e2a33000 	adc	r3, r3, #0
34814ca0:	e1510003 	cmp	r1, r3
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
	size_t len = ops->len;
34814ca4:	e58d0020 	str	r0, [sp, #32]
	/* Initialize retlen, in case of early exit */
	ops->retlen = 0;
	ops->oobretlen = 0;

	/* Do not allow writes past end of device */
	if (unlikely((to + len) > mtd->size)) {
34814ca8:	3a000003 	bcc	34814cbc <onenand_write_ops_nolock+0x6c>
34814cac:	1a000004 	bne	34814cc4 <onenand_write_ops_nolock+0x74>
34814cb0:	e5941008 	ldr	r1, [r4, #8]
34814cb4:	e1510002 	cmp	r1, r2
34814cb8:	2a000001 	bcs	34814cc4 <onenand_write_ops_nolock+0x74>
		printk(KERN_ERR "onenand_write_ops_nolock: Attempt write to past end of device\n");
34814cbc:	e59f02c0 	ldr	r0, [pc, #704]	; 34814f84 <onenand_write_ops_nolock+0x334>
34814cc0:	ea00000a 	b	34814cf0 <onenand_write_ops_nolock+0xa0>
		return -EINVAL;
	}

	/* Reject writes, which are not page aligned */
	if (unlikely(NOTALIGNED(to) || NOTALIGNED(len))) {
34814cc4:	e5951098 	ldr	r1, [r5, #152]	; 0x98
34814cc8:	e1cd21d0 	ldrd	r2, [sp, #16]
34814ccc:	e2411001 	sub	r1, r1, #1
34814cd0:	e0022001 	and	r2, r2, r1
34814cd4:	e0033fc1 	and	r3, r3, r1, asr #31
34814cd8:	e1920003 	orrs	r0, r2, r3
34814cdc:	1a000002 	bne	34814cec <onenand_write_ops_nolock+0x9c>
34814ce0:	e59d2020 	ldr	r2, [sp, #32]
34814ce4:	e1110002 	tst	r1, r2
34814ce8:	0a000003 	beq	34814cfc <onenand_write_ops_nolock+0xac>
		printk(KERN_ERR "onenand_write_ops_nolock: Attempt to write not page aligned data\n");
34814cec:	e59f0294 	ldr	r0, [pc, #660]	; 34814f88 <onenand_write_ops_nolock+0x338>
34814cf0:	ebffd11b 	bl	34809164 <printf>
		return -EINVAL;
34814cf4:	e3e07015 	mvn	r7, #21
34814cf8:	ea00009e 	b	34814f78 <onenand_write_ops_nolock+0x328>
	}

	if (ops->mode == MTD_OOB_AUTO)
34814cfc:	e5963000 	ldr	r3, [r6]
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = to & (mtd->oobsize - 1);
34814d00:	e5942018 	ldr	r2, [r4, #24]
	if (unlikely(NOTALIGNED(to) || NOTALIGNED(len))) {
		printk(KERN_ERR "onenand_write_ops_nolock: Attempt to write not page aligned data\n");
		return -EINVAL;
	}

	if (ops->mode == MTD_OOB_AUTO)
34814d04:	e3530001 	cmp	r3, #1
		oobsize = this->ecclayout->oobavail;
34814d08:	0595309c 	ldreq	r3, [r5, #156]	; 0x9c
	else
		oobsize = mtd->oobsize;
34814d0c:	15943018 	ldrne	r3, [r4, #24]
		printk(KERN_ERR "onenand_write_ops_nolock: Attempt to write not page aligned data\n");
		return -EINVAL;
	}

	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
34814d10:	05933204 	ldreq	r3, [r3, #516]	; 0x204
	else
		oobsize = mtd->oobsize;

	oobcolumn = to & (mtd->oobsize - 1);

	column = to & (mtd->writesize - 1);
34814d14:	e5947014 	ldr	r7, [r4, #20]
	}

	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;
34814d18:	e58d302c 	str	r3, [sp, #44]	; 0x2c

	oobcolumn = to & (mtd->oobsize - 1);
34814d1c:	e59d3010 	ldr	r3, [sp, #16]
34814d20:	e2422001 	sub	r2, r2, #1
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
34814d24:	e3a00000 	mov	r0, #0
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = to & (mtd->oobsize - 1);
34814d28:	e0032002 	and	r2, r3, r2

	column = to & (mtd->writesize - 1);
34814d2c:	e2477001 	sub	r7, r7, #1
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = to & (mtd->oobsize - 1);
34814d30:	e58d2024 	str	r2, [sp, #36]	; 0x24

	column = to & (mtd->writesize - 1);
34814d34:	e0037007 	and	r7, r3, r7
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
	int oobwritten = 0, oobcolumn, thisooblen, oobsize;
34814d38:	e58d0018 	str	r0, [sp, #24]
 */
static int onenand_write_ops_nolock(struct mtd_info *mtd, loff_t to,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int written = 0, column, thislen, subpage;
34814d3c:	e1a0b000 	mov	fp, r0
34814d40:	e1a09006 	mov	r9, r6
	oobcolumn = to & (mtd->oobsize - 1);

	column = to & (mtd->writesize - 1);

	/* Loop until all data write */
	while (written < len) {
34814d44:	ea000083 	b	34814f58 <onenand_write_ops_nolock+0x308>
		u_char *wbuf = (u_char *) buf;

		thislen = min_t(int, mtd->writesize - column, len - written);
34814d48:	e59d1020 	ldr	r1, [sp, #32]
34814d4c:	e594a014 	ldr	sl, [r4, #20]
34814d50:	e06b3001 	rsb	r3, fp, r1
34814d54:	e067a00a 	rsb	sl, r7, sl
34814d58:	e153000a 	cmp	r3, sl
34814d5c:	b1a0a003 	movlt	sl, r3
34814d60:	a1a0a00a 	movge	sl, sl
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);

		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);
34814d64:	e58da000 	str	sl, [sp]
34814d68:	e1cd21d0 	ldrd	r2, [sp, #16]
34814d6c:	e595c050 	ldr	ip, [r5, #80]	; 0x50
34814d70:	e1a00004 	mov	r0, r4
34814d74:	e3011978 	movw	r1, #6520	; 0x1978
34814d78:	e12fff3c 	blx	ip

		/* Partial page write */
		subpage = thislen < mtd->writesize;
34814d7c:	e5942014 	ldr	r2, [r4, #20]
34814d80:	e15a0002 	cmp	sl, r2
34814d84:	23a03000 	movcs	r3, #0
34814d88:	33a03001 	movcc	r3, #1
		if (subpage) {
34814d8c:	e3530000 	cmp	r3, #0
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);

		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);

		/* Partial page write */
		subpage = thislen < mtd->writesize;
34814d90:	e58d3030 	str	r3, [sp, #48]	; 0x30

	column = to & (mtd->writesize - 1);

	/* Loop until all data write */
	while (written < len) {
		u_char *wbuf = (u_char *) buf;
34814d94:	059d3028 	ldreq	r3, [sp, #40]	; 0x28

		this->command(mtd, ONENAND_CMD_BUFFERRAM, to, thislen);

		/* Partial page write */
		subpage = thislen < mtd->writesize;
		if (subpage) {
34814d98:	0a000008 	beq	34814dc0 <onenand_write_ops_nolock+0x170>
			memset(this->page_buf, 0xff, mtd->writesize);
34814d9c:	e3a010ff 	mov	r1, #255	; 0xff
34814da0:	e595008c 	ldr	r0, [r5, #140]	; 0x8c
34814da4:	eb001c46 	bl	3481bec4 <memset>
			memcpy(this->page_buf + column, buf, thislen);
34814da8:	e595008c 	ldr	r0, [r5, #140]	; 0x8c
34814dac:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
34814db0:	e0800007 	add	r0, r0, r7
34814db4:	e1a0200a 	mov	r2, sl
34814db8:	eb001c65 	bl	3481bf54 <memcpy>
			wbuf = this->page_buf;
34814dbc:	e595308c 	ldr	r3, [r5, #140]	; 0x8c
		}

		this->write_bufferram(mtd, to, ONENAND_DATARAM, wbuf, 0, mtd->writesize);
34814dc0:	e58d3004 	str	r3, [sp, #4]
34814dc4:	e5943014 	ldr	r3, [r4, #20]
34814dc8:	e3a00b01 	mov	r0, #1024	; 0x400
34814dcc:	e3a01000 	mov	r1, #0
34814dd0:	e58d0000 	str	r0, [sp]
34814dd4:	e58d300c 	str	r3, [sp, #12]
34814dd8:	e58d1008 	str	r1, [sp, #8]
34814ddc:	e1cd21d0 	ldrd	r2, [sp, #16]
34814de0:	e5951064 	ldr	r1, [r5, #100]	; 0x64
34814de4:	e1a00004 	mov	r0, r4
34814de8:	e12fff31 	blx	r1

		if (oob) {
34814dec:	e59d201c 	ldr	r2, [sp, #28]
34814df0:	e3520000 	cmp	r2, #0

			oobwritten += thisooblen;
			oob += thisooblen;
			oobcolumn = 0;
		} else
			oobbuf = (u_char *) ffchars;
34814df4:	059f6190 	ldreq	r6, [pc, #400]	; 34814f8c <onenand_write_ops_nolock+0x33c>
			wbuf = this->page_buf;
		}

		this->write_bufferram(mtd, to, ONENAND_DATARAM, wbuf, 0, mtd->writesize);

		if (oob) {
34814df8:	0a000023 	beq	34814e8c <onenand_write_ops_nolock+0x23c>
	/* Loop until all data write */
	while (written < len) {
		u_char *wbuf = (u_char *) buf;

		thislen = min_t(int, mtd->writesize - column, len - written);
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);
34814dfc:	e59d3034 	ldr	r3, [sp, #52]	; 0x34
34814e00:	e59d0018 	ldr	r0, [sp, #24]
34814e04:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
34814e08:	e59d2024 	ldr	r2, [sp, #36]	; 0x24
		}

		this->write_bufferram(mtd, to, ONENAND_DATARAM, wbuf, 0, mtd->writesize);

		if (oob) {
			oobbuf = this->oob_buf;
34814e0c:	e5956090 	ldr	r6, [r5, #144]	; 0x90
	/* Loop until all data write */
	while (written < len) {
		u_char *wbuf = (u_char *) buf;

		thislen = min_t(int, mtd->writesize - column, len - written);
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);
34814e10:	e0607003 	rsb	r7, r0, r3
34814e14:	e0623001 	rsb	r3, r2, r1
		if (oob) {
			oobbuf = this->oob_buf;

			/* We send data to spare ram with oobsize
			 *                          * to prevent byte access */
			memset(oobbuf, 0xff, mtd->oobsize);
34814e18:	e1a00006 	mov	r0, r6
34814e1c:	e3a010ff 	mov	r1, #255	; 0xff
34814e20:	e5942018 	ldr	r2, [r4, #24]
	/* Loop until all data write */
	while (written < len) {
		u_char *wbuf = (u_char *) buf;

		thislen = min_t(int, mtd->writesize - column, len - written);
		thisooblen = min_t(int, oobsize - oobcolumn, ooblen - oobwritten);
34814e24:	e1570003 	cmp	r7, r3
34814e28:	a1a07003 	movge	r7, r3
		if (oob) {
			oobbuf = this->oob_buf;

			/* We send data to spare ram with oobsize
			 *                          * to prevent byte access */
			memset(oobbuf, 0xff, mtd->oobsize);
34814e2c:	eb001c24 	bl	3481bec4 <memset>
			if (ops->mode == MTD_OOB_AUTO)
34814e30:	e5993000 	ldr	r3, [r9]
34814e34:	e3530001 	cmp	r3, #1
34814e38:	1a000006 	bne	34814e58 <onenand_write_ops_nolock+0x208>
				onenand_fill_auto_oob(mtd, oobbuf, oob, oobcolumn, thisooblen);
34814e3c:	e5940094 	ldr	r0, [r4, #148]	; 0x94
34814e40:	e1a01006 	mov	r1, r6
34814e44:	e59d201c 	ldr	r2, [sp, #28]
34814e48:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
34814e4c:	e58d7000 	str	r7, [sp]
34814e50:	ebfffe7b 	bl	34814844 <onenand_fill_auto_oob.clone.7>
34814e54:	ea000004 	b	34814e6c <onenand_write_ops_nolock+0x21c>
			else
				memcpy(oobbuf + oobcolumn, oob, thisooblen);
34814e58:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
34814e5c:	e59d101c 	ldr	r1, [sp, #28]
34814e60:	e0860003 	add	r0, r6, r3
34814e64:	e1a02007 	mov	r2, r7
34814e68:	eb001c39 	bl	3481bf54 <memcpy>

			oobwritten += thisooblen;
34814e6c:	e59d0018 	ldr	r0, [sp, #24]
			oob += thisooblen;
34814e70:	e59d101c 	ldr	r1, [sp, #28]
			if (ops->mode == MTD_OOB_AUTO)
				onenand_fill_auto_oob(mtd, oobbuf, oob, oobcolumn, thisooblen);
			else
				memcpy(oobbuf + oobcolumn, oob, thisooblen);

			oobwritten += thisooblen;
34814e74:	e0800007 	add	r0, r0, r7
			oob += thisooblen;
34814e78:	e0811007 	add	r1, r1, r7
			oobcolumn = 0;
34814e7c:	e3a02000 	mov	r2, #0
			if (ops->mode == MTD_OOB_AUTO)
				onenand_fill_auto_oob(mtd, oobbuf, oob, oobcolumn, thisooblen);
			else
				memcpy(oobbuf + oobcolumn, oob, thisooblen);

			oobwritten += thisooblen;
34814e80:	e58d0018 	str	r0, [sp, #24]
			oob += thisooblen;
34814e84:	e58d101c 	str	r1, [sp, #28]
			oobcolumn = 0;
34814e88:	e58d2024 	str	r2, [sp, #36]	; 0x24
		} else
			oobbuf = (u_char *) ffchars;

		this->write_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);
34814e8c:	e59f30fc 	ldr	r3, [pc, #252]	; 34814f90 <onenand_write_ops_nolock+0x340>
34814e90:	e3a00000 	mov	r0, #0
34814e94:	e58d3000 	str	r3, [sp]
34814e98:	e5943018 	ldr	r3, [r4, #24]
34814e9c:	e58d0008 	str	r0, [sp, #8]
34814ea0:	e58d300c 	str	r3, [sp, #12]
34814ea4:	e58d6004 	str	r6, [sp, #4]
34814ea8:	e5951064 	ldr	r1, [r5, #100]	; 0x64
34814eac:	e3a02000 	mov	r2, #0
34814eb0:	e3a03000 	mov	r3, #0
34814eb4:	e1a00004 	mov	r0, r4
34814eb8:	e12fff31 	blx	r1

		this->command(mtd, ONENAND_CMD_PROG, to, mtd->writesize);
34814ebc:	e5943014 	ldr	r3, [r4, #20]
34814ec0:	e3a01080 	mov	r1, #128	; 0x80
34814ec4:	e58d3000 	str	r3, [sp]
34814ec8:	e595c050 	ldr	ip, [r5, #80]	; 0x50
34814ecc:	e1cd21d0 	ldrd	r2, [sp, #16]
34814ed0:	e1a00004 	mov	r0, r4
34814ed4:	e12fff3c 	blx	ip

		ret = this->wait(mtd, FL_WRITING);
34814ed8:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34814edc:	e3a01002 	mov	r1, #2
34814ee0:	e1a00004 	mov	r0, r4
34814ee4:	e12fff33 	blx	r3

		/* In partial page write we don't update bufferram */
		onenand_update_bufferram(mtd, to, !ret && !subpage);
34814ee8:	e59d1030 	ldr	r1, [sp, #48]	; 0x30

		this->write_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, 0, mtd->oobsize);

		this->command(mtd, ONENAND_CMD_PROG, to, mtd->writesize);

		ret = this->wait(mtd, FL_WRITING);
34814eec:	e1a07000 	mov	r7, r0

		/* In partial page write we don't update bufferram */
		onenand_update_bufferram(mtd, to, !ret && !subpage);
34814ef0:	e1901001 	orrs	r1, r0, r1
34814ef4:	13a03000 	movne	r3, #0
34814ef8:	03a03001 	moveq	r3, #1
34814efc:	e58d3000 	str	r3, [sp]
34814f00:	e5940094 	ldr	r0, [r4, #148]	; 0x94
34814f04:	e1cd21d0 	ldrd	r2, [sp, #16]
34814f08:	ebfffe38 	bl	348147f0 <onenand_update_bufferram.clone.2>
		if (ONENAND_IS_2PLANE(this)) {
			ONENAND_SET_BUFFERRAM1(this);
			onenand_update_bufferram(mtd, to + this->writesize, !ret && !subpage);
		}

		if (ret) {
34814f0c:	e3570000 	cmp	r7, #0
34814f10:	0a000004 	beq	34814f28 <onenand_write_ops_nolock+0x2d8>
			printk(KERN_ERR "onenand_write_ops_nolock: write filaed %d\n", ret);
34814f14:	e1a01007 	mov	r1, r7
34814f18:	e59f0074 	ldr	r0, [pc, #116]	; 34814f94 <onenand_write_ops_nolock+0x344>
34814f1c:	e1a06009 	mov	r6, r9
34814f20:	ebffd08f 	bl	34809164 <printf>
			break;
34814f24:	ea000012 	b	34814f74 <onenand_write_ops_nolock+0x324>
			break;
		}

		written += thislen;

		if (written == len)
34814f28:	e59d2020 	ldr	r2, [sp, #32]
		if (ret) {
			printk(KERN_ERR "onenand_write_ops_nolock: verify failed %d\n", ret);
			break;
		}

		written += thislen;
34814f2c:	e08bb00a 	add	fp, fp, sl

		if (written == len)
34814f30:	e15b0002 	cmp	fp, r2
34814f34:	0a00000d 	beq	34814f70 <onenand_write_ops_nolock+0x320>
			break;

		column = 0;
		to += thislen;
34814f38:	e1cd01d0 	ldrd	r0, [sp, #16]
34814f3c:	e090000a 	adds	r0, r0, sl
34814f40:	e0a11fca 	adc	r1, r1, sl, asr #31
34814f44:	e1cd01f0 	strd	r0, [sp, #16]
		buf += thislen;
34814f48:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
		written += thislen;

		if (written == len)
			break;

		column = 0;
34814f4c:	e3a07000 	mov	r7, #0
		to += thislen;
		buf += thislen;
34814f50:	e081100a 	add	r1, r1, sl
34814f54:	e58d1028 	str	r1, [sp, #40]	; 0x28
	oobcolumn = to & (mtd->oobsize - 1);

	column = to & (mtd->writesize - 1);

	/* Loop until all data write */
	while (written < len) {
34814f58:	e59d2020 	ldr	r2, [sp, #32]
34814f5c:	e15b0002 	cmp	fp, r2
34814f60:	3affff78 	bcc	34814d48 <onenand_write_ops_nolock+0xf8>
34814f64:	e1a06009 	mov	r6, r9
34814f68:	e3a07000 	mov	r7, #0
34814f6c:	ea000000 	b	34814f74 <onenand_write_ops_nolock+0x324>
34814f70:	e1a06009 	mov	r6, r9
		column = 0;
		to += thislen;
		buf += thislen;
	}

	ops->retlen = written;
34814f74:	e586b008 	str	fp, [r6, #8]

	return ret;
}
34814f78:	e1a00007 	mov	r0, r7
34814f7c:	e28dd038 	add	sp, sp, #56	; 0x38
34814f80:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34814f84:	3482770a 	.word	0x3482770a
34814f88:	34827749 	.word	0x34827749
34814f8c:	348214a0 	.word	0x348214a0
34814f90:	00010020 	.word	0x00010020
34814f94:	3482778b 	.word	0x3482778b

34814f98 <onenand_write_oob>:
 *
 * OneNAND write main and/or out-of-band
 */
int onenand_write_oob(struct mtd_info *mtd, loff_t to,
			struct mtd_oob_ops *ops)
{
34814f98:	e59d1000 	ldr	r1, [sp]
	int ret;

	switch (ops->mode) {
34814f9c:	e591c000 	ldr	ip, [r1]
34814fa0:	e35c0001 	cmp	ip, #1
34814fa4:	8a000005 	bhi	34814fc0 <onenand_write_oob+0x28>
	default:
		return -EINVAL;
	}

	onenand_get_device(mtd, FL_WRITING);
	if (ops->datbuf)
34814fa8:	e591c018 	ldr	ip, [r1, #24]
34814fac:	e35c0000 	cmp	ip, #0
34814fb0:	0a000000 	beq	34814fb8 <onenand_write_oob+0x20>
		ret = onenand_write_ops_nolock(mtd, to, ops);
34814fb4:	eaffff25 	b	34814c50 <onenand_write_ops_nolock>
	else
		ret = onenand_write_oob_nolock(mtd, to, ops);
34814fb8:	e58d1000 	str	r1, [sp]
34814fbc:	eafffe61 	b	34814948 <onenand_write_oob_nolock>
	onenand_release_device(mtd);

	return ret;

}
34814fc0:	e3e00015 	mvn	r0, #21
34814fc4:	e12fff1e 	bx	lr

34814fc8 <onenand_write>:
 *
 * Write with ECC
 */
int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
		  size_t * retlen, const u_char * buf)
{
34814fc8:	e92d40f0 	push	{r4, r5, r6, r7, lr}
34814fcc:	e24dd02c 	sub	sp, sp, #44	; 0x2c
	struct mtd_oob_ops ops = {
34814fd0:	e28d7008 	add	r7, sp, #8
 *
 * Write with ECC
 */
int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
		  size_t * retlen, const u_char * buf)
{
34814fd4:	e1a06000 	mov	r6, r0
34814fd8:	e1a04002 	mov	r4, r2
	struct mtd_oob_ops ops = {
34814fdc:	e3a01000 	mov	r1, #0
34814fe0:	e1a00007 	mov	r0, r7
34814fe4:	e3a02020 	mov	r2, #32
 *
 * Write with ECC
 */
int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
		  size_t * retlen, const u_char * buf)
{
34814fe8:	e1a05003 	mov	r5, r3
	struct mtd_oob_ops ops = {
34814fec:	eb001bb4 	bl	3481bec4 <memset>
34814ff0:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_WRITING);
	ret = onenand_write_ops_nolock(mtd, to, &ops);
34814ff4:	e1a02004 	mov	r2, r4
 * Write with ECC
 */
int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
		  size_t * retlen, const u_char * buf)
{
	struct mtd_oob_ops ops = {
34814ff8:	e58d300c 	str	r3, [sp, #12]
34814ffc:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_WRITING);
	ret = onenand_write_ops_nolock(mtd, to, &ops);
34815000:	e1a00006 	mov	r0, r6
 * Write with ECC
 */
int onenand_write(struct mtd_info *mtd, loff_t to, size_t len,
		  size_t * retlen, const u_char * buf)
{
	struct mtd_oob_ops ops = {
34815004:	e58d3020 	str	r3, [sp, #32]
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_WRITING);
	ret = onenand_write_ops_nolock(mtd, to, &ops);
34815008:	e1a03005 	mov	r3, r5
3481500c:	e58d7000 	str	r7, [sp]
34815010:	ebffff0e 	bl	34814c50 <onenand_write_ops_nolock>
	onenand_release_device(mtd);

	*retlen = ops.retlen;
34815014:	e59d2010 	ldr	r2, [sp, #16]
34815018:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
3481501c:	e5832000 	str	r2, [r3]
	return ret;
}
34815020:	e28dd02c 	add	sp, sp, #44	; 0x2c
34815024:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

34815028 <onenand_block>:
	blk += die ? this->density_mask : 0;
	return blk;
}

unsigned int onenand_block(struct onenand_chip *this, loff_t addr)
{
34815028:	e92d4070 	push	{r4, r5, r6, lr}
3481502c:	e1a04000 	mov	r4, r0
	if (!FLEXONENAND(this))
34815030:	e594501c 	ldr	r5, [r4, #28]
	blk += die ? this->density_mask : 0;
	return blk;
}

unsigned int onenand_block(struct onenand_chip *this, loff_t addr)
{
34815034:	e1a00002 	mov	r0, r2
	if (!FLEXONENAND(this))
34815038:	e3150c02 	tst	r5, #512	; 0x200
	blk += die ? this->density_mask : 0;
	return blk;
}

unsigned int onenand_block(struct onenand_chip *this, loff_t addr)
{
3481503c:	e1a01003 	mov	r1, r3
	if (!FLEXONENAND(this))
34815040:	1a000002 	bne	34815050 <onenand_block+0x28>
		return addr >> this->erase_shift;
34815044:	e5942030 	ldr	r2, [r4, #48]	; 0x30
34815048:	eb002bee 	bl	34820008 <__ashrdi3>
3481504c:	e8bd8070 	pop	{r4, r5, r6, pc}
 */
static unsigned int flexonenand_block(struct onenand_chip *this, loff_t addr)
{
	unsigned int boundary, blk, die = 0;

	if (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {
34815050:	e2155008 	ands	r5, r5, #8
34815054:	0a00000b 	beq	34815088 <onenand_block+0x60>
34815058:	e5942010 	ldr	r2, [r4, #16]
3481505c:	e3a03000 	mov	r3, #0
34815060:	e1530001 	cmp	r3, r1
34815064:	ca000006 	bgt	34815084 <onenand_block+0x5c>
34815068:	1a000001 	bne	34815074 <onenand_block+0x4c>
3481506c:	e1520000 	cmp	r2, r0
34815070:	8a000003 	bhi	34815084 <onenand_block+0x5c>
		die = 1;
		addr -= this->diesize[0];
34815074:	e0500002 	subs	r0, r0, r2
34815078:	e0c11003 	sbc	r1, r1, r3
static unsigned int flexonenand_block(struct onenand_chip *this, loff_t addr)
{
	unsigned int boundary, blk, die = 0;

	if (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {
		die = 1;
3481507c:	e3a05001 	mov	r5, #1
34815080:	ea000000 	b	34815088 <onenand_block+0x60>
 * @param this		- OneNAND device structure
 * @param addr		- Address for which block number is needed
 */
static unsigned int flexonenand_block(struct onenand_chip *this, loff_t addr)
{
	unsigned int boundary, blk, die = 0;
34815084:	e3a05000 	mov	r5, #0
		addr -= this->diesize[0];
	}

	boundary = this->boundary[die];

	blk = addr >> (this->erase_shift - 1);
34815088:	e5942030 	ldr	r2, [r4, #48]	; 0x30
	if (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {
		die = 1;
		addr -= this->diesize[0];
	}

	boundary = this->boundary[die];
3481508c:	e2853002 	add	r3, r5, #2

	blk = addr >> (this->erase_shift - 1);
34815090:	e2422001 	sub	r2, r2, #1
	if (ONENAND_IS_DDP(this) && addr >= this->diesize[0]) {
		die = 1;
		addr -= this->diesize[0];
	}

	boundary = this->boundary[die];
34815094:	e7946103 	ldr	r6, [r4, r3, lsl #2]

	blk = addr >> (this->erase_shift - 1);
34815098:	eb002bda 	bl	34820008 <__ashrdi3>
	if (blk > boundary)
3481509c:	e1500006 	cmp	r0, r6
		blk = (blk + boundary + 1) >> 1;
348150a0:	82866001 	addhi	r6, r6, #1
348150a4:	80860000 	addhi	r0, r6, r0
348150a8:	81a000a0 	lsrhi	r0, r0, #1

	blk += die ? this->density_mask : 0;
348150ac:	e3550000 	cmp	r5, #0
348150b0:	15945028 	ldrne	r5, [r4, #40]	; 0x28
348150b4:	e0850000 	add	r0, r5, r0
unsigned int onenand_block(struct onenand_chip *this, loff_t addr)
{
	if (!FLEXONENAND(this))
		return addr >> this->erase_shift;
	return flexonenand_block(this, addr);
}
348150b8:	e8bd8070 	pop	{r4, r5, r6, pc}

348150bc <onenand_default_block_markbad>:
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
 */
static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
348150bc:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	struct onenand_chip *this = mtd->priv;
348150c0:	e590a094 	ldr	sl, [r0, #148]	; 0x94
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
 */
static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
348150c4:	e24dd030 	sub	sp, sp, #48	; 0x30
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
	u_char buf[2] = {0, 0};
348150c8:	e3a01000 	mov	r1, #0
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
 */
static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
348150cc:	e1a06002 	mov	r6, r2
348150d0:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
	u_char buf[2] = {0, 0};
	struct mtd_oob_ops ops = {
348150d4:	e3a02020 	mov	r2, #32
348150d8:	e28d000c 	add	r0, sp, #12
 *
 * This is the default implementation, which can be overridden by
 * a hardware specific driver.
 */
static int onenand_default_block_markbad(struct mtd_info *mtd, loff_t ofs)
{
348150dc:	e1a07003 	mov	r7, r3
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
348150e0:	e59a50a0 	ldr	r5, [sl, #160]	; 0xa0
	u_char buf[2] = {0, 0};
348150e4:	e5cd102c 	strb	r1, [sp, #44]	; 0x2c
348150e8:	e5cd102d 	strb	r1, [sp, #45]	; 0x2d
	struct mtd_oob_ops ops = {
348150ec:	eb001b74 	bl	3481bec4 <memset>
348150f0:	e3a03002 	mov	r3, #2
348150f4:	e58d3018 	str	r3, [sp, #24]
348150f8:	e28d302c 	add	r3, sp, #44	; 0x2c
348150fc:	e58d3028 	str	r3, [sp, #40]	; 0x28
		.ooboffs = 0,
	};
	int block;

	/* Get block number */
	block = onenand_block(this, ofs);
34815100:	e1a0000a 	mov	r0, sl
34815104:	e1a03007 	mov	r3, r7
34815108:	e1a02006 	mov	r2, r6
3481510c:	ebffffc5 	bl	34815028 <onenand_block>
	if (bbm->bbt)
34815110:	e595300c 	ldr	r3, [r5, #12]
34815114:	e3530000 	cmp	r3, #0
34815118:	0a000005 	beq	34815134 <onenand_default_block_markbad+0x78>
		bbm->bbt[block >> 2] |= 0x01 << ((block & 0x03) << 1);
3481511c:	e7d31140 	ldrb	r1, [r3, r0, asr #2]
34815120:	e2002003 	and	r2, r0, #3
34815124:	e1a02082 	lsl	r2, r2, #1
34815128:	e3a0c001 	mov	ip, #1
3481512c:	e181221c 	orr	r2, r1, ip, lsl r2
34815130:	e7c32140 	strb	r2, [r3, r0, asr #2]

	/* We write two bytes, so we dont have to mess with 16 bit access */
	ofs += mtd->oobsize + (bbm->badblockpos & ~0x01);
34815134:	e5952004 	ldr	r2, [r5, #4]
34815138:	e5943018 	ldr	r3, [r4, #24]
3481513c:	e3c22001 	bic	r2, r2, #1
34815140:	e0822003 	add	r2, r2, r3
	return onenand_write_oob_nolock(mtd, ofs, &ops);
34815144:	e1a00004 	mov	r0, r4
34815148:	e0964002 	adds	r4, r6, r2
3481514c:	e28d300c 	add	r3, sp, #12
34815150:	e2a75000 	adc	r5, r7, #0
34815154:	e58d3000 	str	r3, [sp]
34815158:	e1a02004 	mov	r2, r4
3481515c:	e1a03005 	mov	r3, r5
34815160:	ebfffdf8 	bl	34814948 <onenand_write_oob_nolock>
}
34815164:	e28dd030 	add	sp, sp, #48	; 0x30
34815168:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

3481516c <onenand_addr>:
	return ofs;
}

loff_t onenand_addr(struct onenand_chip *this, int block)
{
	if (!FLEXONENAND(this))
3481516c:	e590201c 	ldr	r2, [r0, #28]
			<< (this->erase_shift - 1);
	return ofs;
}

loff_t onenand_addr(struct onenand_chip *this, int block)
{
34815170:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	if (!FLEXONENAND(this))
34815174:	e3120c02 	tst	r2, #512	; 0x200
			<< (this->erase_shift - 1);
	return ofs;
}

loff_t onenand_addr(struct onenand_chip *this, int block)
{
34815178:	e1a03000 	mov	r3, r0
3481517c:	e1a06001 	mov	r6, r1
	if (!FLEXONENAND(this))
34815180:	1a000006 	bne	348151a0 <onenand_addr+0x34>
		return (loff_t) block << this->erase_shift;
34815184:	e1a00001 	mov	r0, r1
34815188:	e1a01fc0 	asr	r1, r0, #31
3481518c:	e5932030 	ldr	r2, [r3, #48]	; 0x30
34815190:	eb002ba3 	bl	34820024 <__ashldi3>
34815194:	e1a04000 	mov	r4, r0
34815198:	e1a05001 	mov	r5, r1
3481519c:	ea000020 	b	34815224 <onenand_addr+0xb8>
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
348151a0:	e2122008 	ands	r2, r2, #8
348151a4:	0a000007 	beq	348151c8 <onenand_addr+0x5c>
348151a8:	e5902028 	ldr	r2, [r0, #40]	; 0x28
348151ac:	e1510002 	cmp	r1, r2
 * Return address of the block
 */
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
	int die = 0, boundary;
348151b0:	33a02000 	movcc	r2, #0

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
		block -= this->density_mask;
		die = 1;
		ofs = this->diesize[0];
348151b4:	25904010 	ldrcs	r4, [r0, #16]
{
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
		block -= this->density_mask;
348151b8:	20626001 	rsbcs	r6, r2, r1
		die = 1;
		ofs = this->diesize[0];
348151bc:	23a05000 	movcs	r5, #0
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
		block -= this->density_mask;
		die = 1;
348151c0:	23a02001 	movcs	r2, #1
348151c4:	2a000001 	bcs	348151d0 <onenand_addr+0x64>
 *
 * Return address of the block
 */
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
348151c8:	e3a04000 	mov	r4, #0
348151cc:	e3a05000 	mov	r5, #0
		die = 1;
		ofs = this->diesize[0];
	}

	boundary = this->boundary[die];
	ofs += (loff_t) block << (this->erase_shift - 1);
348151d0:	e5937030 	ldr	r7, [r3, #48]	; 0x30
		block -= this->density_mask;
		die = 1;
		ofs = this->diesize[0];
	}

	boundary = this->boundary[die];
348151d4:	e2822002 	add	r2, r2, #2
	ofs += (loff_t) block << (this->erase_shift - 1);
348151d8:	e2477001 	sub	r7, r7, #1
		block -= this->density_mask;
		die = 1;
		ofs = this->diesize[0];
	}

	boundary = this->boundary[die];
348151dc:	e793a102 	ldr	sl, [r3, r2, lsl #2]
	ofs += (loff_t) block << (this->erase_shift - 1);
348151e0:	e1a00006 	mov	r0, r6
348151e4:	e1a01fc0 	asr	r1, r0, #31
348151e8:	e1a02007 	mov	r2, r7
348151ec:	eb002b8c 	bl	34820024 <__ashldi3>
	if (block > (boundary + 1))
348151f0:	e28a3001 	add	r3, sl, #1
		die = 1;
		ofs = this->diesize[0];
	}

	boundary = this->boundary[die];
	ofs += (loff_t) block << (this->erase_shift - 1);
348151f4:	e0944000 	adds	r4, r4, r0
348151f8:	e0a55001 	adc	r5, r5, r1
	if (block > (boundary + 1))
348151fc:	e1560003 	cmp	r6, r3
34815200:	da000007 	ble	34815224 <onenand_addr+0xb8>
		ofs += (loff_t) (block - boundary - 1)
34815204:	e2466001 	sub	r6, r6, #1
34815208:	e06aa006 	rsb	sl, sl, r6
			<< (this->erase_shift - 1);
3481520c:	e1a0000a 	mov	r0, sl
34815210:	e1a01fc0 	asr	r1, r0, #31
34815214:	e1a02007 	mov	r2, r7
34815218:	eb002b81 	bl	34820024 <__ashldi3>
	}

	boundary = this->boundary[die];
	ofs += (loff_t) block << (this->erase_shift - 1);
	if (block > (boundary + 1))
		ofs += (loff_t) (block - boundary - 1)
3481521c:	e0944000 	adds	r4, r4, r0
34815220:	e0a55001 	adc	r5, r5, r1
loff_t onenand_addr(struct onenand_chip *this, int block)
{
	if (!FLEXONENAND(this))
		return (loff_t) block << this->erase_shift;
	return flexonenand_addr(this, block);
}
34815224:	e1a00004 	mov	r0, r4
34815228:	e1a01005 	mov	r1, r5
3481522c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34815230 <onenand_command>:

	/* Now we use page size operation */
	int sectors = 0, count = 0;

	/* Address translation */
	switch (cmd) {
34815230:	e351002c 	cmp	r1, #44	; 0x2c
 * Send command to OneNAND device. This function is used for middle/large page
 * devices (1KB/2KB Bytes per page)
 */
static int onenand_command(struct mtd_info *mtd, int cmd, loff_t addr,
			   size_t len)
{
34815234:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
34815238:	e1a05001 	mov	r5, r1
3481523c:	e1a06002 	mov	r6, r2
	struct onenand_chip *this = mtd->priv;
34815240:	e5904094 	ldr	r4, [r0, #148]	; 0x94

	/* Now we use page size operation */
	int sectors = 0, count = 0;

	/* Address translation */
	switch (cmd) {
34815244:	0a000079 	beq	34815430 <onenand_command+0x200>
34815248:	ca000006 	bgt	34815268 <onenand_command+0x38>
3481524c:	e3510027 	cmp	r1, #39	; 0x27
34815250:	0a000076 	beq	34815430 <onenand_command+0x200>
34815254:	e351002a 	cmp	r1, #42	; 0x2a
34815258:	0a000074 	beq	34815430 <onenand_command+0x200>
3481525c:	e3510023 	cmp	r1, #35	; 0x23
34815260:	1a00001c 	bne	348152d8 <onenand_command+0xa8>
34815264:	ea000071 	b	34815430 <onenand_command+0x200>
34815268:	e3510094 	cmp	r1, #148	; 0x94
3481526c:	0a00000e 	beq	348152ac <onenand_command+0x7c>
34815270:	ca000002 	bgt	34815280 <onenand_command+0x50>
34815274:	e3510066 	cmp	r1, #102	; 0x66
34815278:	1a000016 	bne	348152d8 <onenand_command+0xa8>
3481527c:	ea000006 	b	3481529c <onenand_command+0x6c>
34815280:	e3012978 	movw	r2, #6520	; 0x1978
34815284:	e1510002 	cmp	r1, r2
34815288:	0a000007 	beq	348152ac <onenand_command+0x7c>
3481528c:	e282200d 	add	r2, r2, #13
34815290:	e1510002 	cmp	r1, r2
34815294:	1a00000f 	bne	348152d8 <onenand_command+0xa8>
34815298:	ea000009 	b	348152c4 <onenand_command+0x94>
		page = -1;
		break;

	case FLEXONENAND_CMD_PI_ACCESS:
		/* addr contains die index */
		block = addr * this->density_mask;
3481529c:	e5947028 	ldr	r7, [r4, #40]	; 0x28
		page = -1;
348152a0:	e3e06000 	mvn	r6, #0
		page = -1;
		break;

	case FLEXONENAND_CMD_PI_ACCESS:
		/* addr contains die index */
		block = addr * this->density_mask;
348152a4:	e0070792 	mul	r7, r2, r7
		page = -1;
		break;
348152a8:	ea000029 	b	34815354 <onenand_command+0x124>

	case ONENAND_CMD_ERASE:
	case ONENAND_CMD_BUFFERRAM:
		block = onenand_block(this, addr);
348152ac:	e1a02006 	mov	r2, r6
348152b0:	e1a00004 	mov	r0, r4
348152b4:	ebffff5b 	bl	34815028 <onenand_block>
		page = -1;
348152b8:	e3e06000 	mvn	r6, #0
		page = -1;
		break;

	case ONENAND_CMD_ERASE:
	case ONENAND_CMD_BUFFERRAM:
		block = onenand_block(this, addr);
348152bc:	e1a07000 	mov	r7, r0
		page = -1;
		break;
348152c0:	ea00000f 	b	34815304 <onenand_command+0xd4>

	case FLEXONENAND_CMD_READ_PI:
		cmd = ONENAND_CMD_READ;
		block = addr * this->density_mask;
348152c4:	e5947028 	ldr	r7, [r4, #40]	; 0x28
348152c8:	e0070796 	mul	r7, r6, r7
		page = 0;
348152cc:	e3a06000 	mov	r6, #0
		block = onenand_block(this, addr);
		page = -1;
		break;

	case FLEXONENAND_CMD_READ_PI:
		cmd = ONENAND_CMD_READ;
348152d0:	e1a05006 	mov	r5, r6
		block = addr * this->density_mask;
		page = 0;
		break;
348152d4:	ea00001e 	b	34815354 <onenand_command+0x124>

	default:
		block = onenand_block(this, addr);
348152d8:	e1a02006 	mov	r2, r6
348152dc:	e1a00004 	mov	r0, r4
348152e0:	ebffff50 	bl	34815028 <onenand_block>
348152e4:	e1a07000 	mov	r7, r0
		page = (int) (addr
			- onenand_addr(this, block)) >> this->page_shift;
348152e8:	e1a01007 	mov	r1, r7
348152ec:	e1a00004 	mov	r0, r4
348152f0:	ebffff9d 	bl	3481516c <onenand_addr>
		page = 0;
		break;

	default:
		block = onenand_block(this, addr);
		page = (int) (addr
348152f4:	e5942034 	ldr	r2, [r4, #52]	; 0x34
			- onenand_addr(this, block)) >> this->page_shift;
		page &= this->page_mask;
348152f8:	e594303c 	ldr	r3, [r4, #60]	; 0x3c
		page = 0;
		break;

	default:
		block = onenand_block(this, addr);
		page = (int) (addr
348152fc:	e0606006 	rsb	r6, r0, r6
			- onenand_addr(this, block)) >> this->page_shift;
		page &= this->page_mask;
34815300:	e0036256 	and	r6, r3, r6, asr r2
		break;
	}

	/* NOTE: The setting order of the registers is very important! */
	if (cmd == ONENAND_CMD_BUFFERRAM) {
34815304:	e3013978 	movw	r3, #6520	; 0x1978
34815308:	e1550003 	cmp	r5, r3
3481530c:	1a000010 	bne	34815354 <onenand_command+0x124>
 * Setup Start Address 2 Register (F101h) for DDP
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
34815310:	e5943028 	ldr	r3, [r4, #40]	; 0x28

	/* NOTE: The setting order of the registers is very important! */
	if (cmd == ONENAND_CMD_BUFFERRAM) {
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
34815314:	e5942000 	ldr	r2, [r4]
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34815318:	e0177003 	ands	r7, r7, r3

	/* NOTE: The setting order of the registers is very important! */
	if (cmd == ONENAND_CMD_BUFFERRAM) {
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
3481531c:	e59f1144 	ldr	r1, [pc, #324]	; 34815468 <onenand_command+0x238>
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34815320:	01a00007 	moveq	r0, r7
34815324:	13a00902 	movne	r0, #32768	; 0x8000

	/* NOTE: The setting order of the registers is very important! */
	if (cmd == ONENAND_CMD_BUFFERRAM) {
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
34815328:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
3481532c:	e6ff0070 	uxth	r0, r0
34815330:	e0821001 	add	r1, r2, r1
34815334:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_START_ADDRESS2);

		if (ONENAND_IS_4KB_PAGE(this))
34815338:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
3481533c:	e3130008 	tst	r3, #8
			ONENAND_SET_BUFFERRAM0(this);
		else
			/* Switch to the next data buffer */
			ONENAND_SET_NEXT_BUFFERRAM(this);
34815340:	05943044 	ldreq	r3, [r4, #68]	; 0x44
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
				 this->base + ONENAND_REG_START_ADDRESS2);

		if (ONENAND_IS_4KB_PAGE(this))
			ONENAND_SET_BUFFERRAM0(this);
34815344:	13a03000 	movne	r3, #0
		else
			/* Switch to the next data buffer */
			ONENAND_SET_NEXT_BUFFERRAM(this);
34815348:	02233001 	eoreq	r3, r3, #1
3481534c:	e5843044 	str	r3, [r4, #68]	; 0x44
34815350:	ea000042 	b	34815460 <onenand_command+0x230>

		return 0;
	}

	if (block != -1) {
34815354:	e3770001 	cmn	r7, #1
34815358:	0a000014 	beq	348153b0 <onenand_command+0x180>
 * onenand_release - [OneNAND Interface] Free resources held by the OneNAND device
 * @param mtd		MTD device structure
 */
void onenand_release(struct mtd_info *mtd)
{
}
3481535c:	e5940028 	ldr	r0, [r4, #40]	; 0x28
	}

	if (block != -1) {
		/* Write 'DFS, FBA' of Flash */
		value = onenand_block_address(this, block);
		this->write_word(value,
34815360:	e5941000 	ldr	r1, [r4]
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34815364:	e1170000 	tst	r7, r0
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
34815368:	10270000 	eorne	r0, r7, r0
3481536c:	13800902 	orrne	r0, r0, #32768	; 0x8000
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34815370:	01a00007 	moveq	r0, r7
	}

	if (block != -1) {
		/* Write 'DFS, FBA' of Flash */
		value = onenand_block_address(this, block);
		this->write_word(value,
34815374:	e2811a1e 	add	r1, r1, #122880	; 0x1e000
34815378:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
3481537c:	e6ff0070 	uxth	r0, r0
34815380:	e2811c02 	add	r1, r1, #512	; 0x200
34815384:	e12fff33 	blx	r3
 * Setup Start Address 2 Register (F101h) for DDP
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
34815388:	e5943028 	ldr	r3, [r4, #40]	; 0x28
		this->write_word(value,
				 this->base + ONENAND_REG_START_ADDRESS1);

		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
3481538c:	e5942000 	ldr	r2, [r4]
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34815390:	e0177003 	ands	r7, r7, r3
		this->write_word(value,
				 this->base + ONENAND_REG_START_ADDRESS1);

		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
34815394:	e59f10cc 	ldr	r1, [pc, #204]	; 34815468 <onenand_command+0x238>
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34815398:	01a00007 	moveq	r0, r7
3481539c:	13a00902 	movne	r0, #32768	; 0x8000
		this->write_word(value,
				 this->base + ONENAND_REG_START_ADDRESS1);

		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value,
348153a0:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
348153a4:	e6ff0070 	uxth	r0, r0
348153a8:	e0821001 	add	r1, r2, r1
348153ac:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_START_ADDRESS2);
	}

	if (page != -1) {
348153b0:	e3760001 	cmn	r6, #1
348153b4:	0a00001d 	beq	34815430 <onenand_command+0x200>
		int dataram;

		switch (cmd) {
348153b8:	e3550013 	cmp	r5, #19
348153bc:	8a00000c 	bhi	348153f4 <onenand_command+0x1c4>
348153c0:	e3a02001 	mov	r2, #1
348153c4:	e1a02512 	lsl	r2, r2, r5
348153c8:	e59f309c 	ldr	r3, [pc, #156]	; 3481546c <onenand_command+0x23c>
348153cc:	e0023003 	and	r3, r2, r3
348153d0:	e3530000 	cmp	r3, #0
348153d4:	0a000006 	beq	348153f4 <onenand_command+0x1c4>
		case FLEXONENAND_CMD_RECOVER_LSB:
		case ONENAND_CMD_READ:
		case ONENAND_CMD_READOOB:
			if (ONENAND_IS_4KB_PAGE(this))
348153d8:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
348153dc:	e3130008 	tst	r3, #8
				dataram = ONENAND_SET_BUFFERRAM0(this);
			else
				dataram = ONENAND_SET_NEXT_BUFFERRAM(this);
348153e0:	05947044 	ldreq	r7, [r4, #68]	; 0x44
		switch (cmd) {
		case FLEXONENAND_CMD_RECOVER_LSB:
		case ONENAND_CMD_READ:
		case ONENAND_CMD_READOOB:
			if (ONENAND_IS_4KB_PAGE(this))
				dataram = ONENAND_SET_BUFFERRAM0(this);
348153e4:	13a07000 	movne	r7, #0
			else
				dataram = ONENAND_SET_NEXT_BUFFERRAM(this);
348153e8:	02277001 	eoreq	r7, r7, #1
348153ec:	e5847044 	str	r7, [r4, #68]	; 0x44
348153f0:	ea000000 	b	348153f8 <onenand_command+0x1c8>

			break;

		default:
			dataram = ONENAND_CURRENT_BUFFERRAM(this);
348153f4:	e5947044 	ldr	r7, [r4, #68]	; 0x44
			break;
		}

		/* Write 'FPA, FSA' of Flash */
		value = onenand_page_address(page, sectors);
		this->write_word(value,
348153f8:	e5942000 	ldr	r2, [r4]
348153fc:	e59f106c 	ldr	r1, [pc, #108]	; 34815470 <onenand_command+0x240>
static int onenand_page_address(int page, int sector)
{
	/* Flash Page Address, Flash Sector Address */
	int fpa, fsa;

	fpa = page & ONENAND_FPA_MASK;
34815400:	e206607f 	and	r6, r6, #127	; 0x7f
			break;
		}

		/* Write 'FPA, FSA' of Flash */
		value = onenand_page_address(page, sectors);
		this->write_word(value,
34815404:	e1a00106 	lsl	r0, r6, #2
34815408:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
3481540c:	e0821001 	add	r1, r2, r1
34815410:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_START_ADDRESS8);

		/* Write 'BSA, BSC' of DataRAM */
		value = onenand_buffer_address(dataram, sectors, count);
		this->write_word(value, this->base + ONENAND_REG_START_BUFFER);
34815414:	e5941000 	ldr	r1, [r4]
34815418:	e3570000 	cmp	r7, #0
3481541c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815420:	13a00b03 	movne	r0, #3072	; 0xc00
34815424:	03a00b02 	moveq	r0, #2048	; 0x800
34815428:	e2811b79 	add	r1, r1, #123904	; 0x1e400
3481542c:	e12fff33 	blx	r3
	}

	/* Interrupt clear */
	this->write_word(ONENAND_INT_CLEAR, this->base + ONENAND_REG_INTERRUPT);
34815430:	e5941000 	ldr	r1, [r4]
34815434:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815438:	e2811b79 	add	r1, r1, #123904	; 0x1e400
3481543c:	e3a00000 	mov	r0, #0
34815440:	e2811082 	add	r1, r1, #130	; 0x82
34815444:	e12fff33 	blx	r3
	/* Write command */
	this->write_word(cmd, this->base + ONENAND_REG_COMMAND);
34815448:	e5941000 	ldr	r1, [r4]
3481544c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815450:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34815454:	e6ff0075 	uxth	r0, r5
34815458:	e2811040 	add	r1, r1, #64	; 0x40
3481545c:	e12fff33 	blx	r3

	return 0;
}
34815460:	e3a00000 	mov	r0, #0
34815464:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34815468:	0001e202 	.word	0x0001e202
3481546c:	00080021 	.word	0x00080021
34815470:	0001e20e 	.word	0x0001e20e

34815474 <flexonenand_region>:
 */
int flexonenand_region(struct mtd_info *mtd, loff_t addr)
{
	int i;

	for (i = 0; i < mtd->numeraseregions; i++)
34815474:	e3a0c000 	mov	ip, #0
 * flexonenand_region - [Flex-OneNAND] Return erase region of addr
 * @param mtd		MTD device structure
 * @param addr		address whose erase region needs to be identified
 */
int flexonenand_region(struct mtd_info *mtd, loff_t addr)
{
34815478:	e92d4070 	push	{r4, r5, r6, lr}
	int i;

	for (i = 0; i < mtd->numeraseregions; i++)
3481547c:	e1a0100c 	mov	r1, ip
34815480:	e590502c 	ldr	r5, [r0, #44]	; 0x2c
34815484:	ea000009 	b	348154b0 <flexonenand_region+0x3c>
		if (addr < mtd->eraseregions[i].offset)
34815488:	e5904030 	ldr	r4, [r0, #48]	; 0x30
3481548c:	e7b4600c 	ldr	r6, [r4, ip]!
34815490:	e28cc018 	add	ip, ip, #24
34815494:	e5944004 	ldr	r4, [r4, #4]
34815498:	e1540003 	cmp	r4, r3
3481549c:	8a000005 	bhi	348154b8 <flexonenand_region+0x44>
348154a0:	1a000001 	bne	348154ac <flexonenand_region+0x38>
348154a4:	e1560002 	cmp	r6, r2
348154a8:	8a000002 	bhi	348154b8 <flexonenand_region+0x44>
 */
int flexonenand_region(struct mtd_info *mtd, loff_t addr)
{
	int i;

	for (i = 0; i < mtd->numeraseregions; i++)
348154ac:	e2811001 	add	r1, r1, #1
348154b0:	e1510005 	cmp	r1, r5
348154b4:	bafffff3 	blt	34815488 <flexonenand_region+0x14>
		if (addr < mtd->eraseregions[i].offset)
			break;
	return i - 1;
}
348154b8:	e2410001 	sub	r0, r1, #1
348154bc:	e8bd8070 	pop	{r4, r5, r6, pc}

348154c0 <onenand_recover_lsb>:
 * become corrupt. LSB page recovery read is a way to read LSB page though page
 * data are corrupted. When uncorrectable error occurs as a result of LSB page
 * read after power up, issue LSB page recovery read.
 */
static int onenand_recover_lsb(struct mtd_info *mtd, loff_t addr, int status)
{
348154c0:	e92d4c73 	push	{r0, r1, r4, r5, r6, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
348154c4:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 * become corrupt. LSB page recovery read is a way to read LSB page though page
 * data are corrupted. When uncorrectable error occurs as a result of LSB page
 * read after power up, issue LSB page recovery read.
 */
static int onenand_recover_lsb(struct mtd_info *mtd, loff_t addr, int status)
{
348154c8:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
	int i;

	/* Recovery is only for Flex-OneNAND */
	if (!FLEXONENAND(this))
348154cc:	e594101c 	ldr	r1, [r4, #28]
 * become corrupt. LSB page recovery read is a way to read LSB page though page
 * data are corrupted. When uncorrectable error occurs as a result of LSB page
 * read after power up, issue LSB page recovery read.
 */
static int onenand_recover_lsb(struct mtd_info *mtd, loff_t addr, int status)
{
348154d0:	e1a0a002 	mov	sl, r2
	struct onenand_chip *this = mtd->priv;
	int i;

	/* Recovery is only for Flex-OneNAND */
	if (!FLEXONENAND(this))
348154d4:	e3110c02 	tst	r1, #512	; 0x200
 * become corrupt. LSB page recovery read is a way to read LSB page though page
 * data are corrupted. When uncorrectable error occurs as a result of LSB page
 * read after power up, issue LSB page recovery read.
 */
static int onenand_recover_lsb(struct mtd_info *mtd, loff_t addr, int status)
{
348154d8:	e1a0b003 	mov	fp, r3
348154dc:	e59d6020 	ldr	r6, [sp, #32]
	struct onenand_chip *this = mtd->priv;
	int i;

	/* Recovery is only for Flex-OneNAND */
	if (!FLEXONENAND(this))
348154e0:	0a000019 	beq	3481554c <onenand_recover_lsb+0x8c>
		return status;

	/* check if we failed due to uncorrectable error */
	if (status != -EBADMSG && status != ONENAND_BBT_READ_ECC_ERROR)
348154e4:	e3560002 	cmp	r6, #2
348154e8:	1376004a 	cmnne	r6, #74	; 0x4a
348154ec:	1a000016 	bne	3481554c <onenand_recover_lsb+0x8c>
		return status;

	/* check if address lies in MLC region */
	i = flexonenand_region(mtd, addr);
348154f0:	ebffffdf 	bl	34815474 <flexonenand_region>
	if (mtd->eraseregions[i].erasesize < (1 << this->erase_shift))
348154f4:	e5953030 	ldr	r3, [r5, #48]	; 0x30
348154f8:	e3a02018 	mov	r2, #24
348154fc:	e0233092 	mla	r3, r2, r0, r3
34815500:	e5932008 	ldr	r2, [r3, #8]
34815504:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34815508:	e1b03332 	lsrs	r3, r2, r3
3481550c:	0a00000e 	beq	3481554c <onenand_recover_lsb+0x8c>
		return status;

	printk("onenand_recover_lsb:"
34815510:	e59f003c 	ldr	r0, [pc, #60]	; 34815554 <onenand_recover_lsb+0x94>
34815514:	ebffcf12 	bl	34809164 <printf>
		"Attempting to recover from uncorrectable read\n");

	/* Issue the LSB page recovery command */
	this->command(mtd, FLEXONENAND_CMD_RECOVER_LSB, addr, this->writesize);
34815518:	e5943040 	ldr	r3, [r4, #64]	; 0x40
3481551c:	e3a01005 	mov	r1, #5
34815520:	e58d3000 	str	r3, [sp]
34815524:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34815528:	e1a0200a 	mov	r2, sl
3481552c:	e1a0300b 	mov	r3, fp
34815530:	e1a00005 	mov	r0, r5
34815534:	e12fff3c 	blx	ip
	return this->wait(mtd, FL_READING);
34815538:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481553c:	e1a00005 	mov	r0, r5
34815540:	e3a01001 	mov	r1, #1
34815544:	e12fff33 	blx	r3
34815548:	e1a06000 	mov	r6, r0
}
3481554c:	e1a00006 	mov	r0, r6
34815550:	e8bd8c7c 	pop	{r2, r3, r4, r5, r6, sl, fp, pc}
34815554:	348277b6 	.word	0x348277b6

34815558 <onenand_read_oob_nolock>:
 *
 * OneNAND read out-of-band data from the spare area
 */
static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
34815558:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481555c:	e24dd040 	sub	sp, sp, #64	; 0x40
34815560:	e59db060 	ldr	fp, [sp, #96]	; 0x60
	struct onenand_chip *this = mtd->priv;
34815564:	e5907094 	ldr	r7, [r0, #148]	; 0x94
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
	mtd_oob_mode_t mode = ops->mode;
34815568:	e59b1000 	ldr	r1, [fp]
	u_char *buf = ops->oobbuf;
3481556c:	e59b401c 	ldr	r4, [fp, #28]
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
	mtd_oob_mode_t mode = ops->mode;
34815570:	e58d1034 	str	r1, [sp, #52]	; 0x34
	u_char *buf = ops->oobbuf;
	int ret = 0, readcmd;

	from += ops->ooboffs;
34815574:	e59b1014 	ldr	r1, [fp, #20]
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
	mtd_oob_mode_t mode = ops->mode;
	u_char *buf = ops->oobbuf;
34815578:	e58d4024 	str	r4, [sp, #36]	; 0x24
	int ret = 0, readcmd;

	from += ops->ooboffs;
3481557c:	e0924001 	adds	r4, r2, r1
34815580:	e2a35000 	adc	r5, r3, #0
34815584:	e1cd41f8 	strd	r4, [sp, #24]
	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Initialize return length value */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
34815588:	e59d5034 	ldr	r5, [sp, #52]	; 0x34
 *
 * OneNAND read out-of-band data from the spare area
 */
static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
3481558c:	e1a06000 	mov	r6, r0
	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Initialize return length value */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
34815590:	e3550001 	cmp	r5, #1
	from += ops->ooboffs;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Initialize return length value */
	ops->oobretlen = 0;
34815594:	e3a03000 	mov	r3, #0
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
34815598:	e59b000c 	ldr	r0, [fp, #12]
	from += ops->ooboffs;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_oob_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	/* Initialize return length value */
	ops->oobretlen = 0;
3481559c:	e58b3010 	str	r3, [fp, #16]
	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	column = from & (mtd->oobsize - 1);
348155a0:	e5969018 	ldr	r9, [r6, #24]

	/* Initialize return length value */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
348155a4:	0597309c 	ldreq	r3, [r7, #156]	; 0x9c
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
348155a8:	e58d0030 	str	r0, [sp, #48]	; 0x30
	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	column = from & (mtd->oobsize - 1);
348155ac:	e59d0018 	ldr	r0, [sp, #24]

	/* Initialize return length value */
	ops->oobretlen = 0;

	if (mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
348155b0:	0593a204 	ldreq	sl, [r3, #516]	; 0x204
	else
		oobsize = mtd->oobsize;
348155b4:	1596a018 	ldrne	sl, [r6, #24]

	column = from & (mtd->oobsize - 1);
348155b8:	e2499001 	sub	r9, r9, #1
348155bc:	e0099000 	and	r9, r9, r0

	if (unlikely(column >= oobsize)) {
348155c0:	e159000a 	cmp	r9, sl
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to start read outside oob\n");
348155c4:	a59f0220 	ldrge	r0, [pc, #544]	; 348157ec <onenand_read_oob_nolock+0x294>
	else
		oobsize = mtd->oobsize;

	column = from & (mtd->oobsize - 1);

	if (unlikely(column >= oobsize)) {
348155c8:	aa000025 	bge	34815664 <onenand_read_oob_nolock+0x10c>
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to start read outside oob\n");
		return -EINVAL;
	}

	/* Do not allow reads past end of device */
	if (unlikely(from >= mtd->size ||
348155cc:	e596100c 	ldr	r1, [r6, #12]
348155d0:	e59d201c 	ldr	r2, [sp, #28]
348155d4:	e5960008 	ldr	r0, [r6, #8]
348155d8:	e1510002 	cmp	r1, r2
348155dc:	8a000003 	bhi	348155f0 <onenand_read_oob_nolock+0x98>
348155e0:	1a00001e 	bne	34815660 <onenand_read_oob_nolock+0x108>
348155e4:	e59d3018 	ldr	r3, [sp, #24]
348155e8:	e1500003 	cmp	r0, r3
348155ec:	9a00001b 	bls	34815660 <onenand_read_oob_nolock+0x108>
348155f0:	e5973034 	ldr	r3, [r7, #52]	; 0x34
348155f4:	e59d4030 	ldr	r4, [sp, #48]	; 0x30
348155f8:	e1a02003 	mov	r2, r3
348155fc:	e089c004 	add	ip, r9, r4
34815600:	e1a0400a 	mov	r4, sl
34815604:	e1a05fc4 	asr	r5, r4, #31
34815608:	e1cd42f8 	strd	r4, [sp, #40]	; 0x28
3481560c:	e58dc010 	str	ip, [sp, #16]
34815610:	e58d3014 	str	r3, [sp, #20]
34815614:	eb002a74 	bl	3481ffec <__lshrdi3>
34815618:	e59d3014 	ldr	r3, [sp, #20]
3481561c:	e1a04000 	mov	r4, r0
34815620:	e1a05001 	mov	r5, r1
34815624:	e1a02003 	mov	r2, r3
34815628:	e1cd01d8 	ldrd	r0, [sp, #24]
3481562c:	eb002a75 	bl	34820008 <__ashrdi3>
34815630:	e0544000 	subs	r4, r4, r0
34815634:	e0c55001 	sbc	r5, r5, r1
34815638:	e003059a 	mul	r3, sl, r5
3481563c:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
34815640:	e59dc010 	ldr	ip, [sp, #16]
34815644:	e0233094 	mla	r3, r4, r0, r3
34815648:	e085449a 	umull	r4, r5, sl, r4
3481564c:	e0835005 	add	r5, r3, r5
34815650:	e3550000 	cmp	r5, #0
34815654:	1a000005 	bne	34815670 <onenand_read_oob_nolock+0x118>
34815658:	e15c0004 	cmp	ip, r4
3481565c:	9a000003 	bls	34815670 <onenand_read_oob_nolock+0x118>
		column + len > ((mtd->size >> this->page_shift) -
				(from >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to read beyond end of device\n");
34815660:	e59f0188 	ldr	r0, [pc, #392]	; 348157f0 <onenand_read_oob_nolock+0x298>
34815664:	ebffcebe 	bl	34809164 <printf>
		return -EINVAL;
34815668:	e3e04015 	mvn	r4, #21
3481566c:	ea00005b 	b	348157e0 <onenand_read_oob_nolock+0x288>
	}

	stats = mtd->ecc_stats;

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
34815670:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
	/* Do not allow reads past end of device */
	if (unlikely(from >= mtd->size ||
		column + len > ((mtd->size >> this->page_shift) -
				(from >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to read beyond end of device\n");
		return -EINVAL;
34815674:	e5961084 	ldr	r1, [r6, #132]	; 0x84
	}

	stats = mtd->ecc_stats;

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;
34815678:	e3130008 	tst	r3, #8
3481567c:	03a02013 	moveq	r2, #19
34815680:	13a02000 	movne	r2, #0
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
	size_t len = ops->ooblen;
	mtd_oob_mode_t mode = ops->mode;
	u_char *buf = ops->oobbuf;
	int ret = 0, readcmd;
34815684:	e3a04000 	mov	r4, #0
34815688:	e58db028 	str	fp, [sp, #40]	; 0x28
	/* Do not allow reads past end of device */
	if (unlikely(from >= mtd->size ||
		column + len > ((mtd->size >> this->page_shift) -
				(from >> this->page_shift)) * oobsize)) {
		printk(KERN_ERR "onenand_read_oob_nolock: Attempted to read beyond end of device\n");
		return -EINVAL;
3481568c:	e58d103c 	str	r1, [sp, #60]	; 0x3c
	}

	stats = mtd->ecc_stats;

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;
34815690:	e58d2038 	str	r2, [sp, #56]	; 0x38
static int onenand_read_oob_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	int read = 0, thislen, column, oobsize;
34815694:	e1a05004 	mov	r5, r4
34815698:	e1a0b00a 	mov	fp, sl
	stats = mtd->ecc_stats;

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;

	while (read < len) {
3481569c:	ea000043 	b	348157b0 <onenand_read_oob_nolock+0x258>
		thislen = oobsize - column;
		thislen = min_t(int, thislen, len);

		this->spare_buf = buf;
348156a0:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
		this->command(mtd, readcmd, from, mtd->oobsize);
348156a4:	e59d1038 	ldr	r1, [sp, #56]	; 0x38

	while (read < len) {
		thislen = oobsize - column;
		thislen = min_t(int, thislen, len);

		this->spare_buf = buf;
348156a8:	e5873084 	str	r3, [r7, #132]	; 0x84
		this->command(mtd, readcmd, from, mtd->oobsize);
348156ac:	e5963018 	ldr	r3, [r6, #24]
348156b0:	e1a00006 	mov	r0, r6
348156b4:	e58d3000 	str	r3, [sp]
348156b8:	e597c050 	ldr	ip, [r7, #80]	; 0x50
348156bc:	e1cd21d8 	ldrd	r2, [sp, #24]
348156c0:	e12fff3c 	blx	ip

		onenand_update_bufferram(mtd, from, 0);
348156c4:	e1cd21d8 	ldrd	r2, [sp, #24]
348156c8:	e3a04000 	mov	r4, #0
348156cc:	e5960094 	ldr	r0, [r6, #148]	; 0x94
348156d0:	e58d4000 	str	r4, [sp]
348156d4:	ebfffc45 	bl	348147f0 <onenand_update_bufferram.clone.2>

		ret = this->wait(mtd, FL_READING);
348156d8:	e5973054 	ldr	r3, [r7, #84]	; 0x54
348156dc:	e1a00006 	mov	r0, r6
348156e0:	e3a01001 	mov	r1, #1
348156e4:	e12fff33 	blx	r3
		if (unlikely(ret))
348156e8:	e2504000 	subs	r4, r0, #0
348156ec:	0a000004 	beq	34815704 <onenand_read_oob_nolock+0x1ac>
			ret = onenand_recover_lsb(mtd, from, ret);
348156f0:	e1a00006 	mov	r0, r6
348156f4:	e1cd21d8 	ldrd	r2, [sp, #24]
348156f8:	e58d4000 	str	r4, [sp]
348156fc:	ebffff6f 	bl	348154c0 <onenand_recover_lsb>
34815700:	e1a04000 	mov	r4, r0

		if (ret && ret != -EBADMSG) {
34815704:	e3540000 	cmp	r4, #0
34815708:	1374004a 	cmnne	r4, #74	; 0x4a
3481570c:	0a000004 	beq	34815724 <onenand_read_oob_nolock+0x1cc>
			printk(KERN_ERR "onenand_read_oob_nolock: read failed = 0x%x\n", ret);
34815710:	e1a01004 	mov	r1, r4
34815714:	e59f00d8 	ldr	r0, [pc, #216]	; 348157f4 <onenand_read_oob_nolock+0x29c>
34815718:	e59db028 	ldr	fp, [sp, #40]	; 0x28
3481571c:	ebffce90 	bl	34809164 <printf>
			break;
34815720:	ea000026 	b	348157c0 <onenand_read_oob_nolock+0x268>
	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;

	while (read < len) {
		thislen = oobsize - column;
		thislen = min_t(int, thislen, len);
34815724:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
		if (ret && ret != -EBADMSG) {
			printk(KERN_ERR "onenand_read_oob_nolock: read failed = 0x%x\n", ret);
			break;
		}

		if (mode == MTD_OOB_AUTO)
34815728:	e59d1034 	ldr	r1, [sp, #52]	; 0x34

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;

	while (read < len) {
		thislen = oobsize - column;
3481572c:	e069a00b 	rsb	sl, r9, fp
		thislen = min_t(int, thislen, len);
34815730:	e15a0000 	cmp	sl, r0
34815734:	a1a0a000 	movge	sl, r0
		if (ret && ret != -EBADMSG) {
			printk(KERN_ERR "onenand_read_oob_nolock: read failed = 0x%x\n", ret);
			break;
		}

		if (mode == MTD_OOB_AUTO)
34815738:	e3510001 	cmp	r1, #1
3481573c:	1a000005 	bne	34815758 <onenand_read_oob_nolock+0x200>
			onenand_transfer_auto_oob(mtd, buf, column, thislen);
34815740:	e1a00006 	mov	r0, r6
34815744:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
34815748:	e1a02009 	mov	r2, r9
3481574c:	e1a0300a 	mov	r3, sl
34815750:	ebfffbd5 	bl	348146ac <onenand_transfer_auto_oob>
34815754:	ea000007 	b	34815778 <onenand_read_oob_nolock+0x220>
		else
			this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
34815758:	e59f2098 	ldr	r2, [pc, #152]	; 348157f8 <onenand_read_oob_nolock+0x2a0>
3481575c:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
34815760:	e88d060c 	stm	sp, {r2, r3, r9, sl}
34815764:	e5971060 	ldr	r1, [r7, #96]	; 0x60
34815768:	e1a00006 	mov	r0, r6
3481576c:	e3a02000 	mov	r2, #0
34815770:	e3a03000 	mov	r3, #0
34815774:	e12fff31 	blx	r1

		read += thislen;

		if (read == len)
34815778:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
		if (mode == MTD_OOB_AUTO)
			onenand_transfer_auto_oob(mtd, buf, column, thislen);
		else
			this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);

		read += thislen;
3481577c:	e085500a 	add	r5, r5, sl

		if (read == len)
34815780:	e1550000 	cmp	r5, r0
34815784:	0a00000c 	beq	348157bc <onenand_read_oob_nolock+0x264>
			break;

		buf += thislen;
34815788:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
3481578c:	e081100a 	add	r1, r1, sl
34815790:	e58d1024 	str	r1, [sp, #36]	; 0x24

		/* Read more? */
		if (read < len) {
34815794:	2a000005 	bcs	348157b0 <onenand_read_oob_nolock+0x258>
			/* Page size */
			from += mtd->writesize;
34815798:	e5963014 	ldr	r3, [r6, #20]
3481579c:	e1cd01d8 	ldrd	r0, [sp, #24]
348157a0:	e0900003 	adds	r0, r0, r3
348157a4:	e2a11000 	adc	r1, r1, #0
348157a8:	e1cd01f8 	strd	r0, [sp, #24]
			column = 0;
348157ac:	e3a09000 	mov	r9, #0
	stats = mtd->ecc_stats;

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;

	while (read < len) {
348157b0:	e59d1030 	ldr	r1, [sp, #48]	; 0x30
348157b4:	e1550001 	cmp	r5, r1
348157b8:	3affffb8 	bcc	348156a0 <onenand_read_oob_nolock+0x148>
348157bc:	e59db028 	ldr	fp, [sp, #40]	; 0x28
		}
	}

	ops->oobretlen = read;

	if (ret)
348157c0:	e3540000 	cmp	r4, #0
			from += mtd->writesize;
			column = 0;
		}
	}

	ops->oobretlen = read;
348157c4:	e58b5010 	str	r5, [fp, #16]

	if (ret)
348157c8:	1a000004 	bne	348157e0 <onenand_read_oob_nolock+0x288>
		return ret;

	if (mtd->ecc_stats.failed - stats.failed)
348157cc:	e5963084 	ldr	r3, [r6, #132]	; 0x84
		return -EBADMSG;
348157d0:	e59d203c 	ldr	r2, [sp, #60]	; 0x3c
348157d4:	e1530002 	cmp	r3, r2
348157d8:	03a04000 	moveq	r4, #0
348157dc:	13e04049 	mvnne	r4, #73	; 0x49

	return 0;
}
348157e0:	e1a00004 	mov	r0, r4
348157e4:	e28dd040 	add	sp, sp, #64	; 0x40
348157e8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348157ec:	348277f9 	.word	0x348277f9
348157f0:	34827837 	.word	0x34827837
348157f4:	34827878 	.word	0x34827878
348157f8:	00010020 	.word	0x00010020

348157fc <onenand_read_ops_nolock>:
 *
 * OneNAND read main and/or out-of-band data
 */
static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
348157fc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34815800:	e24dd058 	sub	sp, sp, #88	; 0x58
34815804:	e59d7078 	ldr	r7, [sp, #120]	; 0x78
34815808:	e1cd21f8 	strd	r2, [sp, #24]
	int ret = 0, boundary = 0;
	int writesize = this->writesize;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	if (ops->mode == MTD_OOB_AUTO)
3481580c:	e5973000 	ldr	r3, [r7]
 * OneNAND read main and/or out-of-band data
 */
static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
34815810:	e5904094 	ldr	r4, [r0, #148]	; 0x94
	int ret = 0, boundary = 0;
	int writesize = this->writesize;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	if (ops->mode == MTD_OOB_AUTO)
34815814:	e3530001 	cmp	r3, #1
		oobsize = this->ecclayout->oobavail;
34815818:	0594309c 	ldreq	r3, [r4, #156]	; 0x9c
 *
 * OneNAND read main and/or out-of-band data
 */
static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
3481581c:	e1a05000 	mov	r5, r0
	int writesize = this->writesize;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
34815820:	05933204 	ldreq	r3, [r3, #516]	; 0x204
	else
		oobsize = mtd->oobsize;
34815824:	15953018 	ldrne	r3, [r5, #24]
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
	u_char *buf = ops->datbuf;
34815828:	e5971018 	ldr	r1, [r7, #24]
	u_char *oobbuf = ops->oobbuf;
3481582c:	e597201c 	ldr	r2, [r7, #28]
static int onenand_read_ops_nolock(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	size_t len = ops->len;
34815830:	e597b004 	ldr	fp, [r7, #4]
	size_t ooblen = ops->ooblen;
	u_char *buf = ops->datbuf;
34815834:	e58d1028 	str	r1, [sp, #40]	; 0x28
	u_char *oobbuf = ops->oobbuf;
34815838:	e58d202c 	str	r2, [sp, #44]	; 0x2c
	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_read_ops_nolock: from = 0x%08x, len = %i\n", (unsigned int) from, (int) len);

	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;
3481583c:	e58d303c 	str	r3, [sp, #60]	; 0x3c

	oobcolumn = from & (mtd->oobsize - 1);

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
34815840:	e595100c 	ldr	r1, [r5, #12]
34815844:	e1cd21d8 	ldrd	r2, [sp, #24]
34815848:	e092200b 	adds	r2, r2, fp
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
3481584c:	e597000c 	ldr	r0, [r7, #12]
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = from & (mtd->oobsize - 1);
34815850:	e5956018 	ldr	r6, [r5, #24]

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
34815854:	e2a33000 	adc	r3, r3, #0
34815858:	e1510003 	cmp	r1, r3
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	struct mtd_ecc_stats stats;
	size_t len = ops->len;
	size_t ooblen = ops->ooblen;
3481585c:	e58d004c 	str	r0, [sp, #76]	; 0x4c
	u_char *buf = ops->datbuf;
	u_char *oobbuf = ops->oobbuf;
	int read = 0, column, thislen;
	int oobread = 0, oobcolumn, thisooblen, oobsize;
	int ret = 0, boundary = 0;
	int writesize = this->writesize;
34815860:	e5949040 	ldr	r9, [r4, #64]	; 0x40
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = from & (mtd->oobsize - 1);
34815864:	e58d6020 	str	r6, [sp, #32]

	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
34815868:	3a000003 	bcc	3481587c <onenand_read_ops_nolock+0x80>
3481586c:	1a000009 	bne	34815898 <onenand_read_ops_nolock+0x9c>
34815870:	e5951008 	ldr	r1, [r5, #8]
34815874:	e1510002 	cmp	r1, r2
34815878:	2a000006 	bcs	34815898 <onenand_read_ops_nolock+0x9c>
		printk(KERN_ERR "onenand_read_ops_nolock: Attempt read beyond end of device\n");
3481587c:	e59f047c 	ldr	r0, [pc, #1148]	; 34815d00 <onenand_read_ops_nolock+0x504>
34815880:	ebffce37 	bl	34809164 <printf>
		ops->retlen = 0;
34815884:	e3a03000 	mov	r3, #0
34815888:	e5873008 	str	r3, [r7, #8]
		ops->oobretlen = 0;
3481588c:	e5873010 	str	r3, [r7, #16]
		return -EINVAL;
34815890:	e3e06015 	mvn	r6, #21
34815894:	ea000114 	b	34815cec <onenand_read_ops_nolock+0x4f0>
34815898:	e5950080 	ldr	r0, [r5, #128]	; 0x80
3481589c:	e5951084 	ldr	r1, [r5, #132]	; 0x84

	/* Read-while-load method */
	/* Note: We can't use this feature in MLC */

	/* Do first load to bufferRAM */
	if (read < len) {
348158a0:	e35b0000 	cmp	fp, #0
	/* Do not allow reads past end of device */
	if ((from + len) > mtd->size) {
		printk(KERN_ERR "onenand_read_ops_nolock: Attempt read beyond end of device\n");
		ops->retlen = 0;
		ops->oobretlen = 0;
		return -EINVAL;
348158a4:	e58d0054 	str	r0, [sp, #84]	; 0x54
348158a8:	e58d1050 	str	r1, [sp, #80]	; 0x50
	size_t ooblen = ops->ooblen;
	u_char *buf = ops->datbuf;
	u_char *oobbuf = ops->oobbuf;
	int read = 0, column, thislen;
	int oobread = 0, oobcolumn, thisooblen, oobsize;
	int ret = 0, boundary = 0;
348158ac:	01a0600b 	moveq	r6, fp

	/* Read-while-load method */
	/* Note: We can't use this feature in MLC */

	/* Do first load to bufferRAM */
	if (read < len) {
348158b0:	0a000038 	beq	34815998 <onenand_read_ops_nolock+0x19c>
#endif

	if (ONENAND_IS_2PLANE(this))
		blockpage = onenand_get_2x_blockpage(mtd, addr);
	else
		blockpage = (int) (addr >> this->page_shift);
348158b4:	e5942034 	ldr	r2, [r4, #52]	; 0x34
348158b8:	e1cd01d8 	ldrd	r0, [sp, #24]
348158bc:	eb0029d1 	bl	34820008 <__ashrdi3>

	/* Is there valid data? */
	i = ONENAND_CURRENT_BUFFERRAM(this);
348158c0:	e5943044 	ldr	r3, [r4, #68]	; 0x44
	if (this->bufferram[i].blockpage == blockpage)
348158c4:	e2832012 	add	r2, r3, #18
348158c8:	e7942102 	ldr	r2, [r4, r2, lsl #2]
348158cc:	e1520000 	cmp	r2, r0
348158d0:	0a000005 	beq	348158ec <onenand_read_ops_nolock+0xf0>
		found = 1;
	else {
		/* Check another BufferRAM */
		i = ONENAND_NEXT_BUFFERRAM(this);
348158d4:	e2233001 	eor	r3, r3, #1
		if (this->bufferram[i].blockpage == blockpage) {
348158d8:	e2832012 	add	r2, r3, #18
348158dc:	e7942102 	ldr	r2, [r4, r2, lsl #2]
348158e0:	e1520000 	cmp	r2, r0
348158e4:	1a000010 	bne	3481592c <onenand_read_ops_nolock+0x130>
			ONENAND_SET_NEXT_BUFFERRAM(this);
348158e8:	e5843044 	str	r3, [r4, #68]	; 0x44
			found = 1;
		}
	}

	if (found && ONENAND_IS_DDP(this)) {
348158ec:	e594301c 	ldr	r3, [r4, #28]
348158f0:	e3130008 	tst	r3, #8
348158f4:	0a0000ff 	beq	34815cf8 <onenand_read_ops_nolock+0x4fc>
		/* Select DataRAM for DDP */
		int block = onenand_block(this, addr);
348158f8:	e1cd21d8 	ldrd	r2, [sp, #24]
348158fc:	e1a00004 	mov	r0, r4
34815900:	ebfffdc8 	bl	34815028 <onenand_block>
 * Setup Start Address 2 Register (F101h) for DDP
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
34815904:	e5943028 	ldr	r3, [r4, #40]	; 0x28

	if (found && ONENAND_IS_DDP(this)) {
		/* Select DataRAM for DDP */
		int block = onenand_block(this, addr);
		int value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34815908:	e5942000 	ldr	r2, [r4]
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
3481590c:	e0100003 	ands	r0, r0, r3

	if (found && ONENAND_IS_DDP(this)) {
		/* Select DataRAM for DDP */
		int block = onenand_block(this, addr);
		int value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34815910:	e59f13ec 	ldr	r1, [pc, #1004]	; 34815d04 <onenand_read_ops_nolock+0x508>
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34815914:	13a00902 	movne	r0, #32768	; 0x8000

	if (found && ONENAND_IS_DDP(this)) {
		/* Select DataRAM for DDP */
		int block = onenand_block(this, addr);
		int value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34815918:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
3481591c:	e6ff0070 	uxth	r0, r0
34815920:	e0821001 	add	r1, r2, r1
34815924:	e12fff33 	blx	r3
34815928:	ea0000f2 	b	34815cf8 <onenand_read_ops_nolock+0x4fc>
	/* Note: We can't use this feature in MLC */

	/* Do first load to bufferRAM */
	if (read < len) {
		if (!onenand_check_bufferram(mtd, from)) {
			this->main_buf = buf;
3481592c:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
34815930:	e3a01000 	mov	r1, #0
	/* Note: We can't use this feature in MLC */

	/* Do first load to bufferRAM */
	if (read < len) {
		if (!onenand_check_bufferram(mtd, from)) {
			this->main_buf = buf;
34815934:	e5842080 	str	r2, [r4, #128]	; 0x80
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
34815938:	e58d9000 	str	r9, [sp]
3481593c:	e1cd21d8 	ldrd	r2, [sp, #24]
34815940:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34815944:	e1a00005 	mov	r0, r5
34815948:	e12fff3c 	blx	ip
			ret = this->wait(mtd, FL_READING);
3481594c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34815950:	e1a00005 	mov	r0, r5
34815954:	e3a01001 	mov	r1, #1
34815958:	e12fff33 	blx	r3
			if (unlikely(ret))
3481595c:	e2506000 	subs	r6, r0, #0
34815960:	0a000004 	beq	34815978 <onenand_read_ops_nolock+0x17c>
				ret = onenand_recover_lsb(mtd, from, ret);
34815964:	e1a00005 	mov	r0, r5
34815968:	e1cd21d8 	ldrd	r2, [sp, #24]
3481596c:	e58d6000 	str	r6, [sp]
34815970:	ebfffed2 	bl	348154c0 <onenand_recover_lsb>
34815974:	e1a06000 	mov	r6, r0
			onenand_update_bufferram(mtd, from, !ret);
34815978:	e2763001 	rsbs	r3, r6, #1
3481597c:	33a03000 	movcc	r3, #0
34815980:	e58d3000 	str	r3, [sp]
34815984:	e5950094 	ldr	r0, [r5, #148]	; 0x94
34815988:	e1cd21d8 	ldrd	r2, [sp, #24]
3481598c:	ebfffb97 	bl	348147f0 <onenand_update_bufferram.clone.2>
			if (ret == -EBADMSG)
				ret = 0;
34815990:	e376004a 	cmn	r6, #74	; 0x4a
34815994:	03a06000 	moveq	r6, #0
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = from & (mtd->oobsize - 1);
34815998:	e59d2018 	ldr	r2, [sp, #24]
				ret = 0;
		}
	}

	thislen = min_t(int, writesize, len - read);
	column = from & (writesize - 1);
3481599c:	e2493001 	sub	r3, r9, #1
			if (ret == -EBADMSG)
				ret = 0;
		}
	}

	thislen = min_t(int, writesize, len - read);
348159a0:	e15b0009 	cmp	fp, r9
348159a4:	b1a0a00b 	movlt	sl, fp
348159a8:	a1a0a009 	movge	sl, r9
	column = from & (writesize - 1);
348159ac:	e0023003 	and	r3, r2, r3
348159b0:	e58d3030 	str	r3, [sp, #48]	; 0x30
	if (column + thislen > writesize)
348159b4:	e083300a 	add	r3, r3, sl
348159b8:	e1530009 	cmp	r3, r9
		thislen = writesize - column;
348159bc:	c59d3030 	ldrgt	r3, [sp, #48]	; 0x30
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = from & (mtd->oobsize - 1);
348159c0:	e59d0020 	ldr	r0, [sp, #32]
	}

	thislen = min_t(int, writesize, len - read);
	column = from & (writesize - 1);
	if (column + thislen > writesize)
		thislen = writesize - column;
348159c4:	c063a009 	rsbgt	sl, r3, r9
	if (ops->mode == MTD_OOB_AUTO)
		oobsize = this->ecclayout->oobavail;
	else
		oobsize = mtd->oobsize;

	oobcolumn = from & (mtd->oobsize - 1);
348159c8:	e2403001 	sub	r3, r0, #1
348159cc:	e3a01000 	mov	r1, #0
348159d0:	e0023003 	and	r3, r2, r3
348159d4:	e58d3038 	str	r3, [sp, #56]	; 0x38
348159d8:	e58d1024 	str	r1, [sp, #36]	; 0x24
348159dc:	e58d1034 	str	r1, [sp, #52]	; 0x34
348159e0:	e58d1020 	str	r1, [sp, #32]
348159e4:	e58d7014 	str	r7, [sp, #20]
348159e8:	ea0000ac 	b	34815ca0 <onenand_read_ops_nolock+0x4a4>
	if (column + thislen > writesize)
		thislen = writesize - column;

	while (!ret) {
		/* If there is more to load then start next load */
		from += thislen;
348159ec:	e1a0200a 	mov	r2, sl
348159f0:	e1a03fc2 	asr	r3, r2, #31
348159f4:	e1cd01d8 	ldrd	r0, [sp, #24]
348159f8:	e0900002 	adds	r0, r0, r2
348159fc:	e0a11003 	adc	r1, r1, r3
34815a00:	e1cd24f0 	strd	r2, [sp, #64]	; 0x40
		if (!ONENAND_IS_4KB_PAGE(this) && read + thislen < len) {
34815a04:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
	if (column + thislen > writesize)
		thislen = writesize - column;

	while (!ret) {
		/* If there is more to load then start next load */
		from += thislen;
34815a08:	e1cd01f8 	strd	r0, [sp, #24]
		if (!ONENAND_IS_4KB_PAGE(this) && read + thislen < len) {
34815a0c:	e3130008 	tst	r3, #8
34815a10:	1a000025 	bne	34815aac <onenand_read_ops_nolock+0x2b0>
34815a14:	e59d1020 	ldr	r1, [sp, #32]
34815a18:	e08a3001 	add	r3, sl, r1
34815a1c:	e153000b 	cmp	r3, fp
34815a20:	2a000021 	bcs	34815aac <onenand_read_ops_nolock+0x2b0>
			this->main_buf = buf + thislen;
34815a24:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
34815a28:	e1a00005 	mov	r0, r5

	while (!ret) {
		/* If there is more to load then start next load */
		from += thislen;
		if (!ONENAND_IS_4KB_PAGE(this) && read + thislen < len) {
			this->main_buf = buf + thislen;
34815a2c:	e082300a 	add	r3, r2, sl
34815a30:	e5843080 	str	r3, [r4, #128]	; 0x80
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
34815a34:	e58d9000 	str	r9, [sp]
34815a38:	e1cd21d8 	ldrd	r2, [sp, #24]
34815a3c:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34815a40:	e1a01006 	mov	r1, r6
34815a44:	e12fff3c 	blx	ip
			/*
			 * Chip boundary handling in DDP
			 * Now we issued chip 1 read and pointed chip 1
			 * bufferam so we have to point chip 0 bufferam.
			 */
			if (ONENAND_IS_DDP(this) &&
34815a48:	e594301c 	ldr	r3, [r4, #28]
34815a4c:	e3130008 	tst	r3, #8
					unlikely(from == (this->chipsize >> 1))) {
				this->write_word(ONENAND_DDP_CHIP0, this->base + ONENAND_REG_START_ADDRESS2);
				boundary = 1;
			} else
				boundary = 0;
34815a50:	058d6024 	streq	r6, [sp, #36]	; 0x24
			/*
			 * Chip boundary handling in DDP
			 * Now we issued chip 1 read and pointed chip 1
			 * bufferam so we have to point chip 0 bufferam.
			 */
			if (ONENAND_IS_DDP(this) &&
34815a54:	0a000011 	beq	34815aa0 <onenand_read_ops_nolock+0x2a4>
					unlikely(from == (this->chipsize >> 1))) {
34815a58:	e5943018 	ldr	r3, [r4, #24]
			/*
			 * Chip boundary handling in DDP
			 * Now we issued chip 1 read and pointed chip 1
			 * bufferam so we have to point chip 0 bufferam.
			 */
			if (ONENAND_IS_DDP(this) &&
34815a5c:	e59d6018 	ldr	r6, [sp, #24]
34815a60:	e15600a3 	cmp	r6, r3, lsr #1
34815a64:	1a00000b 	bne	34815a98 <onenand_read_ops_nolock+0x29c>
34815a68:	e59d701c 	ldr	r7, [sp, #28]
34815a6c:	e3570000 	cmp	r7, #0
34815a70:	1a000008 	bne	34815a98 <onenand_read_ops_nolock+0x29c>
					unlikely(from == (this->chipsize >> 1))) {
				this->write_word(ONENAND_DDP_CHIP0, this->base + ONENAND_REG_START_ADDRESS2);
34815a74:	e5942000 	ldr	r2, [r4]
34815a78:	e59f1284 	ldr	r1, [pc, #644]	; 34815d04 <onenand_read_ops_nolock+0x508>
34815a7c:	e1a00007 	mov	r0, r7
34815a80:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815a84:	e0821001 	add	r1, r2, r1
34815a88:	e12fff33 	blx	r3
				boundary = 1;
34815a8c:	e3a00001 	mov	r0, #1
34815a90:	e58d0024 	str	r0, [sp, #36]	; 0x24
34815a94:	ea000001 	b	34815aa0 <onenand_read_ops_nolock+0x2a4>
			} else
				boundary = 0;
34815a98:	e3a01000 	mov	r1, #0
34815a9c:	e58d1024 	str	r1, [sp, #36]	; 0x24
			ONENAND_SET_PREV_BUFFERRAM(this);
34815aa0:	e5943044 	ldr	r3, [r4, #68]	; 0x44
34815aa4:	e2233001 	eor	r3, r3, #1
34815aa8:	e5843044 	str	r3, [r4, #68]	; 0x44
		}

		/* While load is going, read from last bufferRAM */
		this->read_bufferram(mtd, from - thislen, ONENAND_DATARAM, buf, column, thislen);
34815aac:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
34815ab0:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
34815ab4:	e3a02b01 	mov	r2, #1024	; 0x400
34815ab8:	e88d044c 	stm	sp, {r2, r3, r6, sl}
34815abc:	e1cd64d0 	ldrd	r6, [sp, #64]	; 0x40
34815ac0:	e1cd21d8 	ldrd	r2, [sp, #24]
34815ac4:	e5941060 	ldr	r1, [r4, #96]	; 0x60
34815ac8:	e0522006 	subs	r2, r2, r6
34815acc:	e0c33007 	sbc	r3, r3, r7
34815ad0:	e1a00005 	mov	r0, r5
34815ad4:	e12fff31 	blx	r1

		/* Read oob area if needed */
		if (oobbuf) {
34815ad8:	e59d702c 	ldr	r7, [sp, #44]	; 0x2c
34815adc:	e3570000 	cmp	r7, #0
34815ae0:	0a000022 	beq	34815b70 <onenand_read_ops_nolock+0x374>
			thisooblen = oobsize - oobcolumn;
34815ae4:	e59d003c 	ldr	r0, [sp, #60]	; 0x3c
34815ae8:	e59d1038 	ldr	r1, [sp, #56]	; 0x38
			thisooblen = min_t(int, thisooblen, ooblen - oobread);
34815aec:	e59d204c 	ldr	r2, [sp, #76]	; 0x4c
34815af0:	e59d7034 	ldr	r7, [sp, #52]	; 0x34
		/* While load is going, read from last bufferRAM */
		this->read_bufferram(mtd, from - thislen, ONENAND_DATARAM, buf, column, thislen);

		/* Read oob area if needed */
		if (oobbuf) {
			thisooblen = oobsize - oobcolumn;
34815af4:	e0613000 	rsb	r3, r1, r0
			thisooblen = min_t(int, thisooblen, ooblen - oobread);

			if (ops->mode == MTD_OOB_AUTO)
34815af8:	e59d0014 	ldr	r0, [sp, #20]
		this->read_bufferram(mtd, from - thislen, ONENAND_DATARAM, buf, column, thislen);

		/* Read oob area if needed */
		if (oobbuf) {
			thisooblen = oobsize - oobcolumn;
			thisooblen = min_t(int, thisooblen, ooblen - oobread);
34815afc:	e0676002 	rsb	r6, r7, r2
34815b00:	e1560003 	cmp	r6, r3
34815b04:	a1a06003 	movge	r6, r3

			if (ops->mode == MTD_OOB_AUTO)
34815b08:	e5903000 	ldr	r3, [r0]
34815b0c:	e3530001 	cmp	r3, #1
34815b10:	1a000005 	bne	34815b2c <onenand_read_ops_nolock+0x330>
				onenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);
34815b14:	e1a00005 	mov	r0, r5
34815b18:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
34815b1c:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
34815b20:	e1a03006 	mov	r3, r6
34815b24:	ebfffae0 	bl	348146ac <onenand_transfer_auto_oob>
34815b28:	ea000008 	b	34815b50 <onenand_read_ops_nolock+0x354>
			else
				this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);
34815b2c:	e59f11d4 	ldr	r1, [pc, #468]	; 34815d08 <onenand_read_ops_nolock+0x50c>
34815b30:	e59d202c 	ldr	r2, [sp, #44]	; 0x2c
34815b34:	e59d3038 	ldr	r3, [sp, #56]	; 0x38
34815b38:	e88d004e 	stm	sp, {r1, r2, r3, r6}
34815b3c:	e5941060 	ldr	r1, [r4, #96]	; 0x60
34815b40:	e1a00005 	mov	r0, r5
34815b44:	e3a02000 	mov	r2, #0
34815b48:	e3a03000 	mov	r3, #0
34815b4c:	e12fff31 	blx	r1
			oobread += thisooblen;
34815b50:	e59d7034 	ldr	r7, [sp, #52]	; 0x34
			oobbuf += thisooblen;
34815b54:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c

			if (ops->mode == MTD_OOB_AUTO)
				onenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);
			else
				this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);
			oobread += thisooblen;
34815b58:	e0877006 	add	r7, r7, r6
			oobbuf += thisooblen;
34815b5c:	e0800006 	add	r0, r0, r6
			oobcolumn = 0;
34815b60:	e3a01000 	mov	r1, #0

			if (ops->mode == MTD_OOB_AUTO)
				onenand_transfer_auto_oob(mtd, oobbuf, oobcolumn, thisooblen);
			else
				this->read_bufferram(mtd, 0, ONENAND_SPARERAM, oobbuf, oobcolumn, thisooblen);
			oobread += thisooblen;
34815b64:	e58d7034 	str	r7, [sp, #52]	; 0x34
			oobbuf += thisooblen;
34815b68:	e58d002c 	str	r0, [sp, #44]	; 0x2c
			oobcolumn = 0;
34815b6c:	e58d1038 	str	r1, [sp, #56]	; 0x38
		}

		if (ONENAND_IS_4KB_PAGE(this) && (read + thislen < len)) {
34815b70:	e594602c 	ldr	r6, [r4, #44]	; 0x2c
34815b74:	e2166008 	ands	r6, r6, #8
34815b78:	0a00001d 	beq	34815bf4 <onenand_read_ops_nolock+0x3f8>
34815b7c:	e59d2020 	ldr	r2, [sp, #32]
34815b80:	e08a3002 	add	r3, sl, r2
34815b84:	e153000b 	cmp	r3, fp
34815b88:	23a06000 	movcs	r6, #0
34815b8c:	2a000018 	bcs	34815bf4 <onenand_read_ops_nolock+0x3f8>
			this->command(mtd, ONENAND_CMD_READ, from, writesize);
34815b90:	e58d9000 	str	r9, [sp]
34815b94:	e1cd21d8 	ldrd	r2, [sp, #24]
34815b98:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34815b9c:	e3a01000 	mov	r1, #0
34815ba0:	e1a00005 	mov	r0, r5
34815ba4:	e12fff3c 	blx	ip
			ret = this->wait(mtd, FL_READING);
34815ba8:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34815bac:	e1a00005 	mov	r0, r5
34815bb0:	e3a01001 	mov	r1, #1
34815bb4:	e12fff33 	blx	r3
			if (unlikely(ret))
34815bb8:	e2506000 	subs	r6, r0, #0
34815bbc:	0a000004 	beq	34815bd4 <onenand_read_ops_nolock+0x3d8>
				ret = onenand_recover_lsb(mtd, from, ret);
34815bc0:	e1a00005 	mov	r0, r5
34815bc4:	e1cd21d8 	ldrd	r2, [sp, #24]
34815bc8:	e58d6000 	str	r6, [sp]
34815bcc:	ebfffe3b 	bl	348154c0 <onenand_recover_lsb>
34815bd0:	e1a06000 	mov	r6, r0
			onenand_update_bufferram(mtd, from, !ret);
34815bd4:	e2763001 	rsbs	r3, r6, #1
34815bd8:	33a03000 	movcc	r3, #0
34815bdc:	e58d3000 	str	r3, [sp]
34815be0:	e5950094 	ldr	r0, [r5, #148]	; 0x94
34815be4:	e1cd21d8 	ldrd	r2, [sp, #24]
34815be8:	ebfffb00 	bl	348147f0 <onenand_update_bufferram.clone.2>
			if (ret == -EBADMSG)
				ret = 0;
34815bec:	e376004a 	cmn	r6, #74	; 0x4a
34815bf0:	03a06000 	moveq	r6, #0
		}

		/* See if we are done */
		read += thislen;
34815bf4:	e59d3020 	ldr	r3, [sp, #32]
34815bf8:	e083300a 	add	r3, r3, sl
		if (read == len)
34815bfc:	e153000b 	cmp	r3, fp
			if (ret == -EBADMSG)
				ret = 0;
		}

		/* See if we are done */
		read += thislen;
34815c00:	e58d3020 	str	r3, [sp, #32]
		if (read == len)
34815c04:	0a000027 	beq	34815ca8 <onenand_read_ops_nolock+0x4ac>
			break;
		/* Set up for next read from bufferRAM */
		if (unlikely(boundary))
34815c08:	e59d7024 	ldr	r7, [sp, #36]	; 0x24
34815c0c:	e3570000 	cmp	r7, #0
34815c10:	0a000005 	beq	34815c2c <onenand_read_ops_nolock+0x430>
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
34815c14:	e5942000 	ldr	r2, [r4]
34815c18:	e59f10e4 	ldr	r1, [pc, #228]	; 34815d04 <onenand_read_ops_nolock+0x508>
34815c1c:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34815c20:	e3a00902 	mov	r0, #32768	; 0x8000
34815c24:	e0821001 	add	r1, r2, r1
34815c28:	e12fff33 	blx	r3
		if (!ONENAND_IS_4KB_PAGE(this))
34815c2c:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
			ONENAND_SET_NEXT_BUFFERRAM(this);
		buf += thislen;
34815c30:	e59d0028 	ldr	r0, [sp, #40]	; 0x28
		if (read == len)
			break;
		/* Set up for next read from bufferRAM */
		if (unlikely(boundary))
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
		if (!ONENAND_IS_4KB_PAGE(this))
34815c34:	e2133008 	ands	r3, r3, #8
			ONENAND_SET_NEXT_BUFFERRAM(this);
34815c38:	05942044 	ldreq	r2, [r4, #68]	; 0x44
		buf += thislen;
		thislen = min_t(int, writesize, len - read);
34815c3c:	e59d1020 	ldr	r1, [sp, #32]
			break;
		/* Set up for next read from bufferRAM */
		if (unlikely(boundary))
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
		if (!ONENAND_IS_4KB_PAGE(this))
			ONENAND_SET_NEXT_BUFFERRAM(this);
34815c40:	02222001 	eoreq	r2, r2, #1
		buf += thislen;
34815c44:	e080000a 	add	r0, r0, sl
		thislen = min_t(int, writesize, len - read);
34815c48:	e061a00b 	rsb	sl, r1, fp
			break;
		/* Set up for next read from bufferRAM */
		if (unlikely(boundary))
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
		if (!ONENAND_IS_4KB_PAGE(this))
			ONENAND_SET_NEXT_BUFFERRAM(this);
34815c4c:	05842044 	streq	r2, [r4, #68]	; 0x44
		buf += thislen;
		thislen = min_t(int, writesize, len - read);
34815c50:	e15a0009 	cmp	sl, r9
34815c54:	a1a0a009 	movge	sl, r9
		column = 0;

		if (!ONENAND_IS_4KB_PAGE(this)) {
34815c58:	e3530000 	cmp	r3, #0
		/* Set up for next read from bufferRAM */
		if (unlikely(boundary))
			this->write_word(ONENAND_DDP_CHIP1, this->base + ONENAND_REG_START_ADDRESS2);
		if (!ONENAND_IS_4KB_PAGE(this))
			ONENAND_SET_NEXT_BUFFERRAM(this);
		buf += thislen;
34815c5c:	e58d0028 	str	r0, [sp, #40]	; 0x28
		thislen = min_t(int, writesize, len - read);
		column = 0;

		if (!ONENAND_IS_4KB_PAGE(this)) {
34815c60:	1a00000c 	bne	34815c98 <onenand_read_ops_nolock+0x49c>
			/* Now wait for load */
			ret = this->wait(mtd, FL_READING);
34815c64:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34815c68:	e3a01001 	mov	r1, #1
34815c6c:	e1a00005 	mov	r0, r5
34815c70:	e12fff33 	blx	r3
			onenand_update_bufferram(mtd, from, !ret);
34815c74:	e2703001 	rsbs	r3, r0, #1
34815c78:	33a03000 	movcc	r3, #0
34815c7c:	e1a06000 	mov	r6, r0
34815c80:	e58d3000 	str	r3, [sp]
34815c84:	e5950094 	ldr	r0, [r5, #148]	; 0x94
34815c88:	e1cd21d8 	ldrd	r2, [sp, #24]
34815c8c:	ebfffad7 	bl	348147f0 <onenand_update_bufferram.clone.2>
			if (ret == -EBADMSG)
				ret = 0;
34815c90:	e376004a 	cmn	r6, #74	; 0x4a
34815c94:	03a06000 	moveq	r6, #0

		if (!ONENAND_IS_4KB_PAGE(this)) {
			/* Now wait for load */
			ret = this->wait(mtd, FL_READING);
			onenand_update_bufferram(mtd, from, !ret);
			if (ret == -EBADMSG)
34815c98:	e3a02000 	mov	r2, #0
34815c9c:	e58d2030 	str	r2, [sp, #48]	; 0x30
	thislen = min_t(int, writesize, len - read);
	column = from & (writesize - 1);
	if (column + thislen > writesize)
		thislen = writesize - column;

	while (!ret) {
34815ca0:	e3560000 	cmp	r6, #0
34815ca4:	0affff50 	beq	348159ec <onenand_read_ops_nolock+0x1f0>
34815ca8:	e59d7014 	ldr	r7, [sp, #20]
	/*
	 * Return success, if no ECC failures, else -EBADMSG
	 * fs driver will take care of that, because
	 * retlen == desired len and result == -EBADMSG
	 */
	ops->retlen = read;
34815cac:	e59d3020 	ldr	r3, [sp, #32]
	ops->oobretlen = oobread;
34815cb0:	e59d0034 	ldr	r0, [sp, #52]	; 0x34

	if (ret)
34815cb4:	e3560000 	cmp	r6, #0
	/*
	 * Return success, if no ECC failures, else -EBADMSG
	 * fs driver will take care of that, because
	 * retlen == desired len and result == -EBADMSG
	 */
	ops->retlen = read;
34815cb8:	e5873008 	str	r3, [r7, #8]
	ops->oobretlen = oobread;
34815cbc:	e5870010 	str	r0, [r7, #16]

	if (ret)
34815cc0:	1a000009 	bne	34815cec <onenand_read_ops_nolock+0x4f0>
		return ret;

	if (mtd->ecc_stats.failed - stats.failed)
34815cc4:	e5953084 	ldr	r3, [r5, #132]	; 0x84
34815cc8:	e59d1050 	ldr	r1, [sp, #80]	; 0x50
34815ccc:	e1530001 	cmp	r3, r1
		return -EBADMSG;
34815cd0:	13e06049 	mvnne	r6, #73	; 0x49
	ops->oobretlen = oobread;

	if (ret)
		return ret;

	if (mtd->ecc_stats.failed - stats.failed)
34815cd4:	1a000004 	bne	34815cec <onenand_read_ops_nolock+0x4f0>
		return -EBADMSG;

	return mtd->ecc_stats.corrected - stats.corrected ? -EUCLEAN : 0;
34815cd8:	e5953080 	ldr	r3, [r5, #128]	; 0x80
34815cdc:	e59d2054 	ldr	r2, [sp, #84]	; 0x54
34815ce0:	e1530002 	cmp	r3, r2
34815ce4:	03a06000 	moveq	r6, #0
34815ce8:	13e06074 	mvnne	r6, #116	; 0x74
}
34815cec:	e1a00006 	mov	r0, r6
34815cf0:	e28dd058 	add	sp, sp, #88	; 0x58
34815cf4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	size_t ooblen = ops->ooblen;
	u_char *buf = ops->datbuf;
	u_char *oobbuf = ops->oobbuf;
	int read = 0, column, thislen;
	int oobread = 0, oobcolumn, thisooblen, oobsize;
	int ret = 0, boundary = 0;
34815cf8:	e3a06000 	mov	r6, #0
34815cfc:	eaffff25 	b	34815998 <onenand_read_ops_nolock+0x19c>
34815d00:	348278a5 	.word	0x348278a5
34815d04:	0001e202 	.word	0x0001e202
34815d08:	00010020 	.word	0x00010020

34815d0c <onenand_read_oob>:
 *
 * OneNAND main and/or out-of-band
 */
int onenand_read_oob(struct mtd_info *mtd, loff_t from,
			struct mtd_oob_ops *ops)
{
34815d0c:	e59d1000 	ldr	r1, [sp]
	int ret;

	switch (ops->mode) {
34815d10:	e591c000 	ldr	ip, [r1]
34815d14:	e35c0001 	cmp	ip, #1
34815d18:	8a000005 	bhi	34815d34 <onenand_read_oob+0x28>
	default:
		return -EINVAL;
	}

	onenand_get_device(mtd, FL_READING);
	if (ops->datbuf)
34815d1c:	e591c018 	ldr	ip, [r1, #24]
34815d20:	e35c0000 	cmp	ip, #0
34815d24:	0a000000 	beq	34815d2c <onenand_read_oob+0x20>
		ret = onenand_read_ops_nolock(mtd, from, ops);
34815d28:	eafffeb3 	b	348157fc <onenand_read_ops_nolock>
	else
		ret = onenand_read_oob_nolock(mtd, from, ops);
34815d2c:	e58d1000 	str	r1, [sp]
34815d30:	eafffe08 	b	34815558 <onenand_read_oob_nolock>
	onenand_release_device(mtd);

	return ret;
}
34815d34:	e3e00015 	mvn	r0, #21
34815d38:	e12fff1e 	bx	lr

34815d3c <onenand_read>:
 *
 * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
*/
int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
		 size_t * retlen, u_char * buf)
{
34815d3c:	e92d40f0 	push	{r4, r5, r6, r7, lr}
34815d40:	e24dd02c 	sub	sp, sp, #44	; 0x2c
	struct mtd_oob_ops ops = {
34815d44:	e28d7008 	add	r7, sp, #8
 *
 * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
*/
int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
		 size_t * retlen, u_char * buf)
{
34815d48:	e1a06000 	mov	r6, r0
34815d4c:	e1a04002 	mov	r4, r2
	struct mtd_oob_ops ops = {
34815d50:	e3a01000 	mov	r1, #0
34815d54:	e1a00007 	mov	r0, r7
34815d58:	e3a02020 	mov	r2, #32
 *
 * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
*/
int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
		 size_t * retlen, u_char * buf)
{
34815d5c:	e1a05003 	mov	r5, r3
	struct mtd_oob_ops ops = {
34815d60:	eb001857 	bl	3481bec4 <memset>
34815d64:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_READING);
	ret = onenand_read_ops_nolock(mtd, from, &ops);
34815d68:	e1a02004 	mov	r2, r4
 * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
*/
int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
		 size_t * retlen, u_char * buf)
{
	struct mtd_oob_ops ops = {
34815d6c:	e58d300c 	str	r3, [sp, #12]
34815d70:	e59d3048 	ldr	r3, [sp, #72]	; 0x48
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_READING);
	ret = onenand_read_ops_nolock(mtd, from, &ops);
34815d74:	e1a00006 	mov	r0, r6
 * This function simply calls onenand_read_ecc with oob buffer and oobsel = NULL
*/
int onenand_read(struct mtd_info *mtd, loff_t from, size_t len,
		 size_t * retlen, u_char * buf)
{
	struct mtd_oob_ops ops = {
34815d78:	e58d3020 	str	r3, [sp, #32]
		.oobbuf = NULL,
	};
	int ret;

	onenand_get_device(mtd, FL_READING);
	ret = onenand_read_ops_nolock(mtd, from, &ops);
34815d7c:	e1a03005 	mov	r3, r5
34815d80:	e58d7000 	str	r7, [sp]
34815d84:	ebfffe9c 	bl	348157fc <onenand_read_ops_nolock>
	onenand_release_device(mtd);

	*retlen = ops.retlen;
34815d88:	e59d2010 	ldr	r2, [sp, #16]
34815d8c:	e59d3044 	ldr	r3, [sp, #68]	; 0x44
34815d90:	e5832000 	str	r2, [r3]
	return ret;
}
34815d94:	e28dd02c 	add	sp, sp, #44	; 0x2c
34815d98:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}

34815d9c <onenand_erase>:
 * @param instr		erase instruction
 *
 * Erase one ore more blocks
 */
int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
{
34815d9c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
34815da0:	e1a06001 	mov	r6, r1
	struct onenand_chip *this = mtd->priv;
	unsigned int block_size;
	loff_t addr = instr->addr;
	unsigned int len = instr->len;
34815da4:	e5969010 	ldr	r9, [r6, #16]
 * @param instr		erase instruction
 *
 * Erase one ore more blocks
 */
int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
{
34815da8:	e24dd028 	sub	sp, sp, #40	; 0x28
34815dac:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
34815db0:	e590a094 	ldr	sl, [r0, #148]	; 0x94
	unsigned int block_size;
	loff_t addr = instr->addr;
34815db4:	e1c100d8 	ldrd	r0, [r1, #8]

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_erase: start = 0x%08x, len = %i\n",
			(unsigned int) addr, len);

	/* Do not allow erase past end of device */
	if (unlikely((len + addr) > mtd->size)) {
34815db8:	e0902009 	adds	r2, r0, r9
34815dbc:	e2a13000 	adc	r3, r1, #0
 */
int onenand_erase(struct mtd_info *mtd, struct erase_info *instr)
{
	struct onenand_chip *this = mtd->priv;
	unsigned int block_size;
	loff_t addr = instr->addr;
34815dc0:	e1cd01f0 	strd	r0, [sp, #16]
34815dc4:	e1cd01f8 	strd	r0, [sp, #24]

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_erase: start = 0x%08x, len = %i\n",
			(unsigned int) addr, len);

	/* Do not allow erase past end of device */
	if (unlikely((len + addr) > mtd->size)) {
34815dc8:	e595100c 	ldr	r1, [r5, #12]
34815dcc:	e1510003 	cmp	r1, r3
34815dd0:	3a0000b4 	bcc	348160a8 <onenand_erase+0x30c>
34815dd4:	1a000002 	bne	34815de4 <onenand_erase+0x48>
34815dd8:	e5951008 	ldr	r1, [r5, #8]
34815ddc:	e1510002 	cmp	r1, r2
34815de0:	3a0000b0 	bcc	348160a8 <onenand_erase+0x30c>
		MTDDEBUG(MTD_DEBUG_LEVEL0, "onenand_erase:"
					"Erase past end of device\n");
		return -EINVAL;
	}

	if (FLEXONENAND(this)) {
34815de4:	e59a301c 	ldr	r3, [sl, #28]
34815de8:	e3130c02 	tst	r3, #512	; 0x200
34815dec:	0a000015 	beq	34815e48 <onenand_erase+0xac>
		/* Find the eraseregion of this address */
		i = flexonenand_region(mtd, addr);
34815df0:	e1cd21d0 	ldrd	r2, [sp, #16]
34815df4:	e1a00005 	mov	r0, r5
34815df8:	ebfffd9d 	bl	34815474 <flexonenand_region>
		region = &mtd->eraseregions[i];
34815dfc:	e3a03018 	mov	r3, #24
34815e00:	e0000093 	mul	r0, r3, r0
34815e04:	e5951030 	ldr	r1, [r5, #48]	; 0x30
34815e08:	e0817000 	add	r7, r1, r0

		block_size = region->erasesize;
34815e0c:	e5974008 	ldr	r4, [r7, #8]
		region_end = region->offset
34815e10:	e18120d0 	ldrd	r2, [r1, r0]
34815e14:	e1cd22f0 	strd	r2, [sp, #32]
			+ region->erasesize * region->numblocks;

		/* Start address within region must align on block boundary.
		 * Erase region's start offset is always block start address.
		 */
		if (unlikely((addr - region->offset) & (block_size - 1))) {
34815e18:	e1cd02d0 	ldrd	r0, [sp, #32]
34815e1c:	e1cd21d0 	ldrd	r2, [sp, #16]
34815e20:	e244c001 	sub	ip, r4, #1
34815e24:	e0522000 	subs	r2, r2, r0
34815e28:	e0c33001 	sbc	r3, r3, r1
		i = flexonenand_region(mtd, addr);
		region = &mtd->eraseregions[i];

		block_size = region->erasesize;
		region_end = region->offset
			+ region->erasesize * region->numblocks;
34815e2c:	e597b00c 	ldr	fp, [r7, #12]

		/* Start address within region must align on block boundary.
		 * Erase region's start offset is always block start address.
		 */
		if (unlikely((addr - region->offset) & (block_size - 1))) {
34815e30:	e002200c 	and	r2, r2, ip
34815e34:	e3a03000 	mov	r3, #0
34815e38:	e1921003 	orrs	r1, r2, r3
		/* Find the eraseregion of this address */
		i = flexonenand_region(mtd, addr);
		region = &mtd->eraseregions[i];

		block_size = region->erasesize;
		region_end = region->offset
34815e3c:	002b0b94 	mlaeq	fp, r4, fp, r0
			+ region->erasesize * region->numblocks;

		/* Start address within region must align on block boundary.
		 * Erase region's start offset is always block start address.
		 */
		if (unlikely((addr - region->offset) & (block_size - 1))) {
34815e40:	0a00000a 	beq	34815e70 <onenand_erase+0xd4>
34815e44:	ea000097 	b	348160a8 <onenand_erase+0x30c>
			MTDDEBUG(MTD_DEBUG_LEVEL0, "onenand_erase:"
				" Unaligned address\n");
			return -EINVAL;
		}
	} else {
		block_size = 1 << this->erase_shift;
34815e48:	e59a3030 	ldr	r3, [sl, #48]	; 0x30
34815e4c:	e3a04001 	mov	r4, #1
34815e50:	e1a04314 	lsl	r4, r4, r3

		/* Start address must align on block boundary */
		if (unlikely(addr & (block_size - 1))) {
34815e54:	e1cd21d0 	ldrd	r2, [sp, #16]
34815e58:	e2441001 	sub	r1, r4, #1
34815e5c:	e0022001 	and	r2, r2, r1
34815e60:	e3a03000 	mov	r3, #0
34815e64:	e192b003 	orrs	fp, r2, r3
34815e68:	1a00008e 	bne	348160a8 <onenand_erase+0x30c>
	struct onenand_chip *this = mtd->priv;
	unsigned int block_size;
	loff_t addr = instr->addr;
	unsigned int len = instr->len;
	int ret = 0, i;
	struct mtd_erase_region_info *region = NULL;
34815e6c:	e1a0700b 	mov	r7, fp
			return -EINVAL;
		}
	}

	/* Length must align on block boundary */
	if (unlikely(len & (block_size - 1))) {
34815e70:	e2443001 	sub	r3, r4, #1
34815e74:	e1130009 	tst	r3, r9
34815e78:	1a00008a 	bne	348160a8 <onenand_erase+0x30c>
		MTDDEBUG (MTD_DEBUG_LEVEL0,
			 "onenand_erase: Length not block aligned\n");
		return -EINVAL;
	}

	instr->fail_addr = 0xffffffff;
34815e7c:	e3a03000 	mov	r3, #0
34815e80:	e3e02000 	mvn	r2, #0
34815e84:	e1c621f8 	strd	r2, [r6, #24]

	/* Grab the lock and see if the device is available */
	onenand_get_device(mtd, FL_ERASING);

	/* Loop throught the pages */
	instr->state = MTD_ERASING;
34815e88:	e3a03002 	mov	r3, #2
34815e8c:	e5c63038 	strb	r3, [r6, #56]	; 0x38
34815e90:	e58db00c 	str	fp, [sp, #12]

	while (len) {
34815e94:	ea000077 	b	34816078 <onenand_erase+0x2dc>

		/* Check if we have a bad block, we do not erase bad blocks */
		if (instr->priv == 0 && onenand_block_isbad_nolock(mtd, addr, 0)) {
34815e98:	e5963034 	ldr	r3, [r6, #52]	; 0x34
34815e9c:	e3530000 	cmp	r3, #0
34815ea0:	1a00000d 	bne	34815edc <onenand_erase+0x140>
 * calling of the scan function.
 */
static int onenand_block_isbad_nolock(struct mtd_info *mtd, loff_t ofs, int allowbbt)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
34815ea4:	e5952094 	ldr	r2, [r5, #148]	; 0x94

	/* Return info from the table */
	return bbm->isbad_bbt(mtd, ofs, allowbbt);
34815ea8:	e1a00005 	mov	r0, r5
34815eac:	e59220a0 	ldr	r2, [r2, #160]	; 0xa0
34815eb0:	e58d3000 	str	r3, [sp]
34815eb4:	e5921010 	ldr	r1, [r2, #16]
34815eb8:	e1cd21d8 	ldrd	r2, [sp, #24]
34815ebc:	e12fff31 	blx	r1
	instr->state = MTD_ERASING;

	while (len) {

		/* Check if we have a bad block, we do not erase bad blocks */
		if (instr->priv == 0 && onenand_block_isbad_nolock(mtd, addr, 0)) {
34815ec0:	e3500000 	cmp	r0, #0
34815ec4:	0a000004 	beq	34815edc <onenand_erase+0x140>
			printk(KERN_WARNING "onenand_erase: attempt to erase"
34815ec8:	e59f01e4 	ldr	r0, [pc, #484]	; 348160b4 <onenand_erase+0x318>
34815ecc:	e59d1018 	ldr	r1, [sp, #24]
34815ed0:	ebffcca3 	bl	34809164 <printf>
				" a bad block at addr 0x%08x\n",
				(unsigned int) addr);
			instr->state = MTD_ERASE_FAILED;
34815ed4:	e3a03010 	mov	r3, #16
34815ed8:	ea000069 	b	34816084 <onenand_erase+0x2e8>
			goto erase_exit;
		}

		this->command(mtd, ONENAND_CMD_ERASE, addr, block_size);
34815edc:	e58d4000 	str	r4, [sp]
34815ee0:	e1cd21d8 	ldrd	r2, [sp, #24]
34815ee4:	e59ac050 	ldr	ip, [sl, #80]	; 0x50
34815ee8:	e3a01094 	mov	r1, #148	; 0x94
34815eec:	e1a00005 	mov	r0, r5
34815ef0:	e12fff3c 	blx	ip
static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
					 unsigned int len)
{
	struct onenand_chip *this = mtd->priv;
	int i;
	loff_t end_addr = addr + len;
34815ef4:	e1cd01d8 	ldrd	r0, [sp, #24]
 * Invalidate BufferRAM information
 */
static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
					 unsigned int len)
{
	struct onenand_chip *this = mtd->priv;
34815ef8:	e5953094 	ldr	r3, [r5, #148]	; 0x94
	int i;
	loff_t end_addr = addr + len;
34815efc:	e0900004 	adds	r0, r0, r4

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
34815f00:	e593c034 	ldr	ip, [r3, #52]	; 0x34
34815f04:	e5932048 	ldr	r2, [r3, #72]	; 0x48
static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
					 unsigned int len)
{
	struct onenand_chip *this = mtd->priv;
	int i;
	loff_t end_addr = addr + len;
34815f08:	e2a11000 	adc	r1, r1, #0

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
34815f0c:	e1a02c12 	lsl	r2, r2, ip
static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
					 unsigned int len)
{
	struct onenand_chip *this = mtd->priv;
	int i;
	loff_t end_addr = addr + len;
34815f10:	e1cd01f0 	strd	r0, [sp, #16]

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;

		if (buf_addr >= addr && buf_addr < end_addr)
34815f14:	e59db014 	ldr	fp, [sp, #20]
	int i;
	loff_t end_addr = addr + len;

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
34815f18:	e1a00002 	mov	r0, r2
34815f1c:	e1a01fc0 	asr	r1, r0, #31

		if (buf_addr >= addr && buf_addr < end_addr)
34815f20:	e15b0001 	cmp	fp, r1
	int i;
	loff_t end_addr = addr + len;

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
34815f24:	e1cd02f0 	strd	r0, [sp, #32]

		if (buf_addr >= addr && buf_addr < end_addr)
34815f28:	e3a00001 	mov	r0, #1
34815f2c:	ca000004 	bgt	34815f44 <onenand_erase+0x1a8>
34815f30:	1a000002 	bne	34815f40 <onenand_erase+0x1a4>
34815f34:	e59de010 	ldr	lr, [sp, #16]
34815f38:	e15e0002 	cmp	lr, r2
34815f3c:	8a000000 	bhi	34815f44 <onenand_erase+0x1a8>
34815f40:	e3a00000 	mov	r0, #0
34815f44:	e59db01c 	ldr	fp, [sp, #28]
34815f48:	e59de024 	ldr	lr, [sp, #36]	; 0x24
34815f4c:	e3a01001 	mov	r1, #1
34815f50:	e15b000e 	cmp	fp, lr
34815f54:	ca000003 	bgt	34815f68 <onenand_erase+0x1cc>
34815f58:	1a000003 	bne	34815f6c <onenand_erase+0x1d0>
34815f5c:	e59db018 	ldr	fp, [sp, #24]
34815f60:	e15b0002 	cmp	fp, r2
34815f64:	9a000000 	bls	34815f6c <onenand_erase+0x1d0>
34815f68:	e3a01000 	mov	r1, #0
	int i;
	loff_t end_addr = addr + len;

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
34815f6c:	e593204c 	ldr	r2, [r3, #76]	; 0x4c

		if (buf_addr >= addr && buf_addr < end_addr)
34815f70:	e0001001 	and	r1, r0, r1
	int i;
	loff_t end_addr = addr + len;

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
34815f74:	e1a0cc12 	lsl	ip, r2, ip

		if (buf_addr >= addr && buf_addr < end_addr)
34815f78:	e31100ff 	tst	r1, #255	; 0xff
	int i;
	loff_t end_addr = addr + len;

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;
34815f7c:	e1a0000c 	mov	r0, ip
34815f80:	e1a01fc0 	asr	r1, r0, #31
34815f84:	e1cd02f0 	strd	r0, [sp, #32]

		if (buf_addr >= addr && buf_addr < end_addr)
34815f88:	e59d2014 	ldr	r2, [sp, #20]
34815f8c:	e59db024 	ldr	fp, [sp, #36]	; 0x24
			this->bufferram[i].blockpage = -1;
34815f90:	13e0e000 	mvnne	lr, #0
34815f94:	1583e048 	strne	lr, [r3, #72]	; 0x48

	/* Invalidate BufferRAM */
	for (i = 0; i < MAX_BUFFERRAM; i++) {
		loff_t buf_addr = this->bufferram[i].blockpage << this->page_shift;

		if (buf_addr >= addr && buf_addr < end_addr)
34815f98:	e152000b 	cmp	r2, fp
34815f9c:	e3a01001 	mov	r1, #1
34815fa0:	ca000004 	bgt	34815fb8 <onenand_erase+0x21c>
34815fa4:	1a000002 	bne	34815fb4 <onenand_erase+0x218>
34815fa8:	e59de010 	ldr	lr, [sp, #16]
34815fac:	e15e000c 	cmp	lr, ip
34815fb0:	8a000000 	bhi	34815fb8 <onenand_erase+0x21c>
34815fb4:	e3a01000 	mov	r1, #0
34815fb8:	e59d001c 	ldr	r0, [sp, #28]
34815fbc:	e59db024 	ldr	fp, [sp, #36]	; 0x24
34815fc0:	e3a02001 	mov	r2, #1
34815fc4:	e150000b 	cmp	r0, fp
34815fc8:	ca000003 	bgt	34815fdc <onenand_erase+0x240>
34815fcc:	1a000003 	bne	34815fe0 <onenand_erase+0x244>
34815fd0:	e59de018 	ldr	lr, [sp, #24]
34815fd4:	e15e000c 	cmp	lr, ip
34815fd8:	9a000000 	bls	34815fe0 <onenand_erase+0x244>
34815fdc:	e3a02000 	mov	r2, #0
34815fe0:	e0012002 	and	r2, r1, r2
34815fe4:	e31200ff 	tst	r2, #255	; 0xff
			this->bufferram[i].blockpage = -1;
34815fe8:	13e00000 	mvnne	r0, #0
34815fec:	1583004c 	strne	r0, [r3, #76]	; 0x4c

		this->command(mtd, ONENAND_CMD_ERASE, addr, block_size);

		onenand_invalidate_bufferram(mtd, addr, block_size);

		ret = this->wait(mtd, FL_ERASING);
34815ff0:	e3a01003 	mov	r1, #3
34815ff4:	e59a3054 	ldr	r3, [sl, #84]	; 0x54
34815ff8:	e1a00005 	mov	r0, r5
34815ffc:	e12fff33 	blx	r3
		/* Check, if it is write protected */
		if (ret) {
34816000:	e3500000 	cmp	r0, #0
					  "Device is write protected!!!\n");
			else
				MTDDEBUG (MTD_DEBUG_LEVEL0, "onenand_erase: "
					  "Failed erase, block %d\n",
					onenand_block(this, addr));
			instr->state = MTD_ERASE_FAILED;
34816004:	13a03010 	movne	r3, #16
34816008:	15c63038 	strbne	r3, [r6, #56]	; 0x38
			instr->fail_addr = addr;
3481600c:	11cd21d8 	ldrdne	r2, [sp, #24]
34816010:	11c621f8 	strdne	r2, [r6, #24]

			goto erase_exit;
34816014:	1a00001b 	bne	34816088 <onenand_erase+0x2ec>
		}

		len -= block_size;
		addr += block_size;

		if (addr == region_end) {
34816018:	e59d3010 	ldr	r3, [sp, #16]
3481601c:	e59db00c 	ldr	fp, [sp, #12]
			instr->fail_addr = addr;

			goto erase_exit;
		}

		len -= block_size;
34816020:	e0649009 	rsb	r9, r4, r9
		addr += block_size;

		if (addr == region_end) {
34816024:	e153000b 	cmp	r3, fp
34816028:	1a000010 	bne	34816070 <onenand_erase+0x2d4>
3481602c:	e59d0014 	ldr	r0, [sp, #20]
34816030:	e3500000 	cmp	r0, #0
34816034:	1a00000d 	bne	34816070 <onenand_erase+0x2d4>
			if (!len)
34816038:	e3590000 	cmp	r9, #0
3481603c:	0a00000f 	beq	34816080 <onenand_erase+0x2e4>
				break;
			region++;
34816040:	e2877018 	add	r7, r7, #24

			block_size = region->erasesize;
34816044:	e5974008 	ldr	r4, [r7, #8]
			region_end = region->offset
34816048:	e5973000 	ldr	r3, [r7]
				+ region->erasesize * region->numblocks;

			if (len & (block_size - 1)) {
3481604c:	e2442001 	sub	r2, r4, #1
34816050:	e1190002 	tst	r9, r2
				break;
			region++;

			block_size = region->erasesize;
			region_end = region->offset
				+ region->erasesize * region->numblocks;
34816054:	e597b00c 	ldr	fp, [r7, #12]
			if (!len)
				break;
			region++;

			block_size = region->erasesize;
			region_end = region->offset
34816058:	00233b94 	mlaeq	r3, r4, fp, r3
3481605c:	058d300c 	streq	r3, [sp, #12]
34816060:	0a000002 	beq	34816070 <onenand_erase+0x2d4>
				+ region->erasesize * region->numblocks;

			if (len & (block_size - 1)) {
				/* This has been checked at MTD
				 * partitioning level. */
				printk("onenand_erase: Unaligned address\n");
34816064:	e59f004c 	ldr	r0, [pc, #76]	; 348160b8 <onenand_erase+0x31c>
34816068:	ebffcc3d 	bl	34809164 <printf>
				goto erase_exit;
3481606c:	ea000005 	b	34816088 <onenand_erase+0x2ec>
static void onenand_invalidate_bufferram(struct mtd_info *mtd, loff_t addr,
					 unsigned int len)
{
	struct onenand_chip *this = mtd->priv;
	int i;
	loff_t end_addr = addr + len;
34816070:	e1cd21d0 	ldrd	r2, [sp, #16]
34816074:	e1cd21f8 	strd	r2, [sp, #24]
	onenand_get_device(mtd, FL_ERASING);

	/* Loop throught the pages */
	instr->state = MTD_ERASING;

	while (len) {
34816078:	e3590000 	cmp	r9, #0
3481607c:	1affff85 	bne	34815e98 <onenand_erase+0xfc>
				goto erase_exit;
			}
		}
	}

	instr->state = MTD_ERASE_DONE;
34816080:	e3a03008 	mov	r3, #8
34816084:	e5c63038 	strb	r3, [r6, #56]	; 0x38

erase_exit:

	ret = instr->state == MTD_ERASE_DONE ? 0 : -EIO;
34816088:	e5d63038 	ldrb	r3, [r6, #56]	; 0x38
3481608c:	e3530008 	cmp	r3, #8
34816090:	13e00004 	mvnne	r0, #4
34816094:	1a000004 	bne	348160ac <onenand_erase+0x310>
	/* Do call back function */
	if (!ret)
		mtd_erase_callback(instr);
34816098:	e1a00006 	mov	r0, r6
3481609c:	ebfff548 	bl	348135c4 <mtd_erase_callback>
348160a0:	e3a00000 	mov	r0, #0
348160a4:	ea000000 	b	348160ac <onenand_erase+0x310>

	/* Length must align on block boundary */
	if (unlikely(len & (block_size - 1))) {
		MTDDEBUG (MTD_DEBUG_LEVEL0,
			 "onenand_erase: Length not block aligned\n");
		return -EINVAL;
348160a8:	e3e00015 	mvn	r0, #21

	/* Deselect and wake up anyone waiting on the device */
	onenand_release_device(mtd);

	return ret;
}
348160ac:	e28dd028 	add	sp, sp, #40	; 0x28
348160b0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
348160b4:	348278e1 	.word	0x348278e1
348160b8:	3482791d 	.word	0x3482791d

348160bc <onenand_bbt_read_oob>:
 *
 * OneNAND read out-of-band data from the spare area for bbt scan
 */
int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
348160bc:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
348160c0:	e5905094 	ldr	r5, [r0, #148]	; 0x94
 *
 * OneNAND read out-of-band data from the spare area for bbt scan
 */
int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
348160c4:	e24dd020 	sub	sp, sp, #32
348160c8:	e1a04000 	mov	r4, r0
348160cc:	e1cd21f0 	strd	r2, [sp, #16]
	struct onenand_chip *this = mtd->priv;
	int read = 0, thislen, column;
	int ret = 0, readcmd;
	size_t len = ops->ooblen;
348160d0:	e59d0040 	ldr	r0, [sp, #64]	; 0x40
	u_char *buf = ops->oobbuf;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_bbt_read_oob: from = 0x%08x, len = %zi\n", (unsigned int) from, len);

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
348160d4:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int read = 0, thislen, column;
	int ret = 0, readcmd;
	size_t len = ops->ooblen;
348160d8:	e590700c 	ldr	r7, [r0, #12]
	u_char *buf = ops->oobbuf;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_bbt_read_oob: from = 0x%08x, len = %zi\n", (unsigned int) from, len);

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;
348160dc:	e3130008 	tst	r3, #8
348160e0:	03a01013 	moveq	r1, #19
348160e4:	13a01000 	movne	r1, #0

	/* Initialize return value */
	ops->oobretlen = 0;
348160e8:	e3a03000 	mov	r3, #0
	u_char *buf = ops->oobbuf;

	MTDDEBUG(MTD_DEBUG_LEVEL3, "onenand_bbt_read_oob: from = 0x%08x, len = %zi\n", (unsigned int) from, len);

	readcmd = ONENAND_IS_4KB_PAGE(this) ?
		ONENAND_CMD_READ : ONENAND_CMD_READOOB;
348160ec:	e58d101c 	str	r1, [sp, #28]

	/* Initialize return value */
	ops->oobretlen = 0;
348160f0:	e5803010 	str	r3, [r0, #16]

	/* Do not allow reads past end of device */
	if (unlikely((from + len) > mtd->size)) {
348160f4:	e594100c 	ldr	r1, [r4, #12]
348160f8:	e1cd21d0 	ldrd	r2, [sp, #16]
348160fc:	e0922007 	adds	r2, r2, r7
34816100:	e2a33000 	adc	r3, r3, #0
34816104:	e1510003 	cmp	r1, r3
{
	struct onenand_chip *this = mtd->priv;
	int read = 0, thislen, column;
	int ret = 0, readcmd;
	size_t len = ops->ooblen;
	u_char *buf = ops->oobbuf;
34816108:	e590a01c 	ldr	sl, [r0, #28]

	/* Initialize return value */
	ops->oobretlen = 0;

	/* Do not allow reads past end of device */
	if (unlikely((from + len) > mtd->size)) {
3481610c:	3a000003 	bcc	34816120 <onenand_bbt_read_oob+0x64>
34816110:	1a000006 	bne	34816130 <onenand_bbt_read_oob+0x74>
34816114:	e5941008 	ldr	r1, [r4, #8]
34816118:	e1510002 	cmp	r1, r2
3481611c:	2a000003 	bcs	34816130 <onenand_bbt_read_oob+0x74>
		printk(KERN_ERR "onenand_bbt_read_oob: Attempt read beyond end of device\n");
34816120:	e59f00f8 	ldr	r0, [pc, #248]	; 34816220 <onenand_bbt_read_oob+0x164>
34816124:	ebffcc0e 	bl	34809164 <printf>
		return ONENAND_BBT_READ_FATAL_ERROR;
34816128:	e3a00004 	mov	r0, #4
3481612c:	ea000039 	b	34816218 <onenand_bbt_read_oob+0x15c>
	}

	/* Grab the lock and see if the device is available */
	onenand_get_device(mtd, FL_READING);

	column = from & (mtd->oobsize - 1);
34816130:	e594b018 	ldr	fp, [r4, #24]
34816134:	e59d2010 	ldr	r2, [sp, #16]
34816138:	e24bb001 	sub	fp, fp, #1
3481613c:	e00bb002 	and	fp, fp, r2
 */
int onenand_bbt_read_oob(struct mtd_info *mtd, loff_t from,
		struct mtd_oob_ops *ops)
{
	struct onenand_chip *this = mtd->priv;
	int read = 0, thislen, column;
34816140:	e3a06000 	mov	r6, #0
	/* Grab the lock and see if the device is available */
	onenand_get_device(mtd, FL_READING);

	column = from & (mtd->oobsize - 1);

	while (read < len) {
34816144:	ea00002e 	b	34816204 <onenand_bbt_read_oob+0x148>

		thislen = mtd->oobsize - column;
34816148:	e5949018 	ldr	r9, [r4, #24]
		thislen = min_t(int, thislen, len);

		this->spare_buf = buf;
3481614c:	e585a084 	str	sl, [r5, #132]	; 0x84
		this->command(mtd, readcmd, from, mtd->oobsize);
34816150:	e58d9000 	str	r9, [sp]
34816154:	e595c050 	ldr	ip, [r5, #80]	; 0x50
34816158:	e59d101c 	ldr	r1, [sp, #28]
3481615c:	e1cd21d0 	ldrd	r2, [sp, #16]
34816160:	e1a00004 	mov	r0, r4
34816164:	e12fff3c 	blx	ip

		onenand_update_bufferram(mtd, from, 0);
34816168:	e3a03000 	mov	r3, #0
3481616c:	e58d3000 	str	r3, [sp]
34816170:	e5940094 	ldr	r0, [r4, #148]	; 0x94
34816174:	e1cd21d0 	ldrd	r2, [sp, #16]
34816178:	ebfff99c 	bl	348147f0 <onenand_update_bufferram.clone.2>

		ret = this->bbt_wait(mtd, FL_READING);
3481617c:	e5953058 	ldr	r3, [r5, #88]	; 0x58
34816180:	e1a00004 	mov	r0, r4
34816184:	e3a01001 	mov	r1, #1
34816188:	e12fff33 	blx	r3
		if (unlikely(ret))
3481618c:	e3500000 	cmp	r0, #0
34816190:	0a000005 	beq	348161ac <onenand_bbt_read_oob+0xf0>
			ret = onenand_recover_lsb(mtd, from, ret);
34816194:	e58d0000 	str	r0, [sp]
34816198:	e1cd21d0 	ldrd	r2, [sp, #16]
3481619c:	e1a00004 	mov	r0, r4
348161a0:	ebfffcc6 	bl	348154c0 <onenand_recover_lsb>

		if (ret)
348161a4:	e3500000 	cmp	r0, #0
348161a8:	1a000018 	bne	34816210 <onenand_bbt_read_oob+0x154>
			break;

		this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
348161ac:	e59f0070 	ldr	r0, [pc, #112]	; 34816224 <onenand_bbt_read_oob+0x168>

	column = from & (mtd->oobsize - 1);

	while (read < len) {

		thislen = mtd->oobsize - column;
348161b0:	e06b9009 	rsb	r9, fp, r9
		thislen = min_t(int, thislen, len);
348161b4:	e1590007 	cmp	r9, r7
348161b8:	a1a09007 	movge	r9, r7
			ret = onenand_recover_lsb(mtd, from, ret);

		if (ret)
			break;

		this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
348161bc:	e88d0c01 	stm	sp, {r0, sl, fp}
348161c0:	e58d900c 	str	r9, [sp, #12]
348161c4:	e5951060 	ldr	r1, [r5, #96]	; 0x60
348161c8:	e1a00004 	mov	r0, r4
348161cc:	e3a02000 	mov	r2, #0
348161d0:	e3a03000 	mov	r3, #0
		read += thislen;
348161d4:	e0866009 	add	r6, r6, r9
			ret = onenand_recover_lsb(mtd, from, ret);

		if (ret)
			break;

		this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
348161d8:	e12fff31 	blx	r1
		read += thislen;
		if (read == len)
348161dc:	e1560007 	cmp	r6, r7
348161e0:	0a000009 	beq	3481620c <onenand_bbt_read_oob+0x150>
			break;

		buf += thislen;
348161e4:	e08aa009 	add	sl, sl, r9

		/* Read more? */
		if (read < len) {
348161e8:	2a000005 	bcs	34816204 <onenand_bbt_read_oob+0x148>
			/* Update Page size */
			from += this->writesize;
348161ec:	e5953040 	ldr	r3, [r5, #64]	; 0x40
348161f0:	e1cd01d0 	ldrd	r0, [sp, #16]
348161f4:	e0900003 	adds	r0, r0, r3
348161f8:	e2a11000 	adc	r1, r1, #0
348161fc:	e1cd01f0 	strd	r0, [sp, #16]
			column = 0;
34816200:	e3a0b000 	mov	fp, #0
	/* Grab the lock and see if the device is available */
	onenand_get_device(mtd, FL_READING);

	column = from & (mtd->oobsize - 1);

	while (read < len) {
34816204:	e1560007 	cmp	r6, r7
34816208:	3affffce 	bcc	34816148 <onenand_bbt_read_oob+0x8c>
		if (ret)
			break;

		this->read_bufferram(mtd, 0, ONENAND_SPARERAM, buf, column, thislen);
		read += thislen;
		if (read == len)
3481620c:	e3a00000 	mov	r0, #0
	}

	/* Deselect and wake up anyone waiting on the device */
	onenand_release_device(mtd);

	ops->oobretlen = read;
34816210:	e59d1040 	ldr	r1, [sp, #64]	; 0x40
34816214:	e5816010 	str	r6, [r1, #16]
	return ret;
}
34816218:	e28dd020 	add	sp, sp, #32
3481621c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34816220:	3482793f 	.word	0x3482793f
34816224:	00010020 	.word	0x00010020

34816228 <onenand_print_device_info>:
 * @param device        device ID
 *
 * Print device ID
 */
char *onenand_print_device_info(int device, int version)
{
34816228:	e92d40f0 	push	{r4, r5, r6, r7, lr}
3481622c:	e1a06000 	mov	r6, r0
34816230:	e24dd014 	sub	sp, sp, #20
	int vcc, demuxed, ddp, density, flexonenand;
	char *dev_info = malloc(80);
34816234:	e3a00050 	mov	r0, #80	; 0x50
 * @param device        device ID
 *
 * Print device ID
 */
char *onenand_print_device_info(int device, int version)
{
34816238:	e1a05001 	mov	r5, r1
	int vcc, demuxed, ddp, density, flexonenand;
	char *dev_info = malloc(80);
3481623c:	ebffcd8f 	bl	34809880 <malloc>
	vcc = device & ONENAND_DEVICE_VCC_MASK;
	demuxed = device & ONENAND_DEVICE_IS_DEMUX;
	ddp = device & ONENAND_DEVICE_IS_DDP;
	density = onenand_get_density(device);
	flexonenand = device & DEVICE_IS_FLEXONENAND;
	p += sprintf(dev_info, "%s%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
34816240:	e59f1080 	ldr	r1, [pc, #128]	; 348162c8 <onenand_print_device_info+0xa0>
34816244:	e59f2080 	ldr	r2, [pc, #128]	; 348162cc <onenand_print_device_info+0xa4>
34816248:	e3160004 	tst	r6, #4
3481624c:	e59f307c 	ldr	r3, [pc, #124]	; 348162d0 <onenand_print_device_info+0xa8>
34816250:	11a02001 	movne	r2, r1
34816254:	e59fe078 	ldr	lr, [pc, #120]	; 348162d4 <onenand_print_device_info+0xac>
34816258:	e3160c02 	tst	r6, #512	; 0x200
3481625c:	01a03001 	moveq	r3, r1
34816260:	e3160008 	tst	r6, #8
34816264:	11a0100e 	movne	r1, lr
 * Get OneNAND density from device ID
 */
static inline int onenand_get_density(int dev_id)
{
	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34816268:	e7e3c256 	ubfx	ip, r6, #4, #4
	vcc = device & ONENAND_DEVICE_VCC_MASK;
	demuxed = device & ONENAND_DEVICE_IS_DEMUX;
	ddp = device & ONENAND_DEVICE_IS_DDP;
	density = onenand_get_density(device);
	flexonenand = device & DEVICE_IS_FLEXONENAND;
	p += sprintf(dev_info, "%s%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
3481626c:	e3a0e010 	mov	lr, #16
34816270:	e1a0ec1e 	lsl	lr, lr, ip
34816274:	e59f705c 	ldr	r7, [pc, #92]	; 348162d8 <onenand_print_device_info+0xb0>
34816278:	e59fc05c 	ldr	ip, [pc, #92]	; 348162dc <onenand_print_device_info+0xb4>
3481627c:	e3160003 	tst	r6, #3
34816280:	01a0c007 	moveq	ip, r7
34816284:	e58d1000 	str	r1, [sp]
34816288:	e59f1050 	ldr	r1, [pc, #80]	; 348162e0 <onenand_print_device_info+0xb8>
 * Print device ID
 */
char *onenand_print_device_info(int device, int version)
{
	int vcc, demuxed, ddp, density, flexonenand;
	char *dev_info = malloc(80);
3481628c:	e1a04000 	mov	r4, r0
	vcc = device & ONENAND_DEVICE_VCC_MASK;
	demuxed = device & ONENAND_DEVICE_IS_DEMUX;
	ddp = device & ONENAND_DEVICE_IS_DDP;
	density = onenand_get_density(device);
	flexonenand = device & DEVICE_IS_FLEXONENAND;
	p += sprintf(dev_info, "%s%sOneNAND%s %dMB %sV 16-bit (0x%02x)",
34816290:	e58de004 	str	lr, [sp, #4]
34816294:	e58dc008 	str	ip, [sp, #8]
34816298:	e58d600c 	str	r6, [sp, #12]
3481629c:	eb001aa1 	bl	3481cd28 <sprintf>
	       demuxed ? "" : "Muxed ",
	       flexonenand ? "Flex-" : "",
	       ddp ? "(DDP)" : "",
	       (16 << density), vcc ? "2.65/3.3" : "1.8", device);

	sprintf(p, "\nOneNAND version = 0x%04x", version);
348162a0:	e1a02005 	mov	r2, r5
348162a4:	e0840000 	add	r0, r4, r0
348162a8:	e59f1034 	ldr	r1, [pc, #52]	; 348162e4 <onenand_print_device_info+0xbc>
348162ac:	eb001a9d 	bl	3481cd28 <sprintf>
	printk("%s\n", dev_info);
348162b0:	e1a01004 	mov	r1, r4
348162b4:	e59f002c 	ldr	r0, [pc, #44]	; 348162e8 <onenand_print_device_info+0xc0>
348162b8:	ebffcba9 	bl	34809164 <printf>

	return dev_info;
}
348162bc:	e1a00004 	mov	r0, r4
348162c0:	e28dd014 	add	sp, sp, #20
348162c4:	e8bd80f0 	pop	{r4, r5, r6, r7, pc}
348162c8:	34823cce 	.word	0x34823cce
348162cc:	34827978 	.word	0x34827978
348162d0:	3482747d 	.word	0x3482747d
348162d4:	3482797f 	.word	0x3482797f
348162d8:	3482798e 	.word	0x3482798e
348162dc:	34827985 	.word	0x34827985
348162e0:	34827992 	.word	0x34827992
348162e4:	348279b9 	.word	0x348279b9
348162e8:	34825ea6 	.word	0x34825ea6

348162ec <flexonenand_set_boundary>:
 * flexonenand_set_boundary	- Writes the SLC boundary
 * @param mtd			- mtd info structure
 */
int flexonenand_set_boundary(struct mtd_info *mtd, int die,
				    int boundary, int lock)
{
348162ec:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
348162f0:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 * flexonenand_set_boundary	- Writes the SLC boundary
 * @param mtd			- mtd info structure
 */
int flexonenand_set_boundary(struct mtd_info *mtd, int die,
				    int boundary, int lock)
{
348162f4:	e24dd048 	sub	sp, sp, #72	; 0x48
348162f8:	e58d3024 	str	r3, [sp, #36]	; 0x24
	struct onenand_chip *this = mtd->priv;
	int ret, density, blksperdie, old, new, thisboundary;
	loff_t addr;

	if (die >= this->dies)
348162fc:	e5943004 	ldr	r3, [r4, #4]
 * flexonenand_set_boundary	- Writes the SLC boundary
 * @param mtd			- mtd info structure
 */
int flexonenand_set_boundary(struct mtd_info *mtd, int die,
				    int boundary, int lock)
{
34816300:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
	int ret, density, blksperdie, old, new, thisboundary;
	loff_t addr;

	if (die >= this->dies)
34816304:	e1510003 	cmp	r1, r3
 * flexonenand_set_boundary	- Writes the SLC boundary
 * @param mtd			- mtd info structure
 */
int flexonenand_set_boundary(struct mtd_info *mtd, int die,
				    int boundary, int lock)
{
34816308:	e1a07001 	mov	r7, r1
3481630c:	e1a09002 	mov	r9, r2
	struct onenand_chip *this = mtd->priv;
	int ret, density, blksperdie, old, new, thisboundary;
	loff_t addr;

	if (die >= this->dies)
34816310:	2a0000d9 	bcs	3481667c <flexonenand_set_boundary+0x390>
		return -EINVAL;

	if (boundary == this->boundary[die])
34816314:	e2813002 	add	r3, r1, #2
34816318:	e7943103 	ldr	r3, [r4, r3, lsl #2]
3481631c:	e1520003 	cmp	r2, r3
		return 0;
34816320:	03a0a000 	moveq	sl, #0
	loff_t addr;

	if (die >= this->dies)
		return -EINVAL;

	if (boundary == this->boundary[die])
34816324:	0a0000d5 	beq	34816680 <flexonenand_set_boundary+0x394>
		return 0;

	density = onenand_get_density(this->device_id);
34816328:	e594201c 	ldr	r2, [r4, #28]
	blksperdie = ((16 << density) << 20) >> this->erase_shift;
3481632c:	e3a00401 	mov	r0, #16777216	; 0x1000000
 * Get OneNAND density from device ID
 */
static inline int onenand_get_density(int dev_id)
{
	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34816330:	e7e31252 	ubfx	r1, r2, #4, #4

	if (boundary == this->boundary[die])
		return 0;

	density = onenand_get_density(this->device_id);
	blksperdie = ((16 << density) << 20) >> this->erase_shift;
34816334:	e1a01110 	lsl	r1, r0, r1
34816338:	e5940030 	ldr	r0, [r4, #48]	; 0x30
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;
3481633c:	e7e021d2 	ubfx	r2, r2, #3, #1

	if (boundary == this->boundary[die])
		return 0;

	density = onenand_get_density(this->device_id);
	blksperdie = ((16 << density) << 20) >> this->erase_shift;
34816340:	e1a01051 	asr	r1, r1, r0
	blksperdie >>= ONENAND_IS_DDP(this) ? 1 : 0;

	if (boundary >= blksperdie) {
34816344:	e1590251 	cmp	r9, r1, asr r2
34816348:	ba000002 	blt	34816358 <flexonenand_set_boundary+0x6c>
		printk("flexonenand_set_boundary:"
3481634c:	e59f03c0 	ldr	r0, [pc, #960]	; 34816714 <flexonenand_set_boundary+0x428>
34816350:	ebffcb83 	bl	34809164 <printf>
34816354:	ea0000c8 	b	3481667c <flexonenand_set_boundary+0x390>
			"Boundary not changed.\n");
		return -EINVAL;
	}

	/* Check if converting blocks are erased */
	old = this->boundary[die] + (die * this->density_mask);
34816358:	e5942028 	ldr	r2, [r4, #40]	; 0x28
					int start, int end)
{
	struct onenand_chip *this = mtd->priv;
	int i, ret;
	int block;
	struct mtd_oob_ops ops = {
3481635c:	e28da028 	add	sl, sp, #40	; 0x28
			"Boundary not changed.\n");
		return -EINVAL;
	}

	/* Check if converting blocks are erased */
	old = this->boundary[die] + (die * this->density_mask);
34816360:	e0020792 	mul	r2, r2, r7
34816364:	e0823003 	add	r3, r2, r3
	new = boundary + (die * this->density_mask);
34816368:	e0822009 	add	r2, r2, r9
	ret = flexonenand_check_blocks_erased(mtd, min(old, new)
3481636c:	e1520003 	cmp	r2, r3
34816370:	b1a06002 	movlt	r6, r2
34816374:	a1a06003 	movge	r6, r3
						+ 1, max(old, new));
34816378:	e1520003 	cmp	r2, r3
3481637c:	b1a02003 	movlt	r2, r3
	struct mtd_oob_ops ops = {
		.mode = MTD_OOB_PLACE,
		.ooboffs = 0,
		.ooblen	= mtd->oobsize,
		.datbuf	= NULL,
		.oobbuf	= this->oob_buf,
34816380:	e5943090 	ldr	r3, [r4, #144]	; 0x90

	/* Check if converting blocks are erased */
	old = this->boundary[die] + (die * this->density_mask);
	new = boundary + (die * this->density_mask);
	ret = flexonenand_check_blocks_erased(mtd, min(old, new)
						+ 1, max(old, new));
34816384:	e58d2018 	str	r2, [sp, #24]
					int start, int end)
{
	struct onenand_chip *this = mtd->priv;
	int i, ret;
	int block;
	struct mtd_oob_ops ops = {
34816388:	e3a01000 	mov	r1, #0
3481638c:	e3a02020 	mov	r2, #32
34816390:	e1a0000a 	mov	r0, sl
		.mode = MTD_OOB_PLACE,
		.ooboffs = 0,
		.ooblen	= mtd->oobsize,
34816394:	e595b018 	ldr	fp, [r5, #24]
					int start, int end)
{
	struct onenand_chip *this = mtd->priv;
	int i, ret;
	int block;
	struct mtd_oob_ops ops = {
34816398:	e58d300c 	str	r3, [sp, #12]
	}

	/* Check if converting blocks are erased */
	old = this->boundary[die] + (die * this->density_mask);
	new = boundary + (die * this->density_mask);
	ret = flexonenand_check_blocks_erased(mtd, min(old, new)
3481639c:	e2866001 	add	r6, r6, #1
					int start, int end)
{
	struct onenand_chip *this = mtd->priv;
	int i, ret;
	int block;
	struct mtd_oob_ops ops = {
348163a0:	eb0016c7 	bl	3481bec4 <memset>
348163a4:	e59d300c 	ldr	r3, [sp, #12]
		.datbuf	= NULL,
		.oobbuf	= this->oob_buf,
	};
	loff_t addr;

	printk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);
348163a8:	e59f0368 	ldr	r0, [pc, #872]	; 34816718 <flexonenand_set_boundary+0x42c>
348163ac:	e1a01006 	mov	r1, r6
348163b0:	e59d2018 	ldr	r2, [sp, #24]
					int start, int end)
{
	struct onenand_chip *this = mtd->priv;
	int i, ret;
	int block;
	struct mtd_oob_ops ops = {
348163b4:	e58db034 	str	fp, [sp, #52]	; 0x34
348163b8:	e58d3044 	str	r3, [sp, #68]	; 0x44
348163bc:	e1a0b007 	mov	fp, r7
		.datbuf	= NULL,
		.oobbuf	= this->oob_buf,
	};
	loff_t addr;

	printk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);
348163c0:	ebffcb67 	bl	34809164 <printf>
348163c4:	ea00004f 	b	34816508 <flexonenand_set_boundary+0x21c>
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
348163c8:	e594301c 	ldr	r3, [r4, #28]
348163cc:	e2133008 	ands	r3, r3, #8
348163d0:	01a07006 	moveq	r7, r6
348163d4:	0a00000b 	beq	34816408 <flexonenand_set_boundary+0x11c>
348163d8:	e5947028 	ldr	r7, [r4, #40]	; 0x28
348163dc:	e1560007 	cmp	r6, r7
348163e0:	31a07006 	movcc	r7, r6
 * Return address of the block
 */
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
	int die = 0, boundary;
348163e4:	33a03000 	movcc	r3, #0

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
348163e8:	3a000006 	bcc	34816408 <flexonenand_set_boundary+0x11c>
		block -= this->density_mask;
		die = 1;
		ofs = this->diesize[0];
348163ec:	e5943010 	ldr	r3, [r4, #16]
{
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
		block -= this->density_mask;
348163f0:	e0677006 	rsb	r7, r7, r6
		die = 1;
		ofs = this->diesize[0];
348163f4:	e1a00003 	mov	r0, r3
348163f8:	e3a01000 	mov	r1, #0
348163fc:	e1cd01f0 	strd	r0, [sp, #16]
	loff_t ofs = 0;
	int die = 0, boundary;

	if (ONENAND_IS_DDP(this) && block >= this->density_mask) {
		block -= this->density_mask;
		die = 1;
34816400:	e3a03001 	mov	r3, #1
34816404:	ea000002 	b	34816414 <flexonenand_set_boundary+0x128>
 *
 * Return address of the block
 */
static loff_t flexonenand_addr(struct onenand_chip *this, int block)
{
	loff_t ofs = 0;
34816408:	e3a00000 	mov	r0, #0
3481640c:	e3a01000 	mov	r1, #0
34816410:	e1cd01f0 	strd	r0, [sp, #16]
		block -= this->density_mask;
		die = 1;
		ofs = this->diesize[0];
	}

	boundary = this->boundary[die];
34816414:	e2833002 	add	r3, r3, #2
34816418:	e794a103 	ldr	sl, [r4, r3, lsl #2]
	ofs += (loff_t) block << (this->erase_shift - 1);
3481641c:	e5943030 	ldr	r3, [r4, #48]	; 0x30
34816420:	e1a00007 	mov	r0, r7
34816424:	e1a01fc0 	asr	r1, r0, #31
34816428:	e243c001 	sub	ip, r3, #1
3481642c:	e1a0200c 	mov	r2, ip
34816430:	e58dc00c 	str	ip, [sp, #12]
34816434:	eb0026fa 	bl	34820024 <__ashldi3>
34816438:	e1cd21d0 	ldrd	r2, [sp, #16]
3481643c:	e0922000 	adds	r2, r2, r0
34816440:	e0a33001 	adc	r3, r3, r1
34816444:	e1cd21f0 	strd	r2, [sp, #16]
	if (block > (boundary + 1))
34816448:	e28a2001 	add	r2, sl, #1
3481644c:	e1570002 	cmp	r7, r2
34816450:	e59dc00c 	ldr	ip, [sp, #12]
34816454:	da000009 	ble	34816480 <flexonenand_set_boundary+0x194>
		ofs += (loff_t) (block - boundary - 1)
34816458:	e2477001 	sub	r7, r7, #1
3481645c:	e06aa007 	rsb	sl, sl, r7
			<< (this->erase_shift - 1);
34816460:	e1a0200c 	mov	r2, ip
34816464:	e1a0000a 	mov	r0, sl
34816468:	e1a01fc0 	asr	r1, r0, #31
3481646c:	eb0026ec 	bl	34820024 <__ashldi3>
	}

	boundary = this->boundary[die];
	ofs += (loff_t) block << (this->erase_shift - 1);
	if (block > (boundary + 1))
		ofs += (loff_t) (block - boundary - 1)
34816470:	e1cd21d0 	ldrd	r2, [sp, #16]
34816474:	e0922000 	adds	r2, r2, r0
34816478:	e0a33001 	adc	r3, r3, r1
3481647c:	e1cd21f0 	strd	r2, [sp, #16]
 * calling of the scan function.
 */
static int onenand_block_isbad_nolock(struct mtd_info *mtd, loff_t ofs, int allowbbt)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
34816480:	e5953094 	ldr	r3, [r5, #148]	; 0x94

	/* Return info from the table */
	return bbm->isbad_bbt(mtd, ofs, allowbbt);
34816484:	e3a0e000 	mov	lr, #0
34816488:	e59330a0 	ldr	r3, [r3, #160]	; 0xa0
3481648c:	e58de000 	str	lr, [sp]
34816490:	e5931010 	ldr	r1, [r3, #16]
34816494:	e1a00005 	mov	r0, r5
34816498:	e1cd21d0 	ldrd	r2, [sp, #16]
3481649c:	e12fff31 	blx	r1

	printk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);

	for (block = start; block <= end; block++) {
		addr = flexonenand_addr(this, block);
		if (onenand_block_isbad_nolock(mtd, addr, 0))
348164a0:	e3500000 	cmp	r0, #0
348164a4:	1a000016 	bne	34816504 <flexonenand_set_boundary+0x218>

		/*
		 * Since main area write results in ECC write to spare,
		 * it is sufficient to check only ECC bytes for change.
		 */
		ret = onenand_read_oob_nolock(mtd, addr, &ops);
348164a8:	e28d0028 	add	r0, sp, #40	; 0x28
348164ac:	e58d0000 	str	r0, [sp]
348164b0:	e1cd21d0 	ldrd	r2, [sp, #16]
348164b4:	e1a00005 	mov	r0, r5
348164b8:	ebfffc26 	bl	34815558 <onenand_read_oob_nolock>
		if (ret)
348164bc:	e250a000 	subs	sl, r0, #0
348164c0:	1a000014 	bne	34816518 <flexonenand_set_boundary+0x22c>
			return ret;

		for (i = 0; i < mtd->oobsize; i++)
348164c4:	e5952018 	ldr	r2, [r5, #24]
348164c8:	e3a03000 	mov	r3, #0
348164cc:	ea000004 	b	348164e4 <flexonenand_set_boundary+0x1f8>
			if (this->oob_buf[i] != 0xff)
348164d0:	e5941090 	ldr	r1, [r4, #144]	; 0x90
348164d4:	e7d11003 	ldrb	r1, [r1, r3]
348164d8:	e35100ff 	cmp	r1, #255	; 0xff
348164dc:	1a000003 	bne	348164f0 <flexonenand_set_boundary+0x204>
		 */
		ret = onenand_read_oob_nolock(mtd, addr, &ops);
		if (ret)
			return ret;

		for (i = 0; i < mtd->oobsize; i++)
348164e0:	e2833001 	add	r3, r3, #1
348164e4:	e1530002 	cmp	r3, r2
348164e8:	3afffff8 	bcc	348164d0 <flexonenand_set_boundary+0x1e4>
			if (this->oob_buf[i] != 0xff)
				break;

		if (i != mtd->oobsize) {
348164ec:	0a000004 	beq	34816504 <flexonenand_set_boundary+0x218>
			printk(KERN_WARNING "Block %d not erased.\n", block);
348164f0:	e59f0224 	ldr	r0, [pc, #548]	; 3481671c <flexonenand_set_boundary+0x430>
348164f4:	e1a01006 	mov	r1, r6
348164f8:	ebffcb19 	bl	34809164 <printf>
			return 1;
348164fc:	e3a0a001 	mov	sl, #1
34816500:	ea000004 	b	34816518 <flexonenand_set_boundary+0x22c>
	};
	loff_t addr;

	printk(KERN_DEBUG "Check blocks from %d to %d\n", start, end);

	for (block = start; block <= end; block++) {
34816504:	e2866001 	add	r6, r6, #1
34816508:	e59d1018 	ldr	r1, [sp, #24]
3481650c:	e1560001 	cmp	r6, r1
34816510:	daffffac 	ble	348163c8 <flexonenand_set_boundary+0xdc>
34816514:	ea00005c 	b	3481668c <flexonenand_set_boundary+0x3a0>
	old = this->boundary[die] + (die * this->density_mask);
	new = boundary + (die * this->density_mask);
	ret = flexonenand_check_blocks_erased(mtd, min(old, new)
						+ 1, max(old, new));
	if (ret) {
		printk(KERN_ERR "flexonenand_set_boundary: Please erase blocks before boundary change\n");
34816518:	e59f0200 	ldr	r0, [pc, #512]	; 34816720 <flexonenand_set_boundary+0x434>
3481651c:	ebffcb10 	bl	34809164 <printf>
		return ret;
34816520:	ea000056 	b	34816680 <flexonenand_set_boundary+0x394>
	this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
	ret = this->wait(mtd, FL_READING);

	thisboundary = this->read_word(this->base + ONENAND_DATARAM);
	if ((thisboundary >> FLEXONENAND_PI_UNLOCK_SHIFT) != 3) {
		printk(KERN_ERR "flexonenand_set_boundary: boundary locked\n");
34816524:	e59f01f8 	ldr	r0, [pc, #504]	; 34816724 <flexonenand_set_boundary+0x438>
34816528:	ebffcb0d 	bl	34809164 <printf>
		goto out;
3481652c:	ea000043 	b	34816640 <flexonenand_set_boundary+0x354>
	}

	printk(KERN_INFO "flexonenand_set_boundary: Changing die %d boundary: %d%s\n",
34816530:	e59de024 	ldr	lr, [sp, #36]	; 0x24
34816534:	e59fc1ec 	ldr	ip, [pc, #492]	; 34816728 <flexonenand_set_boundary+0x43c>
34816538:	e35e0000 	cmp	lr, #0
3481653c:	e59f31e8 	ldr	r3, [pc, #488]	; 3481672c <flexonenand_set_boundary+0x440>
34816540:	e59f01e8 	ldr	r0, [pc, #488]	; 34816730 <flexonenand_set_boundary+0x444>
34816544:	01a0300c 	moveq	r3, ip
34816548:	e1a01007 	mov	r1, r7
3481654c:	e1a02009 	mov	r2, r9
34816550:	ebffcb03 	bl	34809164 <printf>
			die, boundary, lock ? "(Locked)" : "(Unlocked)");

	boundary &= FLEXONENAND_PI_MASK;
	boundary |= lock ? 0 : (3 << FLEXONENAND_PI_UNLOCK_SHIFT);
34816554:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
34816558:	e3500000 	cmp	r0, #0
3481655c:	03a06903 	moveq	r6, #49152	; 0xc000
34816560:	13a06000 	movne	r6, #0

	addr = die ? this->diesize[0] : 0;
34816564:	e3570000 	cmp	r7, #0
34816568:	15943010 	ldrne	r3, [r4, #16]
3481656c:	11a00003 	movne	r0, r3
34816570:	13a01000 	movne	r1, #0
34816574:	11cd01f0 	strdne	r0, [sp, #16]
34816578:	03a02000 	moveq	r2, #0
3481657c:	03a03000 	moveq	r3, #0
34816580:	01cd21f0 	strdeq	r2, [sp, #16]
	this->command(mtd, ONENAND_CMD_ERASE, addr, 0);
34816584:	e3a03000 	mov	r3, #0
34816588:	e58d3000 	str	r3, [sp]
3481658c:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34816590:	e1cd21d0 	ldrd	r2, [sp, #16]
34816594:	e3a01094 	mov	r1, #148	; 0x94
34816598:	e1a00005 	mov	r0, r5
3481659c:	e12fff3c 	blx	ip
	ret = this->wait(mtd, FL_ERASING);
348165a0:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348165a4:	e1a00005 	mov	r0, r5
348165a8:	e3a01003 	mov	r1, #3
348165ac:	e12fff33 	blx	r3
	if (ret) {
348165b0:	e250a000 	subs	sl, r0, #0
		printk("flexonenand_set_boundary:"
348165b4:	159f0178 	ldrne	r0, [pc, #376]	; 34816734 <flexonenand_set_boundary+0x448>
	boundary |= lock ? 0 : (3 << FLEXONENAND_PI_UNLOCK_SHIFT);

	addr = die ? this->diesize[0] : 0;
	this->command(mtd, ONENAND_CMD_ERASE, addr, 0);
	ret = this->wait(mtd, FL_ERASING);
	if (ret) {
348165b8:	1a000012 	bne	34816608 <flexonenand_set_boundary+0x31c>
		printk("flexonenand_set_boundary:"
			"Failed PI erase for Die %d\n", die);
		goto out;
	}

	this->write_word(boundary, this->base + ONENAND_DATARAM);
348165bc:	e5941000 	ldr	r1, [r4]
	}

	printk(KERN_INFO "flexonenand_set_boundary: Changing die %d boundary: %d%s\n",
			die, boundary, lock ? "(Locked)" : "(Unlocked)");

	boundary &= FLEXONENAND_PI_MASK;
348165c0:	e1a00b09 	lsl	r0, r9, #22
		printk("flexonenand_set_boundary:"
			"Failed PI erase for Die %d\n", die);
		goto out;
	}

	this->write_word(boundary, this->base + ONENAND_DATARAM);
348165c4:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
348165c8:	e1860b20 	orr	r0, r6, r0, lsr #22
348165cc:	e2811b01 	add	r1, r1, #1024	; 0x400
348165d0:	e12fff33 	blx	r3
	this->command(mtd, ONENAND_CMD_PROG, addr, 0);
348165d4:	e1cd21d0 	ldrd	r2, [sp, #16]
348165d8:	e58da000 	str	sl, [sp]
348165dc:	e594c050 	ldr	ip, [r4, #80]	; 0x50
348165e0:	e3a01080 	mov	r1, #128	; 0x80
348165e4:	e1a00005 	mov	r0, r5
348165e8:	e12fff3c 	blx	ip
	ret = this->wait(mtd, FL_WRITING);
348165ec:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348165f0:	e1a00005 	mov	r0, r5
348165f4:	e3a01002 	mov	r1, #2
348165f8:	e12fff33 	blx	r3
	if (ret) {
348165fc:	e250a000 	subs	sl, r0, #0
34816600:	0a000003 	beq	34816614 <flexonenand_set_boundary+0x328>
		printk("flexonenand_set_boundary:"
34816604:	e59f012c 	ldr	r0, [pc, #300]	; 34816738 <flexonenand_set_boundary+0x44c>
34816608:	e1a01007 	mov	r1, r7
3481660c:	ebffcad4 	bl	34809164 <printf>
			"Failed PI write for Die %d\n", die);
		goto out;
34816610:	ea00000a 	b	34816640 <flexonenand_set_boundary+0x354>
	}

	this->command(mtd, FLEXONENAND_CMD_PI_UPDATE, die, 0);
34816614:	e58da000 	str	sl, [sp]
34816618:	e1cd21d8 	ldrd	r2, [sp, #24]
3481661c:	e594c050 	ldr	ip, [r4, #80]	; 0x50
34816620:	e3a01005 	mov	r1, #5
34816624:	e1a00005 	mov	r0, r5
34816628:	e12fff3c 	blx	ip
	ret = this->wait(mtd, FL_WRITING);
3481662c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816630:	e1a00005 	mov	r0, r5
34816634:	e3a01002 	mov	r1, #2
34816638:	e12fff33 	blx	r3
3481663c:	e1a0a000 	mov	sl, r0
out:
	this->write_word(ONENAND_CMD_RESET, this->base + ONENAND_REG_COMMAND);
34816640:	e5941000 	ldr	r1, [r4]
34816644:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34816648:	e2811b79 	add	r1, r1, #123904	; 0x1e400
3481664c:	e3a000f0 	mov	r0, #240	; 0xf0
34816650:	e2811040 	add	r1, r1, #64	; 0x40
34816654:	e12fff33 	blx	r3
	this->wait(mtd, FL_RESETING);
34816658:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481665c:	e1a00005 	mov	r0, r5
34816660:	e3a01006 	mov	r1, #6
34816664:	e12fff33 	blx	r3
	if (!ret)
34816668:	e35a0000 	cmp	sl, #0
3481666c:	1a000003 	bne	34816680 <flexonenand_set_boundary+0x394>
		/* Recalculate device size on boundary change*/
		flexonenand_get_size(mtd);
34816670:	e1a00005 	mov	r0, r5
34816674:	ebfff6a0 	bl	348140fc <flexonenand_get_size>
34816678:	ea000000 	b	34816680 <flexonenand_set_boundary+0x394>
	struct onenand_chip *this = mtd->priv;
	int ret, density, blksperdie, old, new, thisboundary;
	loff_t addr;

	if (die >= this->dies)
		return -EINVAL;
3481667c:	e3e0a015 	mvn	sl, #21
	if (!ret)
		/* Recalculate device size on boundary change*/
		flexonenand_get_size(mtd);

	return ret;
}
34816680:	e1a0000a 	mov	r0, sl
34816684:	e28dd048 	add	sp, sp, #72	; 0x48
34816688:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	if (ret) {
		printk(KERN_ERR "flexonenand_set_boundary: Please erase blocks before boundary change\n");
		return ret;
	}

	this->command(mtd, FLEXONENAND_CMD_PI_ACCESS, die, 0);
3481668c:	e1a0000b 	mov	r0, fp
34816690:	e1a01fc0 	asr	r1, r0, #31
34816694:	e3a06000 	mov	r6, #0
34816698:	e1cd01f8 	strd	r0, [sp, #24]
3481669c:	e1cd21d8 	ldrd	r2, [sp, #24]
348166a0:	e58d6000 	str	r6, [sp]
348166a4:	e594c050 	ldr	ip, [r4, #80]	; 0x50
348166a8:	e3a01066 	mov	r1, #102	; 0x66
348166ac:	e1a00005 	mov	r0, r5
348166b0:	e12fff3c 	blx	ip
	this->wait(mtd, FL_SYNCING);
348166b4:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348166b8:	e3a01004 	mov	r1, #4
348166bc:	e1a00005 	mov	r0, r5
348166c0:	e12fff33 	blx	r3

	/* Check is boundary is locked */
	this->command(mtd, FLEXONENAND_CMD_READ_PI, die, 0);
348166c4:	e1cd21d8 	ldrd	r2, [sp, #24]
348166c8:	e58d6000 	str	r6, [sp]
348166cc:	e594c050 	ldr	ip, [r4, #80]	; 0x50
348166d0:	e3011985 	movw	r1, #6533	; 0x1985
348166d4:	e1a00005 	mov	r0, r5
348166d8:	e12fff3c 	blx	ip
	ret = this->wait(mtd, FL_READING);
348166dc:	e5943054 	ldr	r3, [r4, #84]	; 0x54
348166e0:	e3a01001 	mov	r1, #1
348166e4:	e1a00005 	mov	r0, r5
348166e8:	e12fff33 	blx	r3
348166ec:	e1a0a000 	mov	sl, r0

	thisboundary = this->read_word(this->base + ONENAND_DATARAM);
348166f0:	e5940000 	ldr	r0, [r4]
348166f4:	e5943068 	ldr	r3, [r4, #104]	; 0x68
348166f8:	e2800b01 	add	r0, r0, #1024	; 0x400
348166fc:	e12fff33 	blx	r3
	if ((thisboundary >> FLEXONENAND_PI_UNLOCK_SHIFT) != 3) {
34816700:	e1a00740 	asr	r0, r0, #14
34816704:	e3500003 	cmp	r0, #3
34816708:	e1a0700b 	mov	r7, fp
3481670c:	1affff84 	bne	34816524 <flexonenand_set_boundary+0x238>
34816710:	eaffff86 	b	34816530 <flexonenand_set_boundary+0x244>
34816714:	348279d3 	.word	0x348279d3
34816718:	34827a1b 	.word	0x34827a1b
3481671c:	34827a37 	.word	0x34827a37
34816720:	34827a4d 	.word	0x34827a4d
34816724:	34827a93 	.word	0x34827a93
34816728:	34827496 	.word	0x34827496
3481672c:	3482748d 	.word	0x3482748d
34816730:	34827abe 	.word	0x34827abe
34816734:	34827af8 	.word	0x34827af8
34816738:	34827b2d 	.word	0x34827b2d

3481673c <onenand_probe>:
 *
 * OneNAND detection method:
 *   Compare the the values from command with ones from register
 */
int onenand_probe(struct mtd_info *mtd)
{
3481673c:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34816740:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 *
 * OneNAND detection method:
 *   Compare the the values from command with ones from register
 */
int onenand_probe(struct mtd_info *mtd)
{
34816744:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
	int dev_id, ver_id;
	int density;
	int ret;

	ret = this->chip_probe(mtd);
34816748:	e5943070 	ldr	r3, [r4, #112]	; 0x70
3481674c:	e12fff33 	blx	r3
	if (ret)
34816750:	e250a000 	subs	sl, r0, #0
34816754:	1a0000b6 	bne	34816a34 <onenand_probe+0x2f8>
		return ret;

	/* Read device IDs from Register */
	dev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);
34816758:	e5940000 	ldr	r0, [r4]
3481675c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34816760:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
34816764:	e2800002 	add	r0, r0, #2
34816768:	e12fff33 	blx	r3
3481676c:	e1a06000 	mov	r6, r0
	ver_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
34816770:	e5940000 	ldr	r0, [r4]
34816774:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34816778:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
3481677c:	e2800004 	add	r0, r0, #4
34816780:	e12fff33 	blx	r3
34816784:	e1a07000 	mov	r7, r0
	this->technology = this->read_word(this->base + ONENAND_REG_TECHNOLOGY);
34816788:	e5940000 	ldr	r0, [r4]
3481678c:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34816790:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
34816794:	e280000c 	add	r0, r0, #12
34816798:	e12fff33 	blx	r3

	/* Flash device information */
	mtd->name = onenand_print_device_info(dev_id, ver_id);
3481679c:	e1a01007 	mov	r1, r7
		return ret;

	/* Read device IDs from Register */
	dev_id = this->read_word(this->base + ONENAND_REG_DEVICE_ID);
	ver_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
	this->technology = this->read_word(this->base + ONENAND_REG_TECHNOLOGY);
348167a0:	e5840024 	str	r0, [r4, #36]	; 0x24

	/* Flash device information */
	mtd->name = onenand_print_device_info(dev_id, ver_id);
348167a4:	e1a00006 	mov	r0, r6
348167a8:	ebfffe9e 	bl	34816228 <onenand_print_device_info>
348167ac:	e5850020 	str	r0, [r5, #32]
	this->device_id = dev_id;
	this->version_id = ver_id;
348167b0:	e5847020 	str	r7, [r4, #32]
 * - lock scheme
 * - two plane
 */
static void onenand_check_features(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
348167b4:	e5957094 	ldr	r7, [r5, #148]	; 0x94
	ver_id = this->read_word(this->base + ONENAND_REG_VERSION_ID);
	this->technology = this->read_word(this->base + ONENAND_REG_TECHNOLOGY);

	/* Flash device information */
	mtd->name = onenand_print_device_info(dev_id, ver_id);
	this->device_id = dev_id;
348167b8:	e584601c 	str	r6, [r4, #28]
{
	struct onenand_chip *this = mtd->priv;
	unsigned int density, process;

	/* Lock scheme depends on density and process */
	density = onenand_get_density(this->device_id);
348167bc:	e597301c 	ldr	r3, [r7, #28]
	process = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;
348167c0:	e5971020 	ldr	r1, [r7, #32]
 * Get OneNAND density from device ID
 */
static inline int onenand_get_density(int dev_id)
{
	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
	return (density & ONENAND_DEVICE_DENSITY_MASK);
348167c4:	e7e32253 	ubfx	r2, r3, #4, #4
	/* Lock scheme depends on density and process */
	density = onenand_get_density(this->device_id);
	process = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;

	/* Lock scheme */
	switch (density) {
348167c8:	e3520004 	cmp	r2, #4
	struct onenand_chip *this = mtd->priv;
	unsigned int density, process;

	/* Lock scheme depends on density and process */
	density = onenand_get_density(this->device_id);
	process = this->version_id >> ONENAND_VERSION_PROCESS_SHIFT;
348167cc:	e1a01421 	lsr	r1, r1, #8

	/* Lock scheme */
	switch (density) {
348167d0:	0a000009 	beq	348167fc <onenand_probe+0xc0>
348167d4:	e3520005 	cmp	r2, #5
348167d8:	0a000002 	beq	348167e8 <onenand_probe+0xac>
348167dc:	e3520003 	cmp	r2, #3
348167e0:	1a000011 	bne	3481682c <onenand_probe+0xf0>
348167e4:	ea00000b 	b	34816818 <onenand_probe+0xdc>
348167e8:	e597202c 	ldr	r2, [r7, #44]	; 0x2c
	case ONENAND_DEVICE_DENSITY_4Gb:
		if (ONENAND_IS_DDP(this))
348167ec:	e3130008 	tst	r3, #8
			this->options |= ONENAND_HAS_2PLANE;
348167f0:	13822004 	orrne	r2, r2, #4
		else
			this->options |= ONENAND_HAS_4KB_PAGE;
348167f4:	03822008 	orreq	r2, r2, #8
348167f8:	e587202c 	str	r2, [r7, #44]	; 0x2c

	case ONENAND_DEVICE_DENSITY_2Gb:
		/* 2Gb DDP don't have 2 plane */
		if (!ONENAND_IS_DDP(this))
348167fc:	e3130008 	tst	r3, #8
			this->options |= ONENAND_HAS_2PLANE;
34816800:	0597302c 	ldreq	r3, [r7, #44]	; 0x2c
34816804:	03833004 	orreq	r3, r3, #4
34816808:	0587302c 	streq	r3, [r7, #44]	; 0x2c
		this->options |= ONENAND_HAS_UNLOCK_ALL;
3481680c:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34816810:	e3833002 	orr	r3, r3, #2
34816814:	e587302c 	str	r3, [r7, #44]	; 0x2c

	case ONENAND_DEVICE_DENSITY_1Gb:
		/* A-Die has all block unlock */
		if (process)
34816818:	e3510000 	cmp	r1, #0
			this->options |= ONENAND_HAS_UNLOCK_ALL;
3481681c:	1597302c 	ldrne	r3, [r7, #44]	; 0x2c
34816820:	13833002 	orrne	r3, r3, #2
			this->options |= ONENAND_HAS_2PLANE;
		this->options |= ONENAND_HAS_UNLOCK_ALL;

	case ONENAND_DEVICE_DENSITY_1Gb:
		/* A-Die has all block unlock */
		if (process)
34816824:	1a000004 	bne	3481683c <onenand_probe+0x100>
34816828:	ea000004 	b	34816840 <onenand_probe+0x104>
			this->options |= ONENAND_HAS_UNLOCK_ALL;
		break;

	default:
		/* Some OneNAND has continuous lock scheme */
		if (!process)
3481682c:	e3510000 	cmp	r1, #0
34816830:	1a000002 	bne	34816840 <onenand_probe+0x104>
			this->options |= ONENAND_HAS_CONT_LOCK;
34816834:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34816838:	e3833001 	orr	r3, r3, #1
3481683c:	e587302c 	str	r3, [r7, #44]	; 0x2c
		break;
	}

	if (ONENAND_IS_MLC(this))
34816840:	e5973024 	ldr	r3, [r7, #36]	; 0x24
34816844:	e3130001 	tst	r3, #1
		this->options |= ONENAND_HAS_4KB_PAGE;
34816848:	1597302c 	ldrne	r3, [r7, #44]	; 0x2c
3481684c:	13833008 	orrne	r3, r3, #8
34816850:	1587302c 	strne	r3, [r7, #44]	; 0x2c

	if (ONENAND_IS_4KB_PAGE(this))
34816854:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34816858:	e3130008 	tst	r3, #8
		this->options &= ~ONENAND_HAS_2PLANE;
3481685c:	13c33004 	bicne	r3, r3, #4
34816860:	1587302c 	strne	r3, [r7, #44]	; 0x2c

	if (FLEXONENAND(this)) {
34816864:	e597301c 	ldr	r3, [r7, #28]
34816868:	e3130c02 	tst	r3, #512	; 0x200
		this->options &= ~ONENAND_HAS_CONT_LOCK;
3481686c:	1597302c 	ldrne	r3, [r7, #44]	; 0x2c
34816870:	13c33001 	bicne	r3, r3, #1
		this->options |= ONENAND_HAS_UNLOCK_ALL;
34816874:	13833002 	orrne	r3, r3, #2
34816878:	1587302c 	strne	r3, [r7, #44]	; 0x2c
	}

	if (this->options & ONENAND_HAS_CONT_LOCK)
3481687c:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34816880:	e3130001 	tst	r3, #1
34816884:	0a000001 	beq	34816890 <onenand_probe+0x154>
		printk(KERN_DEBUG "Lock scheme is Continuous Lock\n");
34816888:	e59f01ac 	ldr	r0, [pc, #428]	; 34816a3c <onenand_probe+0x300>
3481688c:	ebffca34 	bl	34809164 <printf>
	if (this->options & ONENAND_HAS_UNLOCK_ALL)
34816890:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
34816894:	e3130002 	tst	r3, #2
34816898:	0a000001 	beq	348168a4 <onenand_probe+0x168>
		printk(KERN_DEBUG "Chip support all block unlock\n");
3481689c:	e59f019c 	ldr	r0, [pc, #412]	; 34816a40 <onenand_probe+0x304>
348168a0:	ebffca2f 	bl	34809164 <printf>
	if (this->options & ONENAND_HAS_2PLANE)
348168a4:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
348168a8:	e3130004 	tst	r3, #4
348168ac:	0a000001 	beq	348168b8 <onenand_probe+0x17c>
		printk(KERN_DEBUG "Chip has 2 plane\n");
348168b0:	e59f018c 	ldr	r0, [pc, #396]	; 34816a44 <onenand_probe+0x308>
348168b4:	ebffca2a 	bl	34809164 <printf>
	if (this->options & ONENAND_HAS_4KB_PAGE)
348168b8:	e597302c 	ldr	r3, [r7, #44]	; 0x2c
348168bc:	e3130008 	tst	r3, #8
348168c0:	0a000001 	beq	348168cc <onenand_probe+0x190>
		printk(KERN_DEBUG "Chip has 4KiB pagesize\n");
348168c4:	e59f017c 	ldr	r0, [pc, #380]	; 34816a48 <onenand_probe+0x30c>
348168c8:	ebffca25 	bl	34809164 <printf>

	/* Check OneNAND features */
	onenand_check_features(mtd);

	density = onenand_get_density(dev_id);
	if (FLEXONENAND(this)) {
348168cc:	e594301c 	ldr	r3, [r4, #28]
348168d0:	e3130c02 	tst	r3, #512	; 0x200
348168d4:	0a00000c 	beq	3481690c <onenand_probe+0x1d0>
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
348168d8:	e3130008 	tst	r3, #8
348168dc:	03a03001 	moveq	r3, #1
348168e0:	13a03002 	movne	r3, #2
		/* Maximum possible erase regions */
		mtd->numeraseregions = this->dies << 1;
348168e4:	e1a02083 	lsl	r2, r3, #1
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
348168e8:	e3a00030 	mov	r0, #48	; 0x30
	/* Check OneNAND features */
	onenand_check_features(mtd);

	density = onenand_get_density(dev_id);
	if (FLEXONENAND(this)) {
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
348168ec:	e5843004 	str	r3, [r4, #4]
		/* Maximum possible erase regions */
		mtd->numeraseregions = this->dies << 1;
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
348168f0:	e0000390 	mul	r0, r0, r3

	density = onenand_get_density(dev_id);
	if (FLEXONENAND(this)) {
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
		/* Maximum possible erase regions */
		mtd->numeraseregions = this->dies << 1;
348168f4:	e585202c 	str	r2, [r5, #44]	; 0x2c
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
348168f8:	ebffcbe0 	bl	34809880 <malloc>
					* (this->dies << 1));
		if (!mtd->eraseregions)
348168fc:	e3500000 	cmp	r0, #0
	density = onenand_get_density(dev_id);
	if (FLEXONENAND(this)) {
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
		/* Maximum possible erase regions */
		mtd->numeraseregions = this->dies << 1;
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
34816900:	e5850030 	str	r0, [r5, #48]	; 0x30
					* (this->dies << 1));
		if (!mtd->eraseregions)
			return -ENOMEM;
34816904:	03e0a00b 	mvneq	sl, #11
		this->dies = ONENAND_IS_DDP(this) ? 2 : 1;
		/* Maximum possible erase regions */
		mtd->numeraseregions = this->dies << 1;
		mtd->eraseregions = malloc(sizeof(struct mtd_erase_region_info)
					* (this->dies << 1));
		if (!mtd->eraseregions)
34816908:	0a000049 	beq	34816a34 <onenand_probe+0x2f8>

	/*
	 * For Flex-OneNAND, chipsize represents maximum possible device size.
	 * mtd->size represents the actual device size.
	 */
	this->chipsize = (16 << density) << 20;
3481690c:	e3a03401 	mov	r3, #16777216	; 0x1000000
 * Get OneNAND density from device ID
 */
static inline int onenand_get_density(int dev_id)
{
	int density = dev_id >> ONENAND_DEVICE_DENSITY_SHIFT;
	return (density & ONENAND_DEVICE_DENSITY_MASK);
34816910:	e7e36256 	ubfx	r6, r6, #4, #4

	/*
	 * For Flex-OneNAND, chipsize represents maximum possible device size.
	 * mtd->size represents the actual device size.
	 */
	this->chipsize = (16 << density) << 20;
34816914:	e1a06613 	lsl	r6, r3, r6

	/* OneNAND page size & block size */
	/* The data buffer size is equal to page size */
	mtd->writesize =
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
34816918:	e5940000 	ldr	r0, [r4]

	/*
	 * For Flex-OneNAND, chipsize represents maximum possible device size.
	 * mtd->size represents the actual device size.
	 */
	this->chipsize = (16 << density) << 20;
3481691c:	e5846018 	str	r6, [r4, #24]

	/* OneNAND page size & block size */
	/* The data buffer size is equal to page size */
	mtd->writesize =
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
34816920:	e2800a1e 	add	r0, r0, #122880	; 0x1e000
34816924:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34816928:	e2800006 	add	r0, r0, #6
3481692c:	e12fff33 	blx	r3
	/* We use the full BufferRAM */
	if (ONENAND_IS_4KB_PAGE(this))
34816930:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
	 */
	this->chipsize = (16 << density) << 20;

	/* OneNAND page size & block size */
	/* The data buffer size is equal to page size */
	mtd->writesize =
34816934:	e5850014 	str	r0, [r5, #20]
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
	/* We use the full BufferRAM */
	if (ONENAND_IS_4KB_PAGE(this))
34816938:	e3130008 	tst	r3, #8
		mtd->writesize <<= 1;
3481693c:	11a00080 	lslne	r0, r0, #1
34816940:	15850014 	strne	r0, [r5, #20]

	mtd->oobsize = mtd->writesize >> 5;
34816944:	e5956014 	ldr	r6, [r5, #20]
	/*
	 * Flex-OneNAND SLC area has 64 pages per block.
	 * Flex-OneNAND MLC area has 128 pages per block.
	 * Expose MLC erase size to find erase_shift and page_mask.
	 */
	if (FLEXONENAND(this))
34816948:	e594701c 	ldr	r7, [r4, #28]
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
	/* We use the full BufferRAM */
	if (ONENAND_IS_4KB_PAGE(this))
		mtd->writesize <<= 1;

	mtd->oobsize = mtd->writesize >> 5;
3481694c:	e1a032a6 	lsr	r3, r6, #5
	/*
	 * Flex-OneNAND SLC area has 64 pages per block.
	 * Flex-OneNAND MLC area has 128 pages per block.
	 * Expose MLC erase size to find erase_shift and page_mask.
	 */
	if (FLEXONENAND(this))
34816950:	e2179c02 	ands	r9, r7, #512	; 0x200
	    this->read_word(this->base + ONENAND_REG_DATA_BUFFER_SIZE);
	/* We use the full BufferRAM */
	if (ONENAND_IS_4KB_PAGE(this))
		mtd->writesize <<= 1;

	mtd->oobsize = mtd->writesize >> 5;
34816954:	e5853018 	str	r3, [r5, #24]
	/* Pagers per block is always 64 in OneNAND */
	mtd->erasesize = mtd->writesize << 6;
34816958:	e1a03306 	lsl	r3, r6, #6
3481695c:	e5853010 	str	r3, [r5, #16]
	 * Flex-OneNAND SLC area has 64 pages per block.
	 * Flex-OneNAND MLC area has 128 pages per block.
	 * Expose MLC erase size to find erase_shift and page_mask.
	 */
	if (FLEXONENAND(this))
		mtd->erasesize <<= 1;
34816960:	11a03386 	lslne	r3, r6, #7
34816964:	15853010 	strne	r3, [r5, #16]

	this->erase_shift = ffs(mtd->erasesize) - 1;
34816968:	e5953010 	ldr	r3, [r5, #16]
3481696c:	e1a00003 	mov	r0, r3
34816970:	e58d3000 	str	r3, [sp]
34816974:	ebfff50a 	bl	34813da4 <generic_ffs>
34816978:	e2402001 	sub	r2, r0, #1
3481697c:	e1a0b000 	mov	fp, r0
34816980:	e5842030 	str	r2, [r4, #48]	; 0x30
	this->page_shift = ffs(mtd->writesize) - 1;
34816984:	e1a00006 	mov	r0, r6
34816988:	e58d2004 	str	r2, [sp, #4]
3481698c:	ebfff504 	bl	34813da4 <generic_ffs>
	this->ppb_shift = (this->erase_shift - this->page_shift);
34816990:	e59d2004 	ldr	r2, [sp, #4]
	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
34816994:	e59d3000 	ldr	r3, [sp]
	 */
	if (FLEXONENAND(this))
		mtd->erasesize <<= 1;

	this->erase_shift = ffs(mtd->erasesize) - 1;
	this->page_shift = ffs(mtd->writesize) - 1;
34816998:	e2400001 	sub	r0, r0, #1
	this->ppb_shift = (this->erase_shift - this->page_shift);
3481699c:	e0602002 	rsb	r2, r0, r2
	 */
	if (FLEXONENAND(this))
		mtd->erasesize <<= 1;

	this->erase_shift = ffs(mtd->erasesize) - 1;
	this->page_shift = ffs(mtd->writesize) - 1;
348169a0:	e5840034 	str	r0, [r4, #52]	; 0x34
	this->ppb_shift = (this->erase_shift - this->page_shift);
348169a4:	e5842038 	str	r2, [r4, #56]	; 0x38
	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
348169a8:	e1a00003 	mov	r0, r3
348169ac:	e1a01006 	mov	r1, r6
348169b0:	eb00247a 	bl	3481fba0 <__udivsi3>
	/* Set density mask. it is used for DDP */
	if (ONENAND_IS_DDP(this))
348169b4:	e3170008 	tst	r7, #8
		this->density_mask = this->chipsize >> (this->erase_shift + 1);
348169b8:	15943018 	ldrne	r3, [r4, #24]
		mtd->erasesize <<= 1;

	this->erase_shift = ffs(mtd->erasesize) - 1;
	this->page_shift = ffs(mtd->writesize) - 1;
	this->ppb_shift = (this->erase_shift - this->page_shift);
	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
348169bc:	e2400001 	sub	r0, r0, #1
	/* Set density mask. it is used for DDP */
	if (ONENAND_IS_DDP(this))
		this->density_mask = this->chipsize >> (this->erase_shift + 1);
348169c0:	11a0bb33 	lsrne	fp, r3, fp
348169c4:	1584b028 	strne	fp, [r4, #40]	; 0x28
	/* It's real page size */
	this->writesize = mtd->writesize;

	/* REVIST: Multichip handling */

	if (FLEXONENAND(this))
348169c8:	e3590000 	cmp	r9, #0
		flexonenand_get_size(mtd);
	else
		mtd->size = this->chipsize;
348169cc:	05943018 	ldreq	r3, [r4, #24]
		mtd->erasesize <<= 1;

	this->erase_shift = ffs(mtd->erasesize) - 1;
	this->page_shift = ffs(mtd->writesize) - 1;
	this->ppb_shift = (this->erase_shift - this->page_shift);
	this->page_mask = (mtd->erasesize / mtd->writesize) - 1;
348169d0:	e584003c 	str	r0, [r4, #60]	; 0x3c
	/* Set density mask. it is used for DDP */
	if (ONENAND_IS_DDP(this))
		this->density_mask = this->chipsize >> (this->erase_shift + 1);
	/* It's real page size */
	this->writesize = mtd->writesize;
348169d4:	e5846040 	str	r6, [r4, #64]	; 0x40
	/* REVIST: Multichip handling */

	if (FLEXONENAND(this))
		flexonenand_get_size(mtd);
	else
		mtd->size = this->chipsize;
348169d8:	05853008 	streq	r3, [r5, #8]
348169dc:	0585900c 	streq	r9, [r5, #12]
	/* It's real page size */
	this->writesize = mtd->writesize;

	/* REVIST: Multichip handling */

	if (FLEXONENAND(this))
348169e0:	0a000001 	beq	348169ec <onenand_probe+0x2b0>
		flexonenand_get_size(mtd);
348169e4:	e1a00005 	mov	r0, r5
348169e8:	ebfff5c3 	bl	348140fc <flexonenand_get_size>
	else
		mtd->size = this->chipsize;

	mtd->flags = MTD_CAP_NANDFLASH;
348169ec:	e3a03b01 	mov	r3, #1024	; 0x400
348169f0:	e5853004 	str	r3, [r5, #4]
	mtd->erase = onenand_erase;
348169f4:	e59f3050 	ldr	r3, [pc, #80]	; 34816a4c <onenand_probe+0x310>
348169f8:	e5853034 	str	r3, [r5, #52]	; 0x34
	mtd->read = onenand_read;
348169fc:	e59f304c 	ldr	r3, [pc, #76]	; 34816a50 <onenand_probe+0x314>
34816a00:	e5853040 	str	r3, [r5, #64]	; 0x40
	mtd->write = onenand_write;
34816a04:	e59f3048 	ldr	r3, [pc, #72]	; 34816a54 <onenand_probe+0x318>
34816a08:	e5853044 	str	r3, [r5, #68]	; 0x44
	mtd->read_oob = onenand_read_oob;
34816a0c:	e59f3044 	ldr	r3, [pc, #68]	; 34816a58 <onenand_probe+0x31c>
34816a10:	e585304c 	str	r3, [r5, #76]	; 0x4c
	mtd->write_oob = onenand_write_oob;
34816a14:	e59f3040 	ldr	r3, [pc, #64]	; 34816a5c <onenand_probe+0x320>
34816a18:	e5853050 	str	r3, [r5, #80]	; 0x50
	mtd->sync = onenand_sync;
34816a1c:	e59f303c 	ldr	r3, [pc, #60]	; 34816a60 <onenand_probe+0x324>
34816a20:	e585306c 	str	r3, [r5, #108]	; 0x6c
	mtd->block_isbad = onenand_block_isbad;
34816a24:	e59f3038 	ldr	r3, [pc, #56]	; 34816a64 <onenand_probe+0x328>
34816a28:	e5853078 	str	r3, [r5, #120]	; 0x78
	mtd->block_markbad = onenand_block_markbad;
34816a2c:	e59f3034 	ldr	r3, [pc, #52]	; 34816a68 <onenand_probe+0x32c>
34816a30:	e585307c 	str	r3, [r5, #124]	; 0x7c

	return 0;
}
34816a34:	e1a0000a 	mov	r0, sl
34816a38:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34816a3c:	34827b62 	.word	0x34827b62
34816a40:	34827b82 	.word	0x34827b82
34816a44:	34827ba1 	.word	0x34827ba1
34816a48:	34827bb3 	.word	0x34827bb3
34816a4c:	34815d9c 	.word	0x34815d9c
34816a50:	34815d3c 	.word	0x34815d3c
34816a54:	34814fc8 	.word	0x34814fc8
34816a58:	34815d0c 	.word	0x34815d0c
34816a5c:	34814f98 	.word	0x34814f98
34816a60:	34813f74 	.word	0x34813f74
34816a64:	34813f78 	.word	0x34813f78
34816a68:	34813fbc 	.word	0x34813fbc

34816a6c <onenand_scan>:
 * with the defaults.
 * The flash ID is read and the mtd/chip structures are
 * filled with the appropriate values.
 */
int onenand_scan(struct mtd_info *mtd, int maxchips)
{
34816a6c:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	int i;
	struct onenand_chip *this = mtd->priv;
34816a70:	e5904094 	ldr	r4, [r0, #148]	; 0x94
 * with the defaults.
 * The flash ID is read and the mtd/chip structures are
 * filled with the appropriate values.
 */
int onenand_scan(struct mtd_info *mtd, int maxchips)
{
34816a74:	e1a06000 	mov	r6, r0
	int i;
	struct onenand_chip *this = mtd->priv;

	if (!this->read_word)
34816a78:	e5943068 	ldr	r3, [r4, #104]	; 0x68
34816a7c:	e3530000 	cmp	r3, #0
		this->read_word = onenand_readw;
34816a80:	059f3568 	ldreq	r3, [pc, #1384]	; 34816ff0 <onenand_scan+0x584>
34816a84:	05843068 	streq	r3, [r4, #104]	; 0x68
	if (!this->write_word)
34816a88:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
34816a8c:	e3530000 	cmp	r3, #0
		this->write_word = onenand_writew;
34816a90:	059f355c 	ldreq	r3, [pc, #1372]	; 34816ff4 <onenand_scan+0x588>
34816a94:	0584306c 	streq	r3, [r4, #108]	; 0x6c

	if (!this->command)
34816a98:	e5943050 	ldr	r3, [r4, #80]	; 0x50
34816a9c:	e3530000 	cmp	r3, #0
		this->command = onenand_command;
34816aa0:	059f3550 	ldreq	r3, [pc, #1360]	; 34816ff8 <onenand_scan+0x58c>
34816aa4:	05843050 	streq	r3, [r4, #80]	; 0x50
	if (!this->wait)
34816aa8:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34816aac:	e3530000 	cmp	r3, #0
		this->wait = onenand_wait;
34816ab0:	059f3544 	ldreq	r3, [pc, #1348]	; 34816ffc <onenand_scan+0x590>
34816ab4:	05843054 	streq	r3, [r4, #84]	; 0x54
	if (!this->bbt_wait)
34816ab8:	e5943058 	ldr	r3, [r4, #88]	; 0x58
34816abc:	e3530000 	cmp	r3, #0
		this->bbt_wait = onenand_bbt_wait;
34816ac0:	059f3538 	ldreq	r3, [pc, #1336]	; 34817000 <onenand_scan+0x594>
34816ac4:	05843058 	streq	r3, [r4, #88]	; 0x58

	if (!this->read_bufferram)
34816ac8:	e5943060 	ldr	r3, [r4, #96]	; 0x60
34816acc:	e3530000 	cmp	r3, #0
		this->read_bufferram = onenand_read_bufferram;
34816ad0:	059f352c 	ldreq	r3, [pc, #1324]	; 34817004 <onenand_scan+0x598>
34816ad4:	05843060 	streq	r3, [r4, #96]	; 0x60
	if (!this->write_bufferram)
34816ad8:	e5943064 	ldr	r3, [r4, #100]	; 0x64
34816adc:	e3530000 	cmp	r3, #0
		this->write_bufferram = onenand_write_bufferram;
34816ae0:	059f3520 	ldreq	r3, [pc, #1312]	; 34817008 <onenand_scan+0x59c>
34816ae4:	05843064 	streq	r3, [r4, #100]	; 0x64

	if (!this->chip_probe)
34816ae8:	e5943070 	ldr	r3, [r4, #112]	; 0x70
34816aec:	e3530000 	cmp	r3, #0
		this->chip_probe = onenand_chip_probe;
34816af0:	059f3514 	ldreq	r3, [pc, #1300]	; 3481700c <onenand_scan+0x5a0>
34816af4:	05843070 	streq	r3, [r4, #112]	; 0x70

	if (!this->block_markbad)
34816af8:	e5943078 	ldr	r3, [r4, #120]	; 0x78
34816afc:	e3530000 	cmp	r3, #0
		this->block_markbad = onenand_default_block_markbad;
34816b00:	059f3508 	ldreq	r3, [pc, #1288]	; 34817010 <onenand_scan+0x5a4>
34816b04:	05843078 	streq	r3, [r4, #120]	; 0x78
	if (!this->scan_bbt)
34816b08:	e594307c 	ldr	r3, [r4, #124]	; 0x7c
34816b0c:	e3530000 	cmp	r3, #0
		this->scan_bbt = onenand_default_bbt;
34816b10:	059f34fc 	ldreq	r3, [pc, #1276]	; 34817014 <onenand_scan+0x5a8>
34816b14:	0584307c 	streq	r3, [r4, #124]	; 0x7c

	if (onenand_probe(mtd))
34816b18:	ebffff07 	bl	3481673c <onenand_probe>
34816b1c:	e3500000 	cmp	r0, #0
		return -ENXIO;
34816b20:	13e00005 	mvnne	r0, #5
	if (!this->block_markbad)
		this->block_markbad = onenand_default_block_markbad;
	if (!this->scan_bbt)
		this->scan_bbt = onenand_default_bbt;

	if (onenand_probe(mtd))
34816b24:	1a00012f 	bne	34816fe8 <onenand_scan+0x57c>
		return -ENXIO;

	/* Set Sync. Burst Read after probing */
	if (this->mmcontrol) {
34816b28:	e5943074 	ldr	r3, [r4, #116]	; 0x74
34816b2c:	e3530000 	cmp	r3, #0
34816b30:	0a000003 	beq	34816b44 <onenand_scan+0xd8>
		printk(KERN_INFO "OneNAND Sync. Burst Read support\n");
34816b34:	e59f04dc 	ldr	r0, [pc, #1244]	; 34817018 <onenand_scan+0x5ac>
34816b38:	ebffc989 	bl	34809164 <printf>
		this->read_bufferram = onenand_sync_read_bufferram;
34816b3c:	e59f34d8 	ldr	r3, [pc, #1240]	; 3481701c <onenand_scan+0x5b0>
34816b40:	e5843060 	str	r3, [r4, #96]	; 0x60
	}

	/* Allocate buffers, if necessary */
	if (!this->page_buf) {
34816b44:	e594308c 	ldr	r3, [r4, #140]	; 0x8c
34816b48:	e3530000 	cmp	r3, #0
34816b4c:	1a00000b 	bne	34816b80 <onenand_scan+0x114>
		this->page_buf = kzalloc(mtd->writesize, GFP_KERNEL);
34816b50:	e5960014 	ldr	r0, [r6, #20]
34816b54:	e3a01001 	mov	r1, #1
34816b58:	ebffccb5 	bl	34809e34 <calloc>
		if (!this->page_buf) {
34816b5c:	e3500000 	cmp	r0, #0
			printk(KERN_ERR "onenand_scan(): Can't allocate page_buf\n");
			return -ENOMEM;
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
34816b60:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
		this->read_bufferram = onenand_sync_read_bufferram;
	}

	/* Allocate buffers, if necessary */
	if (!this->page_buf) {
		this->page_buf = kzalloc(mtd->writesize, GFP_KERNEL);
34816b64:	e584008c 	str	r0, [r4, #140]	; 0x8c
		if (!this->page_buf) {
			printk(KERN_ERR "onenand_scan(): Can't allocate page_buf\n");
			return -ENOMEM;
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
34816b68:	13833a01 	orrne	r3, r3, #4096	; 0x1000
34816b6c:	1584302c 	strne	r3, [r4, #44]	; 0x2c
	}

	/* Allocate buffers, if necessary */
	if (!this->page_buf) {
		this->page_buf = kzalloc(mtd->writesize, GFP_KERNEL);
		if (!this->page_buf) {
34816b70:	1a000002 	bne	34816b80 <onenand_scan+0x114>
			printk(KERN_ERR "onenand_scan(): Can't allocate page_buf\n");
34816b74:	e59f04a4 	ldr	r0, [pc, #1188]	; 34817020 <onenand_scan+0x5b4>
34816b78:	ebffc979 	bl	34809164 <printf>
34816b7c:	ea000118 	b	34816fe4 <onenand_scan+0x578>
			return -ENOMEM;
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
	}
	if (!this->oob_buf) {
34816b80:	e5943090 	ldr	r3, [r4, #144]	; 0x90
34816b84:	e3530000 	cmp	r3, #0
34816b88:	1a000012 	bne	34816bd8 <onenand_scan+0x16c>
		this->oob_buf = kzalloc(mtd->oobsize, GFP_KERNEL);
34816b8c:	e5960018 	ldr	r0, [r6, #24]
34816b90:	e3a01001 	mov	r1, #1
34816b94:	ebffcca6 	bl	34809e34 <calloc>
		if (!this->oob_buf) {
34816b98:	e3500000 	cmp	r0, #0
				this->options &= ~ONENAND_PAGEBUF_ALLOC;
				kfree(this->page_buf);
			}
			return -ENOMEM;
		}
		this->options |= ONENAND_OOBBUF_ALLOC;
34816b9c:	1594302c 	ldrne	r3, [r4, #44]	; 0x2c
			return -ENOMEM;
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
	}
	if (!this->oob_buf) {
		this->oob_buf = kzalloc(mtd->oobsize, GFP_KERNEL);
34816ba0:	e5840090 	str	r0, [r4, #144]	; 0x90
				this->options &= ~ONENAND_PAGEBUF_ALLOC;
				kfree(this->page_buf);
			}
			return -ENOMEM;
		}
		this->options |= ONENAND_OOBBUF_ALLOC;
34816ba4:	13833a02 	orrne	r3, r3, #8192	; 0x2000
34816ba8:	1584302c 	strne	r3, [r4, #44]	; 0x2c
		}
		this->options |= ONENAND_PAGEBUF_ALLOC;
	}
	if (!this->oob_buf) {
		this->oob_buf = kzalloc(mtd->oobsize, GFP_KERNEL);
		if (!this->oob_buf) {
34816bac:	1a000009 	bne	34816bd8 <onenand_scan+0x16c>
			printk(KERN_ERR "onenand_scan: Can't allocate oob_buf\n");
34816bb0:	e59f046c 	ldr	r0, [pc, #1132]	; 34817024 <onenand_scan+0x5b8>
34816bb4:	ebffc96a 	bl	34809164 <printf>
			if (this->options & ONENAND_PAGEBUF_ALLOC) {
34816bb8:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
34816bbc:	e3130a01 	tst	r3, #4096	; 0x1000
34816bc0:	0a000107 	beq	34816fe4 <onenand_scan+0x578>
				this->options &= ~ONENAND_PAGEBUF_ALLOC;
34816bc4:	e3c33a01 	bic	r3, r3, #4096	; 0x1000
34816bc8:	e584302c 	str	r3, [r4, #44]	; 0x2c
				kfree(this->page_buf);
34816bcc:	e594008c 	ldr	r0, [r4, #140]	; 0x8c
34816bd0:	ebffcaa1 	bl	3480965c <free>
34816bd4:	ea000102 	b	34816fe4 <onenand_scan+0x578>
	this->state = FL_READY;

	/*
	 * Allow subpage writes up to oobsize.
	 */
	switch (mtd->oobsize) {
34816bd8:	e5961018 	ldr	r1, [r6, #24]
			return -ENOMEM;
		}
		this->options |= ONENAND_OOBBUF_ALLOC;
	}

	this->state = FL_READY;
34816bdc:	e3a05000 	mov	r5, #0

	/*
	 * Allow subpage writes up to oobsize.
	 */
	switch (mtd->oobsize) {
34816be0:	e3510040 	cmp	r1, #64	; 0x40
			return -ENOMEM;
		}
		this->options |= ONENAND_OOBBUF_ALLOC;
	}

	this->state = FL_READY;
34816be4:	e5845088 	str	r5, [r4, #136]	; 0x88

	/*
	 * Allow subpage writes up to oobsize.
	 */
	switch (mtd->oobsize) {
34816be8:	0a000009 	beq	34816c14 <onenand_scan+0x1a8>
34816bec:	e3510080 	cmp	r1, #128	; 0x80
34816bf0:	0a000003 	beq	34816c04 <onenand_scan+0x198>
34816bf4:	e3510020 	cmp	r1, #32
34816bf8:	e59f7428 	ldr	r7, [pc, #1064]	; 34817028 <onenand_scan+0x5bc>
34816bfc:	1a00000c 	bne	34816c34 <onenand_scan+0x1c8>
34816c00:	ea000007 	b	34816c24 <onenand_scan+0x1b8>
	case 128:
		this->ecclayout = &onenand_oob_128;
34816c04:	e59f3420 	ldr	r3, [pc, #1056]	; 3481702c <onenand_scan+0x5c0>
34816c08:	e584309c 	str	r3, [r4, #156]	; 0x9c
		mtd->subpage_sft = 0;
34816c0c:	e5865090 	str	r5, [r6, #144]	; 0x90
		break;
34816c10:	ea00000b 	b	34816c44 <onenand_scan+0x1d8>

	case 64:
		this->ecclayout = &onenand_oob_64;
34816c14:	e59f3414 	ldr	r3, [pc, #1044]	; 34817030 <onenand_scan+0x5c4>
34816c18:	e584309c 	str	r3, [r4, #156]	; 0x9c
		mtd->subpage_sft = 2;
34816c1c:	e3a03002 	mov	r3, #2
34816c20:	ea000001 	b	34816c2c <onenand_scan+0x1c0>
		break;

	case 32:
		this->ecclayout = &onenand_oob_32;
34816c24:	e584709c 	str	r7, [r4, #156]	; 0x9c
		mtd->subpage_sft = 1;
34816c28:	e3a03001 	mov	r3, #1
34816c2c:	e5863090 	str	r3, [r6, #144]	; 0x90
		break;
34816c30:	ea000003 	b	34816c44 <onenand_scan+0x1d8>

	default:
		printk(KERN_WARNING "No OOB scheme defined for oobsize %d\n",
34816c34:	e59f03f8 	ldr	r0, [pc, #1016]	; 34817034 <onenand_scan+0x5c8>
34816c38:	ebffc949 	bl	34809164 <printf>
			mtd->oobsize);
		mtd->subpage_sft = 0;
34816c3c:	e5865090 	str	r5, [r6, #144]	; 0x90
		/* To prevent kernel oops */
		this->ecclayout = &onenand_oob_32;
34816c40:	e584709c 	str	r7, [r4, #156]	; 0x9c
		break;
	}

	this->subpagesize = mtd->writesize >> mtd->subpage_sft;
34816c44:	e5962014 	ldr	r2, [r6, #20]
34816c48:	e5963090 	ldr	r3, [r6, #144]	; 0x90
34816c4c:	e1a03332 	lsr	r3, r2, r3
34816c50:	e5843098 	str	r3, [r4, #152]	; 0x98

	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
34816c54:	e594309c 	ldr	r3, [r4, #156]	; 0x9c
34816c58:	e3a02000 	mov	r2, #0
34816c5c:	e5832204 	str	r2, [r3, #516]	; 0x204
 * This fills out all the not initialized function pointers
 * with the defaults.
 * The flash ID is read and the mtd/chip structures are
 * filled with the appropriate values.
 */
int onenand_scan(struct mtd_info *mtd, int maxchips)
34816c60:	e2830040 	add	r0, r3, #64	; 0x40

	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
34816c64:	e1a02003 	mov	r2, r3
34816c68:	ea000005 	b	34816c84 <onenand_scan+0x218>
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
	    this->ecclayout->oobfree[i].length; i++)
		this->ecclayout->oobavail +=
34816c6c:	e593c204 	ldr	ip, [r3, #516]	; 0x204
34816c70:	e2822008 	add	r2, r2, #8
34816c74:	e08c1001 	add	r1, ip, r1
	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
34816c78:	e1520000 	cmp	r2, r0
	    this->ecclayout->oobfree[i].length; i++)
		this->ecclayout->oobavail +=
34816c7c:	e5831204 	str	r1, [r3, #516]	; 0x204
	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
34816c80:	0a000002 	beq	34816c90 <onenand_scan+0x224>
	    this->ecclayout->oobfree[i].length; i++)
34816c84:	e592120c 	ldr	r1, [r2, #524]	; 0x20c
	/*
	 * The number of bytes available for a client to place data into
	 * the out of band area
	 */
	this->ecclayout->oobavail = 0;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
34816c88:	e3510000 	cmp	r1, #0
34816c8c:	1afffff6 	bne	34816c6c <onenand_scan+0x200>
 *
 * Unlock all blocks
 */
static void onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
34816c90:	e5965094 	ldr	r5, [r6, #148]	; 0x94
	this->ecclayout->oobavail = 0;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
	    this->ecclayout->oobfree[i].length; i++)
		this->ecclayout->oobavail +=
			this->ecclayout->oobfree[i].length;
	mtd->oobavail = this->ecclayout->oobavail;
34816c94:	e5932204 	ldr	r2, [r3, #516]	; 0x204

	mtd->ecclayout = this->ecclayout;
34816c98:	e5863028 	str	r3, [r6, #40]	; 0x28
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = mtd->size;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
34816c9c:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
	this->ecclayout->oobavail = 0;
	for (i = 0; i < MTD_MAX_OOBFREE_ENTRIES &&
	    this->ecclayout->oobfree[i].length; i++)
		this->ecclayout->oobavail +=
			this->ecclayout->oobfree[i].length;
	mtd->oobavail = this->ecclayout->oobavail;
34816ca0:	e586201c 	str	r2, [r6, #28]
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = mtd->size;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
34816ca4:	e3130002 	tst	r3, #2
 */
static void onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = mtd->size;
34816ca8:	e596a008 	ldr	sl, [r6, #8]

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
34816cac:	0a000050 	beq	34816df4 <onenand_scan+0x388>
		/* Set start block address */
		this->write_word(0, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
34816cb0:	e5951000 	ldr	r1, [r5]
34816cb4:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816cb8:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34816cbc:	e3a00000 	mov	r0, #0
34816cc0:	e2811098 	add	r1, r1, #152	; 0x98
34816cc4:	e12fff33 	blx	r3
		/* Write unlock command */
		this->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);
34816cc8:	e3a03000 	mov	r3, #0
34816ccc:	e58d3000 	str	r3, [sp]
34816cd0:	e3a01027 	mov	r1, #39	; 0x27
34816cd4:	e3a03000 	mov	r3, #0
34816cd8:	e595c050 	ldr	ip, [r5, #80]	; 0x50
34816cdc:	e1a00006 	mov	r0, r6
34816ce0:	e3a02000 	mov	r2, #0
34816ce4:	e12fff3c 	blx	ip

		/* There's no return value */
		this->wait(mtd, FL_LOCKING);
34816ce8:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34816cec:	e1a00006 	mov	r0, r6
34816cf0:	e3a01008 	mov	r1, #8
34816cf4:	e12fff33 	blx	r3

		/* Sanity check */
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
34816cf8:	e5950000 	ldr	r0, [r5]
34816cfc:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34816d00:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34816d04:	e2800080 	add	r0, r0, #128	; 0x80
34816d08:	e12fff33 	blx	r3
34816d0c:	e3100902 	tst	r0, #32768	; 0x8000
34816d10:	1afffff8 	bne	34816cf8 <onenand_scan+0x28c>
static int onenand_check_lock_status(struct onenand_chip *this)
{
	unsigned int value, block, status;
	unsigned int end;

	end = this->chipsize >> this->erase_shift;
34816d14:	e5959018 	ldr	r9, [r5, #24]
34816d18:	e5953030 	ldr	r3, [r5, #48]	; 0x30
	for (block = 0; block < end; block++) {
34816d1c:	e3a07000 	mov	r7, #0
static int onenand_check_lock_status(struct onenand_chip *this)
{
	unsigned int value, block, status;
	unsigned int end;

	end = this->chipsize >> this->erase_shift;
34816d20:	e1a09339 	lsr	r9, r9, r3
34816d24:	ea00002f 	b	34816de8 <onenand_scan+0x37c>
 * onenand_release - [OneNAND Interface] Free resources held by the OneNAND device
 * @param mtd		MTD device structure
 */
void onenand_release(struct mtd_info *mtd)
{
}
34816d28:	e5950028 	ldr	r0, [r5, #40]	; 0x28

	end = this->chipsize >> this->erase_shift;
	for (block = 0; block < end; block++) {
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34816d2c:	e5951000 	ldr	r1, [r5]
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34816d30:	e1170000 	tst	r7, r0
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
34816d34:	10270000 	eorne	r0, r7, r0
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34816d38:	01a00007 	moveq	r0, r7
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
34816d3c:	13800902 	orrne	r0, r0, #32768	; 0x8000

	end = this->chipsize >> this->erase_shift;
	for (block = 0; block < end; block++) {
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34816d40:	e2811a1e 	add	r1, r1, #122880	; 0x1e000
34816d44:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816d48:	e6ff0070 	uxth	r0, r0
34816d4c:	e2811c02 	add	r1, r1, #512	; 0x200
34816d50:	e12fff33 	blx	r3
 * Setup Start Address 2 Register (F101h) for DDP
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
34816d54:	e5953028 	ldr	r3, [r5, #40]	; 0x28
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34816d58:	e5952000 	ldr	r2, [r5]
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34816d5c:	e0173003 	ands	r3, r7, r3
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34816d60:	e59f12d0 	ldr	r1, [pc, #720]	; 34817038 <onenand_scan+0x5cc>
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34816d64:	01a00003 	moveq	r0, r3
34816d68:	13a00902 	movne	r0, #32768	; 0x8000
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34816d6c:	e0821001 	add	r1, r2, r1
34816d70:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816d74:	e6ff0070 	uxth	r0, r0
34816d78:	e12fff33 	blx	r3
		/* Set start block address */
		this->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);
34816d7c:	e5951000 	ldr	r1, [r5]
34816d80:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816d84:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34816d88:	e6ff0077 	uxth	r0, r7
34816d8c:	e2811098 	add	r1, r1, #152	; 0x98
34816d90:	e12fff33 	blx	r3

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34816d94:	e5950000 	ldr	r0, [r5]
34816d98:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34816d9c:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34816da0:	e280009c 	add	r0, r0, #156	; 0x9c
34816da4:	e12fff33 	blx	r3
		if (!(status & ONENAND_WP_US)) {
34816da8:	e3100004 	tst	r0, #4
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
		/* Set start block address */
		this->write_word(block, this->base + ONENAND_REG_START_BLOCK_ADDRESS);

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34816dac:	e1a02000 	mov	r2, r0
		if (!(status & ONENAND_WP_US)) {
34816db0:	1a00000b 	bne	34816de4 <onenand_scan+0x378>
			printk(KERN_ERR "block = %d, wp status = 0x%x\n", block, status);
34816db4:	e59f0280 	ldr	r0, [pc, #640]	; 3481703c <onenand_scan+0x5d0>
34816db8:	e1a01007 	mov	r1, r7
34816dbc:	ebffc8e8 	bl	34809164 <printf>
		/* Check lock status */
		if (onenand_check_lock_status(this))
			return;

		/* Workaround for all block unlock in DDP */
		if (ONENAND_IS_DDP(this) && !FLEXONENAND(this)) {
34816dc0:	e595301c 	ldr	r3, [r5, #28]
34816dc4:	e2033f82 	and	r3, r3, #520	; 0x208
34816dc8:	e3530008 	cmp	r3, #8
			/* All blocks on another chip */
			ofs = this->chipsize >> 1;
34816dcc:	0595a018 	ldreq	sl, [r5, #24]
34816dd0:	01a0a0aa 	lsreq	sl, sl, #1
34816dd4:	01a0200a 	moveq	r2, sl
34816dd8:	03a03000 	moveq	r3, #0
		/* Check lock status */
		if (onenand_check_lock_status(this))
			return;

		/* Workaround for all block unlock in DDP */
		if (ONENAND_IS_DDP(this) && !FLEXONENAND(this)) {
34816ddc:	1a000004 	bne	34816df4 <onenand_scan+0x388>
34816de0:	ea000005 	b	34816dfc <onenand_scan+0x390>
{
	unsigned int value, block, status;
	unsigned int end;

	end = this->chipsize >> this->erase_shift;
	for (block = 0; block < end; block++) {
34816de4:	e2877001 	add	r7, r7, #1
34816de8:	e1570009 	cmp	r7, r9
34816dec:	3affffcd 	bcc	34816d28 <onenand_scan+0x2bc>
34816df0:	ea000077 	b	34816fd4 <onenand_scan+0x568>
 * Unlock all blocks
 */
static void onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
34816df4:	e3a02000 	mov	r2, #0
34816df8:	e3a03000 	mov	r3, #0
 *
 * Lock or unlock one or more blocks
 */
static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
34816dfc:	e5965094 	ldr	r5, [r6, #148]	; 0x94
 * Unlock all blocks
 */
static void onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
34816e00:	e1cd20f8 	strd	r2, [sp, #8]
static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
	int start, end, block, value, status;

	start = onenand_block(this, ofs);
34816e04:	e1cd20d8 	ldrd	r2, [sp, #8]
34816e08:	e1a00005 	mov	r0, r5
34816e0c:	ebfff885 	bl	34815028 <onenand_block>
	end = onenand_block(this, ofs + len);
34816e10:	e1cd20d8 	ldrd	r2, [sp, #8]
34816e14:	e092200a 	adds	r2, r2, sl
34816e18:	e2a33000 	adc	r3, r3, #0
static int onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs, size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
	int start, end, block, value, status;

	start = onenand_block(this, ofs);
34816e1c:	e1a07000 	mov	r7, r0
34816e20:	e1a0b000 	mov	fp, r0
	end = onenand_block(this, ofs + len);
34816e24:	e1a00005 	mov	r0, r5
34816e28:	ebfff87e 	bl	34815028 <onenand_block>

	/* Continuous lock scheme */
	if (this->options & ONENAND_HAS_CONT_LOCK) {
34816e2c:	e595902c 	ldr	r9, [r5, #44]	; 0x2c
{
	struct onenand_chip *this = mtd->priv;
	int start, end, block, value, status;

	start = onenand_block(this, ofs);
	end = onenand_block(this, ofs + len);
34816e30:	e1a0a000 	mov	sl, r0

	/* Continuous lock scheme */
	if (this->options & ONENAND_HAS_CONT_LOCK) {
34816e34:	e2199001 	ands	r9, r9, #1
34816e38:	0a000063 	beq	34816fcc <onenand_scan+0x560>
		/* Set start block address */
		this->write_word(start,
34816e3c:	e5951000 	ldr	r1, [r5]
34816e40:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816e44:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34816e48:	e6ff0077 	uxth	r0, r7
34816e4c:	e2811098 	add	r1, r1, #152	; 0x98
34816e50:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_START_BLOCK_ADDRESS);
		/* Set end block address */
		this->write_word(end - 1,
34816e54:	e5951000 	ldr	r1, [r5]
34816e58:	e24a0001 	sub	r0, sl, #1
34816e5c:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34816e60:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816e64:	e6ff0070 	uxth	r0, r0
34816e68:	e281109a 	add	r1, r1, #154	; 0x9a
34816e6c:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_END_BLOCK_ADDRESS);
		/* Write unlock command */
		this->command(mtd, cmd, 0, 0);
34816e70:	e3a03000 	mov	r3, #0
34816e74:	e58d3000 	str	r3, [sp]
34816e78:	e3a01023 	mov	r1, #35	; 0x23
34816e7c:	e3a03000 	mov	r3, #0
34816e80:	e595c050 	ldr	ip, [r5, #80]	; 0x50
34816e84:	e1a00006 	mov	r0, r6
34816e88:	e3a02000 	mov	r2, #0
34816e8c:	e12fff3c 	blx	ip

		/* There's no return value */
		this->wait(mtd, FL_UNLOCKING);
34816e90:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34816e94:	e1a00006 	mov	r0, r6
34816e98:	e3a01007 	mov	r1, #7
34816e9c:	e12fff33 	blx	r3

		/* Sanity check */
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
34816ea0:	e5950000 	ldr	r0, [r5]
34816ea4:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34816ea8:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34816eac:	e2800080 	add	r0, r0, #128	; 0x80
34816eb0:	e12fff33 	blx	r3
34816eb4:	e3100902 	tst	r0, #32768	; 0x8000
34816eb8:	1afffff8 	bne	34816ea0 <onenand_scan+0x434>
		       & ONENAND_CTRL_ONGO)
			continue;

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34816ebc:	e5950000 	ldr	r0, [r5]
34816ec0:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34816ec4:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34816ec8:	e280009c 	add	r0, r0, #156	; 0x9c
34816ecc:	e12fff33 	blx	r3
		if (!(status & ONENAND_WP_US))
34816ed0:	e3100004 	tst	r0, #4
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
		       & ONENAND_CTRL_ONGO)
			continue;

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34816ed4:	e1a01000 	mov	r1, r0
		if (!(status & ONENAND_WP_US))
34816ed8:	1a00003d 	bne	34816fd4 <onenand_scan+0x568>
			printk(KERN_ERR "wp status = 0x%x\n", status);
34816edc:	e59f015c 	ldr	r0, [pc, #348]	; 34817040 <onenand_scan+0x5d4>
34816ee0:	ebffc89f 	bl	34809164 <printf>
34816ee4:	ea00003a 	b	34816fd4 <onenand_scan+0x568>
 * onenand_release - [OneNAND Interface] Free resources held by the OneNAND device
 * @param mtd		MTD device structure
 */
void onenand_release(struct mtd_info *mtd)
{
}
34816ee8:	e5950028 	ldr	r0, [r5, #40]	; 0x28

	/* Block lock scheme */
	for (block = start; block < end; block++) {
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34816eec:	e5951000 	ldr	r1, [r5]
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34816ef0:	e1170000 	tst	r7, r0
		return ONENAND_DDP_CHIP1 | (block ^ this->density_mask);
34816ef4:	10270000 	eorne	r0, r7, r0
34816ef8:	13800902 	orrne	r0, r0, #32768	; 0x8000
 * Setup Start Address 1 Register (F100h)
 */
static int onenand_block_address(struct onenand_chip *this, int block)
{
	/* Device Flash Core select, NAND Flash Block Address */
	if (block & this->density_mask)
34816efc:	01a00007 	moveq	r0, r7

	/* Block lock scheme */
	for (block = start; block < end; block++) {
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
34816f00:	e2811a1e 	add	r1, r1, #122880	; 0x1e000
34816f04:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816f08:	e6ff0070 	uxth	r0, r0
34816f0c:	e2811c02 	add	r1, r1, #512	; 0x200
34816f10:	e12fff33 	blx	r3
 * Setup Start Address 2 Register (F101h) for DDP
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
34816f14:	e5953028 	ldr	r3, [r5, #40]	; 0x28
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34816f18:	e5952000 	ldr	r2, [r5]
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34816f1c:	e0173003 	ands	r3, r7, r3
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34816f20:	e59f1110 	ldr	r1, [pc, #272]	; 34817038 <onenand_scan+0x5cc>
 */
static int onenand_bufferram_address(struct onenand_chip *this, int block)
{
	/* Device BufferRAM Select */
	if (block & this->density_mask)
		return ONENAND_DDP_CHIP1;
34816f24:	01a00003 	moveq	r0, r3
34816f28:	13a00902 	movne	r0, #32768	; 0x8000
		/* Set block address */
		value = onenand_block_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS1);
		/* Select DataRAM for DDP */
		value = onenand_bufferram_address(this, block);
		this->write_word(value, this->base + ONENAND_REG_START_ADDRESS2);
34816f2c:	e0821001 	add	r1, r2, r1
34816f30:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816f34:	e6ff0070 	uxth	r0, r0
34816f38:	e12fff33 	blx	r3

		/* Set start block address */
		this->write_word(block,
34816f3c:	e5951000 	ldr	r1, [r5]
34816f40:	e595306c 	ldr	r3, [r5, #108]	; 0x6c
34816f44:	e2811b79 	add	r1, r1, #123904	; 0x1e400
34816f48:	e6ff0077 	uxth	r0, r7
34816f4c:	e2811098 	add	r1, r1, #152	; 0x98
34816f50:	e12fff33 	blx	r3
				 this->base + ONENAND_REG_START_BLOCK_ADDRESS);
		/* Write unlock command */
		this->command(mtd, ONENAND_CMD_UNLOCK, 0, 0);
34816f54:	e58d9000 	str	r9, [sp]
34816f58:	e3a01023 	mov	r1, #35	; 0x23
34816f5c:	e3a03000 	mov	r3, #0
34816f60:	e595c050 	ldr	ip, [r5, #80]	; 0x50
34816f64:	e1a00006 	mov	r0, r6
34816f68:	e3a02000 	mov	r2, #0
34816f6c:	e12fff3c 	blx	ip

		/* There's no return value */
		this->wait(mtd, FL_UNLOCKING);
34816f70:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34816f74:	e1a00006 	mov	r0, r6
34816f78:	e3a01007 	mov	r1, #7
34816f7c:	e12fff33 	blx	r3

		/* Sanity check */
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
34816f80:	e5950000 	ldr	r0, [r5]
34816f84:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34816f88:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34816f8c:	e2800080 	add	r0, r0, #128	; 0x80
34816f90:	e12fff33 	blx	r3
34816f94:	e3100902 	tst	r0, #32768	; 0x8000
34816f98:	1afffff8 	bne	34816f80 <onenand_scan+0x514>
		       & ONENAND_CTRL_ONGO)
			continue;

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34816f9c:	e5950000 	ldr	r0, [r5]
34816fa0:	e5953068 	ldr	r3, [r5, #104]	; 0x68
34816fa4:	e2800b79 	add	r0, r0, #123904	; 0x1e400
34816fa8:	e280009c 	add	r0, r0, #156	; 0x9c
34816fac:	e12fff33 	blx	r3
		if (!(status & ONENAND_WP_US))
34816fb0:	e3100004 	tst	r0, #4
		while (this->read_word(this->base + ONENAND_REG_CTRL_STATUS)
		       & ONENAND_CTRL_ONGO)
			continue;

		/* Check lock status */
		status = this->read_word(this->base + ONENAND_REG_WP_STATUS);
34816fb4:	e1a02000 	mov	r2, r0
		if (!(status & ONENAND_WP_US))
34816fb8:	1a000002 	bne	34816fc8 <onenand_scan+0x55c>
			printk(KERN_ERR "block = %d, wp status = 0x%x\n",
34816fbc:	e59f0078 	ldr	r0, [pc, #120]	; 3481703c <onenand_scan+0x5d0>
34816fc0:	e1a01007 	mov	r1, r7
34816fc4:	ebffc866 	bl	34809164 <printf>

		return 0;
	}

	/* Block lock scheme */
	for (block = start; block < end; block++) {
34816fc8:	e2877001 	add	r7, r7, #1
34816fcc:	e157000a 	cmp	r7, sl
34816fd0:	baffffc4 	blt	34816ee8 <onenand_scan+0x47c>
	mtd->ecclayout = this->ecclayout;

	/* Unlock whole block */
	onenand_unlock_all(mtd);

	return this->scan_bbt(mtd);
34816fd4:	e594307c 	ldr	r3, [r4, #124]	; 0x7c
34816fd8:	e1a00006 	mov	r0, r6
34816fdc:	e12fff33 	blx	r3
34816fe0:	ea000000 	b	34816fe8 <onenand_scan+0x57c>
			printk(KERN_ERR "onenand_scan: Can't allocate oob_buf\n");
			if (this->options & ONENAND_PAGEBUF_ALLOC) {
				this->options &= ~ONENAND_PAGEBUF_ALLOC;
				kfree(this->page_buf);
			}
			return -ENOMEM;
34816fe4:	e3e0000b 	mvn	r0, #11

	/* Unlock whole block */
	onenand_unlock_all(mtd);

	return this->scan_bbt(mtd);
}
34816fe8:	e28dd010 	add	sp, sp, #16
34816fec:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34816ff0:	34813e20 	.word	0x34813e20
34816ff4:	34813e28 	.word	0x34813e28
34816ff8:	34815230 	.word	0x34815230
34816ffc:	348145f4 	.word	0x348145f4
34817000:	34814528 	.word	0x34814528
34817004:	34813e30 	.word	0x34813e30
34817008:	34813f14 	.word	0x34813f14
3481700c:	34813ff8 	.word	0x34813ff8
34817010:	348150bc 	.word	0x348150bc
34817014:	3481730c 	.word	0x3481730c
34817018:	34827bcb 	.word	0x34827bcb
3481701c:	34813e90 	.word	0x34813e90
34817020:	34827bed 	.word	0x34827bed
34817024:	34827c16 	.word	0x34827c16
34817028:	34828fb8 	.word	0x34828fb8
3481702c:	34828b28 	.word	0x34828b28
34817030:	34828d70 	.word	0x34828d70
34817034:	34827c3c 	.word	0x34827c3c
34817038:	0001e202 	.word	0x0001e202
3481703c:	34827c62 	.word	0x34827c62
34817040:	34827c6e 	.word	0x34827c6e

34817044 <onenand_release>:
 * onenand_release - [OneNAND Interface] Free resources held by the OneNAND device
 * @param mtd		MTD device structure
 */
void onenand_release(struct mtd_info *mtd)
{
}
34817044:	e12fff1e 	bx	lr

34817048 <onenand_isbad_bbt>:
 * @param offs		offset in the device
 * @param allowbbt	allow access to bad block table region
 */
static int onenand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)
{
	struct onenand_chip *this = mtd->priv;
34817048:	e5900094 	ldr	r0, [r0, #148]	; 0x94
 * @param mtd		MTD device structure
 * @param offs		offset in the device
 * @param allowbbt	allow access to bad block table region
 */
static int onenand_isbad_bbt(struct mtd_info *mtd, loff_t offs, int allowbbt)
{
3481704c:	e92d4010 	push	{r4, lr}
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
34817050:	e59040a0 	ldr	r4, [r0, #160]	; 0xa0
	int block;
	uint8_t res;

	/* Get block number * 2 */
	block = (int) (onenand_block(this, offs) << 1);
34817054:	ebfff7f3 	bl	34815028 <onenand_block>
	res = (bbm->bbt[block >> 3] >> (block & 0x06)) & 0x03;
34817058:	e594300c 	ldr	r3, [r4, #12]
	struct bbm_info *bbm = this->bbm;
	int block;
	uint8_t res;

	/* Get block number * 2 */
	block = (int) (onenand_block(this, offs) << 1);
3481705c:	e1a00080 	lsl	r0, r0, #1
	res = (bbm->bbt[block >> 3] >> (block & 0x06)) & 0x03;
34817060:	e7d331c0 	ldrb	r3, [r3, r0, asr #3]
34817064:	e2000006 	and	r0, r0, #6
34817068:	e1a00053 	asr	r0, r3, r0

	MTDDEBUG (MTD_DEBUG_LEVEL2,
		"onenand_isbad_bbt: bbt info for offs 0x%08x: (block %d) 0x%02x\n",
		(unsigned int)offs, block >> 1, res);

	switch ((int)res) {
3481706c:	e2100003 	ands	r0, r0, #3
34817070:	08bd8010 	popeq	{r4, pc}
34817074:	e3500002 	cmp	r0, #2
34817078:	1a000003 	bne	3481708c <onenand_isbad_bbt+0x44>
	case 0x00:
		return 0;
	case 0x01:
		return 1;
	case 0x02:
		return allowbbt ? 0 : 1;
3481707c:	e59d0008 	ldr	r0, [sp, #8]
34817080:	e2700001 	rsbs	r0, r0, #1
34817084:	33a00000 	movcc	r0, #0
34817088:	e8bd8010 	pop	{r4, pc}

	switch ((int)res) {
	case 0x00:
		return 0;
	case 0x01:
		return 1;
3481708c:	e3a00001 	mov	r0, #1
	case 0x02:
		return allowbbt ? 0 : 1;
	}

	return 1;
}
34817090:	e8bd8010 	pop	{r4, pc}

34817094 <onenand_memory_bbt>:
 * The function creates a memory based bbt by scanning the device
 * for manufacturer / software marked good / bad blocks
 */
static inline int onenand_memory_bbt(struct mtd_info *mtd,
				     struct nand_bbt_descr *bd)
{
34817094:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	unsigned char data_buf[MAX_ONENAND_PAGESIZE];

	bd->options &= ~NAND_BBT_SCANEMPTY;
34817098:	e5913000 	ldr	r3, [r1]
 * for the given good/bad block identify pattern
 */
static int create_bbt(struct mtd_info *mtd, uint8_t * buf,
		      struct nand_bbt_descr *bd, int chip)
{
	struct onenand_chip *this = mtd->priv;
3481709c:	e590a094 	ldr	sl, [r0, #148]	; 0x94
static inline int onenand_memory_bbt(struct mtd_info *mtd,
				     struct nand_bbt_descr *bd)
{
	unsigned char data_buf[MAX_ONENAND_PAGESIZE];

	bd->options &= ~NAND_BBT_SCANEMPTY;
348170a0:	e3c33b02 	bic	r3, r3, #2048	; 0x800
 */
static int create_bbt(struct mtd_info *mtd, uint8_t * buf,
		      struct nand_bbt_descr *bd, int chip)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
348170a4:	e59a60a0 	ldr	r6, [sl, #160]	; 0xa0
 * The function creates a memory based bbt by scanning the device
 * for manufacturer / software marked good / bad blocks
 */
static inline int onenand_memory_bbt(struct mtd_info *mtd,
				     struct nand_bbt_descr *bd)
{
348170a8:	e24ddd42 	sub	sp, sp, #4224	; 0x1080
348170ac:	e24dd038 	sub	sp, sp, #56	; 0x38
348170b0:	e1a05001 	mov	r5, r1
	unsigned char data_buf[MAX_ONENAND_PAGESIZE];

	bd->options &= ~NAND_BBT_SCANEMPTY;
348170b4:	e5813000 	str	r3, [r1]
 * The function creates a memory based bbt by scanning the device
 * for manufacturer / software marked good / bad blocks
 */
static inline int onenand_memory_bbt(struct mtd_info *mtd,
				     struct nand_bbt_descr *bd)
{
348170b8:	e1a07000 	mov	r7, r0
	loff_t from;
	size_t readlen, ooblen;
	struct mtd_oob_ops ops;
	int rgn;

	printk(KERN_INFO "Scanning device for bad blocks\n");
348170bc:	e59f018c 	ldr	r0, [pc, #396]	; 34817250 <onenand_memory_bbt+0x1bc>
348170c0:	ebffc827 	bl	34809164 <printf>

	/* chip == -1 case only */
	/* Note that numblocks is 2 * (real numblocks) here;
	 * see i += 2 below as it makses shifting and masking less painful
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
348170c4:	e5969000 	ldr	r9, [r6]

	len = 1;

	/* We need only read few bytes from the OOB area */
	scanlen = ooblen = 0;
	readlen = bd->len;
348170c8:	e5953014 	ldr	r3, [r5, #20]
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
348170cc:	e28d0a01 	add	r0, sp, #4096	; 0x1000

	/* chip == -1 case only */
	/* Note that numblocks is 2 * (real numblocks) here;
	 * see i += 2 below as it makses shifting and masking less painful
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
348170d0:	e59a2018 	ldr	r2, [sl, #24]
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
	ops.ooblen = readlen;
348170d4:	e58030a4 	str	r3, [r0, #164]	; 0xa4

	/* chip == -1 case only */
	/* Note that numblocks is 2 * (real numblocks) here;
	 * see i += 2 below as it makses shifting and masking less painful
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
348170d8:	e2499001 	sub	r9, r9, #1
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
	ops.ooblen = readlen;
	ops.oobbuf = buf;
348170dc:	e28d3038 	add	r3, sp, #56	; 0x38
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
348170e0:	e3a04000 	mov	r4, #0

	/* chip == -1 case only */
	/* Note that numblocks is 2 * (real numblocks) here;
	 * see i += 2 below as it makses shifting and masking less painful
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
348170e4:	e1a09932 	lsr	r9, r2, r9
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
	ops.ooblen = readlen;
	ops.oobbuf = buf;
348170e8:	e2432020 	sub	r2, r3, #32
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
	startblock = 0;
	from = 0;

	ops.mode = MTD_OOB_PLACE;
348170ec:	e5804098 	str	r4, [r0, #152]	; 0x98
	ops.ooblen = readlen;
	ops.oobbuf = buf;
348170f0:	e58020b4 	str	r2, [r0, #180]	; 0xb4
	ops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;
348170f4:	e58040a8 	str	r4, [r0, #168]	; 0xa8
348170f8:	e58040a0 	str	r4, [r0, #160]	; 0xa0
348170fc:	e58040ac 	str	r4, [r0, #172]	; 0xac
34817100:	e580409c 	str	r4, [r0, #156]	; 0x9c
	/* Note that numblocks is 2 * (real numblocks) here;
	 * see i += 2 below as it makses shifting and masking less painful
	 */
	numblocks = this->chipsize >> (bbm->bbt_erase_shift - 1);
	startblock = 0;
	from = 0;
34817104:	e3a01000 	mov	r1, #0
34817108:	e3a00000 	mov	r0, #0
3481710c:	e1cd01f0 	strd	r0, [sp, #16]
34817110:	e1a0c00a 	mov	ip, sl
34817114:	ea000045 	b	34817230 <onenand_memory_bbt+0x19c>
		int ret;

		for (j = 0; j < len; j++) {
			/* No need to read pages fully,
			 * just read required OOB bytes */
			ret = onenand_bbt_read_oob(mtd,
34817118:	e5952008 	ldr	r2, [r5, #8]
3481711c:	e1cda1d0 	ldrd	sl, [sp, #16]
34817120:	e09aa002 	adds	sl, sl, r2
34817124:	e0abbfc2 	adc	fp, fp, r2, asr #31
34817128:	e28d1d42 	add	r1, sp, #4224	; 0x1080
3481712c:	e2811018 	add	r1, r1, #24
34817130:	e1a00007 	mov	r0, r7
34817134:	e1a0200a 	mov	r2, sl
34817138:	e1a0300b 	mov	r3, fp
3481713c:	e58dc00c 	str	ip, [sp, #12]
34817140:	e58d1000 	str	r1, [sp]
34817144:	ebfffbdc 	bl	348160bc <onenand_bbt_read_oob>
					     from + j * mtd->writesize +
					     bd->offs, &ops);

			/* If it is a initial bad block, just ignore it */
			if (ret == ONENAND_BBT_READ_FATAL_ERROR)
34817148:	e3500004 	cmp	r0, #4
3481714c:	e59dc00c 	ldr	ip, [sp, #12]
34817150:	0a00003a 	beq	34817240 <onenand_memory_bbt+0x1ac>
				return -EIO;

			if (ret || check_short_pattern
34817154:	e3500000 	cmp	r0, #0
{
	int i;
	uint8_t *p = buf;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
34817158:	05953014 	ldreq	r3, [r5, #20]
3481715c:	01a0a00c 	moveq	sl, ip

			/* If it is a initial bad block, just ignore it */
			if (ret == ONENAND_BBT_READ_FATAL_ERROR)
				return -EIO;

			if (ret || check_short_pattern
34817160:	0a000008 	beq	34817188 <onenand_memory_bbt+0xf4>
34817164:	ea00000c 	b	3481719c <onenand_memory_bbt+0x108>
	int i;
	uint8_t *p = buf;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
		if (p[i] != td->pattern[i])
34817168:	e28db038 	add	fp, sp, #56	; 0x38
3481716c:	e5952020 	ldr	r2, [r5, #32]
34817170:	e24b1020 	sub	r1, fp, #32
34817174:	e7d11000 	ldrb	r1, [r1, r0]
34817178:	e7d22000 	ldrb	r2, [r2, r0]
3481717c:	e1510002 	cmp	r1, r2
34817180:	1a000004 	bne	34817198 <onenand_memory_bbt+0x104>
{
	int i;
	uint8_t *p = buf;

	/* Compare the pattern */
	for (i = 0; i < td->len; i++) {
34817184:	e2800001 	add	r0, r0, #1
34817188:	e1500003 	cmp	r0, r3
3481718c:	bafffff5 	blt	34817168 <onenand_memory_bbt+0xd4>
34817190:	e1a0c00a 	mov	ip, sl
34817194:	ea00000c 	b	348171cc <onenand_memory_bbt+0x138>
34817198:	e1a0c00a 	mov	ip, sl
			if (ret == ONENAND_BBT_READ_FATAL_ERROR)
				return -EIO;

			if (ret || check_short_pattern
			    (&buf[j * scanlen], scanlen, mtd->writesize, bd)) {
				bbm->bbt[i >> 3] |= 0x03 << (i & 0x6);
3481719c:	e596300c 	ldr	r3, [r6, #12]
348171a0:	e2041006 	and	r1, r4, #6
348171a4:	e7d321c4 	ldrb	r2, [r3, r4, asr #3]
348171a8:	e3a00003 	mov	r0, #3
348171ac:	e1822110 	orr	r2, r2, r0, lsl r1
348171b0:	e7c321c4 	strb	r2, [r3, r4, asr #3]
				printk(KERN_WARNING
348171b4:	e59f0098 	ldr	r0, [pc, #152]	; 34817254 <onenand_memory_bbt+0x1c0>
348171b8:	e1a010c4 	asr	r1, r4, #1
348171bc:	e59d2010 	ldr	r2, [sp, #16]
348171c0:	e58dc00c 	str	ip, [sp, #12]
348171c4:	ebffc7e6 	bl	34809164 <printf>
348171c8:	e59dc00c 	ldr	ip, [sp, #12]
				break;
			}
		}
		i += 2;

		if (FLEXONENAND(this)) {
348171cc:	e59c301c 	ldr	r3, [ip, #28]
				       "Bad eraseblock %d at 0x%08x\n", i >> 1,
				       (unsigned int)from);
				break;
			}
		}
		i += 2;
348171d0:	e2844002 	add	r4, r4, #2

		if (FLEXONENAND(this)) {
348171d4:	e3130c02 	tst	r3, #512	; 0x200
348171d8:	0a00000d 	beq	34817214 <onenand_memory_bbt+0x180>
			rgn = flexonenand_region(mtd, from);
348171dc:	e1cd21d0 	ldrd	r2, [sp, #16]
348171e0:	e1a00007 	mov	r0, r7
348171e4:	e58dc00c 	str	ip, [sp, #12]
348171e8:	ebfff8a1 	bl	34815474 <flexonenand_region>
			from += mtd->eraseregions[rgn].erasesize;
348171ec:	e1cda1d0 	ldrd	sl, [sp, #16]
348171f0:	e5973030 	ldr	r3, [r7, #48]	; 0x30
348171f4:	e3a01018 	mov	r1, #24
348171f8:	e0233091 	mla	r3, r1, r0, r3
348171fc:	e5933008 	ldr	r3, [r3, #8]
34817200:	e59dc00c 	ldr	ip, [sp, #12]
34817204:	e09aa003 	adds	sl, sl, r3
34817208:	e2abb000 	adc	fp, fp, #0
3481720c:	e1cda1f0 	strd	sl, [sp, #16]
34817210:	ea000006 	b	34817230 <onenand_memory_bbt+0x19c>
		} else
			from += (1 << bbm->bbt_erase_shift);
34817214:	e5963000 	ldr	r3, [r6]
34817218:	e3a0b001 	mov	fp, #1
3481721c:	e1a0331b 	lsl	r3, fp, r3
34817220:	e1cd01d0 	ldrd	r0, [sp, #16]
34817224:	e0900003 	adds	r0, r0, r3
34817228:	e0a11fc3 	adc	r1, r1, r3, asr #31
3481722c:	e1cd01f0 	strd	r0, [sp, #16]
	ops.mode = MTD_OOB_PLACE;
	ops.ooblen = readlen;
	ops.oobbuf = buf;
	ops.len = ops.ooboffs = ops.retlen = ops.oobretlen = 0;

	for (i = startblock; i < numblocks;) {
34817230:	e1540009 	cmp	r4, r9
34817234:	baffffb7 	blt	34817118 <onenand_memory_bbt+0x84>
			from += mtd->eraseregions[rgn].erasesize;
		} else
			from += (1 << bbm->bbt_erase_shift);
	}

	return 0;
34817238:	e3a00000 	mov	r0, #0
3481723c:	ea000000 	b	34817244 <onenand_memory_bbt+0x1b0>
					     from + j * mtd->writesize +
					     bd->offs, &ops);

			/* If it is a initial bad block, just ignore it */
			if (ret == ONENAND_BBT_READ_FATAL_ERROR)
				return -EIO;
34817240:	e3e00004 	mvn	r0, #4
{
	unsigned char data_buf[MAX_ONENAND_PAGESIZE];

	bd->options &= ~NAND_BBT_SCANEMPTY;
	return create_bbt(mtd, data_buf, bd, -1);
}
34817244:	e28dd0b8 	add	sp, sp, #184	; 0xb8
34817248:	e28dda01 	add	sp, sp, #4096	; 0x1000
3481724c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34817250:	34827c80 	.word	0x34827c80
34817254:	34827ca0 	.word	0x34827ca0

34817258 <onenand_scan_bbt>:
 * The bad block table memory is allocated here. It must be freed
 * by calling the onenand_free_bbt function.
 *
 */
int onenand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
34817258:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	struct onenand_chip *this = mtd->priv;
3481725c:	e5905094 	ldr	r5, [r0, #148]	; 0x94
 * The bad block table memory is allocated here. It must be freed
 * by calling the onenand_free_bbt function.
 *
 */
int onenand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
34817260:	e1a06000 	mov	r6, r0
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
	int len, ret = 0;

	len = this->chipsize >> (this->erase_shift + 2);
34817264:	e595a030 	ldr	sl, [r5, #48]	; 0x30
34817268:	e5953018 	ldr	r3, [r5, #24]
3481726c:	e28aa002 	add	sl, sl, #2
34817270:	e1a0aa33 	lsr	sl, r3, sl
	/* Allocate memory (2bit per block) */
	bbm->bbt = malloc(len);
34817274:	e1a0000a 	mov	r0, sl
 *
 */
int onenand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm = this->bbm;
34817278:	e59540a0 	ldr	r4, [r5, #160]	; 0xa0
 * The bad block table memory is allocated here. It must be freed
 * by calling the onenand_free_bbt function.
 *
 */
int onenand_scan_bbt(struct mtd_info *mtd, struct nand_bbt_descr *bd)
{
3481727c:	e1a07001 	mov	r7, r1
	struct bbm_info *bbm = this->bbm;
	int len, ret = 0;

	len = this->chipsize >> (this->erase_shift + 2);
	/* Allocate memory (2bit per block) */
	bbm->bbt = malloc(len);
34817280:	ebffc97e 	bl	34809880 <malloc>
	if (!bbm->bbt) {
34817284:	e3500000 	cmp	r0, #0
	struct bbm_info *bbm = this->bbm;
	int len, ret = 0;

	len = this->chipsize >> (this->erase_shift + 2);
	/* Allocate memory (2bit per block) */
	bbm->bbt = malloc(len);
34817288:	e584000c 	str	r0, [r4, #12]
	if (!bbm->bbt) {
3481728c:	1a000003 	bne	348172a0 <onenand_scan_bbt+0x48>
		printk(KERN_ERR "onenand_scan_bbt: Out of memory\n");
34817290:	e59f0068 	ldr	r0, [pc, #104]	; 34817300 <onenand_scan_bbt+0xa8>
34817294:	ebffc7b2 	bl	34809164 <printf>
		return -ENOMEM;
34817298:	e3e0500b 	mvn	r5, #11
3481729c:	ea000015 	b	348172f8 <onenand_scan_bbt+0xa0>
	}
	/* Clear the memory bad block table */
	memset(bbm->bbt, 0x00, len);
348172a0:	e3a01000 	mov	r1, #0
348172a4:	e1a0200a 	mov	r2, sl
348172a8:	eb001305 	bl	3481bec4 <memset>

	/* Set the bad block position */
	bbm->badblockpos = ONENAND_BADBLOCK_POS;
348172ac:	e3a03000 	mov	r3, #0
348172b0:	e5843004 	str	r3, [r4, #4]

	/* Set erase shift */
	bbm->bbt_erase_shift = this->erase_shift;
348172b4:	e5953030 	ldr	r3, [r5, #48]	; 0x30

	if (!bbm->isbad_bbt)
		bbm->isbad_bbt = onenand_isbad_bbt;

	/* Scan the device to build a memory based bad block table */
	if ((ret = onenand_memory_bbt(mtd, bd))) {
348172b8:	e1a00006 	mov	r0, r6

	/* Set the bad block position */
	bbm->badblockpos = ONENAND_BADBLOCK_POS;

	/* Set erase shift */
	bbm->bbt_erase_shift = this->erase_shift;
348172bc:	e5843000 	str	r3, [r4]

	if (!bbm->isbad_bbt)
348172c0:	e5943010 	ldr	r3, [r4, #16]
		bbm->isbad_bbt = onenand_isbad_bbt;

	/* Scan the device to build a memory based bad block table */
	if ((ret = onenand_memory_bbt(mtd, bd))) {
348172c4:	e1a01007 	mov	r1, r7
	bbm->badblockpos = ONENAND_BADBLOCK_POS;

	/* Set erase shift */
	bbm->bbt_erase_shift = this->erase_shift;

	if (!bbm->isbad_bbt)
348172c8:	e3530000 	cmp	r3, #0
		bbm->isbad_bbt = onenand_isbad_bbt;
348172cc:	059f3030 	ldreq	r3, [pc, #48]	; 34817304 <onenand_scan_bbt+0xac>
348172d0:	05843010 	streq	r3, [r4, #16]

	/* Scan the device to build a memory based bad block table */
	if ((ret = onenand_memory_bbt(mtd, bd))) {
348172d4:	ebffff6e 	bl	34817094 <onenand_memory_bbt>
348172d8:	e2505000 	subs	r5, r0, #0
348172dc:	0a000005 	beq	348172f8 <onenand_scan_bbt+0xa0>
		printk(KERN_ERR
348172e0:	e59f0020 	ldr	r0, [pc, #32]	; 34817308 <onenand_scan_bbt+0xb0>
348172e4:	ebffc79e 	bl	34809164 <printf>
		       "onenand_scan_bbt: Can't scan flash and build the RAM-based BBT\n");
		free(bbm->bbt);
348172e8:	e594000c 	ldr	r0, [r4, #12]
348172ec:	ebffc8da 	bl	3480965c <free>
		bbm->bbt = NULL;
348172f0:	e3a03000 	mov	r3, #0
348172f4:	e584300c 	str	r3, [r4, #12]
	}

	return ret;
}
348172f8:	e1a00005 	mov	r0, r5
348172fc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34817300:	34827cbd 	.word	0x34827cbd
34817304:	34817048 	.word	0x34817048
34817308:	34827cde 	.word	0x34827cde

3481730c <onenand_default_bbt>:
 *
 * This function selects the default bad block table
 * support for the device and calls the onenand_scan_bbt function
 */
int onenand_default_bbt(struct mtd_info *mtd)
{
3481730c:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = mtd->priv;
34817310:	e5906094 	ldr	r6, [r0, #148]	; 0x94
 *
 * This function selects the default bad block table
 * support for the device and calls the onenand_scan_bbt function
 */
int onenand_default_bbt(struct mtd_info *mtd)
{
34817314:	e1a05000 	mov	r5, r0
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm;

	this->bbm = malloc(sizeof(struct bbm_info));
34817318:	e3a0001c 	mov	r0, #28
3481731c:	ebffc957 	bl	34809880 <malloc>
	if (!this->bbm)
34817320:	e3500000 	cmp	r0, #0
int onenand_default_bbt(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	struct bbm_info *bbm;

	this->bbm = malloc(sizeof(struct bbm_info));
34817324:	e1a04000 	mov	r4, r0
34817328:	e58600a0 	str	r0, [r6, #160]	; 0xa0
	if (!this->bbm)
3481732c:	0a00000a 	beq	3481735c <onenand_default_bbt+0x50>
		return -ENOMEM;

	bbm = this->bbm;

	memset(bbm, 0, sizeof(struct bbm_info));
34817330:	e3a01000 	mov	r1, #0
34817334:	e3a0201c 	mov	r2, #28
34817338:	eb0012e1 	bl	3481bec4 <memset>

	/* 1KB page has same configuration as 2KB page */
	if (!bbm->badblock_pattern)
3481733c:	e5943014 	ldr	r3, [r4, #20]
		bbm->badblock_pattern = &largepage_memorybased;

	return onenand_scan_bbt(mtd, bbm->badblock_pattern);
34817340:	e1a00005 	mov	r0, r5
	bbm = this->bbm;

	memset(bbm, 0, sizeof(struct bbm_info));

	/* 1KB page has same configuration as 2KB page */
	if (!bbm->badblock_pattern)
34817344:	e3530000 	cmp	r3, #0
		bbm->badblock_pattern = &largepage_memorybased;
34817348:	059f3014 	ldreq	r3, [pc, #20]	; 34817364 <onenand_default_bbt+0x58>
3481734c:	05843014 	streq	r3, [r4, #20]

	return onenand_scan_bbt(mtd, bbm->badblock_pattern);
34817350:	e5941014 	ldr	r1, [r4, #20]
}
34817354:	e8bd4070 	pop	{r4, r5, r6, lr}

	/* 1KB page has same configuration as 2KB page */
	if (!bbm->badblock_pattern)
		bbm->badblock_pattern = &largepage_memorybased;

	return onenand_scan_bbt(mtd, bbm->badblock_pattern);
34817358:	eaffffbe 	b	34817258 <onenand_scan_bbt>
}
3481735c:	e3e0000b 	mvn	r0, #11
34817360:	e8bd8070 	pop	{r4, r5, r6, pc}
34817364:	34829200 	.word	0x34829200

34817368 <s3c_read_cmd>:

static struct s3c_onenand *onenand;

static int s3c_read_cmd(unsigned int cmd)
{
	return readl(onenand->ahb_addr + cmd);
34817368:	e59f300c 	ldr	r3, [pc, #12]	; 3481737c <s3c_read_cmd+0x14>
3481736c:	e5933000 	ldr	r3, [r3]
34817370:	e5933008 	ldr	r3, [r3, #8]
34817374:	e7930000 	ldr	r0, [r3, r0]
}
34817378:	e12fff1e 	bx	lr
3481737c:	3482bc10 	.word	0x3482bc10

34817380 <s3c_write_cmd>:

static void s3c_write_cmd(int value, unsigned int cmd)
{
	writel(value, onenand->ahb_addr + cmd);
34817380:	e59f300c 	ldr	r3, [pc, #12]	; 34817394 <s3c_write_cmd+0x14>
34817384:	e5933000 	ldr	r3, [r3]
34817388:	e5933008 	ldr	r3, [r3, #8]
3481738c:	e7830001 	str	r0, [r3, r1]
}
34817390:	e12fff1e 	bx	lr
34817394:	3482bc10 	.word	0x3482bc10

34817398 <s3c_mem_addr>:
	return (fba << 12) | (fpa << 6) | (fsa << 4);
}
#elif defined(CONFIG_S5P)
static unsigned int s3c_mem_addr(int fba, int fpa, int fsa)
{
	return (fba << 13) | (fpa << 7) | (fsa << 5);
34817398:	e1a00680 	lsl	r0, r0, #13
3481739c:	e1800381 	orr	r0, r0, r1, lsl #7
}
348173a0:	e1800282 	orr	r0, r0, r2, lsl #5
348173a4:	e12fff1e 	bx	lr

348173a8 <s3c_onenand_reset>:
static void s3c_onenand_reset(void)
{
	unsigned long timeout = 0x10000;
	int stat;

	writel(ONENAND_MEM_RESET_COLD, &onenand->reg->mem_reset);
348173a8:	e59f206c 	ldr	r2, [pc, #108]	; 3481741c <s3c_onenand_reset+0x74>
348173ac:	e3a01002 	mov	r1, #2
348173b0:	e5923000 	ldr	r3, [r2]
348173b4:	e593301c 	ldr	r3, [r3, #28]
348173b8:	e5831020 	str	r1, [r3, #32]
}
#endif

static void s3c_onenand_reset(void)
{
	unsigned long timeout = 0x10000;
348173bc:	e3a03801 	mov	r3, #65536	; 0x10000
	int stat;

	writel(ONENAND_MEM_RESET_COLD, &onenand->reg->mem_reset);
	while (timeout--) {
348173c0:	ea000004 	b	348173d8 <s3c_onenand_reset+0x30>
		stat = readl(&onenand->reg->int_err_stat);
348173c4:	e5921000 	ldr	r1, [r2]
348173c8:	e591101c 	ldr	r1, [r1, #28]
348173cc:	e5911030 	ldr	r1, [r1, #48]	; 0x30
		if (stat & RST_CMP)
348173d0:	e3110a01 	tst	r1, #4096	; 0x1000
348173d4:	1a000001 	bne	348173e0 <s3c_onenand_reset+0x38>
{
	unsigned long timeout = 0x10000;
	int stat;

	writel(ONENAND_MEM_RESET_COLD, &onenand->reg->mem_reset);
	while (timeout--) {
348173d8:	e2533001 	subs	r3, r3, #1
348173dc:	2afffff8 	bcs	348173c4 <s3c_onenand_reset+0x1c>
		stat = readl(&onenand->reg->int_err_stat);
		if (stat & RST_CMP)
			break;
	}
	stat = readl(&onenand->reg->int_err_stat);
348173e0:	e59f3034 	ldr	r3, [pc, #52]	; 3481741c <s3c_onenand_reset+0x74>
348173e4:	e5932000 	ldr	r2, [r3]
348173e8:	e592201c 	ldr	r2, [r2, #28]
348173ec:	e5921030 	ldr	r1, [r2, #48]	; 0x30
	writel(stat, &onenand->reg->int_err_ack);
348173f0:	e5932000 	ldr	r2, [r3]
348173f4:	e592201c 	ldr	r2, [r2, #28]
348173f8:	e5821050 	str	r1, [r2, #80]	; 0x50

	/* Clear interrupt */
	writel(0x0, &onenand->reg->int_err_ack);
348173fc:	e5932000 	ldr	r2, [r3]
34817400:	e592101c 	ldr	r1, [r2, #28]
34817404:	e3a02000 	mov	r2, #0
34817408:	e5812050 	str	r2, [r1, #80]	; 0x50
	/* Clear the ECC status */
	writel(0x0, &onenand->reg->ecc_err_stat);
3481740c:	e5933000 	ldr	r3, [r3]
34817410:	e593301c 	ldr	r3, [r3, #28]
34817414:	e5832060 	str	r2, [r3, #96]	; 0x60
}
34817418:	e12fff1e 	bx	lr
3481741c:	3482bc10 	.word	0x3482bc10

34817420 <s3c_onenand_command>:
	return 0;
}

static int s3c_onenand_command(struct mtd_info *mtd, int cmd,
		loff_t addr, size_t len)
{
34817420:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
	struct onenand_chip *this = mtd->priv;
34817424:	e5906094 	ldr	r6, [r0, #148]	; 0x94
	return 0;
}

static int s3c_onenand_command(struct mtd_info *mtd, int cmd,
		loff_t addr, size_t len)
{
34817428:	e1cd20f0 	strd	r2, [sp]
3481742c:	e1a04001 	mov	r4, r1
34817430:	e1a05000 	mov	r5, r0
	unsigned int mem_addr;
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
34817434:	e1a01003 	mov	r1, r3
34817438:	e1a00002 	mov	r0, r2
3481743c:	e5962034 	ldr	r2, [r6, #52]	; 0x34
34817440:	eb0022f0 	bl	34820008 <__ashrdi3>
	fpa &= this->page_mask;

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
34817444:	e59f3230 	ldr	r3, [pc, #560]	; 3481767c <s3c_onenand_command+0x25c>
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;
34817448:	e596703c 	ldr	r7, [r6, #60]	; 0x3c

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
3481744c:	e593a000 	ldr	sl, [r3]
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;
34817450:	e0077000 	and	r7, r7, r0
	int fba, fpa, fsa = 0;
	unsigned int mem_addr;
	int i, mcount, scount;
	int index;

	fba = (int) (addr >> this->erase_shift);
34817454:	e5962030 	ldr	r2, [r6, #48]	; 0x30
34817458:	e1cd00d0 	ldrd	r0, [sp]
3481745c:	eb0022e9 	bl	34820008 <__ashrdi3>
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
34817460:	e1a01007 	mov	r1, r7
34817464:	e59a3018 	ldr	r3, [sl, #24]
34817468:	e3a02000 	mov	r2, #0
3481746c:	e12fff33 	blx	r3

	switch (cmd) {
34817470:	e3540013 	cmp	r4, #19

	fba = (int) (addr >> this->erase_shift);
	fpa = (int) (addr >> this->page_shift);
	fpa &= this->page_mask;

	mem_addr = onenand->mem_addr(fba, fpa, fsa);
34817474:	e1a07000 	mov	r7, r0

	switch (cmd) {
34817478:	0a000004 	beq	34817490 <s3c_onenand_command+0x70>
3481747c:	e3013978 	movw	r3, #6520	; 0x1978
34817480:	e1540003 	cmp	r4, r3
34817484:	0a000001 	beq	34817490 <s3c_onenand_command+0x70>
34817488:	e3540000 	cmp	r4, #0
3481748c:	1a000002 	bne	3481749c <s3c_onenand_command+0x7c>
	case ONENAND_CMD_READ:
	case ONENAND_CMD_READOOB:
	case ONENAND_CMD_BUFFERRAM:
		ONENAND_SET_NEXT_BUFFERRAM(this);
34817490:	e5963044 	ldr	r3, [r6, #68]	; 0x44
34817494:	e2233001 	eor	r3, r3, #1
34817498:	e5863044 	str	r3, [r6, #68]	; 0x44
	index = ONENAND_CURRENT_BUFFERRAM(this);

	/*
	 * Emulate Two BufferRAMs and access with 4 bytes pointer
	 */
	m = (unsigned int *) onenand->page_buf;
3481749c:	e59f31d8 	ldr	r3, [pc, #472]	; 3481767c <s3c_onenand_command+0x25c>
348174a0:	e5933000 	ldr	r3, [r3]
348174a4:	e593a010 	ldr	sl, [r3, #16]
	s = (unsigned int *) onenand->oob_buf;
348174a8:	e5939014 	ldr	r9, [r3, #20]

	if (index) {
348174ac:	e5963044 	ldr	r3, [r6, #68]	; 0x44
348174b0:	e3530000 	cmp	r3, #0
348174b4:	0a000005 	beq	348174d0 <s3c_onenand_command+0xb0>
		m += (this->writesize >> 2);
348174b8:	e5963040 	ldr	r3, [r6, #64]	; 0x40
348174bc:	e3c33003 	bic	r3, r3, #3
348174c0:	e08aa003 	add	sl, sl, r3
		s += (mtd->oobsize >> 2);
348174c4:	e5953018 	ldr	r3, [r5, #24]
348174c8:	e3c33003 	bic	r3, r3, #3
348174cc:	e0899003 	add	r9, r9, r3
	}

	mcount = mtd->writesize >> 2;
348174d0:	e5956014 	ldr	r6, [r5, #20]
	scount = mtd->oobsize >> 2;
348174d4:	e5955018 	ldr	r5, [r5, #24]

	switch (cmd) {
348174d8:	e3540027 	cmp	r4, #39	; 0x27
	if (index) {
		m += (this->writesize >> 2);
		s += (mtd->oobsize >> 2);
	}

	mcount = mtd->writesize >> 2;
348174dc:	e1a06126 	lsr	r6, r6, #2
	scount = mtd->oobsize >> 2;
348174e0:	e1a05125 	lsr	r5, r5, #2

	switch (cmd) {
348174e4:	0a000059 	beq	34817650 <s3c_onenand_command+0x230>
348174e8:	ca000007 	bgt	3481750c <s3c_onenand_command+0xec>
348174ec:	e3540013 	cmp	r4, #19
348174f0:	0a00001a 	beq	34817560 <s3c_onenand_command+0x140>
348174f4:	e354001a 	cmp	r4, #26
348174f8:	0a000037 	beq	348175dc <s3c_onenand_command+0x1bc>
348174fc:	e3540000 	cmp	r4, #0
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817500:	03877301 	orreq	r7, r7, #67108864	; 0x4000000
	}

	mcount = mtd->writesize >> 2;
	scount = mtd->oobsize >> 2;

	switch (cmd) {
34817504:	0a000012 	beq	34817554 <s3c_onenand_command+0x134>
34817508:	ea000059 	b	34817674 <s3c_onenand_command+0x254>
3481750c:	e3540080 	cmp	r4, #128	; 0x80
34817510:	0a000008 	beq	34817538 <s3c_onenand_command+0x118>
34817514:	ca000002 	bgt	34817524 <s3c_onenand_command+0x104>
34817518:	e3540071 	cmp	r4, #113	; 0x71
3481751c:	1a000054 	bne	34817674 <s3c_onenand_command+0x254>
34817520:	ea000050 	b	34817668 <s3c_onenand_command+0x248>
34817524:	e3540094 	cmp	r4, #148	; 0x94
34817528:	0a00004a 	beq	34817658 <s3c_onenand_command+0x238>
3481752c:	e3540095 	cmp	r4, #149	; 0x95
34817530:	1a00004f 	bne	34817674 <s3c_onenand_command+0x254>
34817534:	ea000049 	b	34817660 <s3c_onenand_command+0x240>
34817538:	e3a04000 	mov	r4, #0
		return 0;

	case ONENAND_CMD_PROG:
		/* Main */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
3481753c:	e3877301 	orr	r7, r7, #67108864	; 0x4000000
34817540:	ea000022 	b	348175d0 <s3c_onenand_command+0x1b0>

	switch (cmd) {
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817544:	e1a00007 	mov	r0, r7
34817548:	ebffff86 	bl	34817368 <s3c_read_cmd>
	scount = mtd->oobsize >> 2;

	switch (cmd) {
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
3481754c:	e2844001 	add	r4, r4, #1
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817550:	e48a0004 	str	r0, [sl], #4
	scount = mtd->oobsize >> 2;

	switch (cmd) {
	case ONENAND_CMD_READ:
		/* Main */
		for (i = 0; i < mcount; i++)
34817554:	e1540006 	cmp	r4, r6
34817558:	bafffff9 	blt	34817544 <s3c_onenand_command+0x124>
3481755c:	ea000044 	b	34817674 <s3c_onenand_command+0x254>
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34817560:	e59f3114 	ldr	r3, [pc, #276]	; 3481767c <s3c_onenand_command+0x25c>
34817564:	e3a02001 	mov	r2, #1
34817568:	e5933000 	ldr	r3, [r3]
		/* Main */
		for (i = 0; i < mcount; i++)
3481756c:	e3a04000 	mov	r4, #0
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34817570:	e593301c 	ldr	r3, [r3, #28]
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817574:	e387b301 	orr	fp, r7, #67108864	; 0x4000000
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
34817578:	e5832140 	str	r2, [r3, #320]	; 0x140
		/* Main */
		for (i = 0; i < mcount; i++)
3481757c:	ea000003 	b	34817590 <s3c_onenand_command+0x170>
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
34817580:	e1a0000b 	mov	r0, fp
34817584:	ebffff77 	bl	34817368 <s3c_read_cmd>
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
		/* Main */
		for (i = 0; i < mcount; i++)
34817588:	e2844001 	add	r4, r4, #1
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
3481758c:	e48a0004 	str	r0, [sl], #4
		return 0;

	case ONENAND_CMD_READOOB:
		writel(TSRF, &onenand->reg->trans_spare);
		/* Main */
		for (i = 0; i < mcount; i++)
34817590:	e1540006 	cmp	r4, r6
34817594:	bafffff9 	blt	34817580 <s3c_onenand_command+0x160>
34817598:	e3a04000 	mov	r4, #0
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
			*s++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
3481759c:	e3877301 	orr	r7, r7, #67108864	; 0x4000000
348175a0:	ea000003 	b	348175b4 <s3c_onenand_command+0x194>
348175a4:	e1a00007 	mov	r0, r7
348175a8:	ebffff6e 	bl	34817368 <s3c_read_cmd>
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
348175ac:	e2844001 	add	r4, r4, #1
			*s++ = s3c_read_cmd(CMD_MAP_01(mem_addr));
348175b0:	e4890004 	str	r0, [r9], #4
		/* Main */
		for (i = 0; i < mcount; i++)
			*m++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
348175b4:	e1540005 	cmp	r4, r5
348175b8:	bafffff9 	blt	348175a4 <s3c_onenand_command+0x184>
			*s++ = s3c_read_cmd(CMD_MAP_01(mem_addr));

		writel(0, &onenand->reg->trans_spare);
348175bc:	ea00001d 	b	34817638 <s3c_onenand_command+0x218>
		return 0;

	case ONENAND_CMD_PROG:
		/* Main */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
348175c0:	e49a0004 	ldr	r0, [sl], #4
348175c4:	e1a01007 	mov	r1, r7
348175c8:	ebffff6c 	bl	34817380 <s3c_write_cmd>
		writel(0, &onenand->reg->trans_spare);
		return 0;

	case ONENAND_CMD_PROG:
		/* Main */
		for (i = 0; i < mcount; i++)
348175cc:	e2844001 	add	r4, r4, #1
348175d0:	e1540006 	cmp	r4, r6
348175d4:	bafffff9 	blt	348175c0 <s3c_onenand_command+0x1a0>
348175d8:	ea000025 	b	34817674 <s3c_onenand_command+0x254>
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);
348175dc:	e59f3098 	ldr	r3, [pc, #152]	; 3481767c <s3c_onenand_command+0x25c>
348175e0:	e3a02001 	mov	r2, #1
348175e4:	e5933000 	ldr	r3, [r3]

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
348175e8:	e3a04000 	mov	r4, #0
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);
348175ec:	e593301c 	ldr	r3, [r3, #28]

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));
348175f0:	e387a301 	orr	sl, r7, #67108864	; 0x4000000
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(*m++, CMD_MAP_01(mem_addr));
		return 0;

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);
348175f4:	e5832140 	str	r2, [r3, #320]	; 0x140

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
348175f8:	ea000003 	b	3481760c <s3c_onenand_command+0x1ec>
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));
348175fc:	e3e00000 	mvn	r0, #0
34817600:	e1a0100a 	mov	r1, sl
34817604:	ebffff5d 	bl	34817380 <s3c_write_cmd>

	case ONENAND_CMD_PROGOOB:
		writel(TSRF, &onenand->reg->trans_spare);

		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
34817608:	e2844001 	add	r4, r4, #1
3481760c:	e1540006 	cmp	r4, r6
34817610:	bafffff9 	blt	348175fc <s3c_onenand_command+0x1dc>
34817614:	e3a04000 	mov	r4, #0
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
			s3c_write_cmd(*s++, CMD_MAP_01(mem_addr));
34817618:	e3877301 	orr	r7, r7, #67108864	; 0x4000000
3481761c:	ea000003 	b	34817630 <s3c_onenand_command+0x210>
34817620:	e4990004 	ldr	r0, [r9], #4
34817624:	e1a01007 	mov	r1, r7
34817628:	ebffff54 	bl	34817380 <s3c_write_cmd>
		/* Main - dummy write */
		for (i = 0; i < mcount; i++)
			s3c_write_cmd(0xffffffff, CMD_MAP_01(mem_addr));

		/* Spare */
		for (i = 0; i < scount; i++)
3481762c:	e2844001 	add	r4, r4, #1
34817630:	e1540005 	cmp	r4, r5
34817634:	bafffff9 	blt	34817620 <s3c_onenand_command+0x200>
			s3c_write_cmd(*s++, CMD_MAP_01(mem_addr));

		writel(0, &onenand->reg->trans_spare);
34817638:	e59f303c 	ldr	r3, [pc, #60]	; 3481767c <s3c_onenand_command+0x25c>
3481763c:	e3a02000 	mov	r2, #0
34817640:	e5933000 	ldr	r3, [r3]
34817644:	e593301c 	ldr	r3, [r3, #28]
34817648:	e5832140 	str	r2, [r3, #320]	; 0x140
		return 0;
3481764c:	ea000008 	b	34817674 <s3c_onenand_command+0x254>

	case ONENAND_CMD_UNLOCK_ALL:
		s3c_write_cmd(ONENAND_UNLOCK_ALL, CMD_MAP_10(mem_addr));
34817650:	e3a0000e 	mov	r0, #14
34817654:	ea000004 	b	3481766c <s3c_onenand_command+0x24c>
		return 0;

	case ONENAND_CMD_ERASE:
		s3c_write_cmd(ONENAND_ERASE_START, CMD_MAP_10(mem_addr));
34817658:	e3a00003 	mov	r0, #3
3481765c:	ea000002 	b	3481766c <s3c_onenand_command+0x24c>
		return 0;

	case ONENAND_CMD_MULTIBLOCK_ERASE:
		s3c_write_cmd(ONENAND_MULTI_ERASE_SET, CMD_MAP_10(mem_addr));
34817660:	e3a00001 	mov	r0, #1
34817664:	ea000000 	b	3481766c <s3c_onenand_command+0x24c>
		return 0;

	case ONENAND_CMD_ERASE_VERIFY:
		s3c_write_cmd(ONENAND_ERASE_VERIFY, CMD_MAP_10(mem_addr));
34817668:	e3a00015 	mov	r0, #21
3481766c:	e3871302 	orr	r1, r7, #134217728	; 0x8000000
34817670:	ebffff42 	bl	34817380 <s3c_write_cmd>
	default:
		break;
	}

	return 0;
}
34817674:	e3a00000 	mov	r0, #0
34817678:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
3481767c:	3482bc10 	.word	0x3482bc10

34817680 <s3c_get_bufferram>:

static unsigned char *s3c_get_bufferram(struct mtd_info *mtd, int area)
{
	struct onenand_chip *this = mtd->priv;
34817680:	e590c094 	ldr	ip, [r0, #148]	; 0x94
	int index = ONENAND_CURRENT_BUFFERRAM(this);
	unsigned char *p;

	if (area == ONENAND_DATARAM) {
34817684:	e3510b01 	cmp	r1, #1024	; 0x400

	return 0;
}

static unsigned char *s3c_get_bufferram(struct mtd_info *mtd, int area)
{
34817688:	e1a03000 	mov	r3, r0
	struct onenand_chip *this = mtd->priv;
	int index = ONENAND_CURRENT_BUFFERRAM(this);
3481768c:	e59c2044 	ldr	r2, [ip, #68]	; 0x44
34817690:	e59f1030 	ldr	r1, [pc, #48]	; 348176c8 <s3c_get_bufferram+0x48>
	unsigned char *p;

	if (area == ONENAND_DATARAM) {
34817694:	1a000005 	bne	348176b0 <s3c_get_bufferram+0x30>
		p = (unsigned char *) onenand->page_buf;
34817698:	e5913000 	ldr	r3, [r1]
		if (index == 1)
3481769c:	e3520001 	cmp	r2, #1
	struct onenand_chip *this = mtd->priv;
	int index = ONENAND_CURRENT_BUFFERRAM(this);
	unsigned char *p;

	if (area == ONENAND_DATARAM) {
		p = (unsigned char *) onenand->page_buf;
348176a0:	e5930010 	ldr	r0, [r3, #16]
		if (index == 1)
			p += this->writesize;
348176a4:	059c3040 	ldreq	r3, [ip, #64]	; 0x40
348176a8:	00800003 	addeq	r0, r0, r3
348176ac:	e12fff1e 	bx	lr
	} else {
		p = (unsigned char *) onenand->oob_buf;
348176b0:	e5911000 	ldr	r1, [r1]
		if (index == 1)
348176b4:	e3520001 	cmp	r2, #1
	if (area == ONENAND_DATARAM) {
		p = (unsigned char *) onenand->page_buf;
		if (index == 1)
			p += this->writesize;
	} else {
		p = (unsigned char *) onenand->oob_buf;
348176b8:	e5910014 	ldr	r0, [r1, #20]
		if (index == 1)
			p += mtd->oobsize;
348176bc:	05933018 	ldreq	r3, [r3, #24]
348176c0:	00800003 	addeq	r0, r0, r3
	}

	return p;
}
348176c4:	e12fff1e 	bx	lr
348176c8:	3482bc10 	.word	0x3482bc10

348176cc <s3c_onenand_bbt_wait>:
	memcpy(p + offset, buffer, count);
	return 0;
}

static int s3c_onenand_bbt_wait(struct mtd_info *mtd, int state)
{
348176cc:	e92d4008 	push	{r3, lr}
	struct samsung_onenand *reg = (struct samsung_onenand *)onenand->base;
348176d0:	e59f3078 	ldr	r3, [pc, #120]	; 34817750 <s3c_onenand_bbt_wait+0x84>
348176d4:	e5933000 	ldr	r3, [r3]
348176d8:	e5932004 	ldr	r2, [r3, #4]
	unsigned int flags = INT_ACT | LOAD_CMP;
	unsigned int stat;
	unsigned long timeout = 0x10000;
348176dc:	e3a03801 	mov	r3, #65536	; 0x10000

	while (timeout--) {
348176e0:	ea000002 	b	348176f0 <s3c_onenand_bbt_wait+0x24>
		stat = readl(&reg->int_err_stat);
348176e4:	e5921030 	ldr	r1, [r2, #48]	; 0x30
		if (stat & flags)
348176e8:	e3110e41 	tst	r1, #1040	; 0x410
348176ec:	1a000001 	bne	348176f8 <s3c_onenand_bbt_wait+0x2c>
	struct samsung_onenand *reg = (struct samsung_onenand *)onenand->base;
	unsigned int flags = INT_ACT | LOAD_CMP;
	unsigned int stat;
	unsigned long timeout = 0x10000;

	while (timeout--) {
348176f0:	e2533001 	subs	r3, r3, #1
348176f4:	2afffffa 	bcs	348176e4 <s3c_onenand_bbt_wait+0x18>
		stat = readl(&reg->int_err_stat);
		if (stat & flags)
			break;
	}
	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
348176f8:	e59f3050 	ldr	r3, [pc, #80]	; 34817750 <s3c_onenand_bbt_wait+0x84>
348176fc:	e5932000 	ldr	r2, [r3]
34817700:	e592201c 	ldr	r2, [r2, #28]
34817704:	e5920030 	ldr	r0, [r2, #48]	; 0x30
	writel(stat, &onenand->reg->int_err_ack);
34817708:	e5933000 	ldr	r3, [r3]

	if (stat & LD_FAIL_ECC_ERR) {
3481770c:	e3100001 	tst	r0, #1
		if (stat & flags)
			break;
	}
	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
	writel(stat, &onenand->reg->int_err_ack);
34817710:	e593301c 	ldr	r3, [r3, #28]
34817714:	e5830050 	str	r0, [r3, #80]	; 0x50

	if (stat & LD_FAIL_ECC_ERR) {
34817718:	0a000002 	beq	34817728 <s3c_onenand_bbt_wait+0x5c>
		s3c_onenand_reset();
3481771c:	ebffff21 	bl	348173a8 <s3c_onenand_reset>
		return ONENAND_BBT_READ_ERROR;
34817720:	e3a00001 	mov	r0, #1
34817724:	e8bd8008 	pop	{r3, pc}
	}

	if (stat & LOAD_CMP) {
34817728:	e2100010 	ands	r0, r0, #16
3481772c:	08bd8008 	popeq	{r3, pc}
		int ecc = readl(&onenand->reg->ecc_err_stat);
34817730:	e5933060 	ldr	r3, [r3, #96]	; 0x60
		if (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {
34817734:	e3010010 	movw	r0, #4112	; 0x1010
34817738:	e0030000 	and	r0, r3, r0
3481773c:	e3500000 	cmp	r0, #0
34817740:	08bd8008 	popeq	{r3, pc}
			s3c_onenand_reset();
34817744:	ebffff17 	bl	348173a8 <s3c_onenand_reset>
			return ONENAND_BBT_READ_ERROR;
34817748:	e3a00001 	mov	r0, #1
		}
	}

	return 0;
}
3481774c:	e8bd8008 	pop	{r3, pc}
34817750:	3482bc10 	.word	0x3482bc10

34817754 <onenand_write_bufferram>:
}

static int onenand_write_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				   const unsigned char *buffer, int offset,
				   size_t count)
{
34817754:	e92d4008 	push	{r3, lr}
	unsigned char *p;

	p = s3c_get_bufferram(mtd, area);
34817758:	e59d1008 	ldr	r1, [sp, #8]
3481775c:	ebffffc7 	bl	34817680 <s3c_get_bufferram>
	memcpy(p + offset, buffer, count);
34817760:	e59d3010 	ldr	r3, [sp, #16]
34817764:	e59d100c 	ldr	r1, [sp, #12]
34817768:	e0800003 	add	r0, r0, r3
3481776c:	e59d2014 	ldr	r2, [sp, #20]
34817770:	eb0011f7 	bl	3481bf54 <memcpy>
	return 0;
}
34817774:	e3a00000 	mov	r0, #0
34817778:	e8bd8008 	pop	{r3, pc}

3481777c <onenand_read_bufferram>:
}

static int onenand_read_bufferram(struct mtd_info *mtd, loff_t addr, int area,
				  unsigned char *buffer, int offset,
				  size_t count)
{
3481777c:	e92d4008 	push	{r3, lr}
	unsigned char *p;

	p = s3c_get_bufferram(mtd, area);
34817780:	e59d1008 	ldr	r1, [sp, #8]
34817784:	ebffffbd 	bl	34817680 <s3c_get_bufferram>
	memcpy(buffer, p + offset, count);
34817788:	e59d1010 	ldr	r1, [sp, #16]
3481778c:	e59d2014 	ldr	r2, [sp, #20]
34817790:	e0801001 	add	r1, r0, r1
34817794:	e59d000c 	ldr	r0, [sp, #12]
34817798:	eb0011ed 	bl	3481bf54 <memcpy>
	return 0;
}
3481779c:	e3a00000 	mov	r0, #0
348177a0:	e8bd8008 	pop	{r3, pc}

348177a4 <s3c_onenand_wait>:
				__func__, stat);
		if (stat & LOCKED_BLK)
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
					__func__, stat);

		return -EIO;
348177a4:	e2411001 	sub	r1, r1, #1
348177a8:	e3510007 	cmp	r1, #7

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
348177ac:	e92d4038 	push	{r3, r4, r5, lr}
				__func__, stat);
		if (stat & LOCKED_BLK)
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
					__func__, stat);

		return -EIO;
348177b0:	959f30d8 	ldrls	r3, [pc, #216]	; 34817890 <s3c_onenand_wait+0xec>

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
348177b4:	e1a05000 	mov	r5, r0
				__func__, stat);
		if (stat & LOCKED_BLK)
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
					__func__, stat);

		return -EIO;
348177b8:	97932101 	ldrls	r2, [r3, r1, lsl #2]
348177bc:	9a000007 	bls	348177e0 <s3c_onenand_wait+0x3c>
348177c0:	ea000005 	b	348177dc <s3c_onenand_wait+0x38>
	default:
		break;
	}

	while (timeout--) {
		stat = readl(&onenand->reg->int_err_stat);
348177c4:	e5910000 	ldr	r0, [r1]
348177c8:	e590001c 	ldr	r0, [r0, #28]
348177cc:	e5900030 	ldr	r0, [r0, #48]	; 0x30
		if (stat & flags)
348177d0:	e1120000 	tst	r2, r0
348177d4:	0a000003 	beq	348177e8 <s3c_onenand_wait+0x44>
348177d8:	ea000004 	b	348177f0 <s3c_onenand_wait+0x4c>

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
348177dc:	e3a02b01 	mov	r2, #1024	; 0x400
	default:
		break;
	}

	while (timeout--) {
		stat = readl(&onenand->reg->int_err_stat);
348177e0:	e59f10ac 	ldr	r1, [pc, #172]	; 34817894 <s3c_onenand_wait+0xf0>

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
}

static int s3c_onenand_wait(struct mtd_info *mtd, int state)
{
348177e4:	e3a03601 	mov	r3, #1048576	; 0x100000
		break;
	default:
		break;
	}

	while (timeout--) {
348177e8:	e2533001 	subs	r3, r3, #1
348177ec:	2afffff4 	bcs	348177c4 <s3c_onenand_wait+0x20>
		if (stat & flags)
			break;
	}

	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
348177f0:	e59f309c 	ldr	r3, [pc, #156]	; 34817894 <s3c_onenand_wait+0xf0>
348177f4:	e5932000 	ldr	r2, [r3]
348177f8:	e592201c 	ldr	r2, [r2, #28]
348177fc:	e5924030 	ldr	r4, [r2, #48]	; 0x30
	writel(stat, &onenand->reg->int_err_ack);
34817800:	e5933000 	ldr	r3, [r3]
	/*
	 * In the Spec. it checks the controller status first
	 * However if you get the correct information in case of
	 * power off recovery (POR) test, it should read ECC status first
	 */
	if (stat & LOAD_CMP) {
34817804:	e3140010 	tst	r4, #16
			break;
	}

	/* To get correct interrupt status in timeout case */
	stat = readl(&onenand->reg->int_err_stat);
	writel(stat, &onenand->reg->int_err_ack);
34817808:	e593301c 	ldr	r3, [r3, #28]
3481780c:	e5834050 	str	r4, [r3, #80]	; 0x50
	/*
	 * In the Spec. it checks the controller status first
	 * However if you get the correct information in case of
	 * power off recovery (POR) test, it should read ECC status first
	 */
	if (stat & LOAD_CMP) {
34817810:	0a00000c 	beq	34817848 <s3c_onenand_wait+0xa4>
		ecc = readl(&onenand->reg->ecc_err_stat);
34817814:	e5932060 	ldr	r2, [r3, #96]	; 0x60
		if (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {
34817818:	e3013010 	movw	r3, #4112	; 0x1010
3481781c:	e0023003 	and	r3, r2, r3
34817820:	e3530000 	cmp	r3, #0
34817824:	0a000007 	beq	34817848 <s3c_onenand_wait+0xa4>
			printk(KERN_INFO "%s: ECC error = 0x%04x\n",
34817828:	e59f0068 	ldr	r0, [pc, #104]	; 34817898 <s3c_onenand_wait+0xf4>
3481782c:	e59f1068 	ldr	r1, [pc, #104]	; 3481789c <s3c_onenand_wait+0xf8>
34817830:	ebffc64b 	bl	34809164 <printf>
					__func__, ecc);
			mtd->ecc_stats.failed++;
34817834:	e5953084 	ldr	r3, [r5, #132]	; 0x84
			return -EBADMSG;
34817838:	e3e00049 	mvn	r0, #73	; 0x49
	if (stat & LOAD_CMP) {
		ecc = readl(&onenand->reg->ecc_err_stat);
		if (ecc & ONENAND_ECC_4BIT_UNCORRECTABLE) {
			printk(KERN_INFO "%s: ECC error = 0x%04x\n",
					__func__, ecc);
			mtd->ecc_stats.failed++;
3481783c:	e2833001 	add	r3, r3, #1
34817840:	e5853084 	str	r3, [r5, #132]	; 0x84
			return -EBADMSG;
34817844:	e8bd8038 	pop	{r3, r4, r5, pc}
		}
	}

	if (stat & (LOCKED_BLK | ERS_FAIL | PGM_FAIL | LD_FAIL_ECC_ERR)) {
34817848:	e300010d 	movw	r0, #269	; 0x10d
3481784c:	e0040000 	and	r0, r4, r0
34817850:	e3500000 	cmp	r0, #0
34817854:	08bd8038 	popeq	{r3, r4, r5, pc}
		printk(KERN_INFO "%s: controller error = 0x%04x\n",
34817858:	e59f0040 	ldr	r0, [pc, #64]	; 348178a0 <s3c_onenand_wait+0xfc>
3481785c:	e59f1038 	ldr	r1, [pc, #56]	; 3481789c <s3c_onenand_wait+0xf8>
34817860:	e1a02004 	mov	r2, r4
34817864:	ebffc63e 	bl	34809164 <printf>
				__func__, stat);
		if (stat & LOCKED_BLK)
34817868:	e3140c01 	tst	r4, #256	; 0x100
3481786c:	0a000005 	beq	34817888 <s3c_onenand_wait+0xe4>
			printk(KERN_INFO "%s: it's locked error = 0x%04x\n",
34817870:	e59f002c 	ldr	r0, [pc, #44]	; 348178a4 <s3c_onenand_wait+0x100>
34817874:	e59f1020 	ldr	r1, [pc, #32]	; 3481789c <s3c_onenand_wait+0xf8>
34817878:	e1a02004 	mov	r2, r4
3481787c:	ebffc638 	bl	34809164 <printf>
					__func__, stat);

		return -EIO;
34817880:	e3e00004 	mvn	r0, #4
34817884:	e8bd8038 	pop	{r3, r4, r5, pc}
34817888:	e3e00004 	mvn	r0, #4
	}

	return 0;
}
3481788c:	e8bd8038 	pop	{r3, r4, r5, pc}
34817890:	34821520 	.word	0x34821520
34817894:	3482bc10 	.word	0x3482bc10
34817898:	34827d1e 	.word	0x34827d1e
3481789c:	34821540 	.word	0x34821540
348178a0:	34827d36 	.word	0x34827d36
348178a4:	34827d55 	.word	0x34827d55

348178a8 <s3c_onenand_writew>:
	return value;
}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
348178a8:	e59f20c8 	ldr	r2, [pc, #200]	; 34817978 <s3c_onenand_writew+0xd0>
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
348178ac:	e92d4070 	push	{r4, r5, r6, lr}
	struct onenand_chip *this = onenand->mtd->priv;
348178b0:	e5923000 	ldr	r3, [r2]
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
348178b4:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = onenand->mtd->priv;
348178b8:	e5930000 	ldr	r0, [r3]
	int reg = addr - this->base;
348178bc:	e5900094 	ldr	r0, [r0, #148]	; 0x94
348178c0:	e5905000 	ldr	r5, [r0]
348178c4:	e0655001 	rsb	r5, r5, r1
	int word_addr = reg >> 1;

	/* It's used for probing time */
	switch (reg) {
348178c8:	e59f10ac 	ldr	r1, [pc, #172]	; 3481797c <s3c_onenand_writew+0xd4>
348178cc:	e1550001 	cmp	r5, r1
348178d0:	08bd8070 	popeq	{r4, r5, r6, pc}
348178d4:	ca000003 	bgt	348178e8 <s3c_onenand_writew+0x40>
348178d8:	e59f20a0 	ldr	r2, [pc, #160]	; 34817980 <s3c_onenand_writew+0xd8>
348178dc:	e1550002 	cmp	r5, r2
348178e0:	1a00000b 	bne	34817914 <s3c_onenand_writew+0x6c>
348178e4:	e8bd8070 	pop	{r4, r5, r6, pc}
348178e8:	e59f1094 	ldr	r1, [pc, #148]	; 34817984 <s3c_onenand_writew+0xdc>
348178ec:	e1550001 	cmp	r5, r1
348178f0:	0a000003 	beq	34817904 <s3c_onenand_writew+0x5c>
348178f4:	e59f208c 	ldr	r2, [pc, #140]	; 34817988 <s3c_onenand_writew+0xe0>
348178f8:	e1550002 	cmp	r5, r2
348178fc:	1a000004 	bne	34817914 <s3c_onenand_writew+0x6c>
34817900:	e8bd8070 	pop	{r4, r5, r6, pc}
	case ONENAND_REG_SYS_CFG1:
		writel(value, &onenand->reg->mem_cfg);
34817904:	e5923000 	ldr	r3, [r2]
34817908:	e593301c 	ldr	r3, [r3, #28]
3481790c:	e5834000 	str	r4, [r3]
		return;
34817910:	e8bd8070 	pop	{r4, r5, r6, pc}
	default:
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM) {
34817914:	e3550b01 	cmp	r5, #1024	; 0x400
34817918:	aa00000c 	bge	34817950 <s3c_onenand_writew+0xa8>
		if (value == ONENAND_CMD_READID) {
3481791c:	e3540090 	cmp	r4, #144	; 0x90
			onenand->bootram_command = 1;
34817920:	03a02001 	moveq	r2, #1
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM) {
		if (value == ONENAND_CMD_READID) {
34817924:	0a000007 	beq	34817948 <s3c_onenand_writew+0xa0>
			onenand->bootram_command = 1;
			return;
		}
		if (value == ONENAND_CMD_RESET) {
34817928:	e35400f0 	cmp	r4, #240	; 0xf0
3481792c:	1a000007 	bne	34817950 <s3c_onenand_writew+0xa8>
			writel(ONENAND_MEM_RESET_COLD,
34817930:	e59f3040 	ldr	r3, [pc, #64]	; 34817978 <s3c_onenand_writew+0xd0>
34817934:	e3a01002 	mov	r1, #2
34817938:	e5933000 	ldr	r3, [r3]
3481793c:	e593201c 	ldr	r2, [r3, #28]
34817940:	e5821020 	str	r1, [r2, #32]
					&onenand->reg->mem_reset);
			onenand->bootram_command = 0;
34817944:	e3a02000 	mov	r2, #0
34817948:	e583200c 	str	r2, [r3, #12]
3481794c:	e8bd8070 	pop	{r4, r5, r6, pc}

static void s3c_onenand_writew(unsigned short value, void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
	int reg = addr - this->base;
	int word_addr = reg >> 1;
34817950:	e1a050c5 	asr	r5, r5, #1
			onenand->bootram_command = 0;
			return;
		}
	}

	printk(KERN_INFO "s3c_onenand_writew: Illegal access"
34817954:	e1a01005 	mov	r1, r5
34817958:	e1a02004 	mov	r2, r4
3481795c:	e59f0028 	ldr	r0, [pc, #40]	; 3481798c <s3c_onenand_writew+0xe4>
34817960:	ebffc5ff 	bl	34809164 <printf>
		" at reg 0x%x, value 0x%x\n", word_addr, value);

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
34817964:	e1a01105 	lsl	r1, r5, #2
34817968:	e1a00004 	mov	r0, r4
3481796c:	e3811303 	orr	r1, r1, #201326592	; 0xc000000
}
34817970:	e8bd4070 	pop	{r4, r5, r6, lr}
	}

	printk(KERN_INFO "s3c_onenand_writew: Illegal access"
		" at reg 0x%x, value 0x%x\n", word_addr, value);

	s3c_write_cmd(value, CMD_MAP_11(word_addr));
34817974:	eafffe81 	b	34817380 <s3c_write_cmd>
34817978:	3482bc10 	.word	0x3482bc10
3481797c:	0001e202 	.word	0x0001e202
34817980:	0001e200 	.word	0x0001e200
34817984:	0001e442 	.word	0x0001e442
34817988:	0001e498 	.word	0x0001e498
3481798c:	34827d75 	.word	0x34827d75

34817990 <s3c_onenand_readw>:
	/* Clear the ECC status */
	writel(0x0, &onenand->reg->ecc_err_stat);
}

static unsigned short s3c_onenand_readw(void __iomem *addr)
{
34817990:	e92d4038 	push	{r3, r4, r5, lr}
	struct onenand_chip *this = onenand->mtd->priv;
34817994:	e59f3154 	ldr	r3, [pc, #340]	; 34817af0 <s3c_onenand_readw+0x160>
	int reg = addr - this->base;
	int word_addr = reg >> 1;
	int value;

	/* It's used for probing time */
	switch (reg) {
34817998:	e59f1154 	ldr	r1, [pc, #340]	; 34817af4 <s3c_onenand_readw+0x164>
	writel(0x0, &onenand->reg->ecc_err_stat);
}

static unsigned short s3c_onenand_readw(void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
3481799c:	e5933000 	ldr	r3, [r3]
348179a0:	e5932000 	ldr	r2, [r3]
	int reg = addr - this->base;
348179a4:	e5922094 	ldr	r2, [r2, #148]	; 0x94
348179a8:	e5922000 	ldr	r2, [r2]
348179ac:	e0622000 	rsb	r2, r2, r0
	int word_addr = reg >> 1;
	int value;

	/* It's used for probing time */
	switch (reg) {
348179b0:	e1520001 	cmp	r2, r1
348179b4:	0a000022 	beq	34817a44 <s3c_onenand_readw+0xb4>
348179b8:	ca000008 	bgt	348179e0 <s3c_onenand_readw+0x50>
348179bc:	e2411004 	sub	r1, r1, #4
348179c0:	e1520001 	cmp	r2, r1
348179c4:	0a000018 	beq	34817a2c <s3c_onenand_readw+0x9c>
348179c8:	e2811002 	add	r1, r1, #2
348179cc:	e1520001 	cmp	r2, r1
348179d0:	0a000018 	beq	34817a38 <s3c_onenand_readw+0xa8>
348179d4:	e3520a1e 	cmp	r2, #122880	; 0x1e000
348179d8:	1a000022 	bne	34817a68 <s3c_onenand_readw+0xd8>
348179dc:	ea00000f 	b	34817a20 <s3c_onenand_readw+0x90>
348179e0:	e59f1110 	ldr	r1, [pc, #272]	; 34817af8 <s3c_onenand_readw+0x168>
348179e4:	e1520001 	cmp	r2, r1
348179e8:	0a00001b 	beq	34817a5c <s3c_onenand_readw+0xcc>
348179ec:	ca000003 	bgt	34817a00 <s3c_onenand_readw+0x70>
348179f0:	e59f1104 	ldr	r1, [pc, #260]	; 34817afc <s3c_onenand_readw+0x16c>
348179f4:	e1520001 	cmp	r2, r1
348179f8:	1a00001a 	bne	34817a68 <s3c_onenand_readw+0xd8>
348179fc:	ea000013 	b	34817a50 <s3c_onenand_readw+0xc0>
34817a00:	e59f10f8 	ldr	r1, [pc, #248]	; 34817b00 <s3c_onenand_readw+0x170>
34817a04:	e1520001 	cmp	r2, r1
	case ONENAND_REG_SYS_CFG1:
		return readl(&onenand->reg->mem_cfg);

	/* Used at unlock all status */
	case ONENAND_REG_CTRL_STATUS:
		return 0;
34817a08:	03a00000 	moveq	r0, #0
	int reg = addr - this->base;
	int word_addr = reg >> 1;
	int value;

	/* It's used for probing time */
	switch (reg) {
34817a0c:	08bd8038 	popeq	{r3, r4, r5, pc}
34817a10:	e281101c 	add	r1, r1, #28
34817a14:	e1520001 	cmp	r2, r1
34817a18:	1a000012 	bne	34817a68 <s3c_onenand_readw+0xd8>
34817a1c:	ea000031 	b	34817ae8 <s3c_onenand_readw+0x158>
	case ONENAND_REG_MANUFACTURER_ID:
		return readl(&onenand->reg->manufact_id);
34817a20:	e593301c 	ldr	r3, [r3, #28]
34817a24:	e5930070 	ldr	r0, [r3, #112]	; 0x70
34817a28:	ea000018 	b	34817a90 <s3c_onenand_readw+0x100>
	case ONENAND_REG_DEVICE_ID:
		return readl(&onenand->reg->device_id);
34817a2c:	e593301c 	ldr	r3, [r3, #28]
34817a30:	e5930080 	ldr	r0, [r3, #128]	; 0x80
34817a34:	ea000015 	b	34817a90 <s3c_onenand_readw+0x100>
	case ONENAND_REG_VERSION_ID:
		return readl(&onenand->reg->flash_ver_id);
34817a38:	e593301c 	ldr	r3, [r3, #28]
34817a3c:	e59301f0 	ldr	r0, [r3, #496]	; 0x1f0
34817a40:	ea000012 	b	34817a90 <s3c_onenand_readw+0x100>
	case ONENAND_REG_DATA_BUFFER_SIZE:
		return readl(&onenand->reg->data_buf_size);
34817a44:	e593301c 	ldr	r3, [r3, #28]
34817a48:	e5930090 	ldr	r0, [r3, #144]	; 0x90
34817a4c:	ea00000f 	b	34817a90 <s3c_onenand_readw+0x100>
	case ONENAND_REG_TECHNOLOGY:
		return readl(&onenand->reg->tech);
34817a50:	e593301c 	ldr	r3, [r3, #28]
34817a54:	e59300c0 	ldr	r0, [r3, #192]	; 0xc0
34817a58:	ea00000c 	b	34817a90 <s3c_onenand_readw+0x100>
	case ONENAND_REG_SYS_CFG1:
		return readl(&onenand->reg->mem_cfg);
34817a5c:	e593301c 	ldr	r3, [r3, #28]
34817a60:	e5930000 	ldr	r0, [r3]
34817a64:	ea000009 	b	34817a90 <s3c_onenand_readw+0x100>
	default:
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM && onenand->bootram_command) {
34817a68:	e3520b01 	cmp	r2, #1024	; 0x400

static unsigned short s3c_onenand_readw(void __iomem *addr)
{
	struct onenand_chip *this = onenand->mtd->priv;
	int reg = addr - this->base;
	int word_addr = reg >> 1;
34817a6c:	e1a050c2 	asr	r5, r2, #1
	default:
		break;
	}

	/* BootRAM access control */
	if (reg < ONENAND_DATARAM && onenand->bootram_command) {
34817a70:	aa000012 	bge	34817ac0 <s3c_onenand_readw+0x130>
34817a74:	e593200c 	ldr	r2, [r3, #12]
34817a78:	e3520000 	cmp	r2, #0
34817a7c:	0a00000f 	beq	34817ac0 <s3c_onenand_readw+0x130>
		if (word_addr == 0)
34817a80:	e3550000 	cmp	r5, #0
34817a84:	1a000003 	bne	34817a98 <s3c_onenand_readw+0x108>
			return readl(&onenand->reg->manufact_id);
34817a88:	e593301c 	ldr	r3, [r3, #28]
34817a8c:	e5930070 	ldr	r0, [r3, #112]	; 0x70
34817a90:	e6ff0070 	uxth	r0, r0
34817a94:	e8bd8038 	pop	{r3, r4, r5, pc}
		if (word_addr == 1)
34817a98:	e3550001 	cmp	r5, #1
34817a9c:	1a000002 	bne	34817aac <s3c_onenand_readw+0x11c>
			return readl(&onenand->reg->device_id);
34817aa0:	e593301c 	ldr	r3, [r3, #28]
34817aa4:	e5930080 	ldr	r0, [r3, #128]	; 0x80
34817aa8:	eafffff8 	b	34817a90 <s3c_onenand_readw+0x100>
		if (word_addr == 2)
34817aac:	e3550002 	cmp	r5, #2
34817ab0:	1a000002 	bne	34817ac0 <s3c_onenand_readw+0x130>
			return readl(&onenand->reg->flash_ver_id);
34817ab4:	e593301c 	ldr	r3, [r3, #28]
34817ab8:	e59301f0 	ldr	r0, [r3, #496]	; 0x1f0
34817abc:	eafffff3 	b	34817a90 <s3c_onenand_readw+0x100>
	}

	value = s3c_read_cmd(CMD_MAP_11(word_addr)) & 0xffff;
34817ac0:	e1a00105 	lsl	r0, r5, #2
34817ac4:	e3800303 	orr	r0, r0, #201326592	; 0xc000000
34817ac8:	ebfffe26 	bl	34817368 <s3c_read_cmd>
34817acc:	e6ff4070 	uxth	r4, r0
	printk(KERN_INFO "s3c_onenand_readw:  Illegal access"
34817ad0:	e1a01005 	mov	r1, r5
34817ad4:	e59f0028 	ldr	r0, [pc, #40]	; 34817b04 <s3c_onenand_readw+0x174>
34817ad8:	e1a02004 	mov	r2, r4
34817adc:	ebffc5a0 	bl	34809164 <printf>
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
34817ae0:	e6ff0074 	uxth	r0, r4
34817ae4:	e8bd8038 	pop	{r3, r4, r5, pc}
	/* Used at unlock all status */
	case ONENAND_REG_CTRL_STATUS:
		return 0;

	case ONENAND_REG_WP_STATUS:
		return ONENAND_WP_US;
34817ae8:	e3a00004 	mov	r0, #4

	value = s3c_read_cmd(CMD_MAP_11(word_addr)) & 0xffff;
	printk(KERN_INFO "s3c_onenand_readw:  Illegal access"
		" at reg 0x%x, value 0x%x\n", word_addr, value);
	return value;
}
34817aec:	e8bd8038 	pop	{r3, r4, r5, pc}
34817af0:	3482bc10 	.word	0x3482bc10
34817af4:	0001e006 	.word	0x0001e006
34817af8:	0001e442 	.word	0x0001e442
34817afc:	0001e00c 	.word	0x0001e00c
34817b00:	0001e480 	.word	0x0001e480
34817b04:	34827db1 	.word	0x34827db1

34817b08 <s3c_onenand_check_lock_status.clone.0>:
	}

	return 0;
}

static void s3c_onenand_check_lock_status(struct mtd_info *mtd)
34817b08:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
{
	struct onenand_chip *this = mtd->priv;
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;
34817b0c:	e5907018 	ldr	r7, [r0, #24]
34817b10:	e5903030 	ldr	r3, [r0, #48]	; 0x30

	for (block = 0; block < end; block++) {
34817b14:	e3a04000 	mov	r4, #0
static void s3c_onenand_check_lock_status(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;
34817b18:	e1a07337 	lsr	r7, r7, r3

	for (block = 0; block < end; block++) {
		s3c_read_cmd(CMD_MAP_01(onenand->mem_addr(block, 0, 0)));
34817b1c:	e59f5060 	ldr	r5, [pc, #96]	; 34817b84 <s3c_onenand_check_lock_status.clone.0+0x7c>

		if (readl(&onenand->reg->int_err_stat) & LOCKED_BLK) {
			printf("block %d is write-protected!\n", block);
			writel(LOCKED_BLK, &onenand->reg->int_err_ack);
34817b20:	e3a06c01 	mov	r6, #256	; 0x100
34817b24:	ea000013 	b	34817b78 <s3c_onenand_check_lock_status.clone.0+0x70>
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;

	for (block = 0; block < end; block++) {
		s3c_read_cmd(CMD_MAP_01(onenand->mem_addr(block, 0, 0)));
34817b28:	e5953000 	ldr	r3, [r5]
34817b2c:	e3a01000 	mov	r1, #0
34817b30:	e5933018 	ldr	r3, [r3, #24]
34817b34:	e1a02001 	mov	r2, r1
34817b38:	e1a00004 	mov	r0, r4
34817b3c:	e12fff33 	blx	r3
34817b40:	e3800301 	orr	r0, r0, #67108864	; 0x4000000
34817b44:	ebfffe07 	bl	34817368 <s3c_read_cmd>

		if (readl(&onenand->reg->int_err_stat) & LOCKED_BLK) {
34817b48:	e5953000 	ldr	r3, [r5]
34817b4c:	e593301c 	ldr	r3, [r3, #28]
34817b50:	e5933030 	ldr	r3, [r3, #48]	; 0x30
34817b54:	e3130c01 	tst	r3, #256	; 0x100
34817b58:	0a000005 	beq	34817b74 <s3c_onenand_check_lock_status.clone.0+0x6c>
			printf("block %d is write-protected!\n", block);
34817b5c:	e1a01004 	mov	r1, r4
34817b60:	e59f0020 	ldr	r0, [pc, #32]	; 34817b88 <s3c_onenand_check_lock_status.clone.0+0x80>
34817b64:	ebffc57e 	bl	34809164 <printf>
			writel(LOCKED_BLK, &onenand->reg->int_err_ack);
34817b68:	e5953000 	ldr	r3, [r5]
34817b6c:	e593301c 	ldr	r3, [r3, #28]
34817b70:	e5836050 	str	r6, [r3, #80]	; 0x50
	struct onenand_chip *this = mtd->priv;
	unsigned int block, end;

	end = this->chipsize >> this->erase_shift;

	for (block = 0; block < end; block++) {
34817b74:	e2844001 	add	r4, r4, #1
34817b78:	e1540007 	cmp	r4, r7
34817b7c:	3affffe9 	bcc	34817b28 <s3c_onenand_check_lock_status.clone.0+0x20>
		if (readl(&onenand->reg->int_err_stat) & LOCKED_BLK) {
			printf("block %d is write-protected!\n", block);
			writel(LOCKED_BLK, &onenand->reg->int_err_ack);
		}
	}
}
34817b80:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34817b84:	3482bc10 	.word	0x3482bc10
34817b88:	34827ded 	.word	0x34827ded

34817b8c <s3c_onenand_unlock_all>:

	this->wait(mtd, FL_LOCKING);
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
34817b8c:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
	struct onenand_chip *this = mtd->priv;
34817b90:	e5905094 	ldr	r5, [r0, #148]	; 0x94
	loff_t ofs = 0;
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
34817b94:	e5903014 	ldr	r3, [r0, #20]
	mtd->subpage_sft = 0;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
34817b98:	e595202c 	ldr	r2, [r5, #44]	; 0x2c
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
34817b9c:	e5853098 	str	r3, [r5, #152]	; 0x98
	mtd->subpage_sft = 0;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
34817ba0:	e3120002 	tst	r2, #2
	loff_t ofs = 0;
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
	mtd->subpage_sft = 0;
34817ba4:	e3a03000 	mov	r3, #0

	this->wait(mtd, FL_LOCKING);
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
34817ba8:	e1a04000 	mov	r4, r0
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
	size_t len = this->chipsize;
34817bac:	e5956018 	ldr	r6, [r5, #24]
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
34817bb0:	03a01000 	moveq	r1, #0
	size_t len = this->chipsize;

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
	mtd->subpage_sft = 0;
34817bb4:	e5803090 	str	r3, [r0, #144]	; 0x90
}

static void s3c_onenand_unlock_all(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	loff_t ofs = 0;
34817bb8:	03a00000 	moveq	r0, #0

	/* FIXME workaround */
	this->subpagesize = mtd->writesize;
	mtd->subpage_sft = 0;

	if (this->options & ONENAND_HAS_UNLOCK_ALL) {
34817bbc:	0a000010 	beq	34817c04 <s3c_onenand_unlock_all+0x78>
		/* Write unlock command */
		this->command(mtd, ONENAND_CMD_UNLOCK_ALL, 0, 0);
34817bc0:	e58d3000 	str	r3, [sp]
34817bc4:	e595c050 	ldr	ip, [r5, #80]	; 0x50
34817bc8:	e3a01027 	mov	r1, #39	; 0x27
34817bcc:	e3a02000 	mov	r2, #0
34817bd0:	e3a03000 	mov	r3, #0
34817bd4:	e12fff3c 	blx	ip

		/* No need to check return value */
		this->wait(mtd, FL_LOCKING);
34817bd8:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34817bdc:	e3a01008 	mov	r1, #8
34817be0:	e1a00004 	mov	r0, r4
34817be4:	e12fff33 	blx	r3

		/* Workaround for all block unlock in DDP */
		if (!ONENAND_IS_DDP(this)) {
34817be8:	e595301c 	ldr	r3, [r5, #28]
34817bec:	e3130008 	tst	r3, #8
			s3c_onenand_check_lock_status(mtd);
			return;
		}

		/* All blocks on another chip */
		ofs = this->chipsize >> 1;
34817bf0:	15956018 	ldrne	r6, [r5, #24]
34817bf4:	11a060a6 	lsrne	r6, r6, #1
34817bf8:	11a00006 	movne	r0, r6
34817bfc:	13a01000 	movne	r1, #0

		/* No need to check return value */
		this->wait(mtd, FL_LOCKING);

		/* Workaround for all block unlock in DDP */
		if (!ONENAND_IS_DDP(this)) {
34817c00:	0a00001e 	beq	34817c80 <s3c_onenand_unlock_all+0xf4>
}

static void s3c_onenand_do_lock_cmd(struct mtd_info *mtd, loff_t ofs,
		size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
34817c04:	e5945094 	ldr	r5, [r4, #148]	; 0x94
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
34817c08:	e59f7080 	ldr	r7, [pc, #128]	; 34817c90 <s3c_onenand_unlock_all+0x104>
		size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
34817c0c:	e5952030 	ldr	r2, [r5, #48]	; 0x30
34817c10:	eb0020fc 	bl	34820008 <__ashrdi3>
	start_mem_addr = onenand->mem_addr(start, 0, 0);
34817c14:	e5973000 	ldr	r3, [r7]
34817c18:	e3a01000 	mov	r1, #0
34817c1c:	e1a02001 	mov	r2, r1
34817c20:	e5933018 	ldr	r3, [r3, #24]
		size_t len, int cmd)
{
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
34817c24:	e1a09000 	mov	r9, r0
	start_mem_addr = onenand->mem_addr(start, 0, 0);
34817c28:	e12fff33 	blx	r3
34817c2c:	e1a0a000 	mov	sl, r0
	end = start + (len >> this->erase_shift) - 1;
34817c30:	e5950030 	ldr	r0, [r5, #48]	; 0x30
	end_mem_addr = onenand->mem_addr(end, 0, 0);
34817c34:	e5973000 	ldr	r3, [r7]
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
	end = start + (len >> this->erase_shift) - 1;
34817c38:	e1a06036 	lsr	r6, r6, r0
	end_mem_addr = onenand->mem_addr(end, 0, 0);
34817c3c:	e3a01000 	mov	r1, #0
	struct onenand_chip *this = mtd->priv;
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
	end = start + (len >> this->erase_shift) - 1;
34817c40:	e2460001 	sub	r0, r6, #1
	end_mem_addr = onenand->mem_addr(end, 0, 0);
34817c44:	e5933018 	ldr	r3, [r3, #24]
34817c48:	e1a02001 	mov	r2, r1
34817c4c:	e0800009 	add	r0, r0, r9
34817c50:	e12fff33 	blx	r3

	if (cmd == ONENAND_CMD_LOCK) {
		s3c_write_cmd(ONENAND_LOCK_START, CMD_MAP_10(start_mem_addr));
		s3c_write_cmd(ONENAND_LOCK_END, CMD_MAP_10(end_mem_addr));
	} else {
		s3c_write_cmd(ONENAND_UNLOCK_START, CMD_MAP_10(start_mem_addr));
34817c54:	e38a1302 	orr	r1, sl, #134217728	; 0x8000000
	int start, end, start_mem_addr, end_mem_addr;

	start = ofs >> this->erase_shift;
	start_mem_addr = onenand->mem_addr(start, 0, 0);
	end = start + (len >> this->erase_shift) - 1;
	end_mem_addr = onenand->mem_addr(end, 0, 0);
34817c58:	e1a06000 	mov	r6, r0

	if (cmd == ONENAND_CMD_LOCK) {
		s3c_write_cmd(ONENAND_LOCK_START, CMD_MAP_10(start_mem_addr));
		s3c_write_cmd(ONENAND_LOCK_END, CMD_MAP_10(end_mem_addr));
	} else {
		s3c_write_cmd(ONENAND_UNLOCK_START, CMD_MAP_10(start_mem_addr));
34817c5c:	e3a00008 	mov	r0, #8
34817c60:	ebfffdc6 	bl	34817380 <s3c_write_cmd>
		s3c_write_cmd(ONENAND_UNLOCK_END, CMD_MAP_10(end_mem_addr));
34817c64:	e3a00009 	mov	r0, #9
34817c68:	e3861302 	orr	r1, r6, #134217728	; 0x8000000
34817c6c:	ebfffdc3 	bl	34817380 <s3c_write_cmd>
	}

	this->wait(mtd, FL_LOCKING);
34817c70:	e5953054 	ldr	r3, [r5, #84]	; 0x54
34817c74:	e1a00004 	mov	r0, r4
34817c78:	e3a01008 	mov	r1, #8
34817c7c:	e12fff33 	blx	r3
		ofs = this->chipsize >> 1;
		len = this->chipsize >> 1;
	}

	s3c_onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
	s3c_onenand_check_lock_status(mtd);
34817c80:	e5940094 	ldr	r0, [r4, #148]	; 0x94
}
34817c84:	e28dd00c 	add	sp, sp, #12
34817c88:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
		ofs = this->chipsize >> 1;
		len = this->chipsize >> 1;
	}

	s3c_onenand_do_lock_cmd(mtd, ofs, len, ONENAND_CMD_UNLOCK);
	s3c_onenand_check_lock_status(mtd);
34817c8c:	eaffff9d 	b	34817b08 <s3c_onenand_check_lock_status.clone.0>
34817c90:	3482bc10 	.word	0x3482bc10

34817c94 <s5pc110_chip_probe>:
#endif

int s5pc110_chip_probe(struct mtd_info *mtd)
{
	return 0;
}
34817c94:	e3a00000 	mov	r0, #0
34817c98:	e12fff1e 	bx	lr

34817c9c <s5pc210_chip_probe>:

int s5pc210_chip_probe(struct mtd_info *mtd)
{
	return 0;
}
34817c9c:	e3a00000 	mov	r0, #0
34817ca0:	e12fff1e 	bx	lr

34817ca4 <s3c_onenand_init>:

void s3c_onenand_init(struct mtd_info *mtd)
{
34817ca4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	struct onenand_chip *this = mtd->priv;
34817ca8:	e5904094 	ldr	r4, [r0, #148]	; 0x94
{
	return 0;
}

void s3c_onenand_init(struct mtd_info *mtd)
{
34817cac:	e1a06000 	mov	r6, r0
	struct onenand_chip *this = mtd->priv;
	u32 size = (4 << 10);	/* 4 KiB */

	onenand = malloc(sizeof(struct s3c_onenand));
34817cb0:	e3a00020 	mov	r0, #32
34817cb4:	ebffc6f1 	bl	34809880 <malloc>
34817cb8:	e59f50d4 	ldr	r5, [pc, #212]	; 34817d94 <s3c_onenand_init+0xf0>
	if (!onenand)
34817cbc:	e3500000 	cmp	r0, #0
void s3c_onenand_init(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
	u32 size = (4 << 10);	/* 4 KiB */

	onenand = malloc(sizeof(struct s3c_onenand));
34817cc0:	e1a07000 	mov	r7, r0
34817cc4:	e5850000 	str	r0, [r5]
	if (!onenand)
34817cc8:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return;

	onenand->page_buf = malloc(size * sizeof(char));
34817ccc:	e3a00a01 	mov	r0, #4096	; 0x1000
34817cd0:	ebffc6ea 	bl	34809880 <malloc>
	if (!onenand->page_buf)
34817cd4:	e5953000 	ldr	r3, [r5]

	onenand = malloc(sizeof(struct s3c_onenand));
	if (!onenand)
		return;

	onenand->page_buf = malloc(size * sizeof(char));
34817cd8:	e5870010 	str	r0, [r7, #16]
	if (!onenand->page_buf)
34817cdc:	e5930010 	ldr	r0, [r3, #16]
34817ce0:	e3500000 	cmp	r0, #0
34817ce4:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return;
	memset(onenand->page_buf, 0xff, size);
34817ce8:	e3a010ff 	mov	r1, #255	; 0xff
34817cec:	e3a02a01 	mov	r2, #4096	; 0x1000
34817cf0:	eb001073 	bl	3481bec4 <memset>

	onenand->oob_buf = malloc(128 * sizeof(char));
34817cf4:	e3a00080 	mov	r0, #128	; 0x80
34817cf8:	e5957000 	ldr	r7, [r5]
34817cfc:	ebffc6df 	bl	34809880 <malloc>
	if (!onenand->oob_buf)
34817d00:	e5953000 	ldr	r3, [r5]
	onenand->page_buf = malloc(size * sizeof(char));
	if (!onenand->page_buf)
		return;
	memset(onenand->page_buf, 0xff, size);

	onenand->oob_buf = malloc(128 * sizeof(char));
34817d04:	e5870014 	str	r0, [r7, #20]
	if (!onenand->oob_buf)
34817d08:	e5930014 	ldr	r0, [r3, #20]
34817d0c:	e3500000 	cmp	r0, #0
34817d10:	08bd80f8 	popeq	{r3, r4, r5, r6, r7, pc}
		return;
	memset(onenand->oob_buf, 0xff, 128);
34817d14:	e3a010ff 	mov	r1, #255	; 0xff
34817d18:	e3a02080 	mov	r2, #128	; 0x80
34817d1c:	eb001068 	bl	3481bec4 <memset>

	onenand->mtd = mtd;
34817d20:	e5953000 	ldr	r3, [r5]
#if defined(CONFIG_S3C64XX)
	onenand->base = (void *)0x70100000;
	onenand->ahb_addr = (void *)0x20000000;
#elif defined(CONFIG_S5P)
	onenand->base = (void *)0xE7100000;
	onenand->ahb_addr = (void *)0xB0000000;
34817d24:	e3a0120b 	mov	r1, #-1342177280	; 0xb0000000
34817d28:	e5831008 	str	r1, [r3, #8]

#if defined(CONFIG_S3C64XX)
	onenand->base = (void *)0x70100000;
	onenand->ahb_addr = (void *)0x20000000;
#elif defined(CONFIG_S5P)
	onenand->base = (void *)0xE7100000;
34817d2c:	e59f2064 	ldr	r2, [pc, #100]	; 34817d98 <s3c_onenand_init+0xf4>
	onenand->ahb_addr = (void *)0xB0000000;
#endif
	onenand->mem_addr = s3c_mem_addr;
34817d30:	e59f1064 	ldr	r1, [pc, #100]	; 34817d9c <s3c_onenand_init+0xf8>
	onenand->oob_buf = malloc(128 * sizeof(char));
	if (!onenand->oob_buf)
		return;
	memset(onenand->oob_buf, 0xff, 128);

	onenand->mtd = mtd;
34817d34:	e5836000 	str	r6, [r3]

#if defined(CONFIG_S3C64XX)
	onenand->base = (void *)0x70100000;
	onenand->ahb_addr = (void *)0x20000000;
#elif defined(CONFIG_S5P)
	onenand->base = (void *)0xE7100000;
34817d38:	e5832004 	str	r2, [r3, #4]
	onenand->ahb_addr = (void *)0xB0000000;
#endif
	onenand->mem_addr = s3c_mem_addr;
34817d3c:	e5831018 	str	r1, [r3, #24]
	onenand->reg = (struct samsung_onenand *)onenand->base;
34817d40:	e583201c 	str	r2, [r3, #28]

	this->read_word = s3c_onenand_readw;
34817d44:	e59f3054 	ldr	r3, [pc, #84]	; 34817da0 <s3c_onenand_init+0xfc>
34817d48:	e5843068 	str	r3, [r4, #104]	; 0x68
	this->write_word = s3c_onenand_writew;
34817d4c:	e59f3050 	ldr	r3, [pc, #80]	; 34817da4 <s3c_onenand_init+0x100>
34817d50:	e584306c 	str	r3, [r4, #108]	; 0x6c

	this->wait = s3c_onenand_wait;
34817d54:	e59f304c 	ldr	r3, [pc, #76]	; 34817da8 <s3c_onenand_init+0x104>
34817d58:	e5843054 	str	r3, [r4, #84]	; 0x54
	this->bbt_wait = s3c_onenand_bbt_wait;
34817d5c:	e59f3048 	ldr	r3, [pc, #72]	; 34817dac <s3c_onenand_init+0x108>
34817d60:	e5843058 	str	r3, [r4, #88]	; 0x58
	this->unlock_all = s3c_onenand_unlock_all;
34817d64:	e59f3044 	ldr	r3, [pc, #68]	; 34817db0 <s3c_onenand_init+0x10c>
34817d68:	e584305c 	str	r3, [r4, #92]	; 0x5c
	this->command = s3c_onenand_command;
34817d6c:	e59f3040 	ldr	r3, [pc, #64]	; 34817db4 <s3c_onenand_init+0x110>
34817d70:	e5843050 	str	r3, [r4, #80]	; 0x50

	this->read_bufferram = onenand_read_bufferram;
34817d74:	e59f303c 	ldr	r3, [pc, #60]	; 34817db8 <s3c_onenand_init+0x114>
34817d78:	e5843060 	str	r3, [r4, #96]	; 0x60
	this->write_bufferram = onenand_write_bufferram;
34817d7c:	e59f3038 	ldr	r3, [pc, #56]	; 34817dbc <s3c_onenand_init+0x118>
34817d80:	e5843064 	str	r3, [r4, #100]	; 0x64

	this->options |= ONENAND_RUNTIME_BADBLOCK_CHECK;
34817d84:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
34817d88:	e3833c02 	orr	r3, r3, #512	; 0x200
34817d8c:	e584302c 	str	r3, [r4, #44]	; 0x2c
34817d90:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34817d94:	3482bc10 	.word	0x3482bc10
34817d98:	e7100000 	.word	0xe7100000
34817d9c:	34817398 	.word	0x34817398
34817da0:	34817990 	.word	0x34817990
34817da4:	348178a8 	.word	0x348178a8
34817da8:	348177a4 	.word	0x348177a4
34817dac:	348176cc 	.word	0x348176cc
34817db0:	34817b8c 	.word	0x34817b8c
34817db4:	34817420 	.word	0x34817420
34817db8:	3481777c 	.word	0x3481777c
34817dbc:	34817754 	.word	0x34817754

34817dc0 <samsung_get_base_uart>:
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
34817dc0:	e59f3028 	ldr	r3, [pc, #40]	; 34817df0 <samsung_get_base_uart+0x30>
34817dc4:	e5933000 	ldr	r3, [r3]
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
SAMSUNG_BASE(sromc, SROMC_BASE)
SAMSUNG_BASE(timer, PWMTIMER_BASE)
SAMSUNG_BASE(uart, UART_BASE)
34817dc8:	e3530cc1 	cmp	r3, #49408	; 0xc100
34817dcc:	0a000005 	beq	34817de8 <samsung_get_base_uart+0x28>
34817dd0:	e30c0110 	movw	r0, #49424	; 0xc110
34817dd4:	e59f2018 	ldr	r2, [pc, #24]	; 34817df4 <samsung_get_base_uart+0x34>
34817dd8:	e1530000 	cmp	r3, r0
34817ddc:	01a00002 	moveq	r0, r2
34817de0:	13a00000 	movne	r0, #0
34817de4:	e12fff1e 	bx	lr
34817de8:	e3a0033b 	mov	r0, #-335544320	; 0xec000000
34817dec:	e12fff1e 	bx	lr
34817df0:	348282ec 	.word	0x348282ec
34817df4:	e2900000 	.word	0xe2900000

34817df8 <serial_setbrg_dev>:
	0xdfdf,
	0xffdf,
};

void serial_setbrg_dev(const int dev_index)
{
34817df8:	e92d4038 	push	{r3, r4, r5, lr}
34817dfc:	e1a05000 	mov	r5, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34817e00:	ebffffee 	bl	34817dc0 <samsung_get_base_uart>
34817e04:	e0804505 	add	r4, r0, r5, lsl #10
};

void serial_setbrg_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);
	u32 uclk = get_uart_clk(dev_index);
34817e08:	e1a00005 	mov	r0, r5
34817e0c:	ebffa461 	bl	34800f98 <get_uart_clk>
	u32 baudrate = gd->baudrate;
34817e10:	e5981008 	ldr	r1, [r8, #8]
	u32 val;

	val = uclk / baudrate;
34817e14:	eb001f61 	bl	3481fba0 <__udivsi3>

	writel(val / 16 - 1, &uart->ubrdiv);
34817e18:	e1a03220 	lsr	r3, r0, #4
34817e1c:	e2433001 	sub	r3, r3, #1
34817e20:	e5843028 	str	r3, [r4, #40]	; 0x28

	if (s5p_uart_divslot())
		writew(udivslot[val % 16], &uart->rest.slot);
34817e24:	e59f3010 	ldr	r3, [pc, #16]	; 34817e3c <serial_setbrg_dev+0x44>
34817e28:	e200000f 	and	r0, r0, #15
34817e2c:	e7933100 	ldr	r3, [r3, r0, lsl #2]
34817e30:	e6ff3073 	uxth	r3, r3
34817e34:	e1c432bc 	strh	r3, [r4, #44]	; 0x2c
	else
		writeb(val % 16, &uart->rest.value);
}
34817e38:	e8bd8038 	pop	{r3, r4, r5, pc}
34817e3c:	34821554 	.word	0x34821554

34817e40 <s5p_serial3_setbrg>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34817e40:	e3a00003 	mov	r0, #3
34817e44:	eaffffeb 	b	34817df8 <serial_setbrg_dev>

34817e48 <s5p_serial2_setbrg>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34817e48:	e3a00002 	mov	r0, #2
34817e4c:	eaffffe9 	b	34817df8 <serial_setbrg_dev>

34817e50 <s5p_serial1_setbrg>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34817e50:	e3a00001 	mov	r0, #1
34817e54:	eaffffe7 	b	34817df8 <serial_setbrg_dev>

34817e58 <s5p_serial0_setbrg>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34817e58:	e3a00000 	mov	r0, #0
34817e5c:	eaffffe5 	b	34817df8 <serial_setbrg_dev>

34817e60 <serial_init_dev>:
/*
 * Initialise the serial port with the given baudrate. The settings
 * are always 8 data bits, no parity, 1 stop bit, no start bits.
 */
int serial_init_dev(const int dev_index)
{
34817e60:	e92d4038 	push	{r3, r4, r5, lr}
34817e64:	e1a05000 	mov	r5, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34817e68:	ebffffd4 	bl	34817dc0 <samsung_get_base_uart>
34817e6c:	e0803505 	add	r3, r0, r5, lsl #10
int serial_init_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* reset and enable FIFOs, set triggers to the maximum */
	writel(0, &uart->ufcon);
34817e70:	e3a04000 	mov	r4, #0
34817e74:	e5834008 	str	r4, [r3, #8]
	writel(0, &uart->umcon);
34817e78:	e583400c 	str	r4, [r3, #12]
	/* 8N1 */
	writel(0x3, &uart->ulcon);
34817e7c:	e3a02003 	mov	r2, #3
34817e80:	e7802505 	str	r2, [r0, r5, lsl #10]
	/* No interrupts, no DMA, pure polling */
	writel(0x245, &uart->ucon);
34817e84:	e3002245 	movw	r2, #581	; 0x245

	serial_setbrg_dev(dev_index);
34817e88:	e1a00005 	mov	r0, r5
	writel(0, &uart->ufcon);
	writel(0, &uart->umcon);
	/* 8N1 */
	writel(0x3, &uart->ulcon);
	/* No interrupts, no DMA, pure polling */
	writel(0x245, &uart->ucon);
34817e8c:	e5832004 	str	r2, [r3, #4]

	serial_setbrg_dev(dev_index);
34817e90:	ebffffd8 	bl	34817df8 <serial_setbrg_dev>

	return 0;
}
34817e94:	e1a00004 	mov	r0, r4
34817e98:	e8bd8038 	pop	{r3, r4, r5, pc}

34817e9c <s5p_serial3_init>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34817e9c:	e3a00003 	mov	r0, #3
34817ea0:	eaffffee 	b	34817e60 <serial_init_dev>

34817ea4 <s5p_serial2_init>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34817ea4:	e3a00002 	mov	r0, #2
34817ea8:	eaffffec 	b	34817e60 <serial_init_dev>

34817eac <s5p_serial1_init>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34817eac:	e3a00001 	mov	r0, #1
34817eb0:	eaffffea 	b	34817e60 <serial_init_dev>

34817eb4 <s5p_serial0_init>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34817eb4:	e3a00000 	mov	r0, #0
34817eb8:	eaffffe8 	b	34817e60 <serial_init_dev>

34817ebc <serial_getc_dev>:
 * Read a single byte from the serial port. Returns 1 on success, 0
 * otherwise. When the function is succesfull, the character read is
 * written into its argument c.
 */
int serial_getc_dev(const int dev_index)
{
34817ebc:	e92d4070 	push	{r4, r5, r6, lr}

DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
34817ec0:	e1a05500 	lsl	r5, r0, #10
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34817ec4:	ebffffbd 	bl	34817dc0 <samsung_get_base_uart>
34817ec8:	e0804005 	add	r4, r0, r5
int serial_getc_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
34817ecc:	ea000004 	b	34817ee4 <serial_getc_dev+0x28>
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34817ed0:	ebffffba 	bl	34817dc0 <samsung_get_base_uart>
	if (op)
		mask = 0x8;
	else
		mask = 0xf;

	return readl(&uart->uerstat) & mask;
34817ed4:	e0800005 	add	r0, r0, r5
34817ed8:	e5903014 	ldr	r3, [r0, #20]
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
		if (serial_err_check(dev_index, 0))
34817edc:	e313000f 	tst	r3, #15
34817ee0:	1a000004 	bne	34817ef8 <serial_getc_dev+0x3c>
int serial_getc_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
34817ee4:	e5946010 	ldr	r6, [r4, #16]
34817ee8:	e2166001 	ands	r6, r6, #1
34817eec:	0afffff7 	beq	34817ed0 <serial_getc_dev+0x14>
		if (serial_err_check(dev_index, 0))
			return 0;
	}

	return (int)(readb(&uart->urxh) & 0xff);
34817ef0:	e5d40024 	ldrb	r0, [r4, #36]	; 0x24
34817ef4:	e8bd8070 	pop	{r4, r5, r6, pc}
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for character to arrive */
	while (!(readl(&uart->utrstat) & 0x1)) {
		if (serial_err_check(dev_index, 0))
			return 0;
34817ef8:	e1a00006 	mov	r0, r6
	}

	return (int)(readb(&uart->urxh) & 0xff);
}
34817efc:	e8bd8070 	pop	{r4, r5, r6, pc}

34817f00 <s5p_serial3_getc>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34817f00:	e3a00003 	mov	r0, #3
34817f04:	eaffffec 	b	34817ebc <serial_getc_dev>

34817f08 <s5p_serial2_getc>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34817f08:	e3a00002 	mov	r0, #2
34817f0c:	eaffffea 	b	34817ebc <serial_getc_dev>

34817f10 <s5p_serial1_getc>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34817f10:	e3a00001 	mov	r0, #1
34817f14:	eaffffe8 	b	34817ebc <serial_getc_dev>

34817f18 <s5p_serial0_getc>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34817f18:	e3a00000 	mov	r0, #0
34817f1c:	eaffffe6 	b	34817ebc <serial_getc_dev>

34817f20 <serial_putc_dev>:

/*
 * Output a single byte to the serial port.
 */
void serial_putc_dev(const char c, const int dev_index)
{
34817f20:	e92d4070 	push	{r4, r5, r6, lr}

DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
34817f24:	e1a06501 	lsl	r6, r1, #10

/*
 * Output a single byte to the serial port.
 */
void serial_putc_dev(const char c, const int dev_index)
{
34817f28:	e1a04000 	mov	r4, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34817f2c:	ebffffa3 	bl	34817dc0 <samsung_get_base_uart>
34817f30:	e0805006 	add	r5, r0, r6
void serial_putc_dev(const char c, const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for room in the tx FIFO */
	while (!(readl(&uart->utrstat) & 0x2)) {
34817f34:	ea000004 	b	34817f4c <serial_putc_dev+0x2c>
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34817f38:	ebffffa0 	bl	34817dc0 <samsung_get_base_uart>
	if (op)
		mask = 0x8;
	else
		mask = 0xf;

	return readl(&uart->uerstat) & mask;
34817f3c:	e0800006 	add	r0, r0, r6
34817f40:	e5903014 	ldr	r3, [r0, #20]
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for room in the tx FIFO */
	while (!(readl(&uart->utrstat) & 0x2)) {
		if (serial_err_check(dev_index, 1))
34817f44:	e3130008 	tst	r3, #8
34817f48:	18bd8070 	popne	{r4, r5, r6, pc}
void serial_putc_dev(const char c, const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	/* wait for room in the tx FIFO */
	while (!(readl(&uart->utrstat) & 0x2)) {
34817f4c:	e5953010 	ldr	r3, [r5, #16]
34817f50:	e3130002 	tst	r3, #2
34817f54:	0afffff7 	beq	34817f38 <serial_putc_dev+0x18>
	}

	writeb(c, &uart->utxh);

	/* If \n, also do \r */
	if (c == '\n')
34817f58:	e354000a 	cmp	r4, #10
	while (!(readl(&uart->utrstat) & 0x2)) {
		if (serial_err_check(dev_index, 1))
			return;
	}

	writeb(c, &uart->utxh);
34817f5c:	e5c54020 	strb	r4, [r5, #32]

	/* If \n, also do \r */
	if (c == '\n')
34817f60:	18bd8070 	popne	{r4, r5, r6, pc}
		serial_putc('\r');
34817f64:	e3a0000d 	mov	r0, #13
}
34817f68:	e8bd4070 	pop	{r4, r5, r6, lr}

	writeb(c, &uart->utxh);

	/* If \n, also do \r */
	if (c == '\n')
		serial_putc('\r');
34817f6c:	eaffd9d0 	b	3480e6b4 <serial_putc>

34817f70 <s5p_serial3_putc>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34817f70:	e3a01003 	mov	r1, #3
34817f74:	eaffffe9 	b	34817f20 <serial_putc_dev>

34817f78 <s5p_serial2_putc>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34817f78:	e3a01002 	mov	r1, #2
34817f7c:	eaffffe7 	b	34817f20 <serial_putc_dev>

34817f80 <s5p_serial1_putc>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34817f80:	e3a01001 	mov	r1, #1
34817f84:	eaffffe5 	b	34817f20 <serial_putc_dev>

34817f88 <s5p_serial0_putc>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34817f88:	e3a01000 	mov	r1, #0
34817f8c:	eaffffe3 	b	34817f20 <serial_putc_dev>

34817f90 <serial_tstc_dev>:

/*
 * Test whether a character is in the RX buffer
 */
int serial_tstc_dev(const int dev_index)
{
34817f90:	e92d4010 	push	{r4, lr}
34817f94:	e1a04000 	mov	r4, r0
DECLARE_GLOBAL_DATA_PTR;

static inline struct s5p_uart *s5p_get_base_uart(int dev_index)
{
	u32 offset = dev_index * sizeof(struct s5p_uart);
	return (struct s5p_uart *)(samsung_get_base_uart() + offset);
34817f98:	ebffff88 	bl	34817dc0 <samsung_get_base_uart>
 */
int serial_tstc_dev(const int dev_index)
{
	struct s5p_uart *const uart = s5p_get_base_uart(dev_index);

	return (int)(readl(&uart->utrstat) & 0x1);
34817f9c:	e0800504 	add	r0, r0, r4, lsl #10
34817fa0:	e5900010 	ldr	r0, [r0, #16]
}
34817fa4:	e2000001 	and	r0, r0, #1
34817fa8:	e8bd8010 	pop	{r4, pc}

34817fac <s5p_serial3_tstc>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34817fac:	e3a00003 	mov	r0, #3
34817fb0:	eafffff6 	b	34817f90 <serial_tstc_dev>

34817fb4 <s5p_serial2_tstc>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34817fb4:	e3a00002 	mov	r0, #2
34817fb8:	eafffff4 	b	34817f90 <serial_tstc_dev>

34817fbc <s5p_serial1_tstc>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34817fbc:	e3a00001 	mov	r0, #1
34817fc0:	eafffff2 	b	34817f90 <serial_tstc_dev>

34817fc4 <s5p_serial0_tstc>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
34817fc4:	e3a00000 	mov	r0, #0
34817fc8:	eafffff0 	b	34817f90 <serial_tstc_dev>

34817fcc <serial_puts_dev>:

	return (int)(readl(&uart->utrstat) & 0x1);
}

void serial_puts_dev(const char *s, const int dev_index)
{
34817fcc:	e92d4038 	push	{r3, r4, r5, lr}
34817fd0:	e1a05001 	mov	r5, r1
34817fd4:	e1a04000 	mov	r4, r0
	while (*s)
34817fd8:	ea000001 	b	34817fe4 <serial_puts_dev+0x18>
		serial_putc_dev(*s++, dev_index);
34817fdc:	e1a01005 	mov	r1, r5
34817fe0:	ebffffce 	bl	34817f20 <serial_putc_dev>
	return (int)(readl(&uart->utrstat) & 0x1);
}

void serial_puts_dev(const char *s, const int dev_index)
{
	while (*s)
34817fe4:	e4d40001 	ldrb	r0, [r4], #1
34817fe8:	e3500000 	cmp	r0, #0
34817fec:	1afffffa 	bne	34817fdc <serial_puts_dev+0x10>
		serial_putc_dev(*s++, dev_index);
}
34817ff0:	e8bd8038 	pop	{r3, r4, r5, pc}

34817ff4 <s5p_serial3_puts>:
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
struct serial_device s5p_serial2_device =
	INIT_S5P_SERIAL_STRUCTURE(2, "s5pser2");
DECLARE_S5P_SERIAL_FUNCTIONS(3);
34817ff4:	e3a01003 	mov	r1, #3
34817ff8:	eafffff3 	b	34817fcc <serial_puts_dev>

34817ffc <s5p_serial2_puts>:
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
struct serial_device s5p_serial1_device =
	INIT_S5P_SERIAL_STRUCTURE(1, "s5pser1");
DECLARE_S5P_SERIAL_FUNCTIONS(2);
34817ffc:	e3a01002 	mov	r1, #2
34818000:	eafffff1 	b	34817fcc <serial_puts_dev>

34818004 <s5p_serial1_puts>:
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
struct serial_device s5p_serial0_device =
	INIT_S5P_SERIAL_STRUCTURE(0, "s5pser0");
DECLARE_S5P_SERIAL_FUNCTIONS(1);
34818004:	e3a01001 	mov	r1, #1
34818008:	eaffffef 	b	34817fcc <serial_puts_dev>

3481800c <s5p_serial0_puts>:
	s5p_serial##port##_getc, \
	s5p_serial##port##_tstc, \
	s5p_serial##port##_putc, \
	s5p_serial##port##_puts, }

DECLARE_S5P_SERIAL_FUNCTIONS(0);
3481800c:	e3a01000 	mov	r1, #0
34818010:	eaffffed 	b	34817fcc <serial_puts_dev>

34818014 <default_serial_console>:
#elif defined(CONFIG_SERIAL3)
	return &s5p_serial3_device;
#else
#error "CONFIG_SERIAL? missing."
#endif
}
34818014:	e59f0000 	ldr	r0, [pc, #0]	; 3481801c <default_serial_console+0x8>
34818018:	e12fff1e 	bx	lr
3481801c:	34829228 	.word	0x34829228

34818020 <usb_ep_autoconfig>:
 */
struct usb_ep *usb_ep_autoconfig(
	struct usb_gadget		*gadget,
	struct usb_endpoint_descriptor	*desc
)
{
34818020:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818024:	e1a07000 	mov	r7, r0
34818028:	e5b74008 	ldr	r4, [r7, #8]!
 */
struct usb_ep *usb_ep_autoconfig(
	struct usb_gadget		*gadget,
	struct usb_endpoint_descriptor	*desc
)
{
3481802c:	e1a0a000 	mov	sl, r0
34818030:	e1a05001 	mov	r5, r1
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818034:	e244400c 	sub	r4, r4, #12
		if (++in_epnum > 15)
			return 0;
		desc->bEndpointAddress = USB_DIR_IN | in_epnum;
#endif
	} else {
		if (++epnum > 15)
34818038:	e59f9200 	ldr	r9, [pc, #512]	; 34818240 <usb_ep_autoconfig+0x220>

	case USB_ENDPOINT_XFER_ISOC:
		/* ISO:  limit 1023 bytes full speed, 1024 high speed */
		if (ep->maxpacket < max)
			return 0;
		if (!gadget->is_dualspeed && max > 1023)
3481803c:	e300b3ff 	movw	fp, #1023	; 0x3ff
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818040:	ea000078 	b	34818228 <usb_ep_autoconfig+0x208>
	u8		type;
	const char	*tmp;
	u16		max;

	/* endpoint already claimed? */
	if (NULL != ep->driver_data)
34818044:	e5943000 	ldr	r3, [r4]
34818048:	e3530000 	cmp	r3, #0
3481804c:	1a000073 	bne	34818220 <usb_ep_autoconfig+0x200>
		return 0;

	/* only support ep0 for portable CONTROL traffic */
	type = desc->bmAttributes & USB_ENDPOINT_XFERTYPE_MASK;
34818050:	e5d56003 	ldrb	r6, [r5, #3]
	if (USB_ENDPOINT_XFER_CONTROL == type)
34818054:	e2166003 	ands	r6, r6, #3
34818058:	0a000070 	beq	34818220 <usb_ep_autoconfig+0x200>
		return 0;

	/* some other naming convention */
	if ('e' != ep->name[0])
3481805c:	e5940004 	ldr	r0, [r4, #4]
34818060:	e5d03000 	ldrb	r3, [r0]
34818064:	e3530065 	cmp	r3, #101	; 0x65
34818068:	1a00006c 	bne	34818220 <usb_ep_autoconfig+0x200>
		return 0;

	/* type-restriction:  "-iso", "-bulk", or "-int".
	 * direction-restriction:  "in", "out".
	 */
	if ('-' != ep->name[2]) {
3481806c:	e5d03002 	ldrb	r3, [r0, #2]
34818070:	e353002d 	cmp	r3, #45	; 0x2d
34818074:	0a000023 	beq	34818108 <usb_ep_autoconfig+0xe8>
		tmp = strrchr(ep->name, '-');
34818078:	e3a0102d 	mov	r1, #45	; 0x2d
3481807c:	eb000f0c 	bl	3481bcb4 <strrchr>
		if (tmp) {
34818080:	e3500000 	cmp	r0, #0
34818084:	0a00000d 	beq	348180c0 <usb_ep_autoconfig+0xa0>
			switch (type) {
34818088:	e3560002 	cmp	r6, #2
3481808c:	0a000005 	beq	348180a8 <usb_ep_autoconfig+0x88>
34818090:	e3560003 	cmp	r6, #3
34818094:	e5d03002 	ldrb	r3, [r0, #2]
34818098:	1a000005 	bne	348180b4 <usb_ep_autoconfig+0x94>
			case USB_ENDPOINT_XFER_INT:
				/* bulk endpoints handle interrupt transfers,
				 * except the toggle-quirky iso-synch kind
				 */
				if ('s' == tmp[2])	/* == "-iso" */
3481809c:	e3530073 	cmp	r3, #115	; 0x73
348180a0:	1a00000c 	bne	348180d8 <usb_ep_autoconfig+0xb8>
348180a4:	ea00005d 	b	34818220 <usb_ep_autoconfig+0x200>
				if (gadget_is_pxa(gadget)
						&& 'i' == tmp[1])
					return 0;
				break;
			case USB_ENDPOINT_XFER_BULK:
				if ('b' != tmp[1])	/* != "-bulk" */
348180a8:	e5d03001 	ldrb	r3, [r0, #1]
348180ac:	e3530062 	cmp	r3, #98	; 0x62
348180b0:	ea000000 	b	348180b8 <usb_ep_autoconfig+0x98>
					return 0;
				break;
			case USB_ENDPOINT_XFER_ISOC:
				if ('s' != tmp[2])	/* != "-iso" */
348180b4:	e3530073 	cmp	r3, #115	; 0x73
348180b8:	1a000058 	bne	34818220 <usb_ep_autoconfig+0x200>
348180bc:	ea000005 	b	348180d8 <usb_ep_autoconfig+0xb8>
					return 0;
			}
		} else {
			tmp = ep->name + strlen(ep->name);
348180c0:	e5943004 	ldr	r3, [r4, #4]
348180c4:	e1a00003 	mov	r0, r3
348180c8:	e58d3000 	str	r3, [sp]
348180cc:	eb000edc 	bl	3481bc44 <strlen>
348180d0:	e59d3000 	ldr	r3, [sp]
348180d4:	e0830000 	add	r0, r3, r0
		}

		/* direction-restriction:  "..in-..", "out-.." */
		tmp--;
		if (!isdigit(*tmp)) {
348180d8:	e5503001 	ldrb	r3, [r0, #-1]
348180dc:	e2432030 	sub	r2, r3, #48	; 0x30
348180e0:	e6ef2072 	uxtb	r2, r2
348180e4:	e3520009 	cmp	r2, #9
348180e8:	9a000006 	bls	34818108 <usb_ep_autoconfig+0xe8>
			if (desc->bEndpointAddress & USB_DIR_IN) {
348180ec:	e1d520d2 	ldrsb	r2, [r5, #2]
348180f0:	e3520000 	cmp	r2, #0
348180f4:	aa000001 	bge	34818100 <usb_ep_autoconfig+0xe0>
				if ('n' != *tmp)
348180f8:	e353006e 	cmp	r3, #110	; 0x6e
348180fc:	ea000000 	b	34818104 <usb_ep_autoconfig+0xe4>
					return 0;
			} else {
				if ('t' != *tmp)
34818100:	e3530074 	cmp	r3, #116	; 0x74
34818104:	1a000045 	bne	34818220 <usb_ep_autoconfig+0x200>

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
34818108:	e5d52004 	ldrb	r2, [r5, #4]
3481810c:	e5d50005 	ldrb	r0, [r5, #5]
	/* endpoint maxpacket size is an input parameter, except for bulk
	 * where it's an output parameter representing the full speed limit.
	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
	 */
	max = 0x7ff & le16_to_cpu(get_unaligned(&desc->wMaxPacketSize));
	switch (type) {
34818110:	e3560001 	cmp	r6, #1
34818114:	e1820400 	orr	r0, r2, r0, lsl #8

	/* endpoint maxpacket size is an input parameter, except for bulk
	 * where it's an output parameter representing the full speed limit.
	 * the usb spec fixes high speed bulk maxpacket at 512 bytes.
	 */
	max = 0x7ff & le16_to_cpu(get_unaligned(&desc->wMaxPacketSize));
34818118:	e1a02a80 	lsl	r2, r0, #21
3481811c:	e2853004 	add	r3, r5, #4
34818120:	e285c005 	add	ip, r5, #5
34818124:	e1a02aa2 	lsr	r2, r2, #21
	switch (type) {
34818128:	0a00000a 	beq	34818158 <usb_ep_autoconfig+0x138>
3481812c:	e3560003 	cmp	r6, #3
34818130:	1a000018 	bne	34818198 <usb_ep_autoconfig+0x178>
	case USB_ENDPOINT_XFER_INT:
		/* INT:  limit 64 bytes full speed, 1024 high speed */
		if (!gadget->is_dualspeed && max > 64)
34818134:	e5da1014 	ldrb	r1, [sl, #20]
34818138:	e3110001 	tst	r1, #1
3481813c:	13a01000 	movne	r1, #0
34818140:	03a01001 	moveq	r1, #1
34818144:	e3520040 	cmp	r2, #64	; 0x40
34818148:	93a01000 	movls	r1, #0
3481814c:	82011001 	andhi	r1, r1, #1
34818150:	e3510000 	cmp	r1, #0
34818154:	1a000031 	bne	34818220 <usb_ep_autoconfig+0x200>
			return 0;
		/* FALLTHROUGH */

	case USB_ENDPOINT_XFER_ISOC:
		/* ISO:  limit 1023 bytes full speed, 1024 high speed */
		if (ep->maxpacket < max)
34818158:	e1d411b4 	ldrh	r1, [r4, #20]
3481815c:	e1510002 	cmp	r1, r2
34818160:	3a00002e 	bcc	34818220 <usb_ep_autoconfig+0x200>
			return 0;
		if (!gadget->is_dualspeed && max > 1023)
34818164:	e5da1014 	ldrb	r1, [sl, #20]
34818168:	e3110001 	tst	r1, #1
3481816c:	13a01000 	movne	r1, #0
34818170:	03a01001 	moveq	r1, #1
34818174:	e152000b 	cmp	r2, fp
34818178:	93a02000 	movls	r2, #0
3481817c:	82012001 	andhi	r2, r1, #1
34818180:	e3520000 	cmp	r2, #0
34818184:	1a000025 	bne	34818220 <usb_ep_autoconfig+0x200>
			return 0;

		/* BOTH:  "high bandwidth" works only at high speed */
		if ((get_unaligned(&desc->wMaxPacketSize) &
34818188:	e3100b06 	tst	r0, #6144	; 0x1800
3481818c:	0a000001 	beq	34818198 <usb_ep_autoconfig+0x178>
					__constant_cpu_to_le16(3<<11))) {
			if (!gadget->is_dualspeed)
34818190:	e3510000 	cmp	r1, #0
34818194:	1a000021 	bne	34818220 <usb_ep_autoconfig+0x200>
	}

	/* MATCH!! */

	/* report address */
	if (isdigit(ep->name[2])) {
34818198:	e5942004 	ldr	r2, [r4, #4]
3481819c:	e2820002 	add	r0, r2, #2
348181a0:	e5d22002 	ldrb	r2, [r2, #2]
348181a4:	e2422030 	sub	r2, r2, #48	; 0x30
348181a8:	e6ef2072 	uxtb	r2, r2
348181ac:	e3520009 	cmp	r2, #9
348181b0:	8a000009 	bhi	348181dc <usb_ep_autoconfig+0x1bc>
		u8	num = simple_strtoul(&ep->name[2], NULL, 10);
348181b4:	e3a0200a 	mov	r2, #10
348181b8:	e3a01000 	mov	r1, #0
348181bc:	e88d1008 	stm	sp, {r3, ip}
348181c0:	eb001232 	bl	3481ca90 <simple_strtoul>
		desc->bEndpointAddress |= num;
348181c4:	e5d52002 	ldrb	r2, [r5, #2]
348181c8:	e59d3000 	ldr	r3, [sp]
348181cc:	e1802002 	orr	r2, r0, r2
348181d0:	e5c52002 	strb	r2, [r5, #2]
348181d4:	e59dc004 	ldr	ip, [sp, #4]
348181d8:	ea000007 	b	348181fc <usb_ep_autoconfig+0x1dc>
		if (++in_epnum > 15)
			return 0;
		desc->bEndpointAddress = USB_DIR_IN | in_epnum;
#endif
	} else {
		if (++epnum > 15)
348181dc:	e5992000 	ldr	r2, [r9]
348181e0:	e2822001 	add	r2, r2, #1
348181e4:	e352000f 	cmp	r2, #15
348181e8:	e5892000 	str	r2, [r9]
348181ec:	8a00000b 	bhi	34818220 <usb_ep_autoconfig+0x200>
			return 0;
		desc->bEndpointAddress |= epnum;
348181f0:	e5d51002 	ldrb	r1, [r5, #2]
348181f4:	e1822001 	orr	r2, r2, r1
348181f8:	e5c52002 	strb	r2, [r5, #2]
	}

	/* report (variable) full speed bulk maxpacket */
	if (USB_ENDPOINT_XFER_BULK == type) {
348181fc:	e3560002 	cmp	r6, #2
34818200:	1a00000c 	bne	34818238 <usb_ep_autoconfig+0x218>
		int size = ep->maxpacket;
34818204:	e1d421b4 	ldrh	r2, [r4, #20]

		/* min() doesn't work on bitfields with gcc-3.5 */
		if (size > 64)
			size = 64;
		put_unaligned(cpu_to_le16(size), &desc->wMaxPacketSize);
34818208:	e3520040 	cmp	r2, #64	; 0x40
3481820c:	a3a02040 	movge	r2, #64	; 0x40
	       __get_unaligned_le32(p);
}

static inline void __put_unaligned_le16(u16 val, u8 *p)
{
	*p++ = val;
34818210:	e5c32000 	strb	r2, [r3]
	*p++ = val >> 8;
34818214:	e3a03000 	mov	r3, #0
34818218:	e5cc3000 	strb	r3, [ip]
3481821c:	ea000005 	b	34818238 <usb_ep_autoconfig+0x218>
		if (ep && ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Second, look at endpoints until an unclaimed one looks usable */
	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818220:	e594400c 	ldr	r4, [r4, #12]
34818224:	e244400c 	sub	r4, r4, #12
34818228:	e284300c 	add	r3, r4, #12
3481822c:	e1530007 	cmp	r3, r7
34818230:	1affff83 	bne	34818044 <usb_ep_autoconfig+0x24>
		if (ep_matches(gadget, ep, desc))
			return ep;
	}

	/* Fail */
	return NULL;
34818234:	e3a04000 	mov	r4, #0
}
34818238:	e1a00004 	mov	r0, r4
3481823c:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
34818240:	3482bc14 	.word	0x3482bc14

34818244 <usb_ep_autoconfig_reset>:
 */
void usb_ep_autoconfig_reset(struct usb_gadget *gadget)
{
	struct usb_ep	*ep;

	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818244:	e5b03008 	ldr	r3, [r0, #8]!
		ep->driver_data = NULL;
34818248:	e3a02000 	mov	r2, #0
 */
void usb_ep_autoconfig_reset(struct usb_gadget *gadget)
{
	struct usb_ep	*ep;

	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
3481824c:	e243300c 	sub	r3, r3, #12
34818250:	ea000002 	b	34818260 <usb_ep_autoconfig_reset+0x1c>
		ep->driver_data = NULL;
34818254:	e5832000 	str	r2, [r3]
 */
void usb_ep_autoconfig_reset(struct usb_gadget *gadget)
{
	struct usb_ep	*ep;

	list_for_each_entry(ep, &gadget->ep_list, ep_list) {
34818258:	e593300c 	ldr	r3, [r3, #12]
3481825c:	e243300c 	sub	r3, r3, #12
34818260:	e283100c 	add	r1, r3, #12
34818264:	e1510000 	cmp	r1, r0
34818268:	1afffff9 	bne	34818254 <usb_ep_autoconfig_reset+0x10>
		ep->driver_data = NULL;
	}
#ifdef	MANY_ENDPOINTS
	in_epnum = 0;
#endif
	epnum = 0;
3481826c:	e59f3008 	ldr	r3, [pc, #8]	; 3481827c <usb_ep_autoconfig_reset+0x38>
34818270:	e3a02000 	mov	r2, #0
34818274:	e5832000 	str	r2, [r3]
}
34818278:	e12fff1e 	bx	lr
3481827c:	3482bc14 	.word	0x3482bc14

34818280 <usb_descriptor_fillbuf>:
 * sets of descriptors need to be marshaled.
 */
int
usb_descriptor_fillbuf(void *buf, unsigned buflen,
		const struct usb_descriptor_header **src)
{
34818280:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	u8	*dest = buf;

	if (!src)
34818284:	e252a000 	subs	sl, r2, #0
 * sets of descriptors need to be marshaled.
 */
int
usb_descriptor_fillbuf(void *buf, unsigned buflen,
		const struct usb_descriptor_header **src)
{
34818288:	e1a07000 	mov	r7, r0
3481828c:	e1a06001 	mov	r6, r1
	u8	*dest = buf;
34818290:	11a04000 	movne	r4, r0

	if (!src)
34818294:	1a000008 	bne	348182bc <usb_descriptor_fillbuf+0x3c>
34818298:	ea00000c 	b	348182d0 <usb_descriptor_fillbuf+0x50>
		return -EINVAL;

	/* fill buffer from src[] until null descriptor ptr */
	for (; NULL != *src; src++) {
		unsigned		len = (*src)->bLength;
3481829c:	e5d15000 	ldrb	r5, [r1]

		if (len > buflen)
348182a0:	e1550006 	cmp	r5, r6
348182a4:	8a00000b 	bhi	348182d8 <usb_descriptor_fillbuf+0x58>
			return -EINVAL;
		memcpy(dest, *src, len);
348182a8:	e1a00004 	mov	r0, r4
348182ac:	e1a02005 	mov	r2, r5
348182b0:	eb000f27 	bl	3481bf54 <memcpy>
		buflen -= len;
348182b4:	e0656006 	rsb	r6, r5, r6
		dest += len;
348182b8:	e0844005 	add	r4, r4, r5

	if (!src)
		return -EINVAL;

	/* fill buffer from src[] until null descriptor ptr */
	for (; NULL != *src; src++) {
348182bc:	e49a1004 	ldr	r1, [sl], #4
348182c0:	e3510000 	cmp	r1, #0
348182c4:	1afffff4 	bne	3481829c <usb_descriptor_fillbuf+0x1c>
			return -EINVAL;
		memcpy(dest, *src, len);
		buflen -= len;
		dest += len;
	}
	return dest - (u8 *)buf;
348182c8:	e0670004 	rsb	r0, r7, r4
348182cc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
		const struct usb_descriptor_header **src)
{
	u8	*dest = buf;

	if (!src)
		return -EINVAL;
348182d0:	e3e00015 	mvn	r0, #21
348182d4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	/* fill buffer from src[] until null descriptor ptr */
	for (; NULL != *src; src++) {
		unsigned		len = (*src)->bLength;

		if (len > buflen)
			return -EINVAL;
348182d8:	e3e00015 	mvn	r0, #21
		memcpy(dest, *src, len);
		buflen -= len;
		dest += len;
	}
	return dest - (u8 *)buf;
}
348182dc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

348182e0 <usb_gadget_config_buf>:
{
	struct usb_config_descriptor		*cp = buf;
	int					len;

	/* config descriptor first */
	if (length < USB_DT_CONFIG_SIZE || !desc)
348182e0:	e3530000 	cmp	r3, #0
348182e4:	13520008 	cmpne	r2, #8
	const struct usb_config_descriptor	*config,
	void					*buf,
	unsigned				length,
	const struct usb_descriptor_header	**desc
)
{
348182e8:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
348182ec:	e1a0c000 	mov	ip, r0
348182f0:	e1a04001 	mov	r4, r1
348182f4:	e1a05002 	mov	r5, r2
	struct usb_config_descriptor		*cp = buf;
	int					len;

	/* config descriptor first */
	if (length < USB_DT_CONFIG_SIZE || !desc)
348182f8:	e1a07003 	mov	r7, r3
		return -EINVAL;
348182fc:	93e00015 	mvnls	r0, #21
{
	struct usb_config_descriptor		*cp = buf;
	int					len;

	/* config descriptor first */
	if (length < USB_DT_CONFIG_SIZE || !desc)
34818300:	98bd80f8 	popls	{r3, r4, r5, r6, r7, pc}
		return -EINVAL;
	*cp = *config;
34818304:	e3a06009 	mov	r6, #9
34818308:	e1a00001 	mov	r0, r1
3481830c:	e1a02006 	mov	r2, r6
34818310:	e1a0100c 	mov	r1, ip
34818314:	eb000f0e 	bl	3481bf54 <memcpy>

	/* then interface/endpoint/class/vendor/... */
	len = usb_descriptor_fillbuf(USB_DT_CONFIG_SIZE + (u8 *)buf,
34818318:	e0840006 	add	r0, r4, r6
3481831c:	e2451009 	sub	r1, r5, #9
34818320:	e1a02007 	mov	r2, r7
34818324:	ebffffd5 	bl	34818280 <usb_descriptor_fillbuf>
			length - USB_DT_CONFIG_SIZE, desc);
	if (len < 0)
34818328:	e3500000 	cmp	r0, #0
3481832c:	b8bd80f8 	poplt	{r3, r4, r5, r6, r7, pc}
		return len;
	len += USB_DT_CONFIG_SIZE;
34818330:	e0800006 	add	r0, r0, r6
	if (len > 0xffff)
34818334:	e3500801 	cmp	r0, #65536	; 0x10000
34818338:	aa00000b 	bge	3481836c <usb_gadget_config_buf+0x8c>
		return -EINVAL;

	/* patch up the config descriptor */
	cp->bLength = USB_DT_CONFIG_SIZE;
	cp->bDescriptorType = USB_DT_CONFIG;
3481833c:	e3a03002 	mov	r3, #2
34818340:	e5c43001 	strb	r3, [r4, #1]
	cp->wTotalLength = cpu_to_le16(len);
34818344:	e6ff3070 	uxth	r3, r0
34818348:	e5c43002 	strb	r3, [r4, #2]
3481834c:	e1a03423 	lsr	r3, r3, #8
34818350:	e5c43003 	strb	r3, [r4, #3]
	cp->bmAttributes |= USB_CONFIG_ATT_ONE;
34818354:	e5d43007 	ldrb	r3, [r4, #7]
	len += USB_DT_CONFIG_SIZE;
	if (len > 0xffff)
		return -EINVAL;

	/* patch up the config descriptor */
	cp->bLength = USB_DT_CONFIG_SIZE;
34818358:	e5c46000 	strb	r6, [r4]
	cp->bDescriptorType = USB_DT_CONFIG;
	cp->wTotalLength = cpu_to_le16(len);
	cp->bmAttributes |= USB_CONFIG_ATT_ONE;
3481835c:	e1e03c83 	mvn	r3, r3, lsl #25
34818360:	e1e03ca3 	mvn	r3, r3, lsr #25
34818364:	e5c43007 	strb	r3, [r4, #7]
	return len;
34818368:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
			length - USB_DT_CONFIG_SIZE, desc);
	if (len < 0)
		return len;
	len += USB_DT_CONFIG_SIZE;
	if (len > 0xffff)
		return -EINVAL;
3481836c:	e3e00015 	mvn	r0, #21
	cp->bLength = USB_DT_CONFIG_SIZE;
	cp->bDescriptorType = USB_DT_CONFIG;
	cp->wTotalLength = cpu_to_le16(len);
	cp->bmAttributes |= USB_CONFIG_ATT_ONE;
	return len;
}
34818370:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

34818374 <usb_gadget_get_string>:
{
	struct usb_string	*s;
	int			len;

	/* descriptor 0 has the language id */
	if (id == 0) {
34818374:	e3510000 	cmp	r1, #0
 * the eighth bit set will be multibyte UTF-8 characters, not ISO-8859/1
 * characters (which are also widely used in C strings).
 */
int
usb_gadget_get_string(struct usb_gadget_strings *table, int id, u8 *buf)
{
34818378:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3481837c:	e1a04002 	mov	r4, r2
	struct usb_string	*s;
	int			len;

	/* descriptor 0 has the language id */
	if (id == 0) {
34818380:	1a00000a 	bne	348183b0 <usb_gadget_get_string+0x3c>
		buf[0] = 4;
34818384:	e3a03004 	mov	r3, #4
34818388:	e5c23000 	strb	r3, [r2]
		buf[1] = USB_DT_STRING;
3481838c:	e3a02003 	mov	r2, #3
34818390:	e5c42001 	strb	r2, [r4, #1]
		buf[2] = (u8) table->language;
34818394:	e1d020b0 	ldrh	r2, [r0]
34818398:	e5c42002 	strb	r2, [r4, #2]
		buf[3] = (u8) (table->language >> 8);
3481839c:	e1d020b0 	ldrh	r2, [r0]
		return 4;
348183a0:	e1a00003 	mov	r0, r3
	/* descriptor 0 has the language id */
	if (id == 0) {
		buf[0] = 4;
		buf[1] = USB_DT_STRING;
		buf[2] = (u8) table->language;
		buf[3] = (u8) (table->language >> 8);
348183a4:	e1a02422 	lsr	r2, r2, #8
348183a8:	e5c42003 	strb	r2, [r4, #3]
		return 4;
348183ac:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	}
	for (s = table->strings; s && s->s; s++)
348183b0:	e5905004 	ldr	r5, [r0, #4]
348183b4:	ea000003 	b	348183c8 <usb_gadget_get_string+0x54>
		if (s->id == id)
348183b8:	e5d53000 	ldrb	r3, [r5]
348183bc:	e1530001 	cmp	r3, r1
348183c0:	0a000006 	beq	348183e0 <usb_gadget_get_string+0x6c>
		buf[1] = USB_DT_STRING;
		buf[2] = (u8) table->language;
		buf[3] = (u8) (table->language >> 8);
		return 4;
	}
	for (s = table->strings; s && s->s; s++)
348183c4:	e2855008 	add	r5, r5, #8
348183c8:	e3550000 	cmp	r5, #0
348183cc:	0a000041 	beq	348184d8 <usb_gadget_get_string+0x164>
348183d0:	e5950004 	ldr	r0, [r5, #4]
348183d4:	e3500000 	cmp	r0, #0
348183d8:	1afffff6 	bne	348183b8 <usb_gadget_get_string+0x44>
348183dc:	ea00003d 	b	348184d8 <usb_gadget_get_string+0x164>
	/* unrecognized: stall. */
	if (!s || !s->s)
		return -EINVAL;

	/* string descriptors have length, tag, then UTF16-LE text */
	len = min((size_t) 126, strlen(s->s));
348183e0:	eb000e17 	bl	3481bc44 <strlen>
348183e4:	e350007e 	cmp	r0, #126	; 0x7e
348183e8:	31a06000 	movcc	r6, r0
348183ec:	23a0607e 	movcs	r6, #126	; 0x7e
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
348183f0:	e3a01000 	mov	r1, #0
348183f4:	e2840002 	add	r0, r4, #2
348183f8:	e1a02086 	lsl	r2, r6, #1
348183fc:	eb000eb0 	bl	3481bec4 <memset>
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
34818400:	e5953004 	ldr	r3, [r5, #4]
34818404:	e1a01004 	mov	r1, r4
#include <asm/unaligned.h>


static int utf8_to_utf16le(const char *s, __le16 *cp, unsigned len)
{
	int	count = 0;
34818408:	e3a00000 	mov	r0, #0
					goto fail;
				c &= 0x3f;
				uchar |= c;

				/* no bogus surrogates */
				if (0xd800 <= uchar && uchar <= 0xdfff)
3481840c:	e30057ff 	movw	r5, #2047	; 0x7ff
34818410:	ea00002a 	b	348184c0 <usb_gadget_get_string+0x14c>
	 * this insists on correct encodings, though not minimal ones.
	 * BUT it currently rejects legit 4-byte UTF-8 code points,
	 * which need surrogate pairs.  (Unicode 3.1 can use them.)
	 */
	while (len != 0 && (c = (u8) *s++) != 0) {
		if ((c & 0x80)) {
34818414:	e3120080 	tst	r2, #128	; 0x80
	/*
	 * this insists on correct encodings, though not minimal ones.
	 * BUT it currently rejects legit 4-byte UTF-8 code points,
	 * which need surrogate pairs.  (Unicode 3.1 can use them.)
	 */
	while (len != 0 && (c = (u8) *s++) != 0) {
34818418:	e2833001 	add	r3, r3, #1
		if ((c & 0x80)) {
3481841c:	0a000022 	beq	348184ac <usb_gadget_get_string+0x138>
			/*
			 * 2-byte sequence:
			 * 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
			 */
			if ((c & 0xe0) == 0xc0) {
34818420:	e202c0e0 	and	ip, r2, #224	; 0xe0
34818424:	e35c00c0 	cmp	ip, #192	; 0xc0
34818428:	1a000008 	bne	34818450 <usb_gadget_get_string+0xdc>
				uchar = (c & 0x1f) << 6;

				c = (u8) *s++;
3481842c:	e5d3c000 	ldrb	ip, [r3]
				if ((c & 0xc0) != 0x80)
34818430:	e20c70c0 	and	r7, ip, #192	; 0xc0
34818434:	e3570080 	cmp	r7, #128	; 0x80
34818438:	1a000026 	bne	348184d8 <usb_gadget_get_string+0x164>
			/*
			 * 2-byte sequence:
			 * 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
			 */
			if ((c & 0xe0) == 0xc0) {
				uchar = (c & 0x1f) << 6;
3481843c:	e202201f 	and	r2, r2, #31

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
34818440:	e20cc03f 	and	ip, ip, #63	; 0x3f
			 * 00000yyyyyxxxxxx = 110yyyyy 10xxxxxx
			 */
			if ((c & 0xe0) == 0xc0) {
				uchar = (c & 0x1f) << 6;

				c = (u8) *s++;
34818444:	e2833001 	add	r3, r3, #1
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
34818448:	e18c2302 	orr	r2, ip, r2, lsl #6
3481844c:	ea000016 	b	348184ac <usb_gadget_get_string+0x138>

			/*
			 * 3-byte sequence (most CJKV characters):
			 * zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
			 */
			} else if ((c & 0xf0) == 0xe0) {
34818450:	e202c0f0 	and	ip, r2, #240	; 0xf0
34818454:	e35c00e0 	cmp	ip, #224	; 0xe0
34818458:	1a00001e 	bne	348184d8 <usb_gadget_get_string+0x164>
				uchar = (c & 0x0f) << 12;

				c = (u8) *s++;
3481845c:	e5d3c000 	ldrb	ip, [r3]
				if ((c & 0xc0) != 0x80)
34818460:	e20c70c0 	and	r7, ip, #192	; 0xc0
34818464:	e3570080 	cmp	r7, #128	; 0x80
34818468:	1a00001a 	bne	348184d8 <usb_gadget_get_string+0x164>
			 * zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
			 */
			} else if ((c & 0xf0) == 0xe0) {
				uchar = (c & 0x0f) << 12;

				c = (u8) *s++;
3481846c:	e2837001 	add	r7, r3, #1
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;

				c = (u8) *s++;
34818470:	e5d33001 	ldrb	r3, [r3, #1]
				if ((c & 0xc0) != 0x80)
34818474:	e203a0c0 	and	sl, r3, #192	; 0xc0
34818478:	e35a0080 	cmp	sl, #128	; 0x80
3481847c:	1a000015 	bne	348184d8 <usb_gadget_get_string+0x164>

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;
34818480:	e20cc03f 	and	ip, ip, #63	; 0x3f
			/*
			 * 3-byte sequence (most CJKV characters):
			 * zzzzyyyyyyxxxxxx = 1110zzzz 10yyyyyy 10xxxxxx
			 */
			} else if ((c & 0xf0) == 0xe0) {
				uchar = (c & 0x0f) << 12;
34818484:	e1a02602 	lsl	r2, r2, #12

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;
34818488:	e182230c 	orr	r2, r2, ip, lsl #6

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
3481848c:	e203303f 	and	r3, r3, #63	; 0x3f

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;
34818490:	e6ff2072 	uxth	r2, r2

				c = (u8) *s++;
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c;
34818494:	e1822003 	orr	r2, r2, r3

				/* no bogus surrogates */
				if (0xd800 <= uchar && uchar <= 0xdfff)
34818498:	e2823b0a 	add	r3, r2, #10240	; 0x2800
3481849c:	e6ff3073 	uxth	r3, r3
348184a0:	e1530005 	cmp	r3, r5
348184a4:	9a00000d 	bls	348184e0 <usb_gadget_get_string+0x16c>
				if ((c & 0xc0) != 0x80)
					goto fail;
				c &= 0x3f;
				uchar |= c << 6;

				c = (u8) *s++;
348184a8:	e2873001 	add	r3, r7, #1
	       __get_unaligned_le32(p);
}

static inline void __put_unaligned_le16(u16 val, u8 *p)
{
	*p++ = val;
348184ac:	e5c12002 	strb	r2, [r1, #2]
	*p++ = val >> 8;
348184b0:	e1a02422 	lsr	r2, r2, #8
348184b4:	e5c12003 	strb	r2, [r1, #3]
			} else
				goto fail;
		} else
			uchar = c;
		put_unaligned_le16(uchar, cp++);
		count++;
348184b8:	e2800001 	add	r0, r0, #1
348184bc:	e2811002 	add	r1, r1, #2
	/*
	 * this insists on correct encodings, though not minimal ones.
	 * BUT it currently rejects legit 4-byte UTF-8 code points,
	 * which need surrogate pairs.  (Unicode 3.1 can use them.)
	 */
	while (len != 0 && (c = (u8) *s++) != 0) {
348184c0:	e1560000 	cmp	r6, r0
348184c4:	0a000007 	beq	348184e8 <usb_gadget_get_string+0x174>
348184c8:	e5d32000 	ldrb	r2, [r3]
348184cc:	e3520000 	cmp	r2, #0
348184d0:	1affffcf 	bne	34818414 <usb_gadget_get_string+0xa0>
348184d4:	ea000003 	b	348184e8 <usb_gadget_get_string+0x174>
	/* string descriptors have length, tag, then UTF16-LE text */
	len = min((size_t) 126, strlen(s->s));
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
	if (len < 0)
		return -EINVAL;
348184d8:	e3e00015 	mvn	r0, #21
348184dc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
348184e0:	e3e00015 	mvn	r0, #21
	buf[0] = (len + 1) * 2;
	buf[1] = USB_DT_STRING;
	return buf[0];
}
348184e4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	len = min((size_t) 126, strlen(s->s));
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
	if (len < 0)
		return -EINVAL;
	buf[0] = (len + 1) * 2;
348184e8:	e2800001 	add	r0, r0, #1
348184ec:	e1a00080 	lsl	r0, r0, #1
	buf[1] = USB_DT_STRING;
348184f0:	e3a03003 	mov	r3, #3
	len = min((size_t) 126, strlen(s->s));
	memset(buf + 2, 0, 2 * len);	/* zero all the bytes */
	len = utf8_to_utf16le(s->s, (__le16 *)&buf[2], len);
	if (len < 0)
		return -EINVAL;
	buf[0] = (len + 1) * 2;
348184f4:	e5c40000 	strb	r0, [r4]
	buf[1] = USB_DT_STRING;
348184f8:	e5c43001 	strb	r3, [r4, #1]
	return buf[0];
348184fc:	e20000fe 	and	r0, r0, #254	; 0xfe
34818500:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

34818504 <get_unaligned_le16>:

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
34818504:	e5d02001 	ldrb	r2, [r0, #1]
34818508:	e5d03000 	ldrb	r3, [r0]
}

static inline u16 get_unaligned_le16(const void *p)
{
	return __get_unaligned_le16((const u8 *)p);
}
3481850c:	e1830402 	orr	r0, r3, r2, lsl #8
34818510:	e12fff1e 	bx	lr

34818514 <set_max_pktsize>:
static void set_max_pktsize(struct s3c_udc *dev, enum usb_device_speed speed)
{
	unsigned int ep_ctrl;
	int i;

	if (speed == USB_SPEED_HIGH) {
34818514:	e3510003 	cmp	r1, #3
34818518:	e59f307c 	ldr	r3, [pc, #124]	; 3481859c <set_max_pktsize+0x88>
3481851c:	1a000007 	bne	34818540 <set_max_pktsize+0x2c>
		ep0_fifo_size = 64;
34818520:	e3a02040 	mov	r2, #64	; 0x40
34818524:	e5832000 	str	r2, [r3]
		ep_fifo_size = 512;
34818528:	e2822d07 	add	r2, r2, #448	; 0x1c0
3481852c:	e5832004 	str	r2, [r3, #4]
		ep_fifo_size2 = 1024;
34818530:	e2822c02 	add	r2, r2, #512	; 0x200
34818534:	e5832008 	str	r2, [r3, #8]
		dev->gadget.speed = USB_SPEED_HIGH;
34818538:	e5801010 	str	r1, [r0, #16]
3481853c:	ea000005 	b	34818558 <set_max_pktsize+0x44>
	} else {
		ep0_fifo_size = 64;
34818540:	e3a02040 	mov	r2, #64	; 0x40
34818544:	e5832000 	str	r2, [r3]
		ep_fifo_size = 64;
34818548:	e5832004 	str	r2, [r3, #4]
		ep_fifo_size2 = 64;
3481854c:	e5832008 	str	r2, [r3, #8]
		dev->gadget.speed = USB_SPEED_FULL;
34818550:	e3a03002 	mov	r3, #2
34818554:	e5803010 	str	r3, [r0, #16]
	}

	dev->ep[0].ep.maxpacket = ep0_fifo_size;
34818558:	e3a03040 	mov	r3, #64	; 0x40
3481855c:	e1c036bc 	strh	r3, [r0, #108]	; 0x6c
	for (i = 1; i < S3C_MAX_ENDPOINTS; i++)
		dev->ep[i].ep.maxpacket = ep_fifo_size;
34818560:	e59f3034 	ldr	r3, [pc, #52]	; 3481859c <set_max_pktsize+0x88>
34818564:	e3a02f4b 	mov	r2, #300	; 0x12c
34818568:	e1d330b4 	ldrh	r3, [r3, #4]
3481856c:	e18030b2 	strh	r3, [r0, r2]
34818570:	e1c03abc 	strh	r3, [r0, #172]	; 0xac
34818574:	e1c03ebc 	strh	r3, [r0, #236]	; 0xec

	/* EP0 - Control IN (64 bytes)*/
	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
34818578:	e59f3020 	ldr	r3, [pc, #32]	; 348185a0 <set_max_pktsize+0x8c>
3481857c:	e5932000 	ldr	r2, [r3]
34818580:	e5921900 	ldr	r1, [r2, #2304]	; 0x900
	writel(ep_ctrl|(0<<0), &reg->in_endp[EP0_CON].diepctl);
34818584:	e5932000 	ldr	r2, [r3]
34818588:	e5821900 	str	r1, [r2, #2304]	; 0x900

	/* EP0 - Control OUT (64 bytes)*/
	ep_ctrl = readl(&reg->out_endp[EP0_CON].doepctl);
3481858c:	e5922b00 	ldr	r2, [r2, #2816]	; 0xb00
	writel(ep_ctrl|(0<<0), &reg->out_endp[EP0_CON].doepctl);
34818590:	e5933000 	ldr	r3, [r3]
34818594:	e5832b00 	str	r2, [r3, #2816]	; 0xb00
}
34818598:	e12fff1e 	bx	lr
3481859c:	348292e8 	.word	0x348292e8
348185a0:	3482bc18 	.word	0x3482bc18

348185a4 <s3c_fifo_status>:
{
	int count = 0;
	struct s3c_ep *ep;

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep) {
348185a4:	e3500000 	cmp	r0, #0
348185a8:	0a000004 	beq	348185c0 <s3c_fifo_status+0x1c>
	}

	debug("%s: %d\n", __func__, ep_index(ep));

	/* LPD can't report unclaimed bytes from IN fifos */
	if (ep_is_in(ep))
348185ac:	e1d033d5 	ldrsb	r3, [r0, #53]	; 0x35
348185b0:	e3530000 	cmp	r3, #0
		return -EOPNOTSUPP;
348185b4:	a3a00000 	movge	r0, #0
348185b8:	b3e0005e 	mvnlt	r0, #94	; 0x5e
348185bc:	e12fff1e 	bx	lr
	struct s3c_ep *ep;

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep) {
		debug("%s: bad ep\n", __func__);
		return -ENODEV;
348185c0:	e3e00012 	mvn	r0, #18
	/* LPD can't report unclaimed bytes from IN fifos */
	if (ep_is_in(ep))
		return -EOPNOTSUPP;

	return count;
}
348185c4:	e12fff1e 	bx	lr

348185c8 <s3c_fifo_flush>:
		debug("%s: bad ep\n", __func__);
		return;
	}

	debug("%s: %d\n", __func__, ep_index(ep));
}
348185c8:	e12fff1e 	bx	lr

348185cc <reconfig_usbd>:
	/* re-init driver-visible data structures */
	udc_reinit(dev);
}

static void reconfig_usbd(void)
{
348185cc:	e92d4038 	push	{r3, r4, r5, lr}
	/* 2. Soft-reset OTG Core and then unreset again. */
	int i;
	unsigned int uTemp = writel(CORE_SOFT_RESET, &reg->grstctl);
348185d0:	e59f4170 	ldr	r4, [pc, #368]	; 34818748 <reconfig_usbd+0x17c>
348185d4:	e3a05001 	mov	r5, #1
348185d8:	e5943000 	ldr	r3, [r4]
348185dc:	e5835010 	str	r5, [r3, #16]

	debug("Reseting OTG controller\n");

	writel(0<<15		/* PHY Low Power Clock sel*/
348185e0:	e5943000 	ldr	r3, [r4]
348185e4:	e305240f 	movw	r2, #21519	; 0x540f
348185e8:	e583200c 	str	r2, [r3, #12]
		|1<<3		/* phy i/f  0:8bit, 1:16bit*/
		|0x7<<0,	/* HS/FS Timeout**/
		&reg->gusbcfg);

	/* 3. Put the OTG device core in the disconnected state.*/
	uTemp = readl(&reg->dctl);
348185ec:	e5932804 	ldr	r2, [r3, #2052]	; 0x804
	uTemp |= SOFT_DISCONNECT;
348185f0:	e3822002 	orr	r2, r2, #2
	writel(uTemp, &reg->dctl);
348185f4:	e5943000 	ldr	r3, [r4]

	udelay(20);
348185f8:	e3a00014 	mov	r0, #20
		&reg->gusbcfg);

	/* 3. Put the OTG device core in the disconnected state.*/
	uTemp = readl(&reg->dctl);
	uTemp |= SOFT_DISCONNECT;
	writel(uTemp, &reg->dctl);
348185fc:	e5832804 	str	r2, [r3, #2052]	; 0x804

	udelay(20);
34818600:	eb000ede 	bl	3481c180 <udelay>

	/* 4. Make the OTG device core exit from the disconnected state.*/
	uTemp = readl(&reg->dctl);
34818604:	e5943000 	ldr	r3, [r4]
34818608:	e5932804 	ldr	r2, [r3, #2052]	; 0x804
	uTemp = uTemp & ~SOFT_DISCONNECT;
3481860c:	e3c22002 	bic	r2, r2, #2
	writel(uTemp, &reg->dctl);
34818610:	e5943000 	ldr	r3, [r4]
34818614:	e5832804 	str	r2, [r3, #2052]	; 0x804

	/* 5. Configure OTG Core to initial settings of device mode.*/
	/* [][1: full speed(30Mhz) 0:high speed]*/
	writel(EP_MISS_CNT(1) | DEV_SPEED_HIGH_SPEED_20, &reg->dcfg);
34818618:	e5943000 	ldr	r3, [r4]
3481861c:	e3a02701 	mov	r2, #262144	; 0x40000
34818620:	e5832800 	str	r2, [r3, #2048]	; 0x800

	mdelay(1);
34818624:	e1a00005 	mov	r0, r5
34818628:	eb000ee0 	bl	3481c1b0 <mdelay>

	/* 6. Unmask the core interrupts*/
	writel(GINTMSK_INIT, &reg->gintmsk);
3481862c:	e59f2118 	ldr	r2, [pc, #280]	; 3481874c <reconfig_usbd+0x180>
34818630:	e5943000 	ldr	r3, [r4]
34818634:	e5832018 	str	r2, [r3, #24]

	/* 7. Set NAK bit of EP0, EP1, EP2*/
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[EP0_CON].doepctl);
34818638:	e5942000 	ldr	r2, [r4]
3481863c:	e3a03312 	mov	r3, #1207959552	; 0x48000000
34818640:	e5823b00 	str	r3, [r2, #2816]	; 0xb00
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[EP0_CON].diepctl);
34818644:	e5942000 	ldr	r2, [r4]
34818648:	e5823900 	str	r3, [r2, #2304]	; 0x900

	for (i = 1; i < S3C_MAX_ENDPOINTS; i++) {
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[i].doepctl);
3481864c:	e1a02003 	mov	r2, r3
34818650:	e5941000 	ldr	r1, [r4]
34818654:	e2850058 	add	r0, r5, #88	; 0x58
34818658:	e7812280 	str	r2, [r1, r0, lsl #5]
3481865c:	e59f30e4 	ldr	r3, [pc, #228]	; 34818748 <reconfig_usbd+0x17c>
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[i].diepctl);
34818660:	e2850048 	add	r0, r5, #72	; 0x48
34818664:	e5941000 	ldr	r1, [r4]

	/* 7. Set NAK bit of EP0, EP1, EP2*/
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[EP0_CON].doepctl);
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[EP0_CON].diepctl);

	for (i = 1; i < S3C_MAX_ENDPOINTS; i++) {
34818668:	e2855001 	add	r5, r5, #1
3481866c:	e3550004 	cmp	r5, #4
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[i].doepctl);
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[i].diepctl);
34818670:	e7812280 	str	r2, [r1, r0, lsl #5]

	/* 7. Set NAK bit of EP0, EP1, EP2*/
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[EP0_CON].doepctl);
	writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[EP0_CON].diepctl);

	for (i = 1; i < S3C_MAX_ENDPOINTS; i++) {
34818674:	1afffff5 	bne	34818650 <reconfig_usbd+0x84>
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->out_endp[i].doepctl);
		writel(DEPCTL_EPDIS|DEPCTL_SNAK, &reg->in_endp[i].diepctl);
	}

	/* 8. Unmask EPO interrupts*/
	writel(((1 << EP0_CON) << DAINT_OUT_BIT)
34818678:	e59f10d0 	ldr	r1, [pc, #208]	; 34818750 <reconfig_usbd+0x184>
3481867c:	e5932000 	ldr	r2, [r3]
34818680:	e582181c 	str	r1, [r2, #2076]	; 0x81c
	       | (1 << EP0_CON), &reg->daintmsk);

	/* 9. Unmask device OUT EP common interrupts*/
	writel(DOEPMSK_INIT, &reg->doepmsk);
34818684:	e5931000 	ldr	r1, [r3]
34818688:	e3a0200d 	mov	r2, #13
3481868c:	e5812814 	str	r2, [r1, #2068]	; 0x814

	/* 10. Unmask device IN EP common interrupts*/
	writel(DIEPMSK_INIT, &reg->diepmsk);
34818690:	e5931000 	ldr	r1, [r3]
34818694:	e5812810 	str	r2, [r1, #2064]	; 0x810

	/* 11. Set Rx FIFO Size (in 32-bit words) */
	writel(RX_FIFO_SIZE >> 2, &reg->grxfsiz);
34818698:	e5932000 	ldr	r2, [r3]
3481869c:	e3a01b01 	mov	r1, #1024	; 0x400
348186a0:	e5821024 	str	r1, [r2, #36]	; 0x24

	/* 12. Set Non Periodic Tx FIFO Size */
	writel((NPTX_FIFO_SIZE >> 2) << 16 | ((RX_FIFO_SIZE >> 2)) << 0,
348186a4:	e5932000 	ldr	r2, [r3]
348186a8:	e2811301 	add	r1, r1, #67108864	; 0x4000000
348186ac:	e5821028 	str	r1, [r2, #40]	; 0x28
348186b0:	e3a01000 	mov	r1, #0
348186b4:	e3a02a02 	mov	r2, #8192	; 0x2000
	       &reg->gnptxfsiz);

	for (i = 1; i < S3C_MAX_HW_ENDPOINTS; i++)
		writel((PTX_FIFO_SIZE >> 2) << 16 |
348186b8:	e1a04142 	asr	r4, r2, #2
348186bc:	e3844506 	orr	r4, r4, #25165824	; 0x1800000
348186c0:	e593c000 	ldr	ip, [r3]
348186c4:	e2822c06 	add	r2, r2, #1536	; 0x600
348186c8:	e28ccf41 	add	ip, ip, #260	; 0x104

	/* 12. Set Non Periodic Tx FIFO Size */
	writel((NPTX_FIFO_SIZE >> 2) << 16 | ((RX_FIFO_SIZE >> 2)) << 0,
	       &reg->gnptxfsiz);

	for (i = 1; i < S3C_MAX_HW_ENDPOINTS; i++)
348186cc:	e3520c7a 	cmp	r2, #31232	; 0x7a00
		writel((PTX_FIFO_SIZE >> 2) << 16 |
348186d0:	e78c4001 	str	r4, [ip, r1]
348186d4:	e59f006c 	ldr	r0, [pc, #108]	; 34818748 <reconfig_usbd+0x17c>
348186d8:	e2811004 	add	r1, r1, #4

	/* 12. Set Non Periodic Tx FIFO Size */
	writel((NPTX_FIFO_SIZE >> 2) << 16 | ((RX_FIFO_SIZE >> 2)) << 0,
	       &reg->gnptxfsiz);

	for (i = 1; i < S3C_MAX_HW_ENDPOINTS; i++)
348186dc:	1afffff5 	bne	348186b8 <reconfig_usbd+0xec>
		       ((RX_FIFO_SIZE + NPTX_FIFO_SIZE +
			 PTX_FIFO_SIZE*(i-1)) >> 2) << 0,
		       &reg->dieptxf[i-1]);

	/* Flush the RX FIFO */
	writel(RX_FIFO_FLUSH, &reg->grstctl);
348186e0:	e5903000 	ldr	r3, [r0]
348186e4:	e3a02010 	mov	r2, #16
348186e8:	e5832010 	str	r2, [r3, #16]
	while (readl(&reg->grstctl) & RX_FIFO_FLUSH)
348186ec:	e5902000 	ldr	r2, [r0]
348186f0:	e59f3050 	ldr	r3, [pc, #80]	; 34818748 <reconfig_usbd+0x17c>
348186f4:	e5922010 	ldr	r2, [r2, #16]
348186f8:	e3120010 	tst	r2, #16
348186fc:	1afffffa 	bne	348186ec <reconfig_usbd+0x120>
		debug("%s: waiting for S3C_UDC_OTG_GRSTCTL\n", __func__);

	/* Flush all the Tx FIFO's */
	writel(TX_FIFO_FLUSH_ALL, &reg->grstctl);
34818700:	e5932000 	ldr	r2, [r3]
34818704:	e3a01b01 	mov	r1, #1024	; 0x400
34818708:	e5821010 	str	r1, [r2, #16]
	writel(TX_FIFO_FLUSH_ALL | TX_FIFO_FLUSH, &reg->grstctl);
3481870c:	e5932000 	ldr	r2, [r3]
34818710:	e2811020 	add	r1, r1, #32
34818714:	e5821010 	str	r1, [r2, #16]
	while (readl(&reg->grstctl) & TX_FIFO_FLUSH)
34818718:	e5931000 	ldr	r1, [r3]
3481871c:	e59f2024 	ldr	r2, [pc, #36]	; 34818748 <reconfig_usbd+0x17c>
34818720:	e5911010 	ldr	r1, [r1, #16]
34818724:	e3110020 	tst	r1, #32
34818728:	1afffffa 	bne	34818718 <reconfig_usbd+0x14c>
		debug("%s: waiting for S3C_UDC_OTG_GRSTCTL\n", __func__);

	/* 13. Clear NAK bit of EP0, EP1, EP2*/
	/* For Slave mode*/
	/* EP0: Control OUT */
	writel(DEPCTL_EPDIS | DEPCTL_CNAK,
3481872c:	e5923000 	ldr	r3, [r2]
34818730:	e3a01311 	mov	r1, #1140850688	; 0x44000000
34818734:	e5831b00 	str	r1, [r3, #2816]	; 0xb00
	       &reg->out_endp[EP0_CON].doepctl);

	/* 14. Initialize OTG Link Core.*/
	writel(GAHBCFG_INIT, &reg->gahbcfg);
34818738:	e5923000 	ldr	r3, [r2]
3481873c:	e3a02027 	mov	r2, #39	; 0x27
34818740:	e5832008 	str	r2, [r3, #8]
}
34818744:	e8bd8038 	pop	{r3, r4, r5, pc}
34818748:	3482bc18 	.word	0x3482bc18
3481874c:	800c3800 	.word	0x800c3800
34818750:	00010001 	.word	0x00010001

34818754 <done>:

/*
 *	done - retire a request; caller blocked irqs
 */
static void done(struct s3c_ep *ep, struct s3c_request *req, int status)
{
34818754:	e92d4038 	push	{r3, r4, r5, lr}
 * list_del_init - deletes entry from list and reinitialize it.
 * @entry: the element to delete from the list.
 */
static inline void list_del_init(struct list_head *entry)
{
	__list_del(entry->prev, entry->next);
34818758:	e591c028 	ldr	ip, [r1, #40]	; 0x28
	unsigned int stopped = ep->stopped;
3481875c:	e5d05034 	ldrb	r5, [r0, #52]	; 0x34

/*
 *	done - retire a request; caller blocked irqs
 */
static void done(struct s3c_ep *ep, struct s3c_request *req, int status)
{
34818760:	e1a04000 	mov	r4, r0
34818764:	e591002c 	ldr	r0, [r1, #44]	; 0x2c
	unsigned int stopped = ep->stopped;

	debug("%s: %s %p, req = %p, stopped = %d\n",
	      __func__, ep->ep.name, ep, &req->req, stopped);

	list_del_init(&req->queue);
34818768:	e2813028 	add	r3, r1, #40	; 0x28
 * This is only for internal list manipulation where we know
 * the prev/next entries already!
 */
static inline void __list_del(struct list_head *prev, struct list_head *next)
{
	next->prev = prev;
3481876c:	e58c0004 	str	r0, [ip, #4]
	prev->next = next;
34818770:	e580c000 	str	ip, [r0]
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
	list->prev = list;
34818774:	e581302c 	str	r3, [r1, #44]	; 0x2c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34818778:	e5813028 	str	r3, [r1, #40]	; 0x28

	if (likely(req->req.status == -EINPROGRESS))
3481877c:	e5913020 	ldr	r3, [r1, #32]
		}
		printf("\n");
	}
#endif
	spin_unlock(&ep->dev->lock);
	req->req.complete(&ep->ep, &req->req);
34818780:	e1a00004 	mov	r0, r4
	debug("%s: %s %p, req = %p, stopped = %d\n",
	      __func__, ep->ep.name, ep, &req->req, stopped);

	list_del_init(&req->queue);

	if (likely(req->req.status == -EINPROGRESS))
34818784:	e3730073 	cmn	r3, #115	; 0x73
		      ep->ep.name, &req->req, status,
		      req->req.actual, req->req.length);
	}

	/* don't modify queue heads during completion callback */
	ep->stopped = 1;
34818788:	e3a03001 	mov	r3, #1
	      __func__, ep->ep.name, ep, &req->req, stopped);

	list_del_init(&req->queue);

	if (likely(req->req.status == -EINPROGRESS))
		req->req.status = status;
3481878c:	05812020 	streq	r2, [r1, #32]
		      ep->ep.name, &req->req, status,
		      req->req.actual, req->req.length);
	}

	/* don't modify queue heads during completion callback */
	ep->stopped = 1;
34818790:	e5c43034 	strb	r3, [r4, #52]	; 0x34
		}
		printf("\n");
	}
#endif
	spin_unlock(&ep->dev->lock);
	req->req.complete(&ep->ep, &req->req);
34818794:	e5913010 	ldr	r3, [r1, #16]
34818798:	e12fff33 	blx	r3
	spin_lock(&ep->dev->lock);

	debug("callback completed\n");

	ep->stopped = stopped;
3481879c:	e5c45034 	strb	r5, [r4, #52]	; 0x34
}
348187a0:	e8bd8038 	pop	{r3, r4, r5, pc}

348187a4 <s3c_dequeue>:
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
348187a4:	e3500000 	cmp	r0, #0
	kfree(req);
}

/* dequeue JUST ONE request */
static int s3c_dequeue(struct usb_ep *_ep, struct usb_request *_req)
{
348187a8:	e92d4008 	push	{r3, lr}
348187ac:	e1a03001 	mov	r3, r1
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
348187b0:	0a000013 	beq	34818804 <s3c_dequeue+0x60>
348187b4:	e59f2058 	ldr	r2, [pc, #88]	; 34818814 <s3c_dequeue+0x70>
348187b8:	e5901004 	ldr	r1, [r0, #4]
348187bc:	e1510002 	cmp	r1, r2
		return -EINVAL;

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* make sure it's actually queued on this endpoint */
	list_for_each_entry(req, &ep->queue, queue) {
348187c0:	11a02000 	movne	r2, r0
348187c4:	15b21020 	ldrne	r1, [r2, #32]!
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
348187c8:	0a00000d 	beq	34818804 <s3c_dequeue+0x60>
348187cc:	ea000002 	b	348187dc <s3c_dequeue+0x38>

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* make sure it's actually queued on this endpoint */
	list_for_each_entry(req, &ep->queue, queue) {
		if (&req->req == _req)
348187d0:	e1510003 	cmp	r1, r3
348187d4:	0a000006 	beq	348187f4 <s3c_dequeue+0x50>
		return -EINVAL;

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* make sure it's actually queued on this endpoint */
	list_for_each_entry(req, &ep->queue, queue) {
348187d8:	e5911028 	ldr	r1, [r1, #40]	; 0x28
348187dc:	e2411028 	sub	r1, r1, #40	; 0x28
348187e0:	e281c028 	add	ip, r1, #40	; 0x28
348187e4:	e15c0002 	cmp	ip, r2
348187e8:	1afffff8 	bne	348187d0 <s3c_dequeue+0x2c>
		if (&req->req == _req)
			break;
	}
	if (&req->req != _req) {
348187ec:	e1510003 	cmp	r1, r3
348187f0:	1a000005 	bne	3481880c <s3c_dequeue+0x68>
		spin_unlock_irqrestore(&ep->dev->lock, flags);
		return -EINVAL;
	}

	done(ep, req, -ECONNRESET);
348187f4:	e3e02067 	mvn	r2, #103	; 0x67
348187f8:	ebffffd5 	bl	34818754 <done>

	spin_unlock_irqrestore(&ep->dev->lock, flags);
	return 0;
348187fc:	e3a00000 	mov	r0, #0
34818800:	e8bd8008 	pop	{r3, pc}

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || ep->ep.name == ep0name)
		return -EINVAL;
34818804:	e3e00015 	mvn	r0, #21
34818808:	e8bd8008 	pop	{r3, pc}
		if (&req->req == _req)
			break;
	}
	if (&req->req != _req) {
		spin_unlock_irqrestore(&ep->dev->lock, flags);
		return -EINVAL;
3481880c:	e3e00015 	mvn	r0, #21

	done(ep, req, -ECONNRESET);

	spin_unlock_irqrestore(&ep->dev->lock, flags);
	return 0;
}
34818810:	e8bd8008 	pop	{r3, pc}
34818814:	34821594 	.word	0x34821594

34818818 <nuke>:

/*
 *	nuke - dequeue ALL requests
 */
static void nuke(struct s3c_ep *ep, int status)
{
34818818:	e92d4070 	push	{r4, r5, r6, lr}
3481881c:	e1a04000 	mov	r4, r0
34818820:	e1a06001 	mov	r6, r1
	struct s3c_request *req;

	debug("%s: %s %p\n", __func__, ep->ep.name, ep);

	/* called with irqs blocked */
	while (!list_empty(&ep->queue)) {
34818824:	e2805020 	add	r5, r0, #32
34818828:	ea000003 	b	3481883c <nuke+0x24>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		done(ep, req, status);
3481882c:	e1a00004 	mov	r0, r4
34818830:	e2411028 	sub	r1, r1, #40	; 0x28
34818834:	e1a02006 	mov	r2, r6
34818838:	ebffffc5 	bl	34818754 <done>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
3481883c:	e5941020 	ldr	r1, [r4, #32]
	struct s3c_request *req;

	debug("%s: %s %p\n", __func__, ep->ep.name, ep);

	/* called with irqs blocked */
	while (!list_empty(&ep->queue)) {
34818840:	e1510005 	cmp	r1, r5
34818844:	1afffff8 	bne	3481882c <nuke+0x14>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		done(ep, req, status);
	}
}
34818848:	e8bd8070 	pop	{r4, r5, r6, pc}

3481884c <s3c_ep_disable>:

/*
 * Disable EP
 */
static int s3c_ep_disable(struct usb_ep *_ep)
{
3481884c:	e92d4010 	push	{r4, lr}
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !ep->desc) {
34818850:	e2504000 	subs	r4, r0, #0
		debug("%s: %s not enabled\n", __func__,
		      _ep ? ep->ep.name : NULL);
		return -EINVAL;
34818854:	03e00015 	mvneq	r0, #21
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !ep->desc) {
34818858:	08bd8010 	popeq	{r4, pc}
3481885c:	e594301c 	ldr	r3, [r4, #28]
34818860:	e3530000 	cmp	r3, #0
34818864:	0a000006 	beq	34818884 <s3c_ep_disable+0x38>
	}

	spin_lock_irqsave(&ep->dev->lock, flags);

	/* Nuke all pending requests */
	nuke(ep, -ESHUTDOWN);
34818868:	e3e0106b 	mvn	r1, #107	; 0x6b
3481886c:	ebffffe9 	bl	34818818 <nuke>

	ep->desc = 0;
34818870:	e3a00000 	mov	r0, #0
	ep->stopped = 1;
34818874:	e3a03001 	mov	r3, #1
	spin_lock_irqsave(&ep->dev->lock, flags);

	/* Nuke all pending requests */
	nuke(ep, -ESHUTDOWN);

	ep->desc = 0;
34818878:	e584001c 	str	r0, [r4, #28]
	ep->stopped = 1;
3481887c:	e5c43034 	strb	r3, [r4, #52]	; 0x34

	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: disabled %s\n", __func__, _ep->name);
	return 0;
34818880:	e8bd8010 	pop	{r4, pc}

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !ep->desc) {
		debug("%s: %s not enabled\n", __func__,
		      _ep ? ep->ep.name : NULL);
		return -EINVAL;
34818884:	e3e00015 	mvn	r0, #21

	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: disabled %s\n", __func__, _ep->name);
	return 0;
}
34818888:	e8bd8010 	pop	{r4, pc}

3481888c <s3c_ep0_complete_out>:
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

}

static inline void s3c_ep0_complete_out(void)
{
3481888c:	e92d4010 	push	{r4, lr}

	debug_cond(DEBUG_IN_EP,
		"%s : Prepare Complete Out packet.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
				(unsigned long) usb_ctrl_dma_addr
34818890:	e59f4034 	ldr	r4, [pc, #52]	; 348188cc <s3c_ep0_complete_out+0x40>
34818894:	e5940004 	ldr	r0, [r4, #4]
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

	debug_cond(DEBUG_IN_EP,
		"%s : Prepare Complete Out packet.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
34818898:	e2801901 	add	r1, r0, #16384	; 0x4000
3481889c:	ebff9f77 	bl	34800680 <invalidate_dcache_range>
				(unsigned long) usb_ctrl_dma_addr
				+ DMA_BUFFER_SIZE);

	writel(DOEPT_SIZ_PKT_CNT(1) | sizeof(struct usb_ctrlrequest),
348188a0:	e59f2028 	ldr	r2, [pc, #40]	; 348188d0 <s3c_ep0_complete_out+0x44>
348188a4:	e5943000 	ldr	r3, [r4]
348188a8:	e5832b10 	str	r2, [r3, #2832]	; 0xb10
	       &reg->out_endp[EP0_CON].doeptsiz);
	writel(usb_ctrl_dma_addr, &reg->out_endp[EP0_CON].doepdma);
348188ac:	e5942004 	ldr	r2, [r4, #4]
348188b0:	e5943000 	ldr	r3, [r4]
348188b4:	e5832b14 	str	r2, [r3, #2836]	; 0xb14

	ep_ctrl = readl(&reg->out_endp[EP0_CON].doepctl);
348188b8:	e5932b00 	ldr	r2, [r3, #2816]	; 0xb00
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
348188bc:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
348188c0:	e5943000 	ldr	r3, [r4]
348188c4:	e5832b00 	str	r2, [r3, #2816]	; 0xb00
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DOEPCTL0 = 0x%x\n",
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

}
348188c8:	e8bd8010 	pop	{r4, pc}
348188cc:	3482bc18 	.word	0x3482bc18
348188d0:	00080008 	.word	0x00080008

348188d4 <setdma_rx>:


static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
348188d4:	e92d4070 	push	{r4, r5, r6, lr}
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);

	buf = req->req.buf + req->req.actual;
348188d8:	e5913024 	ldr	r3, [r1, #36]	; 0x24
348188dc:	e5912000 	ldr	r2, [r1]

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);
348188e0:	e5911004 	ldr	r1, [r1, #4]
348188e4:	e1d061b4 	ldrh	r6, [r0, #20]
{
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);

	buf = req->req.buf + req->req.actual;
348188e8:	e0822003 	add	r2, r2, r3

static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
348188ec:	e5d05035 	ldrb	r5, [r0, #53]	; 0x35

	buf = req->req.buf + req->req.actual;

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);
348188f0:	e0633001 	rsb	r3, r3, r1
348188f4:	e1560003 	cmp	r6, r3
348188f8:	21a06003 	movcs	r6, r3

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
				(unsigned long) ep->dev->dma_buf[ep_num]
348188fc:	e5903018 	ldr	r3, [r0, #24]

static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
34818900:	e205500f 	and	r5, r5, #15

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
				(unsigned long) ep->dev->dma_buf[ep_num]
34818904:	e0833105 	add	r3, r3, r5, lsl #2
	buf = req->req.buf + req->req.actual;

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);

	ep->len = length;
	ep->dma_buf = buf;
34818908:	e5802030 	str	r2, [r0, #48]	; 0x30

	buf = req->req.buf + req->req.actual;

	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);

	ep->len = length;
3481890c:	e580602c 	str	r6, [r0, #44]	; 0x2c

}


static int setdma_rx(struct s3c_ep *ep, struct s3c_request *req)
{
34818910:	e1a04000 	mov	r4, r0

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
				(unsigned long) ep->dev->dma_buf[ep_num]
34818914:	e593002c 	ldr	r0, [r3, #44]	; 0x2c
	length = min(req->req.length - req->req.actual, (int)ep->ep.maxpacket);

	ep->len = length;
	ep->dma_buf = buf;

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_num],
34818918:	e2801901 	add	r1, r0, #16384	; 0x4000
3481891c:	ebff9f57 	bl	34800680 <invalidate_dcache_range>
		pktcnt = 1;
	else
		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;

	pktcnt = 1;
	ctrl =  readl(&reg->out_endp[ep_num].doepctl);
34818920:	e59f3050 	ldr	r3, [pc, #80]	; 34818978 <setdma_rx+0xa4>
34818924:	e2852058 	add	r2, r5, #88	; 0x58
34818928:	e5931000 	ldr	r1, [r3]
3481892c:	e7911282 	ldr	r1, [r1, r2, lsl #5]

	writel(the_controller->dma_addr[ep_index(ep)+1],
34818930:	e5d4c035 	ldrb	ip, [r4, #53]	; 0x35
34818934:	e5930008 	ldr	r0, [r3, #8]
34818938:	e20cc00f 	and	ip, ip, #15
3481893c:	e28cc011 	add	ip, ip, #17
34818940:	e790c10c 	ldr	ip, [r0, ip, lsl #2]
34818944:	e5930000 	ldr	r0, [r3]
34818948:	e1a05285 	lsl	r5, r5, #5
3481894c:	e2855eb1 	add	r5, r5, #2832	; 0xb10
34818950:	e0800005 	add	r0, r0, r5
34818954:	e580c004 	str	ip, [r0, #4]
	       &reg->out_endp[ep_num].doepdma);
	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
34818958:	e3866702 	orr	r6, r6, #524288	; 0x80000
3481895c:	e5930000 	ldr	r0, [r3]
	       &reg->out_endp[ep_num].doeptsiz);
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
34818960:	e3811321 	orr	r1, r1, #-2080374784	; 0x84000000
	pktcnt = 1;
	ctrl =  readl(&reg->out_endp[ep_num].doepctl);

	writel(the_controller->dma_addr[ep_index(ep)+1],
	       &reg->out_endp[ep_num].doepdma);
	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
34818964:	e7806005 	str	r6, [r0, r5]
	       &reg->out_endp[ep_num].doeptsiz);
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
34818968:	e5933000 	ldr	r3, [r3]
		   readl(&reg->out_endp[ep_num].doeptsiz),
		   readl(&reg->out_endp[ep_num].doepctl),
		   buf, pktcnt, length);
	return 0;

}
3481896c:	e3a00000 	mov	r0, #0

	writel(the_controller->dma_addr[ep_index(ep)+1],
	       &reg->out_endp[ep_num].doepdma);
	writel(DOEPT_SIZ_PKT_CNT(pktcnt) | DOEPT_SIZ_XFER_SIZE(length),
	       &reg->out_endp[ep_num].doeptsiz);
	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->out_endp[ep_num].doepctl);
34818970:	e7831282 	str	r1, [r3, r2, lsl #5]
		   readl(&reg->out_endp[ep_num].doeptsiz),
		   readl(&reg->out_endp[ep_num].doepctl),
		   buf, pktcnt, length);
	return 0;

}
34818974:	e8bd8070 	pop	{r4, r5, r6, pc}
34818978:	3482bc18 	.word	0x3482bc18

3481897c <s3c_free_request>:
	struct s3c_request *req;

	debug("%s: %p\n", __func__, ep);

	req = container_of(_req, struct s3c_request, req);
	WARN_ON(!list_empty(&req->queue));
3481897c:	e5912028 	ldr	r2, [r1, #40]	; 0x28
34818980:	e2813028 	add	r3, r1, #40	; 0x28
34818984:	e1520003 	cmp	r2, r3

	return &req->req;
}

static void s3c_free_request(struct usb_ep *ep, struct usb_request *_req)
{
34818988:	e92d4010 	push	{r4, lr}
3481898c:	e1a04001 	mov	r4, r1
	struct s3c_request *req;

	debug("%s: %p\n", __func__, ep);

	req = container_of(_req, struct s3c_request, req);
	WARN_ON(!list_empty(&req->queue));
34818990:	0a000003 	beq	348189a4 <s3c_free_request+0x28>
34818994:	e59f0014 	ldr	r0, [pc, #20]	; 348189b0 <s3c_free_request+0x34>
34818998:	e59f1014 	ldr	r1, [pc, #20]	; 348189b4 <s3c_free_request+0x38>
3481899c:	e3a02faf 	mov	r2, #700	; 0x2bc
348189a0:	ebffc1ef 	bl	34809164 <printf>
	kfree(req);
348189a4:	e1a00004 	mov	r0, r4
}
348189a8:	e8bd4010 	pop	{r4, lr}

	debug("%s: %p\n", __func__, ep);

	req = container_of(_req, struct s3c_request, req);
	WARN_ON(!list_empty(&req->queue));
	kfree(req);
348189ac:	eaffc32a 	b	3480965c <free>
348189b0:	34827e0b 	.word	0x34827e0b
348189b4:	34827e22 	.word	0x34827e22

348189b8 <s3c_alloc_request>:
	return 0;
}

static struct usb_request *s3c_alloc_request(struct usb_ep *ep,
					     gfp_t gfp_flags)
{
348189b8:	e92d4010 	push	{r4, lr}
	struct s3c_request *req;

	debug("%s: %s %p\n", __func__, ep->name, ep);

	req = memalign(CONFIG_SYS_CACHELINE_SIZE, sizeof(*req));
348189bc:	e3a00040 	mov	r0, #64	; 0x40
348189c0:	e3a01030 	mov	r1, #48	; 0x30
348189c4:	ebffc552 	bl	34809f14 <memalign>
	if (!req)
348189c8:	e2504000 	subs	r4, r0, #0
348189cc:	0a000005 	beq	348189e8 <s3c_alloc_request+0x30>
		return 0;

	memset(req, 0, sizeof *req);
348189d0:	e3a01000 	mov	r1, #0
348189d4:	e3a02030 	mov	r2, #48	; 0x30
348189d8:	eb000d39 	bl	3481bec4 <memset>
	INIT_LIST_HEAD(&req->queue);
348189dc:	e2843028 	add	r3, r4, #40	; 0x28
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
348189e0:	e5843028 	str	r3, [r4, #40]	; 0x28
	list->prev = list;
348189e4:	e584302c 	str	r3, [r4, #44]	; 0x2c

	return &req->req;
}
348189e8:	e1a00004 	mov	r0, r4
348189ec:	e8bd8010 	pop	{r4, pc}

348189f0 <s3c_udc_ep0_zlp.clone.2>:

/* Bulk-Only Mass Storage Reset (class-specific request) */
#define GET_MAX_LUN_REQUEST	0xFE
#define BOT_RESET_REQUEST	0xFF

static inline void s3c_udc_ep0_zlp(struct s3c_udc *dev)
348189f0:	e92d4038 	push	{r3, r4, r5, lr}
{
	u32 ep_ctrl;

	flush_dcache_range((unsigned long) usb_ctrl_dma_addr,
			   (unsigned long) usb_ctrl_dma_addr
348189f4:	e59f4040 	ldr	r4, [pc, #64]	; 34818a3c <s3c_udc_ep0_zlp.clone.2+0x4c>

/* Bulk-Only Mass Storage Reset (class-specific request) */
#define GET_MAX_LUN_REQUEST	0xFE
#define BOT_RESET_REQUEST	0xFF

static inline void s3c_udc_ep0_zlp(struct s3c_udc *dev)
348189f8:	e1a05000 	mov	r5, r0
{
	u32 ep_ctrl;

	flush_dcache_range((unsigned long) usb_ctrl_dma_addr,
			   (unsigned long) usb_ctrl_dma_addr
348189fc:	e5940004 	ldr	r0, [r4, #4]

static inline void s3c_udc_ep0_zlp(struct s3c_udc *dev)
{
	u32 ep_ctrl;

	flush_dcache_range((unsigned long) usb_ctrl_dma_addr,
34818a00:	e2801901 	add	r1, r0, #16384	; 0x4000
34818a04:	ebff9f26 	bl	348006a4 <flush_dcache_range>
			   (unsigned long) usb_ctrl_dma_addr
			   + DMA_BUFFER_SIZE);

	writel(usb_ctrl_dma_addr, &reg->in_endp[EP0_CON].diepdma);
34818a08:	e5942004 	ldr	r2, [r4, #4]
34818a0c:	e5943000 	ldr	r3, [r4]
34818a10:	e5832914 	str	r2, [r3, #2324]	; 0x914
	writel(DIEPT_SIZ_PKT_CNT(1), &reg->in_endp[EP0_CON].dieptsiz);
34818a14:	e5943000 	ldr	r3, [r4]
34818a18:	e3a02702 	mov	r2, #524288	; 0x80000
34818a1c:	e5832910 	str	r2, [r3, #2320]	; 0x910

	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
34818a20:	e5932900 	ldr	r2, [r3, #2304]	; 0x900
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
34818a24:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
34818a28:	e5943000 	ldr	r3, [r4]
34818a2c:	e5832900 	str	r2, [r3, #2304]	; 0x900
	       &reg->in_endp[EP0_CON].diepctl);

	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	dev->ep0state = WAIT_FOR_IN_COMPLETE;
34818a30:	e3a03007 	mov	r3, #7
34818a34:	e5853000 	str	r3, [r5]
}
34818a38:	e8bd8038 	pop	{r3, r4, r5, pc}
34818a3c:	3482bc18 	.word	0x3482bc18

34818a40 <complete_rx>:

	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
34818a40:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
34818a44:	e1a05001 	mov	r5, r1
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34818a48:	e1a01301 	lsl	r1, r1, #6
34818a4c:	e0802001 	add	r2, r0, r1
34818a50:	e59f3134 	ldr	r3, [pc, #308]	; 34818b8c <complete_rx+0x14c>

	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
34818a54:	e1a04000 	mov	r4, r0
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34818a58:	e5d2008d 	ldrb	r0, [r2, #141]	; 0x8d
34818a5c:	e593c008 	ldr	ip, [r3, #8]

	if (list_empty(&ep->queue)) {
34818a60:	e2811078 	add	r1, r1, #120	; 0x78
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34818a64:	e5926078 	ldr	r6, [r2, #120]	; 0x78
34818a68:	e0841001 	add	r1, r4, r1
static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34818a6c:	e200000f 	and	r0, r0, #15
34818a70:	e08c0100 	add	r0, ip, r0, lsl #2

	if (list_empty(&ep->queue)) {
34818a74:	e1560001 	cmp	r6, r1
static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req = NULL;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34818a78:	e5909030 	ldr	r9, [r0, #48]	; 0x30

	if (list_empty(&ep->queue)) {
34818a7c:	e58d100c 	str	r1, [sp, #12]
34818a80:	0a00003f 	beq	34818b84 <complete_rx+0x144>
		return;

	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);
34818a84:	e5933000 	ldr	r3, [r3]
			   __func__, ep_num);
		return;

	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
34818a88:	e246c028 	sub	ip, r6, #40	; 0x28
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);
34818a8c:	e0833285 	add	r3, r3, r5, lsl #5
34818a90:	e5933b10 	ldr	r3, [r3, #2832]	; 0xb10
	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;
34818a94:	e285b002 	add	fp, r5, #2
	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);

	if (ep_num == EP0_CON)
34818a98:	e3550000 	cmp	r5, #0
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;
34818a9c:	e084b30b 	add	fp, r4, fp, lsl #6
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);

	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);
34818aa0:	11a03883 	lslne	r3, r3, #17

	xfer_size = ep->len - xfer_size;
34818aa4:	e59b2004 	ldr	r2, [fp, #4]

	req = list_entry(ep->queue.next, struct s3c_request, queue);
	ep_tsr = readl(&reg->out_endp[ep_num].doeptsiz);

	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
34818aa8:	0203307f 	andeq	r3, r3, #127	; 0x7f
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);
34818aac:	11a038a3 	lsrne	r3, r3, #17
	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
34818ab0:	e1a0a305 	lsl	sl, r5, #6
	if (ep_num == EP0_CON)
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP0);
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;
34818ab4:	e0633002 	rsb	r3, r3, r2
	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
34818ab8:	e28a7058 	add	r7, sl, #88	; 0x58
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;

	invalidate_dcache_range((unsigned long) p,
34818abc:	e1a00009 	mov	r0, r9
34818ac0:	e2891901 	add	r1, r9, #16384	; 0x4000
				(unsigned long) p + DMA_BUFFER_SIZE);

	memcpy(ep->dma_buf, p, ep->len);
34818ac4:	e084a00a 	add	sl, r4, sl
	else
		xfer_size = (ep_tsr & DOEPT_SIZ_XFER_SIZE_MAX_EP);

	xfer_size = ep->len - xfer_size;

	invalidate_dcache_range((unsigned long) p,
34818ac8:	e98d1008 	stmib	sp, {r3, ip}
34818acc:	ebff9eeb 	bl	34800680 <invalidate_dcache_range>
				(unsigned long) p + DMA_BUFFER_SIZE);

	memcpy(ep->dma_buf, p, ep->len);
34818ad0:	e1a01009 	mov	r1, r9
34818ad4:	e59b2004 	ldr	r2, [fp, #4]
34818ad8:	e59a0088 	ldr	r0, [sl, #136]	; 0x88
34818adc:	eb000d1c 	bl	3481bf54 <memcpy>

	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34818ae0:	e5161004 	ldr	r1, [r6, #-4]
34818ae4:	e5162024 	ldr	r2, [r6, #-36]	; 0x24
34818ae8:	e59d3004 	ldr	r3, [sp, #4]
34818aec:	e0610002 	rsb	r0, r1, r2
34818af0:	e1530000 	cmp	r3, r0
34818af4:	90811003 	addls	r1, r1, r3
34818af8:	80811000 	addhi	r1, r1, r0
	is_short = (xfer_size < ep->ep.maxpacket);
34818afc:	e1da06bc 	ldrh	r0, [sl, #108]	; 0x6c
	return length;
}

static void complete_rx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
34818b00:	e0847007 	add	r7, r4, r7
		   "%s: RX DMA done : ep = %d, rx bytes = %d/%d, "
		   "is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
		   __func__, ep_num, req->req.actual, req->req.length,
		   is_short, ep_tsr, xfer_size);

	if (is_short || req->req.actual == req->req.length) {
34818b04:	e1530000 	cmp	r3, r0
	invalidate_dcache_range((unsigned long) p,
				(unsigned long) p + DMA_BUFFER_SIZE);

	memcpy(ep->dma_buf, p, ep->len);

	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34818b08:	e5061004 	str	r1, [r6, #-4]
		   "%s: RX DMA done : ep = %d, rx bytes = %d/%d, "
		   "is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
		   __func__, ep_num, req->req.actual, req->req.length,
		   is_short, ep_tsr, xfer_size);

	if (is_short || req->req.actual == req->req.length) {
34818b0c:	e59dc008 	ldr	ip, [sp, #8]
34818b10:	3a000003 	bcc	34818b24 <complete_rx+0xe4>
34818b14:	e1510002 	cmp	r1, r2
					   __func__);
				setdma_rx(ep, req);
			}
		}
	} else
		setdma_rx(ep, req);
34818b18:	11a00007 	movne	r0, r7
34818b1c:	11a0100c 	movne	r1, ip
		   "%s: RX DMA done : ep = %d, rx bytes = %d/%d, "
		   "is_short = %d, DOEPTSIZ = 0x%x, remained bytes = %d\n",
		   __func__, ep_num, req->req.actual, req->req.length,
		   is_short, ep_tsr, xfer_size);

	if (is_short || req->req.actual == req->req.length) {
34818b20:	1a000014 	bne	34818b78 <complete_rx+0x138>
		if (ep_num == EP0_CON && dev->ep0state == DATA_STATE_RECV) {
34818b24:	e3550000 	cmp	r5, #0
34818b28:	1a000007 	bne	34818b4c <complete_rx+0x10c>
34818b2c:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34818b30:	e3530004 	cmp	r3, #4
34818b34:	1a000004 	bne	34818b4c <complete_rx+0x10c>
			debug_cond(DEBUG_OUT_EP != 0, "	=> Send ZLP\n");
			s3c_udc_ep0_zlp(dev);
34818b38:	e2840054 	add	r0, r4, #84	; 0x54
34818b3c:	ebffffab 	bl	348189f0 <s3c_udc_ep0_zlp.clone.2>
			/* packet will be completed in complete_tx() */
			dev->ep0state = WAIT_FOR_IN_COMPLETE;
34818b40:	e3a03007 	mov	r3, #7
34818b44:	e5843054 	str	r3, [r4, #84]	; 0x54
34818b48:	ea00000d 	b	34818b84 <complete_rx+0x144>
		} else {
			done(ep, req, 0);
34818b4c:	e1a00007 	mov	r0, r7
34818b50:	e1a0100c 	mov	r1, ip
34818b54:	e3a02000 	mov	r2, #0
34818b58:	e0844305 	add	r4, r4, r5, lsl #6
34818b5c:	ebfffefc 	bl	34818754 <done>
34818b60:	e5941078 	ldr	r1, [r4, #120]	; 0x78

			if (!list_empty(&ep->queue)) {
34818b64:	e59d200c 	ldr	r2, [sp, #12]
34818b68:	e1510002 	cmp	r1, r2
				req = list_entry(ep->queue.next,
					struct s3c_request, queue);
				debug_cond(DEBUG_OUT_EP != 0,
					   "%s: Next Rx request start...\n",
					   __func__);
				setdma_rx(ep, req);
34818b6c:	11a00007 	movne	r0, r7
34818b70:	12411028 	subne	r1, r1, #40	; 0x28
			/* packet will be completed in complete_tx() */
			dev->ep0state = WAIT_FOR_IN_COMPLETE;
		} else {
			done(ep, req, 0);

			if (!list_empty(&ep->queue)) {
34818b74:	0a000002 	beq	34818b84 <complete_rx+0x144>
				setdma_rx(ep, req);
			}
		}
	} else
		setdma_rx(ep, req);
}
34818b78:	e28dd010 	add	sp, sp, #16
34818b7c:	e8bd4ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, lr}
					   __func__);
				setdma_rx(ep, req);
			}
		}
	} else
		setdma_rx(ep, req);
34818b80:	eaffff53 	b	348188d4 <setdma_rx>
}
34818b84:	e28dd010 	add	sp, sp, #16
34818b88:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34818b8c:	3482bc18 	.word	0x3482bc18

34818b90 <udc_set_address>:
 *
 * Called from control endpoint function
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
34818b90:	e92d4038 	push	{r3, r4, r5, lr}
	u32 ctrl = readl(&reg->dcfg);
34818b94:	e59f3028 	ldr	r3, [pc, #40]	; 34818bc4 <udc_set_address+0x34>
 *
 * Called from control endpoint function
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
34818b98:	e1a04000 	mov	r4, r0
	u32 ctrl = readl(&reg->dcfg);
34818b9c:	e5932000 	ldr	r2, [r3]
 *
 * Called from control endpoint function
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
34818ba0:	e1a05001 	mov	r5, r1
	u32 ctrl = readl(&reg->dcfg);
34818ba4:	e5922800 	ldr	r2, [r2, #2048]	; 0x800
	writel(DEVICE_ADDRESS(address) | ctrl, &reg->dcfg);
34818ba8:	e1822201 	orr	r2, r2, r1, lsl #4
34818bac:	e5933000 	ldr	r3, [r3]

	s3c_udc_ep0_zlp(dev);
34818bb0:	e2800054 	add	r0, r0, #84	; 0x54
 * after it decodes a set address setup packet.
 */
static void udc_set_address(struct s3c_udc *dev, unsigned char address)
{
	u32 ctrl = readl(&reg->dcfg);
	writel(DEVICE_ADDRESS(address) | ctrl, &reg->dcfg);
34818bb4:	e5832800 	str	r2, [r3, #2048]	; 0x800

	s3c_udc_ep0_zlp(dev);
34818bb8:	ebffff8c 	bl	348189f0 <s3c_udc_ep0_zlp.clone.2>

	debug_cond(DEBUG_EP0 != 0,
		   "%s: USB OTG 2.0 Device address=%d, DCFG=0x%x\n",
		   __func__, address, readl(&reg->dcfg));

	dev->usb_address = address;
34818bbc:	e5c45158 	strb	r5, [r4, #344]	; 0x158
}
34818bc0:	e8bd8038 	pop	{r3, r4, r5, pc}
34818bc4:	3482bc18 	.word	0x3482bc18

34818bc8 <set_udc_gadget_private_data>:
void set_udc_gadget_private_data(void *p)
{
	debug_cond(DEBUG_SETUP != 0,
		   "%s: the_controller: 0x%p, p: 0x%p\n", __func__,
		   the_controller, p);
	the_controller->gadget.dev.device_data = p;
34818bc8:	e59f3008 	ldr	r3, [pc, #8]	; 34818bd8 <set_udc_gadget_private_data+0x10>
34818bcc:	e5933008 	ldr	r3, [r3, #8]
34818bd0:	e5830020 	str	r0, [r3, #32]
}
34818bd4:	e12fff1e 	bx	lr
34818bd8:	3482bc18 	.word	0x3482bc18

34818bdc <get_udc_gadget_private_data>:

void *get_udc_gadget_private_data(struct usb_gadget *gadget)
{
	return gadget->dev.device_data;
}
34818bdc:	e5900020 	ldr	r0, [r0, #32]
34818be0:	e12fff1e 	bx	lr

34818be4 <otg_phy_init>:
struct s3c_usbotg_phy *phy;
static unsigned int usb_phy_ctrl;

void otg_phy_init(struct s3c_udc *dev)
{
	dev->pdata->phy_control(1);
34818be4:	e5903028 	ldr	r3, [r0, #40]	; 0x28
struct s3c_usbotg_reg *reg;
struct s3c_usbotg_phy *phy;
static unsigned int usb_phy_ctrl;

void otg_phy_init(struct s3c_udc *dev)
{
34818be8:	e92d4010 	push	{r4, lr}
	dev->pdata->phy_control(1);
34818bec:	e5933000 	ldr	r3, [r3]
struct s3c_usbotg_reg *reg;
struct s3c_usbotg_phy *phy;
static unsigned int usb_phy_ctrl;

void otg_phy_init(struct s3c_udc *dev)
{
34818bf0:	e1a04000 	mov	r4, r0
	dev->pdata->phy_control(1);
34818bf4:	e3a00001 	mov	r0, #1
34818bf8:	e12fff33 	blx	r3

	/*USB PHY0 Enable */
	printf("USB PHY0 Enable\n");
34818bfc:	e59f00a4 	ldr	r0, [pc, #164]	; 34818ca8 <otg_phy_init+0xc4>
34818c00:	ebffc157 	bl	34809164 <printf>

	/* Enable PHY */
	writel(readl(usb_phy_ctrl) | USB_PHY_CTRL_EN0, usb_phy_ctrl);
34818c04:	e59f30a0 	ldr	r3, [pc, #160]	; 34818cac <otg_phy_init+0xc8>
34818c08:	e593200c 	ldr	r2, [r3, #12]
34818c0c:	e5921000 	ldr	r1, [r2]
34818c10:	e3811001 	orr	r1, r1, #1
34818c14:	e593200c 	ldr	r2, [r3, #12]
34818c18:	e5821000 	str	r1, [r2]

	if (dev->pdata->usb_flags == PHY0_SLEEP) /* C210 Universal */
34818c1c:	e5942028 	ldr	r2, [r4, #40]	; 0x28
34818c20:	e5922010 	ldr	r2, [r2, #16]
34818c24:	e3520020 	cmp	r2, #32
34818c28:	1a000003 	bne	34818c3c <otg_phy_init+0x58>
		writel((readl(&phy->phypwr)
34818c2c:	e5932010 	ldr	r2, [r3, #16]
34818c30:	e5922000 	ldr	r2, [r2]
34818c34:	e3c22039 	bic	r2, r2, #57	; 0x39
34818c38:	ea000002 	b	34818c48 <otg_phy_init+0x64>
			&~(PHY_0_SLEEP | OTG_DISABLE_0 | ANALOG_PWRDOWN)
			&~FORCE_SUSPEND_0), &phy->phypwr);
	else /* C110 GONI */
		writel((readl(&phy->phypwr) &~(OTG_DISABLE_0 | ANALOG_PWRDOWN)
34818c3c:	e5932010 	ldr	r2, [r3, #16]
34818c40:	e5922000 	ldr	r2, [r2]
34818c44:	e3c22019 	bic	r2, r2, #25
34818c48:	e5933010 	ldr	r3, [r3, #16]
			&~FORCE_SUSPEND_0), &phy->phypwr);

	writel((readl(&phy->phyclk) &~(ID_PULLUP0 | COMMON_ON_N0)) |
34818c4c:	e59f4058 	ldr	r4, [pc, #88]	; 34818cac <otg_phy_init+0xc8>
	if (dev->pdata->usb_flags == PHY0_SLEEP) /* C210 Universal */
		writel((readl(&phy->phypwr)
			&~(PHY_0_SLEEP | OTG_DISABLE_0 | ANALOG_PWRDOWN)
			&~FORCE_SUSPEND_0), &phy->phypwr);
	else /* C110 GONI */
		writel((readl(&phy->phypwr) &~(OTG_DISABLE_0 | ANALOG_PWRDOWN)
34818c50:	e5832000 	str	r2, [r3]
			&~FORCE_SUSPEND_0), &phy->phypwr);

	writel((readl(&phy->phyclk) &~(ID_PULLUP0 | COMMON_ON_N0)) |
34818c54:	e5943010 	ldr	r3, [r4, #16]
34818c58:	e5932004 	ldr	r2, [r3, #4]
34818c5c:	e3c22017 	bic	r2, r2, #23
34818c60:	e3822003 	orr	r2, r2, #3
34818c64:	e5943010 	ldr	r3, [r4, #16]
34818c68:	e5832004 	str	r2, [r3, #4]
	       CLK_SEL_24MHZ, &phy->phyclk); /* PLL 24Mhz */

	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
34818c6c:	e5932008 	ldr	r2, [r3, #8]
34818c70:	e3c22007 	bic	r2, r2, #7
34818c74:	e3822001 	orr	r2, r2, #1
34818c78:	e5943010 	ldr	r3, [r4, #16]
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
34818c7c:	e3a0000a 	mov	r0, #10
			&~FORCE_SUSPEND_0), &phy->phypwr);

	writel((readl(&phy->phyclk) &~(ID_PULLUP0 | COMMON_ON_N0)) |
	       CLK_SEL_24MHZ, &phy->phyclk); /* PLL 24Mhz */

	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
34818c80:	e5832008 	str	r2, [r3, #8]
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
34818c84:	eb000d3d 	bl	3481c180 <udelay>
	writel(readl(&phy->rstcon)
34818c88:	e5943010 	ldr	r3, [r4, #16]
34818c8c:	e5932008 	ldr	r2, [r3, #8]
34818c90:	e3c22007 	bic	r2, r2, #7
34818c94:	e5943010 	ldr	r3, [r4, #16]
	       &~(PHY_SW_RST0 | LINK_SW_RST | PHYLNK_SW_RST), &phy->rstcon);
	udelay(10);
34818c98:	e3a0000a 	mov	r0, #10
	       CLK_SEL_24MHZ, &phy->phyclk); /* PLL 24Mhz */

	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
	writel(readl(&phy->rstcon)
34818c9c:	e5832008 	str	r2, [r3, #8]
	       &~(PHY_SW_RST0 | LINK_SW_RST | PHYLNK_SW_RST), &phy->rstcon);
	udelay(10);
}
34818ca0:	e8bd4010 	pop	{r4, lr}
	writel((readl(&phy->rstcon) &~(LINK_SW_RST | PHYLNK_SW_RST))
	       | PHY_SW_RST0, &phy->rstcon);
	udelay(10);
	writel(readl(&phy->rstcon)
	       &~(PHY_SW_RST0 | LINK_SW_RST | PHYLNK_SW_RST), &phy->rstcon);
	udelay(10);
34818ca4:	ea000d35 	b	3481c180 <udelay>
34818ca8:	34827e30 	.word	0x34827e30
34818cac:	3482bc18 	.word	0x3482bc18

34818cb0 <otg_phy_off>:
}

void otg_phy_off(struct s3c_udc *dev)
{
34818cb0:	e92d4038 	push	{r3, r4, r5, lr}
34818cb4:	e1a05000 	mov	r5, r0
	/* reset controller just in case */
	writel(PHY_SW_RST0, &phy->rstcon);
34818cb8:	e59f4084 	ldr	r4, [pc, #132]	; 34818d44 <otg_phy_off+0x94>
34818cbc:	e3a02001 	mov	r2, #1
34818cc0:	e5943010 	ldr	r3, [r4, #16]
	udelay(20);
34818cc4:	e3a00014 	mov	r0, #20
}

void otg_phy_off(struct s3c_udc *dev)
{
	/* reset controller just in case */
	writel(PHY_SW_RST0, &phy->rstcon);
34818cc8:	e5832008 	str	r2, [r3, #8]
	udelay(20);
34818ccc:	eb000d2b 	bl	3481c180 <udelay>
	writel(readl(&phy->phypwr) &~PHY_SW_RST0, &phy->rstcon);
34818cd0:	e5943010 	ldr	r3, [r4, #16]
34818cd4:	e5932000 	ldr	r2, [r3]
34818cd8:	e3c22001 	bic	r2, r2, #1
34818cdc:	e5943010 	ldr	r3, [r4, #16]
	udelay(20);
34818ce0:	e3a00014 	mov	r0, #20
void otg_phy_off(struct s3c_udc *dev)
{
	/* reset controller just in case */
	writel(PHY_SW_RST0, &phy->rstcon);
	udelay(20);
	writel(readl(&phy->phypwr) &~PHY_SW_RST0, &phy->rstcon);
34818ce4:	e5832008 	str	r2, [r3, #8]
	udelay(20);
34818ce8:	eb000d24 	bl	3481c180 <udelay>

	writel(readl(&phy->phypwr) | OTG_DISABLE_0 | ANALOG_PWRDOWN
34818cec:	e5943010 	ldr	r3, [r4, #16]
34818cf0:	e5932000 	ldr	r2, [r3]
34818cf4:	e3822019 	orr	r2, r2, #25
34818cf8:	e5943010 	ldr	r3, [r4, #16]
34818cfc:	e5832000 	str	r2, [r3]
	       | FORCE_SUSPEND_0, &phy->phypwr);

	writel(readl(usb_phy_ctrl) &~USB_PHY_CTRL_EN0, usb_phy_ctrl);
34818d00:	e594300c 	ldr	r3, [r4, #12]
34818d04:	e5932000 	ldr	r2, [r3]
34818d08:	e3c22001 	bic	r2, r2, #1
34818d0c:	e594300c 	ldr	r3, [r4, #12]
34818d10:	e5832000 	str	r2, [r3]

	writel((readl(&phy->phyclk) & ~(ID_PULLUP0 | COMMON_ON_N0)),
34818d14:	e5943010 	ldr	r3, [r4, #16]
34818d18:	e5932004 	ldr	r2, [r3, #4]
34818d1c:	e3c22014 	bic	r2, r2, #20
34818d20:	e5943010 	ldr	r3, [r4, #16]
	      &phy->phyclk);

	udelay(10000);
34818d24:	e3020710 	movw	r0, #10000	; 0x2710
	writel(readl(&phy->phypwr) | OTG_DISABLE_0 | ANALOG_PWRDOWN
	       | FORCE_SUSPEND_0, &phy->phypwr);

	writel(readl(usb_phy_ctrl) &~USB_PHY_CTRL_EN0, usb_phy_ctrl);

	writel((readl(&phy->phyclk) & ~(ID_PULLUP0 | COMMON_ON_N0)),
34818d28:	e5832004 	str	r2, [r3, #4]
	      &phy->phyclk);

	udelay(10000);
34818d2c:	eb000d13 	bl	3481c180 <udelay>

	dev->pdata->phy_control(0);
34818d30:	e5953028 	ldr	r3, [r5, #40]	; 0x28
34818d34:	e3a00000 	mov	r0, #0
34818d38:	e5933000 	ldr	r3, [r3]
34818d3c:	e12fff33 	blx	r3
}
34818d40:	e8bd8038 	pop	{r3, r4, r5, pc}
34818d44:	3482bc18 	.word	0x3482bc18

34818d48 <s3c_udc_pre_setup>:
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	dev->ep0state = WAIT_FOR_IN_COMPLETE;
}

void s3c_udc_pre_setup(void)
{
34818d48:	e92d4010 	push	{r4, lr}

	debug_cond(DEBUG_IN_EP,
		   "%s : Prepare Setup packets.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
				(unsigned long) usb_ctrl_dma_addr
34818d4c:	e59f4034 	ldr	r4, [pc, #52]	; 34818d88 <s3c_udc_pre_setup+0x40>
34818d50:	e5940004 	ldr	r0, [r4, #4]
	u32 ep_ctrl;

	debug_cond(DEBUG_IN_EP,
		   "%s : Prepare Setup packets.\n", __func__);

	invalidate_dcache_range((unsigned long) usb_ctrl_dma_addr,
34818d54:	e2801901 	add	r1, r0, #16384	; 0x4000
34818d58:	ebff9e48 	bl	34800680 <invalidate_dcache_range>
				(unsigned long) usb_ctrl_dma_addr
				+ DMA_BUFFER_SIZE);

	writel(DOEPT_SIZ_PKT_CNT(1) | sizeof(struct usb_ctrlrequest),
34818d5c:	e59f2028 	ldr	r2, [pc, #40]	; 34818d8c <s3c_udc_pre_setup+0x44>
34818d60:	e5943000 	ldr	r3, [r4]
34818d64:	e5832b10 	str	r2, [r3, #2832]	; 0xb10
	       &reg->out_endp[EP0_CON].doeptsiz);
	writel(usb_ctrl_dma_addr, &reg->out_endp[EP0_CON].doepdma);
34818d68:	e5942004 	ldr	r2, [r4, #4]
34818d6c:	e5943000 	ldr	r3, [r4]
34818d70:	e5832b14 	str	r2, [r3, #2836]	; 0xb14

	ep_ctrl = readl(&reg->out_endp[EP0_CON].doepctl);
34818d74:	e5932b00 	ldr	r2, [r3, #2816]	; 0xb00
	writel(ep_ctrl|DEPCTL_EPENA, &reg->out_endp[EP0_CON].doepctl);
34818d78:	e3822102 	orr	r2, r2, #-2147483648	; 0x80000000
34818d7c:	e5943000 	ldr	r3, [r4]
34818d80:	e5832b00 	str	r2, [r3, #2816]	; 0xb00
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DIEPCTL0 = 0x%x\n",
		__func__, readl(&reg->in_endp[EP0_CON].diepctl));
	debug_cond(DEBUG_EP0 != 0, "%s:EP0 ZLP DOEPCTL0 = 0x%x\n",
		__func__, readl(&reg->out_endp[EP0_CON].doepctl));

}
34818d84:	e8bd8010 	pop	{r4, pc}
34818d88:	3482bc18 	.word	0x3482bc18
34818d8c:	00080008 	.word	0x00080008

34818d90 <s3c_udc_ep0_set_stall.clone.3>:
{
	struct s3c_udc *dev;
	u32		ep_ctrl = 0;

	dev = ep->dev;
	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
34818d90:	e59f3028 	ldr	r3, [pc, #40]	; 34818dc0 <s3c_udc_ep0_set_stall.clone.3+0x30>
34818d94:	e5933000 	ldr	r3, [r3]
34818d98:	e5933900 	ldr	r3, [r3, #2304]	; 0x900

	/* set the disable and stall bits */
	if (ep_ctrl & DEPCTL_EPENA)
34818d9c:	e3530000 	cmp	r3, #0
		ep_ctrl |= DEPCTL_EPDIS;
34818da0:	b3833101 	orrlt	r3, r3, #1073741824	; 0x40000000

	ep_ctrl |= DEPCTL_STALL;
34818da4:	e3833602 	orr	r3, r3, #2097152	; 0x200000

	writel(ep_ctrl, &reg->in_endp[EP0_CON].diepctl);
34818da8:	e59f2010 	ldr	r2, [pc, #16]	; 34818dc0 <s3c_udc_ep0_set_stall.clone.3+0x30>
34818dac:	e5922000 	ldr	r2, [r2]
34818db0:	e5823900 	str	r3, [r2, #2304]	; 0x900
		   __func__, ep_index(ep), &reg->in_endp[EP0_CON].diepctl);
	/*
	 * The application can only set this bit, and the core clears it,
	 * when a SETUP token is received for this endpoint
	 */
	dev->ep0state = WAIT_FOR_SETUP;
34818db4:	e3a03000 	mov	r3, #0
34818db8:	e5803054 	str	r3, [r0, #84]	; 0x54

	s3c_udc_pre_setup();
34818dbc:	eaffffe1 	b	34818d48 <s3c_udc_pre_setup>
34818dc0:	3482bc18 	.word	0x3482bc18

34818dc4 <setdma_tx>:
	return 0;

}

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
34818dc4:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34818dc8:	e59f211c 	ldr	r2, [pc, #284]	; 34818eec <setdma_tx+0x128>

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
34818dcc:	e5d06035 	ldrb	r6, [r0, #53]	; 0x35
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34818dd0:	e5922008 	ldr	r2, [r2, #8]

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
34818dd4:	e206600f 	and	r6, r6, #15
	return 0;

}

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
34818dd8:	e1a03001 	mov	r3, r1
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];
34818ddc:	e0822106 	add	r2, r2, r6, lsl #2
34818de0:	e5927030 	ldr	r7, [r2, #48]	; 0x30

	buf = req->req.buf + req->req.actual;
	length = req->req.length - req->req.actual;
34818de4:	e5935004 	ldr	r5, [r3, #4]
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];

	buf = req->req.buf + req->req.actual;
34818de8:	e5912024 	ldr	r2, [r1, #36]	; 0x24
34818dec:	e5911000 	ldr	r1, [r1]
	length = req->req.length - req->req.actual;

	if (ep_num == EP0_CON)
34818df0:	e3560000 	cmp	r6, #0
	return 0;

}

int setdma_tx(struct s3c_ep *ep, struct s3c_request *req)
{
34818df4:	e1a04000 	mov	r4, r0
	u32 *buf, ctrl = 0;
	u32 length, pktcnt;
	u32 ep_num = ep_index(ep);
	u32 *p = the_controller->dma_buf[ep_index(ep)+1];

	buf = req->req.buf + req->req.actual;
34818df8:	e0811002 	add	r1, r1, r2
	length = req->req.length - req->req.actual;
34818dfc:	e0625005 	rsb	r5, r2, r5

	if (ep_num == EP0_CON)
34818e00:	1a000002 	bne	34818e10 <setdma_tx+0x4c>
		length = min(length, (u32)ep_maxpacket(ep));
34818e04:	e1d031b4 	ldrh	r3, [r0, #20]
34818e08:	e1550003 	cmp	r5, r3
34818e0c:	21a05003 	movcs	r5, r3

	ep->len = length;
	ep->dma_buf = buf;
34818e10:	e5841030 	str	r1, [r4, #48]	; 0x30
	memcpy(p, ep->dma_buf, length);
34818e14:	e1a02005 	mov	r2, r5
	length = req->req.length - req->req.actual;

	if (ep_num == EP0_CON)
		length = min(length, (u32)ep_maxpacket(ep));

	ep->len = length;
34818e18:	e584502c 	str	r5, [r4, #44]	; 0x2c
	ep->dma_buf = buf;
	memcpy(p, ep->dma_buf, length);
34818e1c:	e1a00007 	mov	r0, r7
34818e20:	eb000c4b 	bl	3481bf54 <memcpy>

	flush_dcache_range((unsigned long) p ,
34818e24:	e1a00007 	mov	r0, r7
34818e28:	e2871901 	add	r1, r7, #16384	; 0x4000
34818e2c:	ebff9e1c 	bl	348006a4 <flush_dcache_range>
			   (unsigned long) p + DMA_BUFFER_SIZE);

	if (length == 0)
34818e30:	e3550000 	cmp	r5, #0
		pktcnt = 1;
34818e34:	03a00001 	moveq	r0, #1
	memcpy(p, ep->dma_buf, length);

	flush_dcache_range((unsigned long) p ,
			   (unsigned long) p + DMA_BUFFER_SIZE);

	if (length == 0)
34818e38:	0a000003 	beq	34818e4c <setdma_tx+0x88>
		pktcnt = 1;
	else
		pktcnt = (length - 1)/(ep->ep.maxpacket) + 1;
34818e3c:	e2450001 	sub	r0, r5, #1
34818e40:	e1d411b4 	ldrh	r1, [r4, #20]
34818e44:	eb001b55 	bl	3481fba0 <__udivsi3>
34818e48:	e2800001 	add	r0, r0, #1

	/* Flush the endpoint's Tx FIFO */
	writel(TX_FIFO_NUMBER(ep->fifo_num), &reg->grstctl);
34818e4c:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
34818e50:	e1a01301 	lsl	r1, r1, #6
34818e54:	e59f3090 	ldr	r3, [pc, #144]	; 34818eec <setdma_tx+0x128>
34818e58:	e5932000 	ldr	r2, [r3]
34818e5c:	e5821010 	str	r1, [r2, #16]
	writel(TX_FIFO_NUMBER(ep->fifo_num) | TX_FIFO_FLUSH, &reg->grstctl);
34818e60:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
34818e64:	e1a01301 	lsl	r1, r1, #6
34818e68:	e3811020 	orr	r1, r1, #32
34818e6c:	e5932000 	ldr	r2, [r3]
34818e70:	e5821010 	str	r1, [r2, #16]
	while (readl(&reg->grstctl) & TX_FIFO_FLUSH)
34818e74:	e1a02003 	mov	r2, r3
34818e78:	e5921000 	ldr	r1, [r2]
34818e7c:	e59f3068 	ldr	r3, [pc, #104]	; 34818eec <setdma_tx+0x128>
34818e80:	e5911010 	ldr	r1, [r1, #16]
34818e84:	e3110020 	tst	r1, #32
34818e88:	1afffffa 	bne	34818e78 <setdma_tx+0xb4>
		;

	writel(the_controller->dma_addr[ep_index(ep)+1],
34818e8c:	e5d41035 	ldrb	r1, [r4, #53]	; 0x35
34818e90:	e5932008 	ldr	r2, [r3, #8]
34818e94:	e201100f 	and	r1, r1, #15
34818e98:	e2811011 	add	r1, r1, #17
34818e9c:	e792c101 	ldr	ip, [r2, r1, lsl #2]
34818ea0:	e5932000 	ldr	r2, [r3]
34818ea4:	e1a01286 	lsl	r1, r6, #5
34818ea8:	e2811e91 	add	r1, r1, #2320	; 0x910
34818eac:	e0822001 	add	r2, r2, r1
34818eb0:	e582c004 	str	ip, [r2, #4]
	       &reg->in_endp[ep_num].diepdma);
	writel(DIEPT_SIZ_PKT_CNT(pktcnt) | DIEPT_SIZ_XFER_SIZE(length),
34818eb4:	e1850980 	orr	r0, r5, r0, lsl #19
34818eb8:	e5932000 	ldr	r2, [r3]
	       &reg->in_endp[ep_num].dieptsiz);

	ctrl = readl(&reg->in_endp[ep_num].diepctl);
34818ebc:	e2866048 	add	r6, r6, #72	; 0x48
	while (readl(&reg->grstctl) & TX_FIFO_FLUSH)
		;

	writel(the_controller->dma_addr[ep_index(ep)+1],
	       &reg->in_endp[ep_num].diepdma);
	writel(DIEPT_SIZ_PKT_CNT(pktcnt) | DIEPT_SIZ_XFER_SIZE(length),
34818ec0:	e7820001 	str	r0, [r2, r1]
	       &reg->in_endp[ep_num].dieptsiz);

	ctrl = readl(&reg->in_endp[ep_num].diepctl);
34818ec4:	e7922286 	ldr	r2, [r2, r6, lsl #5]

	/* Write the FIFO number to be used for this endpoint */
	ctrl &= DIEPCTL_TX_FIFO_NUM_MASK;
	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);
34818ec8:	e594103c 	ldr	r1, [r4, #60]	; 0x3c
	       &reg->in_endp[ep_num].dieptsiz);

	ctrl = readl(&reg->in_endp[ep_num].diepctl);

	/* Write the FIFO number to be used for this endpoint */
	ctrl &= DIEPCTL_TX_FIFO_NUM_MASK;
34818ecc:	e3c2250f 	bic	r2, r2, #62914560	; 0x3c00000
	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);
34818ed0:	e1822b01 	orr	r2, r2, r1, lsl #22

	/* Clear reserved (Next EP) bits */
	ctrl = (ctrl&~(EP_MASK<<DEPCTL_NEXT_EP_BIT));
34818ed4:	e3c22b1e 	bic	r2, r2, #30720	; 0x7800

	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->in_endp[ep_num].diepctl);
34818ed8:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
34818edc:	e5933000 	ldr	r3, [r3]
		readl(&reg->in_endp[ep_num].dieptsiz),
		readl(&reg->in_endp[ep_num].diepctl),
		buf, pktcnt, length);

	return length;
}
34818ee0:	e1a00005 	mov	r0, r5
	ctrl |= DIEPCTL_TX_FIFO_NUM(ep->fifo_num);

	/* Clear reserved (Next EP) bits */
	ctrl = (ctrl&~(EP_MASK<<DEPCTL_NEXT_EP_BIT));

	writel(DEPCTL_EPENA|DEPCTL_CNAK|ctrl, &reg->in_endp[ep_num].diepctl);
34818ee4:	e7832286 	str	r2, [r3, r6, lsl #5]
		readl(&reg->in_endp[ep_num].dieptsiz),
		readl(&reg->in_endp[ep_num].diepctl),
		buf, pktcnt, length);

	return length;
}
34818ee8:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
34818eec:	3482bc18 	.word	0x3482bc18

34818ef0 <write_fifo_ep0>:
/* End Point 0 related functions                                */
/****************************************************************/

/* return:  0 = still running, 1 = completed, negative = errno */
static int write_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req)
{
34818ef0:	e92d4070 	push	{r4, r5, r6, lr}
	u32 max;
	unsigned count;
	int is_last;

	max = ep_maxpacket(ep);
34818ef4:	e1d061b4 	ldrh	r6, [r0, #20]
/* End Point 0 related functions                                */
/****************************************************************/

/* return:  0 = still running, 1 = completed, negative = errno */
static int write_fifo_ep0(struct s3c_ep *ep, struct s3c_request *req)
{
34818ef8:	e1a05000 	mov	r5, r0
34818efc:	e1a04001 	mov	r4, r1

	max = ep_maxpacket(ep);

	debug_cond(DEBUG_EP0 != 0, "%s: max = %d\n", __func__, max);

	count = setdma_tx(ep, req);
34818f00:	ebffffaf 	bl	34818dc4 <setdma_tx>

	/* last packet is usually short (or a zlp) */
	if (likely(count != max))
34818f04:	e1500006 	cmp	r0, r6
34818f08:	1a00000d 	bne	34818f44 <write_fifo_ep0+0x54>
		is_last = 1;
	else {
		if (likely(req->req.length != req->req.actual + count)
34818f0c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
34818f10:	e0800003 	add	r0, r0, r3
34818f14:	e5943004 	ldr	r3, [r4, #4]
34818f18:	e1530000 	cmp	r3, r0
34818f1c:	1a000006 	bne	34818f3c <write_fifo_ep0+0x4c>
		    || req->req.zero)
34818f20:	e5d4300c 	ldrb	r3, [r4, #12]
34818f24:	e2033002 	and	r3, r3, #2
34818f28:	e6ef3073 	uxtb	r3, r3
34818f2c:	e3530000 	cmp	r3, #0
	if (is_last) {
		ep->dev->ep0state = WAIT_FOR_SETUP;
		return 1;
	}

	return 0;
34818f30:	13a00000 	movne	r0, #0
	/* last packet is usually short (or a zlp) */
	if (likely(count != max))
		is_last = 1;
	else {
		if (likely(req->req.length != req->req.actual + count)
		    || req->req.zero)
34818f34:	18bd8070 	popne	{r4, r5, r6, pc}
34818f38:	ea000001 	b	34818f44 <write_fifo_ep0+0x54>
	if (is_last) {
		ep->dev->ep0state = WAIT_FOR_SETUP;
		return 1;
	}

	return 0;
34818f3c:	e3a00000 	mov	r0, #0
}
34818f40:	e8bd8070 	pop	{r4, r5, r6, pc}
		   is_last ? "/L" : "",
		   req->req.length - req->req.actual - count, req);

	/* requests complete when all IN data is in the FIFO */
	if (is_last) {
		ep->dev->ep0state = WAIT_FOR_SETUP;
34818f44:	e5953018 	ldr	r3, [r5, #24]
34818f48:	e3a02000 	mov	r2, #0
34818f4c:	e5832054 	str	r2, [r3, #84]	; 0x54
		return 1;
34818f50:	e3a00001 	mov	r0, #1
34818f54:	e8bd8070 	pop	{r4, r5, r6, pc}

34818f58 <s3c_queue>:
/** Queue one request
 *  Kickstart transfer if needed
 */
static int s3c_queue(struct usb_ep *_ep, struct usb_request *_req,
			 gfp_t gfp_flags)
{
34818f58:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
	struct s3c_udc *dev;
	unsigned long flags;
	u32 ep_num, gintsts;

	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
34818f5c:	e2516000 	subs	r6, r1, #0
/** Queue one request
 *  Kickstart transfer if needed
 */
static int s3c_queue(struct usb_ep *_ep, struct usb_request *_req,
			 gfp_t gfp_flags)
{
34818f60:	e1a04000 	mov	r4, r0
	struct s3c_udc *dev;
	unsigned long flags;
	u32 ep_num, gintsts;

	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
34818f64:	0a00006a 	beq	34819114 <s3c_queue+0x1bc>
34818f68:	e5963010 	ldr	r3, [r6, #16]
34818f6c:	e3530000 	cmp	r3, #0
34818f70:	1a00006c 	bne	34819128 <s3c_queue+0x1d0>
34818f74:	ea000066 	b	34819114 <s3c_queue+0x1bc>
		return -EINVAL;
	}

	ep = container_of(_ep, struct s3c_ep, ep);

	if (unlikely(!_ep || (!ep->desc && ep->ep.name != ep0name))) {
34818f78:	e3540000 	cmp	r4, #0
34818f7c:	0a000064 	beq	34819114 <s3c_queue+0x1bc>
34818f80:	e594301c 	ldr	r3, [r4, #28]
34818f84:	e3530000 	cmp	r3, #0
34818f88:	1a00006e 	bne	34819148 <s3c_queue+0x1f0>
34818f8c:	e5942004 	ldr	r2, [r4, #4]
34818f90:	e59f31c8 	ldr	r3, [pc, #456]	; 34819160 <s3c_queue+0x208>
34818f94:	e1520003 	cmp	r2, r3
34818f98:	0a00006a 	beq	34819148 <s3c_queue+0x1f0>
34818f9c:	ea00005c 	b	34819114 <s3c_queue+0x1bc>
		return -EINVAL;
	}

	ep_num = ep_index(ep);
	dev = ep->dev;
	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
34818fa0:	e5953010 	ldr	r3, [r5, #16]
34818fa4:	e3530000 	cmp	r3, #0
34818fa8:	0a00005b 	beq	3481911c <s3c_queue+0x1c4>
34818fac:	e5942020 	ldr	r2, [r4, #32]
		return -ESHUTDOWN;
	}

	spin_lock_irqsave(&dev->lock, flags);

	_req->status = -EINPROGRESS;
34818fb0:	e3e03072 	mvn	r3, #114	; 0x72
		}
		printf("\n");
	}
#endif

	if (list_empty(&ep->queue) && !ep->stopped) {
34818fb4:	e2849020 	add	r9, r4, #32
		return -ESHUTDOWN;
	}

	spin_lock_irqsave(&dev->lock, flags);

	_req->status = -EINPROGRESS;
34818fb8:	e5863020 	str	r3, [r6, #32]
		}
		printf("\n");
	}
#endif

	if (list_empty(&ep->queue) && !ep->stopped) {
34818fbc:	e1520009 	cmp	r2, r9
	}

	spin_lock_irqsave(&dev->lock, flags);

	_req->status = -EINPROGRESS;
	_req->actual = 0;
34818fc0:	e2833073 	add	r3, r3, #115	; 0x73
34818fc4:	e5863024 	str	r3, [r6, #36]	; 0x24
		}
		printf("\n");
	}
#endif

	if (list_empty(&ep->queue) && !ep->stopped) {
34818fc8:	1a000048 	bne	348190f0 <s3c_queue+0x198>
34818fcc:	e5d43034 	ldrb	r3, [r4, #52]	; 0x34
34818fd0:	e3530000 	cmp	r3, #0
34818fd4:	1a000045 	bne	348190f0 <s3c_queue+0x198>

		if (ep_num == 0) {
34818fd8:	e21aa00f 	ands	sl, sl, #15
34818fdc:	1a000039 	bne	348190c8 <s3c_queue+0x170>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34818fe0:	e5943024 	ldr	r3, [r4, #36]	; 0x24
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34818fe4:	e5862028 	str	r2, [r6, #40]	; 0x28
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34818fe8:	e5847024 	str	r7, [r4, #36]	; 0x24
	new->next = next;
	new->prev = prev;
	prev->next = new;
34818fec:	e5837000 	str	r7, [r3]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
34818ff0:	e586302c 	str	r3, [r6, #44]	; 0x2c

static void s3c_ep0_kick(struct s3c_udc *dev, struct s3c_ep *ep)
{
	debug_cond(DEBUG_EP0 != 0,
		   "%s: ep_is_in = %d\n", __func__, ep_is_in(ep));
	if (ep_is_in(ep)) {
34818ff4:	e1d433d5 	ldrsb	r3, [r4, #53]	; 0x35
34818ff8:	e1a02005 	mov	r2, r5
34818ffc:	e3530000 	cmp	r3, #0
34819000:	e5b23078 	ldr	r3, [r2, #120]!	; 0x78
34819004:	aa000017 	bge	34819068 <s3c_queue+0x110>
		dev->ep0state = DATA_STATE_XMIT;
34819008:	e3a04001 	mov	r4, #1
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];
	int ret, need_zlp = 0;

	if (list_empty(&ep->queue))
3481900c:	e1530002 	cmp	r3, r2
static void s3c_ep0_kick(struct s3c_udc *dev, struct s3c_ep *ep)
{
	debug_cond(DEBUG_EP0 != 0,
		   "%s: ep_is_in = %d\n", __func__, ep_is_in(ep));
	if (ep_is_in(ep)) {
		dev->ep0state = DATA_STATE_XMIT;
34819010:	e5854054 	str	r4, [r5, #84]	; 0x54
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];
	int ret, need_zlp = 0;

	if (list_empty(&ep->queue))
34819014:	0a000041 	beq	34819120 <s3c_queue+0x1c8>
		req = 0;
	else
		req = list_entry(ep->queue.next, struct s3c_request, queue);

	if (!req) {
34819018:	e2531028 	subs	r1, r3, #40	; 0x28
3481901c:	0a00003a 	beq	3481910c <s3c_queue+0x1b4>

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length - req->req.actual == ep0_fifo_size) {
34819020:	e5137024 	ldr	r7, [r3, #-36]	; 0x24
34819024:	e5133004 	ldr	r3, [r3, #-4]
		/* Next write will end with the packet size, */
		/* so we need Zero-length-packet */
		need_zlp = 1;
	}

	ret = write_fifo_ep0(ep, req);
34819028:	e2850058 	add	r0, r5, #88	; 0x58

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length - req->req.actual == ep0_fifo_size) {
3481902c:	e0637007 	rsb	r7, r3, r7
34819030:	e59f312c 	ldr	r3, [pc, #300]	; 34819164 <s3c_queue+0x20c>
34819034:	e5936000 	ldr	r6, [r3]
		/* Next write will end with the packet size, */
		/* so we need Zero-length-packet */
		need_zlp = 1;
	}

	ret = write_fifo_ep0(ep, req);
34819038:	ebffffac 	bl	34818ef0 <write_fifo_ep0>

	if ((ret == 1) && !need_zlp) {
3481903c:	e1500004 	cmp	r0, r4
34819040:	13a01000 	movne	r1, #0
34819044:	03a01001 	moveq	r1, #1
34819048:	e1570006 	cmp	r7, r6
3481904c:	03a01000 	moveq	r1, #0
34819050:	e3510000 	cmp	r1, #0
		/* Last packet */
		dev->ep0state = WAIT_FOR_COMPLETE;
34819054:	13a03005 	movne	r3, #5
34819058:	15853054 	strne	r3, [r5, #84]	; 0x54
		debug_cond(DEBUG_EP0 != 0,
			   "%s: finished, waiting for status\n", __func__);

	} else {
		dev->ep0state = DATA_STATE_XMIT;
3481905c:	05854054 	streq	r4, [r5, #84]	; 0x54
		need_zlp = 1;
	}

	ret = write_fifo_ep0(ep, req);

	if ((ret == 1) && !need_zlp) {
34819060:	0a000029 	beq	3481910c <s3c_queue+0x1b4>
34819064:	ea00002d 	b	34819120 <s3c_queue+0x1c8>
	if (ep_is_in(ep)) {
		dev->ep0state = DATA_STATE_XMIT;
		s3c_ep0_write(dev);

	} else {
		dev->ep0state = DATA_STATE_RECV;
34819068:	e3a01004 	mov	r1, #4
static void s3c_ep0_read(struct s3c_udc *dev)
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];

	if (!list_empty(&ep->queue)) {
3481906c:	e1530002 	cmp	r3, r2
	if (ep_is_in(ep)) {
		dev->ep0state = DATA_STATE_XMIT;
		s3c_ep0_write(dev);

	} else {
		dev->ep0state = DATA_STATE_RECV;
34819070:	e5851054 	str	r1, [r5, #84]	; 0x54
static void s3c_ep0_read(struct s3c_udc *dev)
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];

	if (!list_empty(&ep->queue)) {
34819074:	0a000004 	beq	3481908c <s3c_queue+0x134>

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length == 0) {
34819078:	e5134024 	ldr	r4, [r3, #-36]	; 0x24
{
	struct s3c_request *req;
	struct s3c_ep *ep = &dev->ep[0];

	if (!list_empty(&ep->queue)) {
		req = list_entry(ep->queue.next, struct s3c_request, queue);
3481907c:	e2431028 	sub	r1, r3, #40	; 0x28

	debug_cond(DEBUG_EP0 != 0,
		   "%s: req = %p, req.length = 0x%x, req.actual = 0x%x\n",
		   __func__, req, req->req.length, req->req.actual);

	if (req->req.length == 0) {
34819080:	e3540000 	cmp	r4, #0
34819084:	1a00000c 	bne	348190bc <s3c_queue+0x164>
34819088:	ea000006 	b	348190a8 <s3c_queue+0x150>
	if (!list_empty(&ep->queue)) {
		req = list_entry(ep->queue.next, struct s3c_request, queue);

	} else {
		debug("%s: ---> BUG\n", __func__);
		BUG();
3481908c:	e59f00d4 	ldr	r0, [pc, #212]	; 34819168 <s3c_queue+0x210>
34819090:	e59f10d4 	ldr	r1, [pc, #212]	; 3481916c <s3c_queue+0x214>
34819094:	e3002332 	movw	r2, #818	; 0x332
34819098:	e59f30d0 	ldr	r3, [pc, #208]	; 34819170 <s3c_queue+0x218>
3481909c:	ebffc030 	bl	34809164 <printf>
348190a0:	e59f00cc 	ldr	r0, [pc, #204]	; 34819174 <s3c_queue+0x21c>
348190a4:	eb000f28 	bl	3481cd4c <panic>

	if (req->req.length == 0) {
		/* zlp for Set_configuration, Set_interface,
		 * or Bulk-Only mass storge reset */

		ep->len = 0;
348190a8:	e5854084 	str	r4, [r5, #132]	; 0x84
		s3c_udc_ep0_zlp(dev);
348190ac:	e2850054 	add	r0, r5, #84	; 0x54
348190b0:	ebfffe4e 	bl	348189f0 <s3c_udc_ep0_zlp.clone.2>
	if (likely(req != 0))
		list_add_tail(&req->queue, &ep->queue);

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
348190b4:	e1a0a004 	mov	sl, r4
348190b8:	ea000018 	b	34819120 <s3c_queue+0x1c8>
			   "%s: req.length = 0, bRequest = %d\n",
			   __func__, usb_ctrl->bRequest);
		return;
	}

	setdma_rx(ep, req);
348190bc:	e2850058 	add	r0, r5, #88	; 0x58
348190c0:	ebfffe03 	bl	348188d4 <setdma_rx>
348190c4:	ea000015 	b	34819120 <s3c_queue+0x1c8>
			/* EP0 */
			list_add_tail(&req->queue, &ep->queue);
			s3c_ep0_kick(dev, ep);
			req = 0;

		} else if (ep_is_in(ep)) {
348190c8:	e1d433d5 	ldrsb	r3, [r4, #53]	; 0x35
348190cc:	e3530000 	cmp	r3, #0
348190d0:	aa000003 	bge	348190e4 <s3c_queue+0x18c>
			gintsts = readl(&reg->gintsts);
			debug_cond(DEBUG_IN_EP,
				   "%s: ep_is_in, S3C_UDC_OTG_GINTSTS=0x%x\n",
				   __func__, gintsts);

			setdma_tx(ep, req);
348190d4:	e1a00004 	mov	r0, r4
348190d8:	e1a01006 	mov	r1, r6
348190dc:	ebffff38 	bl	34818dc4 <setdma_tx>
348190e0:	ea000002 	b	348190f0 <s3c_queue+0x198>
			gintsts = readl(&reg->gintsts);
			debug_cond(DEBUG_OUT_EP != 0,
				   "%s:ep_is_out, S3C_UDC_OTG_GINTSTS=0x%x\n",
				   __func__, gintsts);

			setdma_rx(ep, req);
348190e4:	e1a00004 	mov	r0, r4
348190e8:	e1a01006 	mov	r1, r6
348190ec:	ebfffdf8 	bl	348188d4 <setdma_rx>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
348190f0:	e5943024 	ldr	r3, [r4, #36]	; 0x24
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
348190f4:	e5869028 	str	r9, [r6, #40]	; 0x28
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
348190f8:	e5847024 	str	r7, [r4, #36]	; 0x24
	new->next = next;
	new->prev = prev;
	prev->next = new;
348190fc:	e5837000 	str	r7, [r3]
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
	new->prev = prev;
34819100:	e586302c 	str	r3, [r6, #44]	; 0x2c
	if (likely(req != 0))
		list_add_tail(&req->queue, &ep->queue);

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
34819104:	e3a0a000 	mov	sl, #0
34819108:	ea000004 	b	34819120 <s3c_queue+0x1c8>
3481910c:	e1a0a001 	mov	sl, r1
34819110:	ea000002 	b	34819120 <s3c_queue+0x1c8>
	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
		     || !list_empty(&req->queue))) {

		debug("%s: bad params\n", __func__);
		return -EINVAL;
34819114:	e3e0a015 	mvn	sl, #21
34819118:	ea000000 	b	34819120 <s3c_queue+0x1c8>
	ep_num = ep_index(ep);
	dev = ep->dev;
	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {

		debug("%s: bogus device state %p\n", __func__, dev->driver);
		return -ESHUTDOWN;
3481911c:	e3e0a06b 	mvn	sl, #107	; 0x6b
		list_add_tail(&req->queue, &ep->queue);

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
}
34819120:	e1a0000a 	mov	r0, sl
34819124:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	struct s3c_udc *dev;
	unsigned long flags;
	u32 ep_num, gintsts;

	req = container_of(_req, struct s3c_request, req);
	if (unlikely(!_req || !_req->complete || !_req->buf
34819128:	e5963000 	ldr	r3, [r6]
3481912c:	e3530000 	cmp	r3, #0
34819130:	0afffff7 	beq	34819114 <s3c_queue+0x1bc>
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34819134:	e1a03006 	mov	r3, r6
34819138:	e5b37028 	ldr	r7, [r3, #40]!	; 0x28
3481913c:	e1570003 	cmp	r7, r3
34819140:	0affff8c 	beq	34818f78 <s3c_queue+0x20>
34819144:	eafffff2 	b	34819114 <s3c_queue+0x1bc>
		      ep->ep.name, !ep->desc, _ep);
		return -EINVAL;
	}

	ep_num = ep_index(ep);
	dev = ep->dev;
34819148:	e5945018 	ldr	r5, [r4, #24]
		debug("%s: bad ep: %s, %d, %p\n", __func__,
		      ep->ep.name, !ep->desc, _ep);
		return -EINVAL;
	}

	ep_num = ep_index(ep);
3481914c:	e5d4a035 	ldrb	sl, [r4, #53]	; 0x35
	dev = ep->dev;
	if (unlikely(!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN)) {
34819150:	e5953024 	ldr	r3, [r5, #36]	; 0x24
34819154:	e3530000 	cmp	r3, #0
34819158:	1affff90 	bne	34818fa0 <s3c_queue+0x48>
3481915c:	eaffffee 	b	3481911c <s3c_queue+0x1c4>
34819160:	34821594 	.word	0x34821594
34819164:	348292e8 	.word	0x348292e8
34819168:	348273ba 	.word	0x348273ba
3481916c:	34827e41 	.word	0x34827e41
34819170:	348215a0 	.word	0x348215a0
34819174:	348273e1 	.word	0x348273e1

34819178 <s3c_fifo_read>:

	return 0;
}

int s3c_fifo_read(struct s3c_ep *ep, u32 *cp, int max)
{
34819178:	e92d4008 	push	{r3, lr}
	u32 bytes;

	bytes = sizeof(struct usb_ctrlrequest);

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_index(ep)],
				(unsigned long) ep->dev->dma_buf[ep_index(ep)]
3481917c:	e5d03035 	ldrb	r3, [r0, #53]	; 0x35
34819180:	e5902018 	ldr	r2, [r0, #24]
34819184:	e203300f 	and	r3, r3, #15
34819188:	e0823103 	add	r3, r2, r3, lsl #2
3481918c:	e593002c 	ldr	r0, [r3, #44]	; 0x2c
{
	u32 bytes;

	bytes = sizeof(struct usb_ctrlrequest);

	invalidate_dcache_range((unsigned long) ep->dev->dma_buf[ep_index(ep)],
34819190:	e2801901 	add	r1, r0, #16384	; 0x4000
34819194:	ebff9d39 	bl	34800680 <invalidate_dcache_range>
	debug_cond(DEBUG_EP0 != 0,
		   "%s: bytes=%d, ep_index=%d %p\n", __func__,
		   bytes, ep_index(ep), ep->dev->dma_buf[ep_index(ep)]);

	return bytes;
}
34819198:	e3a00008 	mov	r0, #8
3481919c:	e8bd8008 	pop	{r3, pc}

348191a0 <s3c_udc_get_status>:

u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
348191a0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	u8 ep_num = crq->wIndex & 0x7F;
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];
348191a4:	e59f70e8 	ldr	r7, [pc, #232]	; 34819294 <s3c_udc_get_status+0xf4>
u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
	u8 ep_num = crq->wIndex & 0x7F;
348191a8:	e5d13004 	ldrb	r3, [r1, #4]
348191ac:	e5d1a005 	ldrb	sl, [r1, #5]

u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
348191b0:	e1a04001 	mov	r4, r1
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
348191b4:	e5d11000 	ldrb	r1, [r1]
u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
	u8 ep_num = crq->wIndex & 0x7F;
348191b8:	e183a40a 	orr	sl, r3, sl, lsl #8
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];
348191bc:	e5973008 	ldr	r3, [r7, #8]

u16	g_status;

int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
348191c0:	e1a05000 	mov	r5, r0
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
348191c4:	e201101f 	and	r1, r1, #31
348191c8:	e59f00c8 	ldr	r0, [pc, #200]	; 34819298 <s3c_udc_get_status+0xf8>
int s3c_udc_get_status(struct s3c_udc *dev,
		struct usb_ctrlrequest *crq)
{
	u8 ep_num = crq->wIndex & 0x7F;
	u32 ep_ctrl;
	u32 *p = the_controller->dma_buf[1];
348191cc:	e5936030 	ldr	r6, [r3, #48]	; 0x30

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
348191d0:	ebffbfe3 	bl	34809164 <printf>
	switch (crq->bRequestType & USB_RECIP_MASK) {
348191d4:	e5d43000 	ldrb	r3, [r4]
348191d8:	e203301f 	and	r3, r3, #31
348191dc:	e3530001 	cmp	r3, #1
348191e0:	0a000005 	beq	348191fc <s3c_udc_get_status+0x5c>
348191e4:	e3530002 	cmp	r3, #2
348191e8:	0a000005 	beq	34819204 <s3c_udc_get_status+0x64>
348191ec:	e3530000 	cmp	r3, #0
			   "\tGET_STATUS:USB_RECIP_INTERFACE, g_stauts = %d\n",
			   g_status);
		break;

	case USB_RECIP_DEVICE:
		g_status = 0x1; /* Self powered */
348191f0:	03a03001 	moveq	r3, #1
	u32 *p = the_controller->dma_buf[1];

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_GET_STATUS\n", __func__);
	printf("crq->brequest:0x%x\n", crq->bRequestType & USB_RECIP_MASK);
	switch (crq->bRequestType & USB_RECIP_MASK) {
348191f4:	0a00000a 	beq	34819224 <s3c_udc_get_status+0x84>
348191f8:	ea000021 	b	34819284 <s3c_udc_get_status+0xe4>
	case USB_RECIP_INTERFACE:
		g_status = 0;
348191fc:	e3a03000 	mov	r3, #0
34819200:	ea000007 	b	34819224 <s3c_udc_get_status+0x84>
			   "\tGET_STATUS: USB_RECIP_DEVICE, g_stauts = %d\n",
			   g_status);
		break;

	case USB_RECIP_ENDPOINT:
		if (crq->wLength > 2) {
34819204:	e5d43006 	ldrb	r3, [r4, #6]
34819208:	e5d42007 	ldrb	r2, [r4, #7]
3481920c:	e1833402 	orr	r3, r3, r2, lsl #8
34819210:	e3530002 	cmp	r3, #2
34819214:	8a00001c 	bhi	3481928c <s3c_udc_get_status+0xec>
			debug_cond(DEBUG_SETUP != 0,
				   "\tGET_STATUS:Not support EP or wLength\n");
			return 1;
		}

		g_status = dev->ep[ep_num].stopped;
34819218:	e20aa07f 	and	sl, sl, #127	; 0x7f
3481921c:	e085a30a 	add	sl, r5, sl, lsl #6
34819220:	e5da308c 	ldrb	r3, [sl, #140]	; 0x8c

	default:
		return 1;
	}

	memcpy(p, &g_status, sizeof(g_status));
34819224:	e59f4068 	ldr	r4, [pc, #104]	; 34819294 <s3c_udc_get_status+0xf4>
34819228:	e3a02002 	mov	r2, #2
3481922c:	e2841014 	add	r1, r4, #20
34819230:	e1a00006 	mov	r0, r6
			debug_cond(DEBUG_SETUP != 0,
				   "\tGET_STATUS:Not support EP or wLength\n");
			return 1;
		}

		g_status = dev->ep[ep_num].stopped;
34819234:	e1c731b4 	strh	r3, [r7, #20]

	default:
		return 1;
	}

	memcpy(p, &g_status, sizeof(g_status));
34819238:	eb000b45 	bl	3481bf54 <memcpy>

	flush_dcache_range((unsigned long) p,
3481923c:	e1a00006 	mov	r0, r6
34819240:	e2861901 	add	r1, r6, #16384	; 0x4000
34819244:	ebff9d16 	bl	348006a4 <flush_dcache_range>
			   (unsigned long) p + DMA_BUFFER_SIZE);

	writel(the_controller->dma_addr[1], &reg->in_endp[EP0_CON].diepdma);
34819248:	e5943008 	ldr	r3, [r4, #8]
3481924c:	e5932044 	ldr	r2, [r3, #68]	; 0x44
34819250:	e5943000 	ldr	r3, [r4]
34819254:	e5832914 	str	r2, [r3, #2324]	; 0x914
	writel(DIEPT_SIZ_PKT_CNT(1) | DIEPT_SIZ_XFER_SIZE(2),
34819258:	e59f203c 	ldr	r2, [pc, #60]	; 3481929c <s3c_udc_get_status+0xfc>
3481925c:	e5943000 	ldr	r3, [r4]
34819260:	e5832910 	str	r2, [r3, #2320]	; 0x910
	       &reg->in_endp[EP0_CON].dieptsiz);

	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
34819264:	e5932900 	ldr	r2, [r3, #2304]	; 0x900
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
34819268:	e3822321 	orr	r2, r2, #-2080374784	; 0x84000000
3481926c:	e5943000 	ldr	r3, [r4]
	       &reg->in_endp[EP0_CON].diepctl);
	dev->ep0state = WAIT_FOR_NULL_COMPLETE;

	return 0;
34819270:	e3a00000 	mov	r0, #0
	writel(the_controller->dma_addr[1], &reg->in_endp[EP0_CON].diepdma);
	writel(DIEPT_SIZ_PKT_CNT(1) | DIEPT_SIZ_XFER_SIZE(2),
	       &reg->in_endp[EP0_CON].dieptsiz);

	ep_ctrl = readl(&reg->in_endp[EP0_CON].diepctl);
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
34819274:	e5832900 	str	r2, [r3, #2304]	; 0x900
	       &reg->in_endp[EP0_CON].diepctl);
	dev->ep0state = WAIT_FOR_NULL_COMPLETE;
34819278:	e3a03008 	mov	r3, #8
3481927c:	e5853054 	str	r3, [r5, #84]	; 0x54

	return 0;
34819280:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
			   g_status);

		break;

	default:
		return 1;
34819284:	e3a00001 	mov	r0, #1
34819288:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	case USB_RECIP_ENDPOINT:
		if (crq->wLength > 2) {
			debug_cond(DEBUG_SETUP != 0,
				   "\tGET_STATUS:Not support EP or wLength\n");
			return 1;
3481928c:	e3a00001 	mov	r0, #1
	writel(ep_ctrl|DEPCTL_EPENA|DEPCTL_CNAK,
	       &reg->in_endp[EP0_CON].diepctl);
	dev->ep0state = WAIT_FOR_NULL_COMPLETE;

	return 0;
}
34819290:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34819294:	3482bc18 	.word	0x3482bc18
34819298:	34827e58 	.word	0x34827e58
3481929c:	00080002 	.word	0x00080002

348192a0 <s3c_udc_ep_set_stall>:
void s3c_udc_ep_set_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
348192a0:	e5d03035 	ldrb	r3, [r0, #53]	; 0x35
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
348192a4:	e3130080 	tst	r3, #128	; 0x80
void s3c_udc_ep_set_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
348192a8:	e203200f 	and	r2, r3, #15
348192ac:	e59f3048 	ldr	r3, [pc, #72]	; 348192fc <s3c_udc_ep_set_stall+0x5c>
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
348192b0:	0a00000a 	beq	348192e0 <s3c_udc_ep_set_stall+0x40>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
348192b4:	e5933000 	ldr	r3, [r3]
348192b8:	e2821048 	add	r1, r2, #72	; 0x48
348192bc:	e7933281 	ldr	r3, [r3, r1, lsl #5]

		/* set the disable and stall bits */
		if (ep_ctrl & DEPCTL_EPENA)
348192c0:	e3530000 	cmp	r3, #0
			ep_ctrl |= DEPCTL_EPDIS;
348192c4:	b3833101 	orrlt	r3, r3, #1073741824	; 0x40000000

		ep_ctrl |= DEPCTL_STALL;
348192c8:	e3833602 	orr	r3, r3, #2097152	; 0x200000

		writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
348192cc:	e59f1028 	ldr	r1, [pc, #40]	; 348192fc <s3c_udc_ep_set_stall+0x5c>
348192d0:	e2822048 	add	r2, r2, #72	; 0x48
348192d4:	e5911000 	ldr	r1, [r1]
348192d8:	e7813282 	str	r3, [r1, r2, lsl #5]
348192dc:	e12fff1e 	bx	lr
		debug("%s: set stall, DIEPCTL%d = 0x%x\n",
		      __func__, ep_num, readl(&reg->in_endp[ep_num].diepctl));

	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
348192e0:	e5931000 	ldr	r1, [r3]
348192e4:	e2822058 	add	r2, r2, #88	; 0x58
348192e8:	e7911282 	ldr	r1, [r1, r2, lsl #5]

		/* set the stall bit */
		ep_ctrl |= DEPCTL_STALL;
348192ec:	e3811602 	orr	r1, r1, #2097152	; 0x200000

		writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
348192f0:	e5933000 	ldr	r3, [r3]
348192f4:	e7831282 	str	r1, [r3, r2, lsl #5]
348192f8:	e12fff1e 	bx	lr
348192fc:	3482bc18 	.word	0x3482bc18

34819300 <s3c_udc_ep_clear_stall>:
void s3c_udc_ep_clear_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
34819300:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
34819304:	e3120080 	tst	r2, #128	; 0x80
void s3c_udc_ep_clear_stall(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
34819308:	e202300f 	and	r3, r2, #15
3481930c:	e59f2064 	ldr	r2, [pc, #100]	; 34819378 <s3c_udc_ep_clear_stall+0x78>
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
34819310:	0a00000a 	beq	34819340 <s3c_udc_ep_clear_stall+0x40>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819314:	e5922000 	ldr	r2, [r2]
34819318:	e2831048 	add	r1, r3, #72	; 0x48
3481931c:	e7922281 	ldr	r2, [r2, r1, lsl #5]
		 * of whether an endpoint has the Halt feature set, a
		 * ClearFeature(ENDPOINT_HALT) request always results in the
		 * data toggle being reinitialized to DATA0.
		 */
		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
34819320:	e5d01036 	ldrb	r1, [r0, #54]	; 0x36

	if (ep_is_in(ep)) {
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;
34819324:	e3c22602 	bic	r2, r2, #2097152	; 0x200000
		 * of whether an endpoint has the Halt feature set, a
		 * ClearFeature(ENDPOINT_HALT) request always results in the
		 * data toggle being reinitialized to DATA0.
		 */
		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
34819328:	e2411002 	sub	r1, r1, #2
		 * USB Spec 9.4.5: For endpoints using data toggle, regardless
		 * of whether an endpoint has the Halt feature set, a
		 * ClearFeature(ENDPOINT_HALT) request always results in the
		 * data toggle being reinitialized to DATA0.
		 */
		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
3481932c:	e6ef1071 	uxtb	r1, r1
34819330:	e3510001 	cmp	r1, #1
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
34819334:	93822201 	orrls	r2, r2, #268435456	; 0x10000000
		}

		writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
34819338:	e2833048 	add	r3, r3, #72	; 0x48
3481933c:	ea000009 	b	34819368 <s3c_udc_ep_clear_stall+0x68>
		debug("%s: cleared stall, DIEPCTL%d = 0x%x\n",
			__func__, ep_num, readl(&reg->in_endp[ep_num].diepctl));

	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
34819340:	e5922000 	ldr	r2, [r2]
34819344:	e2831058 	add	r1, r3, #88	; 0x58
34819348:	e7922281 	ldr	r2, [r2, r1, lsl #5]

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;

		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
3481934c:	e5d01036 	ldrb	r1, [r0, #54]	; 0x36

	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;
34819350:	e3c22602 	bic	r2, r2, #2097152	; 0x200000

		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
34819354:	e2411002 	sub	r1, r1, #2
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);

		/* clear stall bit */
		ep_ctrl &= ~DEPCTL_STALL;

		if (ep->bmAttributes == USB_ENDPOINT_XFER_INT
34819358:	e6ef1071 	uxtb	r1, r1
3481935c:	e3510001 	cmp	r1, #1
		    || ep->bmAttributes == USB_ENDPOINT_XFER_BULK) {
			ep_ctrl |= DEPCTL_SETD0PID; /* DATA0 */
34819360:	93822201 	orrls	r2, r2, #268435456	; 0x10000000
		}

		writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
34819364:	e2833058 	add	r3, r3, #88	; 0x58
34819368:	e59f1008 	ldr	r1, [pc, #8]	; 34819378 <s3c_udc_ep_clear_stall+0x78>
3481936c:	e5911000 	ldr	r1, [r1]
34819370:	e7812283 	str	r2, [r1, r3, lsl #5]
34819374:	e12fff1e 	bx	lr
34819378:	3482bc18 	.word	0x3482bc18

3481937c <s3c_udc_set_halt>:

	return;
}

static int s3c_udc_set_halt(struct usb_ep *_ep, int value)
{
3481937c:	e92d4010 	push	{r4, lr}
	struct s3c_udc	*dev;
	unsigned long	flags;
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);
34819380:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35

	if (unlikely(!_ep || !ep->desc || ep_num == EP0_CON ||
34819384:	e590301c 	ldr	r3, [r0, #28]
34819388:	e312000f 	tst	r2, #15
3481938c:	13a0c000 	movne	ip, #0
34819390:	03a0c001 	moveq	ip, #1
34819394:	e3530000 	cmp	r3, #0
34819398:	038cc001 	orreq	ip, ip, #1
3481939c:	e35c0000 	cmp	ip, #0
348193a0:	0a000019 	beq	3481940c <s3c_udc_set_halt+0x90>
348193a4:	ea000014 	b	348193fc <s3c_udc_set_halt+0x80>
		return -EINVAL;
	}

	/* Attempt to halt IN ep will fail if any transfer requests
	 * are still queue */
	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
348193a8:	e3510000 	cmp	r1, #0
348193ac:	0a000008 	beq	348193d4 <s3c_udc_set_halt+0x58>
348193b0:	e3120080 	tst	r2, #128	; 0x80
348193b4:	0a000004 	beq	348193cc <s3c_udc_set_halt+0x50>
348193b8:	e5902020 	ldr	r2, [r0, #32]
348193bc:	e2803020 	add	r3, r0, #32
348193c0:	e1520003 	cmp	r2, r3
		debug("%s: %s queue not empty, req = %p\n",
			__func__, ep->ep.name,
			list_entry(ep->queue.next, struct s3c_request, queue));

		return -EAGAIN;
348193c4:	13e0000a 	mvnne	r0, #10
		return -EINVAL;
	}

	/* Attempt to halt IN ep will fail if any transfer requests
	 * are still queue */
	if (value && ep_is_in(ep) && !list_empty(&ep->queue)) {
348193c8:	18bd8010 	popne	{r4, pc}
	dev = ep->dev;
	debug("%s: ep_num = %d, value = %d\n", __func__, ep_num, value);

	spin_lock_irqsave(&dev->lock, flags);

	if (value == 0) {
348193cc:	e3510000 	cmp	r1, #0
348193d0:	1a000004 	bne	348193e8 <s3c_udc_set_halt+0x6c>
		ep->stopped = 0;
348193d4:	e3a04000 	mov	r4, #0
348193d8:	e5c04034 	strb	r4, [r0, #52]	; 0x34
		s3c_udc_ep_clear_stall(ep);
348193dc:	ebffffc7 	bl	34819300 <s3c_udc_ep_clear_stall>
		s3c_udc_ep_set_stall(ep);
	}

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
348193e0:	e1a00004 	mov	r0, r4
348193e4:	e8bd8010 	pop	{r4, pc}
		s3c_udc_ep_clear_stall(ep);
	} else {
		if (ep_num == 0)
			dev->ep0state = WAIT_FOR_SETUP;

		ep->stopped = 1;
348193e8:	e3a03001 	mov	r3, #1
348193ec:	e5c03034 	strb	r3, [r0, #52]	; 0x34
		s3c_udc_ep_set_stall(ep);
348193f0:	ebffffaa 	bl	348192a0 <s3c_udc_ep_set_stall>
	}

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
348193f4:	e3a00000 	mov	r0, #0
348193f8:	e8bd8010 	pop	{r4, pc}
	ep_num = ep_index(ep);

	if (unlikely(!_ep || !ep->desc || ep_num == EP0_CON ||
		     ep->desc->bmAttributes == USB_ENDPOINT_XFER_ISOC)) {
		debug("%s: %s bad ep or descriptor\n", __func__, ep->ep.name);
		return -EINVAL;
348193fc:	e3e00015 	mvn	r0, #21
34819400:	e8bd8010 	pop	{r4, pc}
34819404:	e3e00015 	mvn	r0, #21
	}

	spin_unlock_irqrestore(&dev->lock, flags);

	return 0;
}
34819408:	e8bd8010 	pop	{r4, pc}
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);

	if (unlikely(!_ep || !ep->desc || ep_num == EP0_CON ||
3481940c:	e5d33003 	ldrb	r3, [r3, #3]
34819410:	e3530001 	cmp	r3, #1
34819414:	1affffe3 	bne	348193a8 <s3c_udc_set_halt+0x2c>
34819418:	eafffff9 	b	34819404 <s3c_udc_set_halt+0x88>

3481941c <s3c_udc_ep_activate>:
void s3c_udc_ep_activate(struct s3c_ep *ep)
{
	u8 ep_num;
	u32 ep_ctrl = 0, daintmsk = 0;

	ep_num = ep_index(ep);
3481941c:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35

	/* Read DEPCTLn register */
	if (ep_is_in(ep)) {
34819420:	e3120080 	tst	r2, #128	; 0x80
void s3c_udc_ep_activate(struct s3c_ep *ep)
{
	u8 ep_num;
	u32 ep_ctrl = 0, daintmsk = 0;

	ep_num = ep_index(ep);
34819424:	e202300f 	and	r3, r2, #15
34819428:	e59f2094 	ldr	r2, [pc, #148]	; 348194c4 <s3c_udc_ep_activate+0xa8>

	/* Read DEPCTLn register */
	if (ep_is_in(ep)) {
3481942c:	0a000004 	beq	34819444 <s3c_udc_ep_activate+0x28>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
34819430:	e5922000 	ldr	r2, [r2]
34819434:	e2831048 	add	r1, r3, #72	; 0x48
34819438:	e7922281 	ldr	r2, [r2, r1, lsl #5]
		daintmsk = 1 << ep_num;
3481943c:	e3a01001 	mov	r1, #1
34819440:	ea000003 	b	34819454 <s3c_udc_ep_activate+0x38>
	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
34819444:	e5922000 	ldr	r2, [r2]
34819448:	e2831058 	add	r1, r3, #88	; 0x58
3481944c:	e7922281 	ldr	r2, [r2, r1, lsl #5]
		daintmsk = (1 << ep_num) << DAINT_OUT_BIT;
34819450:	e3a01801 	mov	r1, #65536	; 0x10000
	debug("%s: EPCTRL%d = 0x%x, ep_is_in = %d\n",
		__func__, ep_num, ep_ctrl, ep_is_in(ep));

	/* If the EP is already active don't change the EP Control
	 * register. */
	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
34819454:	e3120902 	tst	r2, #32768	; 0x8000
	if (ep_is_in(ep)) {
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
		daintmsk = 1 << ep_num;
	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
		daintmsk = (1 << ep_num) << DAINT_OUT_BIT;
34819458:	e1a01311 	lsl	r1, r1, r3
	debug("%s: EPCTRL%d = 0x%x, ep_is_in = %d\n",
		__func__, ep_num, ep_ctrl, ep_is_in(ep));

	/* If the EP is already active don't change the EP Control
	 * register. */
	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
3481945c:	1a000011 	bne	348194a8 <s3c_udc_ep_activate+0x8c>
		ep_ctrl = (ep_ctrl & ~DEPCTL_TYPE_MASK) |
			(ep->bmAttributes << DEPCTL_TYPE_BIT);
34819460:	e5d0c036 	ldrb	ip, [r0, #54]	; 0x36
		__func__, ep_num, ep_ctrl, ep_is_in(ep));

	/* If the EP is already active don't change the EP Control
	 * register. */
	if (!(ep_ctrl & DEPCTL_USBACTEP)) {
		ep_ctrl = (ep_ctrl & ~DEPCTL_TYPE_MASK) |
34819464:	e3c22703 	bic	r2, r2, #786432	; 0xc0000
34819468:	e182290c 	orr	r2, r2, ip, lsl #18
			(ep->bmAttributes << DEPCTL_TYPE_BIT);
		ep_ctrl = (ep_ctrl & ~DEPCTL_MPS_MASK) |
3481946c:	e1d0c1b4 	ldrh	ip, [r0, #20]
34819470:	e3c22e7f 	bic	r2, r2, #2032	; 0x7f0
34819474:	e38cc306 	orr	ip, ip, #402653184	; 0x18000000
34819478:	e3c2200f 	bic	r2, r2, #15
3481947c:	e38cc902 	orr	ip, ip, #32768	; 0x8000
			(ep->ep.maxpacket << DEPCTL_MPS_BIT);
		ep_ctrl |= (DEPCTL_SETD0PID | DEPCTL_USBACTEP | DEPCTL_SNAK);
34819480:	e18cc002 	orr	ip, ip, r2

		if (ep_is_in(ep)) {
34819484:	e1d023d5 	ldrsb	r2, [r0, #53]	; 0x35
34819488:	e3520000 	cmp	r2, #0
3481948c:	e59f2030 	ldr	r2, [pc, #48]	; 348194c4 <s3c_udc_ep_activate+0xa8>
34819490:	aa000001 	bge	3481949c <s3c_udc_ep_activate+0x80>
			writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
34819494:	e2833048 	add	r3, r3, #72	; 0x48
34819498:	ea000000 	b	348194a0 <s3c_udc_ep_activate+0x84>
			debug("%s: USB Ative EP%d, DIEPCTRL%d = 0x%x\n",
			      __func__, ep_num, ep_num,
			      readl(&reg->in_endp[ep_num].diepctl));
		} else {
			writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
3481949c:	e2833058 	add	r3, r3, #88	; 0x58
348194a0:	e5922000 	ldr	r2, [r2]
348194a4:	e782c283 	str	ip, [r2, r3, lsl #5]
			      readl(&reg->out_endp[ep_num].doepctl));
		}
	}

	/* Unmask EP Interrtupt */
	writel(readl(&reg->daintmsk)|daintmsk, &reg->daintmsk);
348194a8:	e59f3014 	ldr	r3, [pc, #20]	; 348194c4 <s3c_udc_ep_activate+0xa8>
348194ac:	e5932000 	ldr	r2, [r3]
348194b0:	e592281c 	ldr	r2, [r2, #2076]	; 0x81c
348194b4:	e1811002 	orr	r1, r1, r2
348194b8:	e5933000 	ldr	r3, [r3]
348194bc:	e583181c 	str	r1, [r3, #2076]	; 0x81c
	debug("%s: DAINTMSK = 0x%x\n", __func__, readl(&reg->daintmsk));

}
348194c0:	e12fff1e 	bx	lr
348194c4:	3482bc18 	.word	0x3482bc18

348194c8 <s3c_ep_enable>:
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
348194c8:	e3500000 	cmp	r0, #0
348194cc:	13510000 	cmpne	r1, #0
	writel(ep_ctrl|(0<<0), &reg->out_endp[EP0_CON].doepctl);
}

static int s3c_ep_enable(struct usb_ep *_ep,
			 const struct usb_endpoint_descriptor *desc)
{
348194d0:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	unsigned long flags;

	debug("%s: %p\n", __func__, _ep);

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
348194d4:	e1a05001 	mov	r5, r1
348194d8:	e1a04000 	mov	r4, r0
348194dc:	0a000047 	beq	34819600 <s3c_ep_enable+0x138>
348194e0:	e590301c 	ldr	r3, [r0, #28]
348194e4:	e3530000 	cmp	r3, #0
348194e8:	1a000044 	bne	34819600 <s3c_ep_enable+0x138>
348194ec:	e5902004 	ldr	r2, [r0, #4]
348194f0:	e59f3120 	ldr	r3, [pc, #288]	; 34819618 <s3c_ep_enable+0x150>
348194f4:	e1520003 	cmp	r2, r3
348194f8:	0a000040 	beq	34819600 <s3c_ep_enable+0x138>
	    || desc->bDescriptorType != USB_DT_ENDPOINT
348194fc:	e5d13001 	ldrb	r3, [r1, #1]
34819500:	e3530005 	cmp	r3, #5
34819504:	1a00003d 	bne	34819600 <s3c_ep_enable+0x138>
	    || ep->bEndpointAddress != desc->bEndpointAddress
34819508:	e5d06035 	ldrb	r6, [r0, #53]	; 0x35
3481950c:	e5d13002 	ldrb	r3, [r1, #2]
34819510:	e1530006 	cmp	r3, r6
34819514:	1a000039 	bne	34819600 <s3c_ep_enable+0x138>
	    || ep_maxpacket(ep) <
	    le16_to_cpu(get_unaligned(&desc->wMaxPacketSize))) {
34819518:	e2817004 	add	r7, r1, #4

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
	    || desc->bDescriptorType != USB_DT_ENDPOINT
	    || ep->bEndpointAddress != desc->bEndpointAddress
	    || ep_maxpacket(ep) <
3481951c:	e1d0a1b4 	ldrh	sl, [r0, #20]
	    le16_to_cpu(get_unaligned(&desc->wMaxPacketSize))) {
34819520:	e1a00007 	mov	r0, r7
34819524:	ebfffbf6 	bl	34818504 <get_unaligned_le16>

	ep = container_of(_ep, struct s3c_ep, ep);
	if (!_ep || !desc || ep->desc || _ep->name == ep0name
	    || desc->bDescriptorType != USB_DT_ENDPOINT
	    || ep->bEndpointAddress != desc->bEndpointAddress
	    || ep_maxpacket(ep) <
34819528:	e15a0000 	cmp	sl, r0
3481952c:	3a000033 	bcc	34819600 <s3c_ep_enable+0x138>
		debug("%s: bad ep or descriptor\n", __func__);
		return -EINVAL;
	}

	/* xfer types must match, except that interrupt ~= bulk */
	if (ep->bmAttributes != desc->bmAttributes
34819530:	e5d42036 	ldrb	r2, [r4, #54]	; 0x36
34819534:	e5d53003 	ldrb	r3, [r5, #3]
34819538:	e1520003 	cmp	r2, r3
3481953c:	0a000004 	beq	34819554 <s3c_ep_enable+0x8c>
	    && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
34819540:	e3520002 	cmp	r2, #2
34819544:	0a000002 	beq	34819554 <s3c_ep_enable+0x8c>
	    && desc->bmAttributes != USB_ENDPOINT_XFER_INT) {
34819548:	e3530003 	cmp	r3, #3
3481954c:	1a00002b 	bne	34819600 <s3c_ep_enable+0x138>
34819550:	ea000003 	b	34819564 <s3c_ep_enable+0x9c>
		debug("%s: %s type mismatch\n", __func__, _ep->name);
		return -EINVAL;
	}

	/* hardware _could_ do smaller, but driver doesn't */
	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
34819554:	e3530002 	cmp	r3, #2
34819558:	1a000001 	bne	34819564 <s3c_ep_enable+0x9c>
	     && le16_to_cpu(get_unaligned(&desc->wMaxPacketSize)) !=
3481955c:	e150000a 	cmp	r0, sl
34819560:	1a000028 	bne	34819608 <s3c_ep_enable+0x140>
	     ep_maxpacket(ep)) || !get_unaligned(&desc->wMaxPacketSize)) {
34819564:	e3500000 	cmp	r0, #0
34819568:	0a000026 	beq	34819608 <s3c_ep_enable+0x140>

		debug("%s: bad %s maxpacket\n", __func__, _ep->name);
		return -ERANGE;
	}

	dev = ep->dev;
3481956c:	e5943018 	ldr	r3, [r4, #24]
	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
34819570:	e5932024 	ldr	r2, [r3, #36]	; 0x24
34819574:	e3520000 	cmp	r2, #0

		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
34819578:	03e0006b 	mvneq	r0, #107	; 0x6b
		debug("%s: bad %s maxpacket\n", __func__, _ep->name);
		return -ERANGE;
	}

	dev = ep->dev;
	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {
3481957c:	08bd84f0 	popeq	{r4, r5, r6, r7, sl, pc}
34819580:	e5933010 	ldr	r3, [r3, #16]
34819584:	e3530000 	cmp	r3, #0
34819588:	0a000020 	beq	34819610 <s3c_ep_enable+0x148>

		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
	}

	ep->stopped = 0;
3481958c:	e3a03000 	mov	r3, #0
34819590:	e5c43034 	strb	r3, [r4, #52]	; 0x34
	ep->desc = desc;
	ep->pio_irqs = 0;
34819594:	e5843028 	str	r3, [r4, #40]	; 0x28
		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
	}

	ep->stopped = 0;
	ep->desc = desc;
34819598:	e584501c 	str	r5, [r4, #28]
	ep->pio_irqs = 0;
	ep->ep.maxpacket = le16_to_cpu(get_unaligned(&desc->wMaxPacketSize));
3481959c:	e1a00007 	mov	r0, r7
348195a0:	ebfffbd7 	bl	34818504 <get_unaligned_le16>
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
348195a4:	e3160080 	tst	r6, #128	; 0x80
348195a8:	e1c401b4 	strh	r0, [r4, #20]
static void s3c_udc_set_nak(struct s3c_ep *ep)
{
	u8		ep_num;
	u32		ep_ctrl = 0;

	ep_num = ep_index(ep);
348195ac:	e206200f 	and	r2, r6, #15
348195b0:	e59f3064 	ldr	r3, [pc, #100]	; 3481961c <s3c_ep_enable+0x154>
	debug("%s: ep_num = %d, ep_type = %d\n", __func__, ep_num, ep->ep_type);

	if (ep_is_in(ep)) {
348195b4:	0a000004 	beq	348195cc <s3c_ep_enable+0x104>
		ep_ctrl = readl(&reg->in_endp[ep_num].diepctl);
348195b8:	e5931000 	ldr	r1, [r3]
348195bc:	e2822048 	add	r2, r2, #72	; 0x48
348195c0:	e7911282 	ldr	r1, [r1, r2, lsl #5]
		ep_ctrl |= DEPCTL_SNAK;
348195c4:	e3811302 	orr	r1, r1, #134217728	; 0x8000000
		writel(ep_ctrl, &reg->in_endp[ep_num].diepctl);
348195c8:	ea000003 	b	348195dc <s3c_ep_enable+0x114>
		debug("%s: set NAK, DIEPCTL%d = 0x%x\n",
			__func__, ep_num, readl(&reg->in_endp[ep_num].diepctl));
	} else {
		ep_ctrl = readl(&reg->out_endp[ep_num].doepctl);
348195cc:	e5931000 	ldr	r1, [r3]
348195d0:	e2822058 	add	r2, r2, #88	; 0x58
348195d4:	e7911282 	ldr	r1, [r1, r2, lsl #5]
		ep_ctrl |= DEPCTL_SNAK;
348195d8:	e3811302 	orr	r1, r1, #134217728	; 0x8000000
		writel(ep_ctrl, &reg->out_endp[ep_num].doepctl);
348195dc:	e5933000 	ldr	r3, [r3]

	/* Reset halt state */
	s3c_udc_set_nak(ep);
	s3c_udc_set_halt(_ep, 0);
348195e0:	e1a00004 	mov	r0, r4
348195e4:	e7831282 	str	r1, [r3, r2, lsl #5]
348195e8:	e3a01000 	mov	r1, #0
348195ec:	ebffff62 	bl	3481937c <s3c_udc_set_halt>

	spin_lock_irqsave(&ep->dev->lock, flags);
	s3c_udc_ep_activate(ep);
348195f0:	e1a00004 	mov	r0, r4
348195f4:	ebffff88 	bl	3481941c <s3c_udc_ep_activate>
	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: enabled %s, stopped = %d, maxpacket = %d\n",
	      __func__, _ep->name, ep->stopped, ep->ep.maxpacket);
	return 0;
348195f8:	e3a00000 	mov	r0, #0
348195fc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	if (ep->bmAttributes != desc->bmAttributes
	    && ep->bmAttributes != USB_ENDPOINT_XFER_BULK
	    && desc->bmAttributes != USB_ENDPOINT_XFER_INT) {

		debug("%s: %s type mismatch\n", __func__, _ep->name);
		return -EINVAL;
34819600:	e3e00015 	mvn	r0, #21
34819604:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	if ((desc->bmAttributes == USB_ENDPOINT_XFER_BULK
	     && le16_to_cpu(get_unaligned(&desc->wMaxPacketSize)) !=
	     ep_maxpacket(ep)) || !get_unaligned(&desc->wMaxPacketSize)) {

		debug("%s: bad %s maxpacket\n", __func__, _ep->name);
		return -ERANGE;
34819608:	e3e00021 	mvn	r0, #33	; 0x21
3481960c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

	dev = ep->dev;
	if (!dev->driver || dev->gadget.speed == USB_SPEED_UNKNOWN) {

		debug("%s: bogus device state\n", __func__);
		return -ESHUTDOWN;
34819610:	e3e0006b 	mvn	r0, #107	; 0x6b
	spin_unlock_irqrestore(&ep->dev->lock, flags);

	debug("%s: enabled %s, stopped = %d, maxpacket = %d\n",
	      __func__, _ep->name, ep->stopped, ep->ep.maxpacket);
	return 0;
}
34819614:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
34819618:	34821594 	.word	0x34821594
3481961c:	3482bc18 	.word	0x3482bc18

34819620 <s3c_ep0_setup>:

/*
 * WAIT_FOR_SETUP (OUT_PKT_RDY)
 */
void s3c_ep0_setup(struct s3c_udc *dev)
{
34819620:	e92d4070 	push	{r4, r5, r6, lr}
	struct s3c_ep *ep = &dev->ep[0];
34819624:	e2806058 	add	r6, r0, #88	; 0x58

	/* Nuke all previous transfers */
	nuke(ep, -EPROTO);

	/* read control req from fifo (8 bytes) */
	s3c_fifo_read(ep, (u32 *)usb_ctrl, 8);
34819628:	e59f5298 	ldr	r5, [pc, #664]	; 348198c8 <s3c_ep0_setup+0x2a8>
	struct s3c_ep *ep = &dev->ep[0];
	int i;
	u8 ep_num;

	/* Nuke all previous transfers */
	nuke(ep, -EPROTO);
3481962c:	e3e01046 	mvn	r1, #70	; 0x46

/*
 * WAIT_FOR_SETUP (OUT_PKT_RDY)
 */
void s3c_ep0_setup(struct s3c_udc *dev)
{
34819630:	e1a04000 	mov	r4, r0
	struct s3c_ep *ep = &dev->ep[0];
	int i;
	u8 ep_num;

	/* Nuke all previous transfers */
	nuke(ep, -EPROTO);
34819634:	e1a00006 	mov	r0, r6
34819638:	ebfffc76 	bl	34818818 <nuke>

	/* read control req from fifo (8 bytes) */
	s3c_fifo_read(ep, (u32 *)usb_ctrl, 8);
3481963c:	e5951018 	ldr	r1, [r5, #24]
34819640:	e1a00006 	mov	r0, r6
34819644:	e3a02008 	mov	r2, #8
34819648:	ebfffeca 	bl	34819178 <s3c_fifo_read>
		}
		printf("\n");
	}
#endif

	if (usb_ctrl->bRequest == GET_MAX_LUN_REQUEST &&
3481964c:	e5951018 	ldr	r1, [r5, #24]
34819650:	e5d13001 	ldrb	r3, [r1, #1]
34819654:	e35300fe 	cmp	r3, #254	; 0xfe
34819658:	1a000005 	bne	34819674 <s3c_ep0_setup+0x54>
	    usb_ctrl->wLength != 1) {
3481965c:	e5d13006 	ldrb	r3, [r1, #6]
34819660:	e5d12007 	ldrb	r2, [r1, #7]
		}
		printf("\n");
	}
#endif

	if (usb_ctrl->bRequest == GET_MAX_LUN_REQUEST &&
34819664:	e1833402 	orr	r3, r3, r2, lsl #8
34819668:	e3530001 	cmp	r3, #1
3481966c:	0a000006 	beq	3481968c <s3c_ep0_setup+0x6c>
34819670:	ea00008a 	b	348198a0 <s3c_ep0_setup+0x280>

		s3c_udc_ep0_set_stall(ep);
		dev->ep0state = WAIT_FOR_SETUP;

		return;
	} else if (usb_ctrl->bRequest == BOT_RESET_REQUEST &&
34819674:	e35300ff 	cmp	r3, #255	; 0xff
34819678:	1a000003 	bne	3481968c <s3c_ep0_setup+0x6c>
		 usb_ctrl->wLength != 0) {
3481967c:	e5d13006 	ldrb	r3, [r1, #6]
34819680:	e5d12007 	ldrb	r2, [r1, #7]

		s3c_udc_ep0_set_stall(ep);
		dev->ep0state = WAIT_FOR_SETUP;

		return;
	} else if (usb_ctrl->bRequest == BOT_RESET_REQUEST &&
34819684:	e1932402 	orrs	r2, r3, r2, lsl #8
34819688:	1a000084 	bne	348198a0 <s3c_ep0_setup+0x280>

		return;
	}

	/* Set direction of EP0 */
	if (likely(usb_ctrl->bRequestType & USB_DIR_IN)) {
3481968c:	e1d130d0 	ldrsb	r3, [r1]
34819690:	e3530000 	cmp	r3, #0
34819694:	e5d4308d 	ldrb	r3, [r4, #141]	; 0x8d
		ep->bEndpointAddress |= USB_DIR_IN;
34819698:	b1e03c83 	mvnlt	r3, r3, lsl #25
3481969c:	b1e03ca3 	mvnlt	r3, r3, lsr #25
	} else {
		ep->bEndpointAddress &= ~USB_DIR_IN;
348196a0:	a203307f 	andge	r3, r3, #127	; 0x7f
348196a4:	e5c4308d 	strb	r3, [r4, #141]	; 0x8d
	}
	/* cope with automagic for some standard requests. */
	dev->req_std = (usb_ctrl->bRequestType & USB_TYPE_MASK)
348196a8:	e5d13000 	ldrb	r3, [r1]
		== USB_TYPE_STANDARD;
348196ac:	e3130060 	tst	r3, #96	; 0x60
		ep->bEndpointAddress |= USB_DIR_IN;
	} else {
		ep->bEndpointAddress &= ~USB_DIR_IN;
	}
	/* cope with automagic for some standard requests. */
	dev->req_std = (usb_ctrl->bRequestType & USB_TYPE_MASK)
348196b0:	e5d43159 	ldrb	r3, [r4, #345]	; 0x159
		== USB_TYPE_STANDARD;
348196b4:	13a02000 	movne	r2, #0
348196b8:	03a02001 	moveq	r2, #1
		ep->bEndpointAddress |= USB_DIR_IN;
	} else {
		ep->bEndpointAddress &= ~USB_DIR_IN;
	}
	/* cope with automagic for some standard requests. */
	dev->req_std = (usb_ctrl->bRequestType & USB_TYPE_MASK)
348196bc:	e7c13092 	bfi	r3, r2, #1, #1
		== USB_TYPE_STANDARD;

	dev->req_pending = 1;
348196c0:	e6ef3073 	uxtb	r3, r3
348196c4:	e3833001 	orr	r3, r3, #1
348196c8:	e5c43159 	strb	r3, [r4, #345]	; 0x159

	/* Handle some SETUP packets ourselves */
	if (dev->req_std) {
348196cc:	e2033002 	and	r3, r3, #2
348196d0:	e6ef3073 	uxtb	r3, r3
348196d4:	e3530000 	cmp	r3, #0
348196d8:	0a000066 	beq	34819878 <s3c_ep0_setup+0x258>
		switch (usb_ctrl->bRequest) {
348196dc:	e5d13001 	ldrb	r3, [r1, #1]
348196e0:	e353000b 	cmp	r3, #11
348196e4:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
348196e8:	ea000062 	b	34819878 <s3c_ep0_setup+0x258>
348196ec:	34819764 	.word	0x34819764
348196f0:	34819778 	.word	0x34819778
348196f4:	34819878 	.word	0x34819878
348196f8:	34819800 	.word	0x34819800
348196fc:	34819878 	.word	0x34819878
34819700:	3481971c 	.word	0x3481971c
34819704:	34819878 	.word	0x34819878
34819708:	34819878 	.word	0x34819878
3481970c:	34819878 	.word	0x34819878
34819710:	34819738 	.word	0x34819738
34819714:	34819878 	.word	0x34819878
34819718:	34819750 	.word	0x34819750
		case USB_REQ_SET_ADDRESS:
		debug_cond(DEBUG_SETUP != 0,
			   "%s: *** USB_REQ_SET_ADDRESS (%d)\n",
			   __func__, usb_ctrl->wValue);
			if (usb_ctrl->bRequestType
3481971c:	e5d13000 	ldrb	r3, [r1]
34819720:	e3530000 	cmp	r3, #0
34819724:	1a000053 	bne	34819878 <s3c_ep0_setup+0x258>
				!= (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
				break;

			udc_set_address(dev, usb_ctrl->wValue);
34819728:	e5d11002 	ldrb	r1, [r1, #2]
3481972c:	e1a00004 	mov	r0, r4

		debug_cond(DEBUG_SETUP != 0,
			   "\tep0state = %s\n", state_names[dev->ep0state]);

	}
}
34819730:	e8bd4070 	pop	{r4, r5, r6, lr}
			   __func__, usb_ctrl->wValue);
			if (usb_ctrl->bRequestType
				!= (USB_TYPE_STANDARD | USB_RECIP_DEVICE))
				break;

			udc_set_address(dev, usb_ctrl->wValue);
34819734:	eafffd15 	b	34818b90 <udc_set_address>
				   "=====================================\n");
			debug_cond(DEBUG_SETUP != 0,
				   "%s: USB_REQ_SET_CONFIGURATION (%d)\n",
				   __func__, usb_ctrl->wValue);

			if (usb_ctrl->bRequestType == USB_RECIP_DEVICE)
34819738:	e5d13000 	ldrb	r3, [r1]
3481973c:	e3530000 	cmp	r3, #0
				reset_available = 1;
34819740:	059f3184 	ldreq	r3, [pc, #388]	; 348198cc <s3c_ep0_setup+0x2ac>
34819744:	03a02001 	moveq	r2, #1
34819748:	0583200c 	streq	r2, [r3, #12]
3481974c:	ea000049 	b	34819878 <s3c_ep0_setup+0x258>
		case USB_REQ_SET_INTERFACE:
			debug_cond(DEBUG_SETUP != 0,
				   "%s: *** USB_REQ_SET_INTERFACE (%d)\n",
				   __func__, usb_ctrl->wValue);

			if (usb_ctrl->bRequestType == USB_RECIP_INTERFACE)
34819750:	e5d13000 	ldrb	r3, [r1]
34819754:	e3530001 	cmp	r3, #1
				reset_available = 1;
34819758:	059f216c 	ldreq	r2, [pc, #364]	; 348198cc <s3c_ep0_setup+0x2ac>
3481975c:	0582300c 	streq	r3, [r2, #12]
34819760:	ea000044 	b	34819878 <s3c_ep0_setup+0x258>
				   "%s: *** USB_REQ_GET_CONFIGURATION\n",
				   __func__);
			break;

		case USB_REQ_GET_STATUS:
			if (!s3c_udc_get_status(dev, usb_ctrl))
34819764:	e1a00004 	mov	r0, r4
34819768:	ebfffe8c 	bl	348191a0 <s3c_udc_get_status>
3481976c:	e3500000 	cmp	r0, #0
34819770:	1a000040 	bne	34819878 <s3c_ep0_setup+0x258>
34819774:	e8bd8070 	pop	{r4, r5, r6, pc}
				return;

			break;

		case USB_REQ_CLEAR_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;
34819778:	e5d15004 	ldrb	r5, [r1, #4]
	dev = ep->dev;
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
3481977c:	e5d12006 	ldrb	r2, [r1, #6]
			break;

		case USB_REQ_CLEAR_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_clear_feature(&dev->ep[ep_num].ep))
34819780:	e205507f 	and	r5, r5, #127	; 0x7f
	dev = ep->dev;
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
34819784:	e5d1c007 	ldrb	ip, [r1, #7]
			break;

		case USB_REQ_CLEAR_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_clear_feature(&dev->ep[ep_num].ep))
34819788:	e0845305 	add	r5, r4, r5, lsl #6
3481978c:	e2855058 	add	r5, r5, #88	; 0x58
	dev = ep->dev;
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
34819790:	e192c40c 	orrs	ip, r2, ip, lsl #8
	struct s3c_udc	*dev;
	struct s3c_ep	*ep;
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);
34819794:	e5d53035 	ldrb	r3, [r5, #53]	; 0x35

	dev = ep->dev;
34819798:	e5950018 	ldr	r0, [r5, #24]
	debug_cond(DEBUG_SETUP != 0,
		   "%s: ep_num = %d, is_in = %d, clear_feature_flag = %d\n",
		   __func__, ep_num, ep_is_in(ep), clear_feature_flag);

	if (usb_ctrl->wLength != 0) {
3481979c:	1a000035 	bne	34819878 <s3c_ep0_setup+0x258>
		debug_cond(DEBUG_SETUP != 0,
			   "\tCLEAR_FEATURE: wLength is not zero.....\n");
		return 1;
	}

	switch (usb_ctrl->bRequestType & USB_RECIP_MASK) {
348197a0:	e5d12000 	ldrb	r2, [r1]
348197a4:	e212201f 	ands	r2, r2, #31
				   "\tCLEAR_FEATURE: USB_DEVICE_TEST_MODE\n");
			/** @todo Add CLEAR_FEATURE for TEST modes. */
			break;
		}

		s3c_udc_ep0_zlp(dev);
348197a8:	02800054 	addeq	r0, r0, #84	; 0x54
		debug_cond(DEBUG_SETUP != 0,
			   "\tCLEAR_FEATURE: wLength is not zero.....\n");
		return 1;
	}

	switch (usb_ctrl->bRequestType & USB_RECIP_MASK) {
348197ac:	0a00002f 	beq	34819870 <s3c_ep0_setup+0x250>
348197b0:	e3520002 	cmp	r2, #2
348197b4:	18bd8070 	popne	{r4, r5, r6, pc}
	case USB_RECIP_ENDPOINT:
		debug_cond(DEBUG_SETUP != 0,
			   "\tCLEAR_FEATURE:USB_RECIP_ENDPOINT, wValue = %d\n",
			   usb_ctrl->wValue);

		if (usb_ctrl->wValue == USB_ENDPOINT_HALT) {
348197b8:	e5d12002 	ldrb	r2, [r1, #2]
348197bc:	e5d16003 	ldrb	r6, [r1, #3]
348197c0:	e1926406 	orrs	r6, r2, r6, lsl #8
348197c4:	18bd8070 	popne	{r4, r5, r6, pc}
			if (ep_num == 0) {
348197c8:	e213400f 	ands	r4, r3, #15
348197cc:	0a000021 	beq	34819858 <s3c_ep0_setup+0x238>
				s3c_udc_ep0_set_stall(ep);
				return 0;
			}

			s3c_udc_ep0_zlp(dev);
348197d0:	e2800054 	add	r0, r0, #84	; 0x54
348197d4:	ebfffc85 	bl	348189f0 <s3c_udc_ep0_zlp.clone.2>

			s3c_udc_ep_clear_stall(ep);
348197d8:	e1a00005 	mov	r0, r5
348197dc:	ebfffec7 	bl	34819300 <s3c_udc_ep_clear_stall>
			s3c_udc_ep_activate(ep);
348197e0:	e1a00005 	mov	r0, r5
348197e4:	ebffff0c 	bl	3481941c <s3c_udc_ep_activate>
			ep->stopped = 0;

			clear_feature_num = ep_num;
348197e8:	e59f30d8 	ldr	r3, [pc, #216]	; 348198c8 <s3c_ep0_setup+0x2a8>
			clear_feature_flag = 1;
348197ec:	e3a02001 	mov	r2, #1

			s3c_udc_ep0_zlp(dev);

			s3c_udc_ep_clear_stall(ep);
			s3c_udc_ep_activate(ep);
			ep->stopped = 0;
348197f0:	e5c56034 	strb	r6, [r5, #52]	; 0x34

			clear_feature_num = ep_num;
348197f4:	e5c3401c 	strb	r4, [r3, #28]
			clear_feature_flag = 1;
348197f8:	e5832020 	str	r2, [r3, #32]
348197fc:	e8bd8070 	pop	{r4, r5, r6, pc}
				return;

			break;

		case USB_REQ_SET_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;
34819800:	e5d10004 	ldrb	r0, [r1, #4]

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
34819804:	e5d13006 	ldrb	r3, [r1, #6]
			break;

		case USB_REQ_SET_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_set_feature(&dev->ep[ep_num].ep))
34819808:	e200007f 	and	r0, r0, #127	; 0x7f

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
3481980c:	e5d1c007 	ldrb	ip, [r1, #7]
			break;

		case USB_REQ_SET_FEATURE:
			ep_num = usb_ctrl->wIndex & 0x7f;

			if (!s3c_udc_set_feature(&dev->ep[ep_num].ep))
34819810:	e0840300 	add	r0, r4, r0, lsl #6
34819814:	e2800058 	add	r0, r0, #88	; 0x58

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
34819818:	e193c40c 	orrs	ip, r3, ip, lsl #8
	struct s3c_udc	*dev;
	struct s3c_ep	*ep;
	u8		ep_num;

	ep = container_of(_ep, struct s3c_ep, ep);
	ep_num = ep_index(ep);
3481981c:	e5d02035 	ldrb	r2, [r0, #53]	; 0x35
	dev = ep->dev;
34819820:	e5905018 	ldr	r5, [r0, #24]

	debug_cond(DEBUG_SETUP != 0,
		   "%s: *** USB_REQ_SET_FEATURE , ep_num = %d\n",
		    __func__, ep_num);

	if (usb_ctrl->wLength != 0) {
34819824:	1a000013 	bne	34819878 <s3c_ep0_setup+0x258>
		debug_cond(DEBUG_SETUP != 0,
			   "\tSET_FEATURE: wLength is not zero.....\n");
		return 1;
	}

	switch (usb_ctrl->bRequestType & USB_RECIP_MASK) {
34819828:	e5d13000 	ldrb	r3, [r1]
3481982c:	e213301f 	ands	r3, r3, #31
34819830:	0a00000d 	beq	3481986c <s3c_ep0_setup+0x24c>
34819834:	e3530002 	cmp	r3, #2
34819838:	1a00000e 	bne	34819878 <s3c_ep0_setup+0x258>
		break;

	case USB_RECIP_ENDPOINT:
		debug_cond(DEBUG_SETUP != 0,
			   "\tSET_FEATURE: USB_RECIP_ENDPOINT\n");
		if (usb_ctrl->wValue == USB_ENDPOINT_HALT) {
3481983c:	e5d13002 	ldrb	r3, [r1, #2]
34819840:	e5d11003 	ldrb	r1, [r1, #3]
34819844:	e1931401 	orrs	r1, r3, r1, lsl #8
34819848:	1a000007 	bne	3481986c <s3c_ep0_setup+0x24c>
			if (ep_num == 0) {
3481984c:	e312000f 	tst	r2, #15
34819850:	1a000002 	bne	34819860 <s3c_ep0_setup+0x240>
				s3c_udc_ep0_set_stall(ep);
34819854:	e1a00005 	mov	r0, r5

		debug_cond(DEBUG_SETUP != 0,
			   "\tep0state = %s\n", state_names[dev->ep0state]);

	}
}
34819858:	e8bd4070 	pop	{r4, r5, r6, lr}
	case USB_RECIP_ENDPOINT:
		debug_cond(DEBUG_SETUP != 0,
			   "\tSET_FEATURE: USB_RECIP_ENDPOINT\n");
		if (usb_ctrl->wValue == USB_ENDPOINT_HALT) {
			if (ep_num == 0) {
				s3c_udc_ep0_set_stall(ep);
3481985c:	eafffd4b 	b	34818d90 <s3c_udc_ep0_set_stall.clone.3>
				return 0;
			}
			ep->stopped = 1;
34819860:	e3a03001 	mov	r3, #1
34819864:	e5c03034 	strb	r3, [r0, #52]	; 0x34
			s3c_udc_ep_set_stall(ep);
34819868:	ebfffe8c 	bl	348192a0 <s3c_udc_ep_set_stall>
		}

		s3c_udc_ep0_zlp(dev);
3481986c:	e2850054 	add	r0, r5, #84	; 0x54

		debug_cond(DEBUG_SETUP != 0,
			   "\tep0state = %s\n", state_names[dev->ep0state]);

	}
}
34819870:	e8bd4070 	pop	{r4, r5, r6, lr}
			}
			ep->stopped = 1;
			s3c_udc_ep_set_stall(ep);
		}

		s3c_udc_ep0_zlp(dev);
34819874:	eafffc5d 	b	348189f0 <s3c_udc_ep0_zlp.clone.2>
			break;
		}
	}


	if (likely(dev->driver)) {
34819878:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481987c:	e3530000 	cmp	r3, #0
34819880:	08bd8070 	popeq	{r4, r5, r6, pc}
		debug_cond(DEBUG_SETUP != 0,
			   "%s:usb_ctrlreq will be passed to fsg_setup()\n",
			    __func__);

		spin_unlock(&dev->lock);
		i = dev->driver->setup(&dev->gadget, usb_ctrl);
34819884:	e59f203c 	ldr	r2, [pc, #60]	; 348198c8 <s3c_ep0_setup+0x2a8>
34819888:	e593300c 	ldr	r3, [r3, #12]
3481988c:	e1a00004 	mov	r0, r4
34819890:	e5921018 	ldr	r1, [r2, #24]
34819894:	e12fff33 	blx	r3
		spin_lock(&dev->lock);

		if (i < 0) {
34819898:	e3500000 	cmp	r0, #0
3481989c:	aa000004 	bge	348198b4 <s3c_ep0_setup+0x294>
			/* setup processing failed, force stall */
			s3c_udc_ep0_set_stall(ep);
348198a0:	e5940070 	ldr	r0, [r4, #112]	; 0x70
348198a4:	ebfffd39 	bl	34818d90 <s3c_udc_ep0_set_stall.clone.3>
			dev->ep0state = WAIT_FOR_SETUP;
348198a8:	e3a03000 	mov	r3, #0
348198ac:	e5843054 	str	r3, [r4, #84]	; 0x54
348198b0:	e8bd8070 	pop	{r4, r5, r6, pc}
				   "\tdev->driver->setup failed (%d),"
				    " bRequest = %d\n",
				i, usb_ctrl->bRequest);


		} else if (dev->req_pending) {
348198b4:	e5d43159 	ldrb	r3, [r4, #345]	; 0x159
348198b8:	e3130001 	tst	r3, #1
			dev->req_pending = 0;
348198bc:	17c0301f 	bfcne	r3, #0, #1
348198c0:	15c43159 	strbne	r3, [r4, #345]	; 0x159
348198c4:	e8bd8070 	pop	{r4, r5, r6, pc}
348198c8:	3482bc18 	.word	0x3482bc18
348198cc:	348292e8 	.word	0x348292e8

348198d0 <usb_gadget_register_driver>:
/*
  Register entry point for the peripheral controller driver.
*/
int usb_gadget_register_driver(struct usb_gadget_driver *driver)
{
	struct s3c_udc *dev = the_controller;
348198d0:	e59f3094 	ldr	r3, [pc, #148]	; 3481996c <usb_gadget_register_driver+0x9c>
	int retval = 0;
	unsigned long flags;

	debug_cond(DEBUG_SETUP != 0, "%s: %s\n", __func__, "no name");

	if (!driver
348198d4:	e3500000 	cmp	r0, #0

/*
  Register entry point for the peripheral controller driver.
*/
int usb_gadget_register_driver(struct usb_gadget_driver *driver)
{
348198d8:	e92d4070 	push	{r4, r5, r6, lr}
	struct s3c_udc *dev = the_controller;
348198dc:	e5935008 	ldr	r5, [r3, #8]
	int retval = 0;
	unsigned long flags;

	debug_cond(DEBUG_SETUP != 0, "%s: %s\n", __func__, "no name");

	if (!driver
348198e0:	0a00001e 	beq	34819960 <usb_gadget_register_driver+0x90>
	    || (driver->speed != USB_SPEED_FULL
		&& driver->speed != USB_SPEED_HIGH)
348198e4:	e5903000 	ldr	r3, [r0]
348198e8:	e2433002 	sub	r3, r3, #2
	unsigned long flags;

	debug_cond(DEBUG_SETUP != 0, "%s: %s\n", __func__, "no name");

	if (!driver
	    || (driver->speed != USB_SPEED_FULL
348198ec:	e3530001 	cmp	r3, #1
348198f0:	8a00001a 	bhi	34819960 <usb_gadget_register_driver+0x90>
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
348198f4:	e5903004 	ldr	r3, [r0, #4]
348198f8:	e3530000 	cmp	r3, #0
348198fc:	0a000017 	beq	34819960 <usb_gadget_register_driver+0x90>
34819900:	e5902010 	ldr	r2, [r0, #16]
34819904:	e3520000 	cmp	r2, #0
34819908:	0a000014 	beq	34819960 <usb_gadget_register_driver+0x90>
3481990c:	e590200c 	ldr	r2, [r0, #12]
34819910:	e3520000 	cmp	r2, #0
34819914:	0a000011 	beq	34819960 <usb_gadget_register_driver+0x90>
		return -EINVAL;
	if (!dev)
34819918:	e3550000 	cmp	r5, #0
		return -ENODEV;
3481991c:	03e04012 	mvneq	r4, #18
	if (!driver
	    || (driver->speed != USB_SPEED_FULL
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
		return -EINVAL;
	if (!dev)
34819920:	0a00000f 	beq	34819964 <usb_gadget_register_driver+0x94>
		return -ENODEV;
	if (dev->driver)
34819924:	e5956024 	ldr	r6, [r5, #36]	; 0x24
34819928:	e3560000 	cmp	r6, #0
		return -EBUSY;
3481992c:	13e0400f 	mvnne	r4, #15
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
		return -EINVAL;
	if (!dev)
		return -ENODEV;
	if (dev->driver)
34819930:	1a00000b 	bne	34819964 <usb_gadget_register_driver+0x94>
		return -EBUSY;

	spin_lock_irqsave(&dev->lock, flags);
	/* first hook up the driver ... */
	dev->driver = driver;
34819934:	e5850024 	str	r0, [r5, #36]	; 0x24
	if (retval) { /* TODO */
		printf("target device_add failed, error %d\n", retval);
		return retval;
	}

	retval = driver->bind(&dev->gadget);
34819938:	e1a00005 	mov	r0, r5
3481993c:	e12fff33 	blx	r3
	if (retval) {
34819940:	e2504000 	subs	r4, r0, #0
		debug_cond(DEBUG_SETUP != 0,
			   "%s: bind to driver --> error %d\n",
			    dev->gadget.name, retval);
		dev->driver = 0;
34819944:	15856024 	strne	r6, [r5, #36]	; 0x24
		printf("target device_add failed, error %d\n", retval);
		return retval;
	}

	retval = driver->bind(&dev->gadget);
	if (retval) {
34819948:	1a000005 	bne	34819964 <usb_gadget_register_driver+0x94>
 */
static int udc_enable(struct s3c_udc *dev)
{
	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	otg_phy_init(dev);
3481994c:	e1a00005 	mov	r0, r5
34819950:	ebfffca3 	bl	34818be4 <otg_phy_init>
	reconfig_usbd();
34819954:	ebfffb1c 	bl	348185cc <reconfig_usbd>

	debug_cond(DEBUG_SETUP != 0,
		   "S3C USB 2.0 OTG Controller Core Initialized : 0x%x\n",
		    readl(&reg->gintmsk));

	dev->gadget.speed = USB_SPEED_UNKNOWN;
34819958:	e5854010 	str	r4, [r5, #16]

	debug_cond(DEBUG_SETUP != 0,
		   "Registered gadget driver %s\n", dev->gadget.name);
	udc_enable(dev);

	return 0;
3481995c:	ea000000 	b	34819964 <usb_gadget_register_driver+0x94>

	if (!driver
	    || (driver->speed != USB_SPEED_FULL
		&& driver->speed != USB_SPEED_HIGH)
	    || !driver->bind || !driver->disconnect || !driver->setup)
		return -EINVAL;
34819960:	e3e04015 	mvn	r4, #21
	debug_cond(DEBUG_SETUP != 0,
		   "Registered gadget driver %s\n", dev->gadget.name);
	udc_enable(dev);

	return 0;
}
34819964:	e1a00004 	mov	r0, r4
34819968:	e8bd8070 	pop	{r4, r5, r6, pc}
3481996c:	3482bc18 	.word	0x3482bc18

34819970 <usb_gadget_unregister_driver>:
/*
 * Unregister entry point for the peripheral controller driver.
 */
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
	struct s3c_udc *dev = the_controller;
34819970:	e59f3144 	ldr	r3, [pc, #324]	; 34819abc <usb_gadget_unregister_driver+0x14c>

/*
 * Unregister entry point for the peripheral controller driver.
 */
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
34819974:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	struct s3c_udc *dev = the_controller;
34819978:	e5934008 	ldr	r4, [r3, #8]

/*
 * Unregister entry point for the peripheral controller driver.
 */
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
3481997c:	e1a07000 	mov	r7, r0
	struct s3c_udc *dev = the_controller;
	unsigned long flags;

	if (!dev)
34819980:	e3540000 	cmp	r4, #0
		return -ENODEV;
34819984:	03e00012 	mvneq	r0, #18
int usb_gadget_unregister_driver(struct usb_gadget_driver *driver)
{
	struct s3c_udc *dev = the_controller;
	unsigned long flags;

	if (!dev)
34819988:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
		return -ENODEV;
	if (!driver || driver != dev->driver)
3481998c:	e3570000 	cmp	r7, #0
		return -EINVAL;
34819990:	03e00015 	mvneq	r0, #21
	struct s3c_udc *dev = the_controller;
	unsigned long flags;

	if (!dev)
		return -ENODEV;
	if (!driver || driver != dev->driver)
34819994:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
34819998:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481999c:	e1570003 	cmp	r7, r3
348199a0:	1a000043 	bne	34819ab4 <usb_gadget_unregister_driver+0x144>
			  struct usb_gadget_driver *driver)
{
	int i;

	/* don't disconnect drivers more than once */
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
348199a4:	e5949010 	ldr	r9, [r4, #16]
		return -ENODEV;
	if (!driver || driver != dev->driver)
		return -EINVAL;

	spin_lock_irqsave(&dev->lock, flags);
	dev->driver = 0;
348199a8:	e3a06000 	mov	r6, #0
			  struct usb_gadget_driver *driver)
{
	int i;

	/* don't disconnect drivers more than once */
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
348199ac:	e1590006 	cmp	r9, r6
		return -ENODEV;
	if (!driver || driver != dev->driver)
		return -EINVAL;

	spin_lock_irqsave(&dev->lock, flags);
	dev->driver = 0;
348199b0:	e5846024 	str	r6, [r4, #36]	; 0x24
			  struct usb_gadget_driver *driver)
{
	int i;

	/* don't disconnect drivers more than once */
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
348199b4:	11a09007 	movne	r9, r7
348199b8:	01a09006 	moveq	r9, r6
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;
348199bc:	e5846010 	str	r6, [r4, #16]
348199c0:	e1a05004 	mov	r5, r4
348199c4:	e1a0a004 	mov	sl, r4

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];
		ep->stopped = 1;
348199c8:	e3a0b001 	mov	fp, #1
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];
348199cc:	e0840306 	add	r0, r4, r6, lsl #6
		ep->stopped = 1;
348199d0:	e5cab08c 	strb	fp, [sl, #140]	; 0x8c
		nuke(ep, -ESHUTDOWN);
348199d4:	e2800058 	add	r0, r0, #88	; 0x58
348199d8:	e3e0106b 	mvn	r1, #107	; 0x6b
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
348199dc:	e2866001 	add	r6, r6, #1
		struct s3c_ep *ep = &dev->ep[i];
		ep->stopped = 1;
		nuke(ep, -ESHUTDOWN);
348199e0:	ebfffb8c 	bl	34818818 <nuke>
	if (dev->gadget.speed == USB_SPEED_UNKNOWN)
		driver = 0;
	dev->gadget.speed = USB_SPEED_UNKNOWN;

	/* prevent new request submissions, kill any outstanding requests  */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
348199e4:	e3560004 	cmp	r6, #4
348199e8:	e28aa040 	add	sl, sl, #64	; 0x40
348199ec:	1afffff6 	bne	348199cc <usb_gadget_unregister_driver+0x5c>
		ep->stopped = 1;
		nuke(ep, -ESHUTDOWN);
	}

	/* report disconnect; the driver is already quiesced */
	if (driver) {
348199f0:	e3590000 	cmp	r9, #0
348199f4:	0a000002 	beq	34819a04 <usb_gadget_unregister_driver+0x94>
		spin_unlock(&dev->lock);
		driver->disconnect(&dev->gadget);
348199f8:	e5993010 	ldr	r3, [r9, #16]
348199fc:	e1a00004 	mov	r0, r4
34819a00:	e12fff33 	blx	r3

	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	/* device/ep0 records init */
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
34819a04:	e5943004 	ldr	r3, [r4, #4]
	unsigned int i;

	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	/* device/ep0 records init */
	INIT_LIST_HEAD(&dev->gadget.ep_list);
34819a08:	e2842008 	add	r2, r4, #8
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
34819a0c:	e283100c 	add	r1, r3, #12
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34819a10:	e5842008 	str	r2, [r4, #8]
	list->prev = list;
34819a14:	e584200c 	str	r2, [r4, #12]
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34819a18:	e583100c 	str	r1, [r3, #12]
	list->prev = list;
34819a1c:	e5831010 	str	r1, [r3, #16]
	dev->ep0state = WAIT_FOR_SETUP;
34819a20:	e3a03000 	mov	r3, #0
34819a24:	e5843054 	str	r3, [r4, #84]	; 0x54
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
34819a28:	e1a06003 	mov	r6, r3
34819a2c:	ea000009 	b	34819a58 <usb_gadget_unregister_driver+0xe8>

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
34819a30:	e3530000 	cmp	r3, #0
34819a34:	0a000006 	beq	34819a54 <usb_gadget_unregister_driver+0xe4>
 * Insert a new entry before the specified head.
 * This is useful for implementing queues.
 */
static inline void list_add_tail(struct list_head *new, struct list_head *head)
{
	__list_add(new, head->prev, head);
34819a38:	e594100c 	ldr	r1, [r4, #12]
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
34819a3c:	e0840303 	add	r0, r4, r3, lsl #6
34819a40:	e2800064 	add	r0, r0, #100	; 0x64
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34819a44:	e584000c 	str	r0, [r4, #12]
	new->next = next;
34819a48:	e58520a4 	str	r2, [r5, #164]	; 0xa4
	new->prev = prev;
34819a4c:	e58510a8 	str	r1, [r5, #168]	; 0xa8
	prev->next = new;
34819a50:	e5810000 	str	r0, [r1]
34819a54:	e2855040 	add	r5, r5, #64	; 0x40

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
34819a58:	e0841303 	add	r1, r4, r3, lsl #6
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
34819a5c:	e2833001 	add	r3, r3, #1
		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
34819a60:	e2811078 	add	r1, r1, #120	; 0x78
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
34819a64:	e3530004 	cmp	r3, #4
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
34819a68:	e5856074 	str	r6, [r5, #116]	; 0x74
		ep->stopped = 0;
34819a6c:	e5c5608c 	strb	r6, [r5, #140]	; 0x8c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34819a70:	e5851078 	str	r1, [r5, #120]	; 0x78
	list->prev = list;
34819a74:	e585107c 	str	r1, [r5, #124]	; 0x7c
		INIT_LIST_HEAD(&ep->queue);
		ep->pio_irqs = 0;
34819a78:	e5856080 	str	r6, [r5, #128]	; 0x80
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
34819a7c:	1affffeb 	bne	34819a30 <usb_gadget_unregister_driver+0xc0>
	spin_lock_irqsave(&dev->lock, flags);
	dev->driver = 0;
	stop_activity(dev, driver);
	spin_unlock_irqrestore(&dev->lock, flags);

	driver->unbind(&dev->gadget);
34819a80:	e5973008 	ldr	r3, [r7, #8]
34819a84:	e1a00004 	mov	r0, r4
34819a88:	e12fff33 	blx	r3
 */
static void udc_disable(struct s3c_udc *dev)
{
	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	udc_set_address(dev, 0);
34819a8c:	e1a00004 	mov	r0, r4
34819a90:	e1a01006 	mov	r1, r6
34819a94:	ebfffc3d 	bl	34818b90 <udc_set_address>

	dev->ep0state = WAIT_FOR_SETUP;
	dev->gadget.speed = USB_SPEED_UNKNOWN;
	dev->usb_address = 0;

	otg_phy_off(dev);
34819a98:	e1a00004 	mov	r0, r4
{
	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	udc_set_address(dev, 0);

	dev->ep0state = WAIT_FOR_SETUP;
34819a9c:	e5846054 	str	r6, [r4, #84]	; 0x54
	dev->gadget.speed = USB_SPEED_UNKNOWN;
34819aa0:	e5846010 	str	r6, [r4, #16]
	dev->usb_address = 0;
34819aa4:	e5c46158 	strb	r6, [r4, #344]	; 0x158

	otg_phy_off(dev);
34819aa8:	ebfffc80 	bl	34818cb0 <otg_phy_off>
	driver->unbind(&dev->gadget);

	disable_irq(IRQ_OTG);

	udc_disable(dev);
	return 0;
34819aac:	e1a00006 	mov	r0, r6
34819ab0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	unsigned long flags;

	if (!dev)
		return -ENODEV;
	if (!driver || driver != dev->driver)
		return -EINVAL;
34819ab4:	e3e00015 	mvn	r0, #21

	disable_irq(IRQ_OTG);

	udc_disable(dev);
	return 0;
}
34819ab8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
34819abc:	3482bc18 	.word	0x3482bc18

34819ac0 <s3c_udc_probe>:

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
34819ac0:	e59f3108 	ldr	r3, [pc, #264]	; 34819bd0 <s3c_udc_probe+0x110>
34819ac4:	e5902004 	ldr	r2, [r0, #4]
/*
 *	probe - binds to the platform device
 */

int s3c_udc_probe(struct s3c_plat_otg_data *pdata)
{
34819ac8:	e92d4070 	push	{r4, r5, r6, lr}

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
34819acc:	e5832010 	str	r2, [r3, #16]
	reg = (struct s3c_usbotg_reg *)pdata->regs_otg;
34819ad0:	e5902008 	ldr	r2, [r0, #8]
	struct s3c_udc *dev = &memory;
	int retval = 0, i;

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;
34819ad4:	e59f60f8 	ldr	r6, [pc, #248]	; 34819bd4 <s3c_udc_probe+0x114>

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
	reg = (struct s3c_usbotg_reg *)pdata->regs_otg;
34819ad8:	e5832000 	str	r2, [r3]
	usb_phy_ctrl = pdata->usb_phy_ctrl;
34819adc:	e590200c 	ldr	r2, [r0, #12]
	dev->gadget.is_a_peripheral = 0;
	dev->gadget.b_hnp_enable = 0;
	dev->gadget.a_hnp_support = 0;
	dev->gadget.a_alt_hnp_support = 0;

	the_controller = dev;
34819ae0:	e2864010 	add	r4, r6, #16

	dev->pdata = pdata;

	phy = (struct s3c_usbotg_phy *)pdata->regs_phy;
	reg = (struct s3c_usbotg_reg *)pdata->regs_otg;
	usb_phy_ctrl = pdata->usb_phy_ctrl;
34819ae4:	e583200c 	str	r2, [r3, #12]

	/* regs_otg = (void *)pdata->regs_otg; */

	dev->gadget.is_dualspeed = 1;	/* Hack only*/
34819ae8:	e5d62024 	ldrb	r2, [r6, #36]	; 0x24
	struct s3c_udc *dev = &memory;
	int retval = 0, i;

	debug("%s: %p\n", __func__, pdata);

	dev->pdata = pdata;
34819aec:	e5860038 	str	r0, [r6, #56]	; 0x38
	usb_phy_ctrl = pdata->usb_phy_ctrl;

	/* regs_otg = (void *)pdata->regs_otg; */

	dev->gadget.is_dualspeed = 1;	/* Hack only*/
	dev->gadget.is_otg = 0;
34819af0:	e3822001 	orr	r2, r2, #1
	dev->gadget.is_a_peripheral = 0;
	dev->gadget.b_hnp_enable = 0;
	dev->gadget.a_hnp_support = 0;
	dev->gadget.a_alt_hnp_support = 0;
34819af4:	e20220e1 	and	r2, r2, #225	; 0xe1
34819af8:	e7c5229f 	bfc	r2, #5, #1
34819afc:	e5c62024 	strb	r2, [r6, #36]	; 0x24

	the_controller = dev;
34819b00:	e2865038 	add	r5, r6, #56	; 0x38
34819b04:	e5834008 	str	r4, [r3, #8]

/*
 *	probe - binds to the platform device
 */

int s3c_udc_probe(struct s3c_plat_otg_data *pdata)
34819b08:	e286604c 	add	r6, r6, #76	; 0x4c
	dev->gadget.a_alt_hnp_support = 0;

	the_controller = dev;

	for (i = 0; i < S3C_MAX_ENDPOINTS+1; i++) {
		dev->dma_buf[i] = memalign(CONFIG_SYS_CACHELINE_SIZE,
34819b0c:	e3a01901 	mov	r1, #16384	; 0x4000
34819b10:	e3a00040 	mov	r0, #64	; 0x40
34819b14:	ebffc0fe 	bl	34809f14 <memalign>
34819b18:	e5a50004 	str	r0, [r5, #4]!
					   DMA_BUFFER_SIZE);
		dev->dma_addr[i] = (dma_addr_t) dev->dma_buf[i];
34819b1c:	e5850014 	str	r0, [r5, #20]
		invalidate_dcache_range((unsigned long) dev->dma_buf[i],
34819b20:	e2801901 	add	r1, r0, #16384	; 0x4000
34819b24:	ebff9ad5 	bl	34800680 <invalidate_dcache_range>
	dev->gadget.a_hnp_support = 0;
	dev->gadget.a_alt_hnp_support = 0;

	the_controller = dev;

	for (i = 0; i < S3C_MAX_ENDPOINTS+1; i++) {
34819b28:	e1550006 	cmp	r5, r6
34819b2c:	1afffff6 	bne	34819b0c <s3c_udc_probe+0x4c>
		dev->dma_addr[i] = (dma_addr_t) dev->dma_buf[i];
		invalidate_dcache_range((unsigned long) dev->dma_buf[i],
					(unsigned long) (dev->dma_buf[i]
							 + DMA_BUFFER_SIZE));
	}
	usb_ctrl = dev->dma_buf[0];
34819b30:	e59f309c 	ldr	r3, [pc, #156]	; 34819bd4 <s3c_udc_probe+0x114>
34819b34:	e59f2094 	ldr	r2, [pc, #148]	; 34819bd0 <s3c_udc_probe+0x110>
34819b38:	e593103c 	ldr	r1, [r3, #60]	; 0x3c
34819b3c:	e5821018 	str	r1, [r2, #24]
	usb_ctrl_dma_addr = dev->dma_addr[0];
34819b40:	e5931050 	ldr	r1, [r3, #80]	; 0x50
34819b44:	e5821004 	str	r1, [r2, #4]

	debug_cond(DEBUG_SETUP != 0, "%s: %p\n", __func__, dev);

	/* device/ep0 records init */
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
34819b48:	e5932014 	ldr	r2, [r3, #20]
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34819b4c:	e2831018 	add	r1, r3, #24
34819b50:	e282000c 	add	r0, r2, #12
34819b54:	e582000c 	str	r0, [r2, #12]
	list->prev = list;
34819b58:	e5820010 	str	r0, [r2, #16]
	dev->ep0state = WAIT_FOR_SETUP;
34819b5c:	e3a02000 	mov	r2, #0
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34819b60:	e5831018 	str	r1, [r3, #24]
34819b64:	e5832064 	str	r2, [r3, #100]	; 0x64
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
34819b68:	e1a00002 	mov	r0, r2
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
34819b6c:	e2833010 	add	r3, r3, #16
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
	new->next = next;
34819b70:	e1a05001 	mov	r5, r1
34819b74:	ea000008 	b	34819b9c <s3c_udc_probe+0xdc>

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
34819b78:	e3520000 	cmp	r2, #0
34819b7c:	0a000005 	beq	34819b98 <s3c_udc_probe+0xd8>
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);
34819b80:	e083c302 	add	ip, r3, r2, lsl #6
34819b84:	e28cc064 	add	ip, ip, #100	; 0x64
34819b88:	e58450a4 	str	r5, [r4, #164]	; 0xa4
	new->prev = prev;
34819b8c:	e58410a8 	str	r1, [r4, #168]	; 0xa8
	prev->next = new;
34819b90:	e581c000 	str	ip, [r1]
 */
static inline void __list_add(struct list_head *new,
			      struct list_head *prev,
			      struct list_head *next)
{
	next->prev = new;
34819b94:	e1a0100c 	mov	r1, ip
	new->next = next;
	new->prev = prev;
	prev->next = new;
34819b98:	e2844040 	add	r4, r4, #64	; 0x40

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
34819b9c:	e083c302 	add	ip, r3, r2, lsl #6
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
34819ba0:	e2822001 	add	r2, r2, #1
		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
		ep->stopped = 0;
		INIT_LIST_HEAD(&ep->queue);
34819ba4:	e28cc078 	add	ip, ip, #120	; 0x78
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
34819ba8:	e3520004 	cmp	r2, #4
		struct s3c_ep *ep = &dev->ep[i];

		if (i != 0)
			list_add_tail(&ep->ep.ep_list, &dev->gadget.ep_list);

		ep->desc = 0;
34819bac:	e5840074 	str	r0, [r4, #116]	; 0x74
		ep->stopped = 0;
34819bb0:	e5c4008c 	strb	r0, [r4, #140]	; 0x8c
#define LIST_HEAD(name) \
	struct list_head name = LIST_HEAD_INIT(name)

static inline void INIT_LIST_HEAD(struct list_head *list)
{
	list->next = list;
34819bb4:	e584c078 	str	ip, [r4, #120]	; 0x78
	list->prev = list;
34819bb8:	e584c07c 	str	ip, [r4, #124]	; 0x7c
		INIT_LIST_HEAD(&ep->queue);
		ep->pio_irqs = 0;
34819bbc:	e5840080 	str	r0, [r4, #128]	; 0x80
	INIT_LIST_HEAD(&dev->gadget.ep_list);
	INIT_LIST_HEAD(&dev->gadget.ep0->ep_list);
	dev->ep0state = WAIT_FOR_SETUP;

	/* basic endpoint records init */
	for (i = 0; i < S3C_MAX_ENDPOINTS; i++) {
34819bc0:	1affffec 	bne	34819b78 <s3c_udc_probe+0xb8>
34819bc4:	e59f3008 	ldr	r3, [pc, #8]	; 34819bd4 <s3c_udc_probe+0x114>
34819bc8:	e583101c 	str	r1, [r3, #28]
	usb_ctrl_dma_addr = dev->dma_addr[0];

	udc_reinit(dev);

	return retval;
}
34819bcc:	e8bd8070 	pop	{r4, r5, r6, pc}
34819bd0:	3482bc18 	.word	0x3482bc18
34819bd4:	348292e8 	.word	0x348292e8

34819bd8 <usb_gadget_handle_interrupts>:

int usb_gadget_handle_interrupts()
{
34819bd8:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	u32 intr_status = readl(&reg->gintsts);
34819bdc:	e59f3434 	ldr	r3, [pc, #1076]	; 3481a018 <usb_gadget_handle_interrupts+0x440>
34819be0:	e5932000 	ldr	r2, [r3]
34819be4:	e5922014 	ldr	r2, [r2, #20]
	u32 gintmsk = readl(&reg->gintmsk);
34819be8:	e5931000 	ldr	r1, [r3]
34819bec:	e5910018 	ldr	r0, [r1, #24]

	if (intr_status & gintmsk)
34819bf0:	e0100002 	ands	r0, r0, r2
34819bf4:	0a000105 	beq	3481a010 <usb_gadget_handle_interrupts+0x438>
	u32 usb_status, gintmsk;
	unsigned long flags;

	spin_lock_irqsave(&dev->lock, flags);

	intr_status = readl(&reg->gintsts);
34819bf8:	e5932000 	ldr	r2, [r3]
		return s3c_udc_irq(1, (void *)the_controller);
34819bfc:	e5934008 	ldr	r4, [r3, #8]
34819c00:	e5926014 	ldr	r6, [r2, #20]
		  "\n*** %s : GINTSTS=0x%x(on state %s), GINTMSK : 0x%x,"
		  "DAINT : 0x%x, DAINTMSK : 0x%x\n",
		  __func__, intr_status, state_names[dev->ep0state], gintmsk,
		  readl(&reg->daint), readl(&reg->daintmsk));

	if (!intr_status) {
34819c04:	e3560000 	cmp	r6, #0
34819c08:	0a0000ff 	beq	3481a00c <usb_gadget_handle_interrupts+0x434>
		spin_unlock_irqrestore(&dev->lock, flags);
		return IRQ_HANDLED;
	}

	if (intr_status & INT_ENUMDONE) {
34819c0c:	e3160a02 	tst	r6, #8192	; 0x2000
34819c10:	0a000009 	beq	34819c3c <usb_gadget_handle_interrupts+0x64>
		debug_cond(DEBUG_ISR, "\tSpeed Detection interrupt\n");

		writel(INT_ENUMDONE, &reg->gintsts);
34819c14:	e5933000 	ldr	r3, [r3]
34819c18:	e3a02a02 	mov	r2, #8192	; 0x2000
34819c1c:	e5832014 	str	r2, [r3, #20]
		usb_status = (readl(&reg->dsts) & 0x6);
34819c20:	e5933808 	ldr	r3, [r3, #2056]	; 0x808

		if (usb_status & (USB_FULL_30_60MHZ | USB_FULL_48MHZ)) {
34819c24:	e3130006 	tst	r3, #6
			debug_cond(DEBUG_ISR,
				   "\t\tFull Speed Detection\n");
			set_max_pktsize(dev, USB_SPEED_FULL);
34819c28:	11a00004 	movne	r0, r4
34819c2c:	13a01002 	movne	r1, #2

		} else {
			debug_cond(DEBUG_ISR,
				"\t\tHigh Speed Detection : 0x%x\n",
				usb_status);
			set_max_pktsize(dev, USB_SPEED_HIGH);
34819c30:	01a00004 	moveq	r0, r4
34819c34:	03a01003 	moveq	r1, #3
34819c38:	ebfffa35 	bl	34818514 <set_max_pktsize>
		}
	}

	if (intr_status & INT_EARLY_SUSPEND) {
34819c3c:	e3160b01 	tst	r6, #1024	; 0x400
34819c40:	0a000003 	beq	34819c54 <usb_gadget_handle_interrupts+0x7c>
		debug_cond(DEBUG_ISR, "\tEarly suspend interrupt\n");
		writel(INT_EARLY_SUSPEND, &reg->gintsts);
34819c44:	e59f33cc 	ldr	r3, [pc, #972]	; 3481a018 <usb_gadget_handle_interrupts+0x440>
34819c48:	e3a02b01 	mov	r2, #1024	; 0x400
34819c4c:	e5933000 	ldr	r3, [r3]
34819c50:	e5832014 	str	r2, [r3, #20]
	}

	if (intr_status & INT_SUSPEND) {
34819c54:	e3160b02 	tst	r6, #2048	; 0x800
34819c58:	0a000014 	beq	34819cb0 <usb_gadget_handle_interrupts+0xd8>
		usb_status = readl(&reg->dsts);
		debug_cond(DEBUG_ISR,
			"\tSuspend interrupt :(DSTS):0x%x\n", usb_status);
		writel(INT_SUSPEND, &reg->gintsts);
34819c5c:	e59f33b4 	ldr	r3, [pc, #948]	; 3481a018 <usb_gadget_handle_interrupts+0x440>
34819c60:	e3a02b02 	mov	r2, #2048	; 0x800
34819c64:	e5933000 	ldr	r3, [r3]
34819c68:	e5832014 	str	r2, [r3, #20]

		if (dev->gadget.speed != USB_SPEED_UNKNOWN
34819c6c:	e5943010 	ldr	r3, [r4, #16]
34819c70:	e3530000 	cmp	r3, #0
34819c74:	0a00000d 	beq	34819cb0 <usb_gadget_handle_interrupts+0xd8>
		    && dev->driver) {
34819c78:	e5943024 	ldr	r3, [r4, #36]	; 0x24
34819c7c:	e3530000 	cmp	r3, #0
34819c80:	0a00000a 	beq	34819cb0 <usb_gadget_handle_interrupts+0xd8>
			if (dev->driver->suspend)
34819c84:	e5933014 	ldr	r3, [r3, #20]
34819c88:	e3530000 	cmp	r3, #0
34819c8c:	0a000001 	beq	34819c98 <usb_gadget_handle_interrupts+0xc0>
				dev->driver->suspend(&dev->gadget);
34819c90:	e1a00004 	mov	r0, r4
34819c94:	e12fff33 	blx	r3

			/* HACK to let gadget detect disconnected state */
			if (dev->driver->disconnect) {
34819c98:	e5943024 	ldr	r3, [r4, #36]	; 0x24
34819c9c:	e5933010 	ldr	r3, [r3, #16]
34819ca0:	e3530000 	cmp	r3, #0
34819ca4:	0a000001 	beq	34819cb0 <usb_gadget_handle_interrupts+0xd8>
				spin_unlock_irqrestore(&dev->lock, flags);
				dev->driver->disconnect(&dev->gadget);
34819ca8:	e1a00004 	mov	r0, r4
34819cac:	e12fff33 	blx	r3
				spin_lock_irqsave(&dev->lock, flags);
			}
		}
	}

	if (intr_status & INT_RESUME) {
34819cb0:	e3560000 	cmp	r6, #0
34819cb4:	aa00000e 	bge	34819cf4 <usb_gadget_handle_interrupts+0x11c>
		debug_cond(DEBUG_ISR, "\tResume interrupt\n");
		writel(INT_RESUME, &reg->gintsts);
34819cb8:	e59f3358 	ldr	r3, [pc, #856]	; 3481a018 <usb_gadget_handle_interrupts+0x440>
34819cbc:	e3a02102 	mov	r2, #-2147483648	; 0x80000000
34819cc0:	e5933000 	ldr	r3, [r3]
34819cc4:	e5832014 	str	r2, [r3, #20]

		if (dev->gadget.speed != USB_SPEED_UNKNOWN
34819cc8:	e5943010 	ldr	r3, [r4, #16]
34819ccc:	e3530000 	cmp	r3, #0
34819cd0:	0a000007 	beq	34819cf4 <usb_gadget_handle_interrupts+0x11c>
		    && dev->driver
34819cd4:	e5943024 	ldr	r3, [r4, #36]	; 0x24
34819cd8:	e3530000 	cmp	r3, #0
34819cdc:	0a000004 	beq	34819cf4 <usb_gadget_handle_interrupts+0x11c>
		    && dev->driver->resume) {
34819ce0:	e5933018 	ldr	r3, [r3, #24]
34819ce4:	e3530000 	cmp	r3, #0
34819ce8:	0a000001 	beq	34819cf4 <usb_gadget_handle_interrupts+0x11c>

			dev->driver->resume(&dev->gadget);
34819cec:	e1a00004 	mov	r0, r4
34819cf0:	e12fff33 	blx	r3
		}
	}

	if (intr_status & INT_RESET) {
34819cf4:	e3160a01 	tst	r6, #4096	; 0x1000
34819cf8:	0a000014 	beq	34819d50 <usb_gadget_handle_interrupts+0x178>
		usb_status = readl(&reg->gotgctl);
34819cfc:	e59f3314 	ldr	r3, [pc, #788]	; 3481a018 <usb_gadget_handle_interrupts+0x440>
34819d00:	e5932000 	ldr	r2, [r3]
34819d04:	e5922000 	ldr	r2, [r2]
		debug_cond(DEBUG_ISR,
			"\tReset interrupt - (GOTGCTL):0x%x\n", usb_status);
		writel(INT_RESET, &reg->gintsts);
34819d08:	e5933000 	ldr	r3, [r3]
34819d0c:	e3a01a01 	mov	r1, #4096	; 0x1000
34819d10:	e5831014 	str	r1, [r3, #20]

		if ((usb_status & 0xc0000) == (0x3 << 18)) {
34819d14:	e2023703 	and	r3, r2, #786432	; 0xc0000
34819d18:	e3530703 	cmp	r3, #786432	; 0xc0000
34819d1c:	e59f52f8 	ldr	r5, [pc, #760]	; 3481a01c <usb_gadget_handle_interrupts+0x444>
34819d20:	1a000008 	bne	34819d48 <usb_gadget_handle_interrupts+0x170>
			if (reset_available) {
34819d24:	e595300c 	ldr	r3, [r5, #12]
34819d28:	e3530000 	cmp	r3, #0
34819d2c:	0a000005 	beq	34819d48 <usb_gadget_handle_interrupts+0x170>
				debug_cond(DEBUG_ISR,
					"\t\tOTG core got reset (%d)!!\n",
					reset_available);
				reconfig_usbd();
34819d30:	ebfffa25 	bl	348185cc <reconfig_usbd>
				dev->ep0state = WAIT_FOR_SETUP;
34819d34:	e3a03000 	mov	r3, #0
34819d38:	e5843054 	str	r3, [r4, #84]	; 0x54
				reset_available = 0;
34819d3c:	e585300c 	str	r3, [r5, #12]
				s3c_udc_pre_setup();
34819d40:	ebfffc00 	bl	34818d48 <s3c_udc_pre_setup>
34819d44:	ea000001 	b	34819d50 <usb_gadget_handle_interrupts+0x178>
			} else
				reset_available = 1;

		} else {
			reset_available = 1;
34819d48:	e3a03001 	mov	r3, #1
34819d4c:	e585300c 	str	r3, [r5, #12]
			debug_cond(DEBUG_ISR,
				   "\t\tRESET handling skipped\n");
		}
	}

	if (intr_status & INT_IN_EP)
34819d50:	e3160701 	tst	r6, #262144	; 0x40000
34819d54:	0a00007a 	beq	34819f44 <usb_gadget_handle_interrupts+0x36c>
static void process_ep_in_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;

	ep_intr = readl(&reg->daint);
34819d58:	e59f72b8 	ldr	r7, [pc, #696]	; 3481a018 <usb_gadget_handle_interrupts+0x440>
34819d5c:	e5973000 	ldr	r3, [r7]
34819d60:	e5939818 	ldr	r9, [r3, #2072]	; 0x818
}

static void process_ep_in_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;
34819d64:	e3a05000 	mov	r5, #0

	ep_intr = readl(&reg->daint);
	debug_cond(DEBUG_IN_EP,
		"*** %s: EP In interrupt : DAINT = 0x%x\n", __func__, ep_intr);

	ep_intr &= DAINT_MASK;
34819d68:	e6ff9079 	uxth	r9, r9
34819d6c:	e58d6004 	str	r6, [sp, #4]
34819d70:	ea000070 	b	34819f38 <usb_gadget_handle_interrupts+0x360>

	while (ep_intr) {
		if (ep_intr & DAINT_IN_EP_INT(1)) {
34819d74:	e3190001 	tst	r9, #1
34819d78:	0a00006b 	beq	34819f2c <usb_gadget_handle_interrupts+0x354>
			ep_intr_status = readl(&reg->in_endp[ep_num].diepint);
34819d7c:	e5973000 	ldr	r3, [r7]
34819d80:	e1a02285 	lsl	r2, r5, #5
34819d84:	e0833002 	add	r3, r3, r2
34819d88:	e5933908 	ldr	r3, [r3, #2312]	; 0x908
			debug_cond(DEBUG_IN_EP,
				   "\tEP%d-IN : DIEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->in_endp[ep_num].diepint);
34819d8c:	e2822c09 	add	r2, r2, #2304	; 0x900
34819d90:	e5971000 	ldr	r1, [r7]
34819d94:	e2822008 	add	r2, r2, #8

			if (ep_intr_status & TRANSFER_DONE) {
34819d98:	e3130001 	tst	r3, #1
			debug_cond(DEBUG_IN_EP,
				   "\tEP%d-IN : DIEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->in_endp[ep_num].diepint);
34819d9c:	e7813002 	str	r3, [r1, r2]

			if (ep_intr_status & TRANSFER_DONE) {
34819da0:	0a000061 	beq	34819f2c <usb_gadget_handle_interrupts+0x354>
	struct s3c_ep *ep = &dev->ep[ep_num];
	struct s3c_request *req;
	u32 ep_tsr = 0, xfer_size = 0, is_short = 0;
	u32 last;

	if (dev->ep0state == WAIT_FOR_NULL_COMPLETE) {
34819da4:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34819da8:	e3530008 	cmp	r3, #8
34819dac:	1a000003 	bne	34819dc0 <usb_gadget_handle_interrupts+0x1e8>
		dev->ep0state = WAIT_FOR_OUT_COMPLETE;
34819db0:	e3a00006 	mov	r0, #6
34819db4:	e5840054 	str	r0, [r4, #84]	; 0x54
		s3c_ep0_complete_out();
34819db8:	ebfffab3 	bl	3481888c <s3c_ep0_complete_out>
34819dbc:	ea00003a 	b	34819eac <usb_gadget_handle_interrupts+0x2d4>
		return;
	}

	if (list_empty(&ep->queue)) {
34819dc0:	e1a06305 	lsl	r6, r5, #6
 * list_empty - tests whether a list is empty
 * @head: the list to test.
 */
static inline int list_empty(const struct list_head *head)
{
	return head->next == head;
34819dc4:	e0843006 	add	r3, r4, r6
34819dc8:	e286b078 	add	fp, r6, #120	; 0x78
34819dcc:	e5933078 	ldr	r3, [r3, #120]	; 0x78
34819dd0:	e084b00b 	add	fp, r4, fp
34819dd4:	e153000b 	cmp	r3, fp
34819dd8:	0a000033 	beq	34819eac <usb_gadget_handle_interrupts+0x2d4>
		setdma_rx(ep, req);
}

static void complete_tx(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
34819ddc:	e2866058 	add	r6, r6, #88	; 0x58
34819de0:	e0846006 	add	r6, r4, r6
			__func__, ep_num);
		return;

	}

	req = list_entry(ep->queue.next, struct s3c_request, queue);
34819de4:	e2431028 	sub	r1, r3, #40	; 0x28

	ep_tsr = readl(&reg->in_endp[ep_num].dieptsiz);

	xfer_size = ep->len;
	is_short = (xfer_size < ep->ep.maxpacket);
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34819de8:	e513a004 	ldr	sl, [r3, #-4]
34819dec:	e5132024 	ldr	r2, [r3, #-36]	; 0x24

	req = list_entry(ep->queue.next, struct s3c_request, queue);

	ep_tsr = readl(&reg->in_endp[ep_num].dieptsiz);

	xfer_size = ep->len;
34819df0:	e0840305 	add	r0, r4, r5, lsl #6
	is_short = (xfer_size < ep->ep.maxpacket);
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34819df4:	e5900084 	ldr	r0, [r0, #132]	; 0x84
34819df8:	e06ac002 	rsb	ip, sl, r2
34819dfc:	e15c0000 	cmp	ip, r0
34819e00:	908aa00c 	addls	sl, sl, ip
34819e04:	808aa000 	addhi	sl, sl, r0
		"%s: TX DMA done : ep = %d, tx bytes = %d/%d, "
		"is_short = %d, DIEPTSIZ = 0x%x, remained bytes = %d\n",
		__func__, ep_num, req->req.actual, req->req.length,
		is_short, ep_tsr, xfer_size);

	if (ep_num == 0) {
34819e08:	e3550000 	cmp	r5, #0

	ep_tsr = readl(&reg->in_endp[ep_num].dieptsiz);

	xfer_size = ep->len;
	is_short = (xfer_size < ep->ep.maxpacket);
	req->req.actual += min(xfer_size, req->req.length - req->req.actual);
34819e0c:	e503a004 	str	sl, [r3, #-4]
		"%s: TX DMA done : ep = %d, tx bytes = %d/%d, "
		"is_short = %d, DIEPTSIZ = 0x%x, remained bytes = %d\n",
		__func__, ep_num, req->req.actual, req->req.length,
		is_short, ep_tsr, xfer_size);

	if (ep_num == 0) {
34819e10:	1a000018 	bne	34819e78 <usb_gadget_handle_interrupts+0x2a0>
		if (dev->ep0state == DATA_STATE_XMIT) {
34819e14:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34819e18:	e3530001 	cmp	r3, #1
34819e1c:	1a000005 	bne	34819e38 <usb_gadget_handle_interrupts+0x260>
			debug_cond(DEBUG_IN_EP,
				"%s: ep_num = %d, ep0stat =="
				"DATA_STATE_XMIT\n",
				__func__, ep_num);
			last = write_fifo_ep0(ep, req);
34819e20:	e1a00006 	mov	r0, r6
34819e24:	ebfffc31 	bl	34818ef0 <write_fifo_ep0>
			if (last)
34819e28:	e3500000 	cmp	r0, #0
				dev->ep0state = WAIT_FOR_COMPLETE;
34819e2c:	13a00005 	movne	r0, #5
34819e30:	15840054 	strne	r0, [r4, #84]	; 0x54
34819e34:	ea00001e 	b	34819eb4 <usb_gadget_handle_interrupts+0x2dc>
		} else if (dev->ep0state == WAIT_FOR_IN_COMPLETE) {
34819e38:	e3530007 	cmp	r3, #7
34819e3c:	1a000004 	bne	34819e54 <usb_gadget_handle_interrupts+0x27c>
			debug_cond(DEBUG_IN_EP,
				"%s: ep_num = %d, completing request\n",
				__func__, ep_num);
			done(ep, req, 0);
34819e40:	e1a00006 	mov	r0, r6
34819e44:	e1a02005 	mov	r2, r5
34819e48:	ebfffa41 	bl	34818754 <done>
			dev->ep0state = WAIT_FOR_SETUP;
34819e4c:	e5845054 	str	r5, [r4, #84]	; 0x54
34819e50:	ea000017 	b	34819eb4 <usb_gadget_handle_interrupts+0x2dc>
		} else if (dev->ep0state == WAIT_FOR_COMPLETE) {
34819e54:	e3530005 	cmp	r3, #5
34819e58:	1a000015 	bne	34819eb4 <usb_gadget_handle_interrupts+0x2dc>
			debug_cond(DEBUG_IN_EP,
				"%s: ep_num = %d, completing request\n",
				__func__, ep_num);
			done(ep, req, 0);
34819e5c:	e1a00006 	mov	r0, r6
34819e60:	e1a02005 	mov	r2, r5
34819e64:	ebfffa3a 	bl	34818754 <done>
			dev->ep0state = WAIT_FOR_OUT_COMPLETE;
34819e68:	e3a03006 	mov	r3, #6
34819e6c:	e5843054 	str	r3, [r4, #84]	; 0x54
			s3c_ep0_complete_out();
34819e70:	ebfffa85 	bl	3481888c <s3c_ep0_complete_out>
34819e74:	ea00000e 	b	34819eb4 <usb_gadget_handle_interrupts+0x2dc>
				__func__, ep_num);
		}
		return;
	}

	if (req->req.actual == req->req.length)
34819e78:	e15a0002 	cmp	sl, r2
34819e7c:	1a000002 	bne	34819e8c <usb_gadget_handle_interrupts+0x2b4>
		done(ep, req, 0);
34819e80:	e1a00006 	mov	r0, r6
34819e84:	e3a02000 	mov	r2, #0
34819e88:	ebfffa31 	bl	34818754 <done>
34819e8c:	e0843305 	add	r3, r4, r5, lsl #6
34819e90:	e5931078 	ldr	r1, [r3, #120]	; 0x78

	if (!list_empty(&ep->queue)) {
34819e94:	e151000b 	cmp	r1, fp
34819e98:	0a000023 	beq	34819f2c <usb_gadget_handle_interrupts+0x354>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request start...\n", __func__);
		setdma_tx(ep, req);
34819e9c:	e1a00006 	mov	r0, r6
34819ea0:	e2411028 	sub	r1, r1, #40	; 0x28
34819ea4:	ebfffbc6 	bl	34818dc4 <setdma_tx>
34819ea8:	ea00001f 	b	34819f2c <usb_gadget_handle_interrupts+0x354>
			writel(ep_intr_status, &reg->in_endp[ep_num].diepint);

			if (ep_intr_status & TRANSFER_DONE) {
				complete_tx(dev, ep_num);

				if (ep_num == 0) {
34819eac:	e3550000 	cmp	r5, #0
34819eb0:	1a00001d 	bne	34819f2c <usb_gadget_handle_interrupts+0x354>
					if (dev->ep0state ==
34819eb4:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34819eb8:	e3530007 	cmp	r3, #7
					    WAIT_FOR_IN_COMPLETE)
						dev->ep0state = WAIT_FOR_SETUP;
34819ebc:	03a0a000 	moveq	sl, #0
34819ec0:	0584a054 	streq	sl, [r4, #84]	; 0x54

					if (dev->ep0state == WAIT_FOR_SETUP)
34819ec4:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34819ec8:	e3530000 	cmp	r3, #0
34819ecc:	1a000000 	bne	34819ed4 <usb_gadget_handle_interrupts+0x2fc>
						s3c_udc_pre_setup();
34819ed0:	ebfffb9c 	bl	34818d48 <s3c_udc_pre_setup>

					/* continue transfer after
					   set_clear_halt for DMA mode */
					if (clear_feature_flag == 1) {
34819ed4:	e5973020 	ldr	r3, [r7, #32]
34819ed8:	e3530001 	cmp	r3, #1
34819edc:	1a000012 	bne	34819f2c <usb_gadget_handle_interrupts+0x354>
	}
}

static inline void s3c_udc_check_tx_queue(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
34819ee0:	e5d7001c 	ldrb	r0, [r7, #28]
34819ee4:	e1a00300 	lsl	r0, r0, #6
34819ee8:	e0843000 	add	r3, r4, r0
34819eec:	e5931078 	ldr	r1, [r3, #120]	; 0x78
	struct s3c_request *req;

	debug_cond(DEBUG_IN_EP,
		"%s: Check queue, ep_num = %d\n", __func__, ep_num);

	if (!list_empty(&ep->queue)) {
34819ef0:	e2802078 	add	r2, r0, #120	; 0x78
34819ef4:	e0842002 	add	r2, r4, r2
34819ef8:	e1510002 	cmp	r1, r2
34819efc:	0a000008 	beq	34819f24 <usb_gadget_handle_interrupts+0x34c>
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request(0x%p) start...\n",
			__func__, req);

		if (ep_is_in(ep))
34819f00:	e1d338dd 	ldrsb	r3, [r3, #141]	; 0x8d
	}
}

static inline void s3c_udc_check_tx_queue(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
34819f04:	e2800058 	add	r0, r0, #88	; 0x58
		req = list_entry(ep->queue.next, struct s3c_request, queue);
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request(0x%p) start...\n",
			__func__, req);

		if (ep_is_in(ep))
34819f08:	e3530000 	cmp	r3, #0
	}
}

static inline void s3c_udc_check_tx_queue(struct s3c_udc *dev, u8 ep_num)
{
	struct s3c_ep *ep = &dev->ep[ep_num];
34819f0c:	e0840000 	add	r0, r4, r0

	debug_cond(DEBUG_IN_EP,
		"%s: Check queue, ep_num = %d\n", __func__, ep_num);

	if (!list_empty(&ep->queue)) {
		req = list_entry(ep->queue.next, struct s3c_request, queue);
34819f10:	e2411028 	sub	r1, r1, #40	; 0x28
		debug_cond(DEBUG_IN_EP,
			"%s: Next Tx request(0x%p) start...\n",
			__func__, req);

		if (ep_is_in(ep))
34819f14:	aa000001 	bge	34819f20 <usb_gadget_handle_interrupts+0x348>
			setdma_tx(ep, req);
34819f18:	ebfffba9 	bl	34818dc4 <setdma_tx>
34819f1c:	ea000000 	b	34819f24 <usb_gadget_handle_interrupts+0x34c>
		else
			setdma_rx(ep, req);
34819f20:	ebfffa6b 	bl	348188d4 <setdma_rx>
					/* continue transfer after
					   set_clear_halt for DMA mode */
					if (clear_feature_flag == 1) {
						s3c_udc_check_tx_queue(dev,
							clear_feature_num);
						clear_feature_flag = 0;
34819f24:	e3a00000 	mov	r0, #0
34819f28:	e5870020 	str	r0, [r7, #32]
					}
				}
			}
		}
		ep_num++;
34819f2c:	e2855001 	add	r5, r5, #1
34819f30:	e6ef5075 	uxtb	r5, r5
		ep_intr >>= 1;
34819f34:	e1a090a9 	lsr	r9, r9, #1
	debug_cond(DEBUG_IN_EP,
		"*** %s: EP In interrupt : DAINT = 0x%x\n", __func__, ep_intr);

	ep_intr &= DAINT_MASK;

	while (ep_intr) {
34819f38:	e3590000 	cmp	r9, #0
34819f3c:	1affff8c 	bne	34819d74 <usb_gadget_handle_interrupts+0x19c>
34819f40:	e59d6004 	ldr	r6, [sp, #4]
	}

	if (intr_status & INT_IN_EP)
		process_ep_in_intr(dev);

	if (intr_status & INT_OUT_EP)
34819f44:	e3160702 	tst	r6, #524288	; 0x80000
34819f48:	0a00002f 	beq	3481a00c <usb_gadget_handle_interrupts+0x434>
static void process_ep_out_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;

	ep_intr = readl(&reg->daint);
34819f4c:	e59fa0c4 	ldr	sl, [pc, #196]	; 3481a018 <usb_gadget_handle_interrupts+0x440>
34819f50:	e59a3000 	ldr	r3, [sl]
34819f54:	e5936818 	ldr	r6, [r3, #2072]	; 0x818
}

static void process_ep_out_intr(struct s3c_udc *dev)
{
	u32 ep_intr, ep_intr_status;
	u8 ep_num = 0;
34819f58:	e3a05000 	mov	r5, #0
	ep_intr = readl(&reg->daint);
	debug_cond(DEBUG_OUT_EP != 0,
		   "*** %s: EP OUT interrupt : DAINT = 0x%x\n",
		   __func__, ep_intr);

	ep_intr = (ep_intr >> DAINT_OUT_BIT) & DAINT_MASK;
34819f5c:	e1a06826 	lsr	r6, r6, #16
34819f60:	ea000027 	b	3481a004 <usb_gadget_handle_interrupts+0x42c>

	while (ep_intr) {
		if (ep_intr & 0x1) {
34819f64:	e3160001 	tst	r6, #1
34819f68:	0a000022 	beq	34819ff8 <usb_gadget_handle_interrupts+0x420>
			ep_intr_status = readl(&reg->out_endp[ep_num].doepint);
34819f6c:	e59a2000 	ldr	r2, [sl]
34819f70:	e1a03285 	lsl	r3, r5, #5
34819f74:	e0822003 	add	r2, r2, r3
34819f78:	e5927b08 	ldr	r7, [r2, #2824]	; 0xb08
			debug_cond(DEBUG_OUT_EP != 0,
				   "\tEP%d-OUT : DOEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->out_endp[ep_num].doepint);
34819f7c:	e2833c0b 	add	r3, r3, #2816	; 0xb00
34819f80:	e59a2000 	ldr	r2, [sl]
34819f84:	e2833008 	add	r3, r3, #8

			if (ep_num == 0) {
34819f88:	e3550000 	cmp	r5, #0
			debug_cond(DEBUG_OUT_EP != 0,
				   "\tEP%d-OUT : DOEPINT = 0x%x\n",
				   ep_num, ep_intr_status);

			/* Interrupt Clear */
			writel(ep_intr_status, &reg->out_endp[ep_num].doepint);
34819f8c:	e7827003 	str	r7, [r2, r3]
34819f90:	e2073001 	and	r3, r7, #1

			if (ep_num == 0) {
34819f94:	1a000012 	bne	34819fe4 <usb_gadget_handle_interrupts+0x40c>
				if (ep_intr_status & TRANSFER_DONE) {
34819f98:	e3530000 	cmp	r3, #0
34819f9c:	0a000008 	beq	34819fc4 <usb_gadget_handle_interrupts+0x3ec>
					if (dev->ep0state !=
34819fa0:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34819fa4:	e3530006 	cmp	r3, #6
34819fa8:	0a000003 	beq	34819fbc <usb_gadget_handle_interrupts+0x3e4>
					    WAIT_FOR_OUT_COMPLETE)
						complete_rx(dev, ep_num);
34819fac:	e1a00004 	mov	r0, r4
34819fb0:	e1a01005 	mov	r1, r5
34819fb4:	ebfffaa1 	bl	34818a40 <complete_rx>
34819fb8:	ea000001 	b	34819fc4 <usb_gadget_handle_interrupts+0x3ec>
					else {
						dev->ep0state = WAIT_FOR_SETUP;
34819fbc:	e5845054 	str	r5, [r4, #84]	; 0x54
						s3c_udc_pre_setup();
34819fc0:	ebfffb60 	bl	34818d48 <s3c_udc_pre_setup>
					}
				}

				if (ep_intr_status &
34819fc4:	e3170008 	tst	r7, #8
34819fc8:	0a00000a 	beq	34819ff8 <usb_gadget_handle_interrupts+0x420>
/*
 * handle ep0 interrupt
 */
static void s3c_handle_ep0(struct s3c_udc *dev)
{
	if (dev->ep0state == WAIT_FOR_SETUP) {
34819fcc:	e5943054 	ldr	r3, [r4, #84]	; 0x54
34819fd0:	e3530000 	cmp	r3, #0
34819fd4:	1a000007 	bne	34819ff8 <usb_gadget_handle_interrupts+0x420>
		debug_cond(DEBUG_OUT_EP != 0,
			   "%s: WAIT_FOR_SETUP\n", __func__);
		s3c_ep0_setup(dev);
34819fd8:	e1a00004 	mov	r0, r4
34819fdc:	ebfffd8f 	bl	34819620 <s3c_ep0_setup>
34819fe0:	ea000004 	b	34819ff8 <usb_gadget_handle_interrupts+0x420>
					debug_cond(DEBUG_OUT_EP != 0,
						   "SETUP packet arrived\n");
					s3c_handle_ep0(dev);
				}
			} else {
				if (ep_intr_status & TRANSFER_DONE)
34819fe4:	e3530000 	cmp	r3, #0
34819fe8:	0a000002 	beq	34819ff8 <usb_gadget_handle_interrupts+0x420>
					complete_rx(dev, ep_num);
34819fec:	e1a00004 	mov	r0, r4
34819ff0:	e1a01005 	mov	r1, r5
34819ff4:	ebfffa91 	bl	34818a40 <complete_rx>
			}
		}
		ep_num++;
34819ff8:	e2855001 	add	r5, r5, #1
34819ffc:	e6ef5075 	uxtb	r5, r5
		ep_intr >>= 1;
3481a000:	e1a060a6 	lsr	r6, r6, #1
		   "*** %s: EP OUT interrupt : DAINT = 0x%x\n",
		   __func__, ep_intr);

	ep_intr = (ep_intr >> DAINT_OUT_BIT) & DAINT_MASK;

	while (ep_intr) {
3481a004:	e3560000 	cmp	r6, #0
3481a008:	1affffd5 	bne	34819f64 <usb_gadget_handle_interrupts+0x38c>
3481a00c:	e3a00001 	mov	r0, #1
	return 0;
}
3481a010:	e28dd010 	add	sp, sp, #16
3481a014:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481a018:	3482bc18 	.word	0x3482bc18
3481a01c:	348292e8 	.word	0x348292e8

3481a020 <cyg_crc16>:
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
};

uint16_t
cyg_crc16(unsigned char *buf, int len)
{
3481a020:	e1a03000 	mov	r3, r0
    int i;
    uint16_t cksum;

    cksum = 0;
3481a024:	e3a00000 	mov	r0, #0
    0x6e17, 0x7e36, 0x4e55, 0x5e74, 0x2e93, 0x3eb2, 0x0ed1, 0x1ef0,
};

uint16_t
cyg_crc16(unsigned char *buf, int len)
{
3481a028:	e92d4010 	push	{r4, lr}
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
3481a02c:	e1a02000 	mov	r2, r0
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
3481a030:	e59fc028 	ldr	ip, [pc, #40]	; 3481a060 <cyg_crc16+0x40>
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
3481a034:	ea000006 	b	3481a054 <cyg_crc16+0x34>
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
3481a038:	e7d34002 	ldrb	r4, [r3, r2]
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
3481a03c:	e2822001 	add	r2, r2, #1
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
3481a040:	e0244420 	eor	r4, r4, r0, lsr #8
3481a044:	e1a04084 	lsl	r4, r4, #1
3481a048:	e19c40b4 	ldrh	r4, [ip, r4]
3481a04c:	e0240400 	eor	r0, r4, r0, lsl #8
3481a050:	e6ff0070 	uxth	r0, r0
{
    int i;
    uint16_t cksum;

    cksum = 0;
    for (i = 0;  i < len;  i++) {
3481a054:	e1520001 	cmp	r2, r1
3481a058:	bafffff6 	blt	3481a038 <cyg_crc16+0x18>
	cksum = crc16_tab[((cksum>>8) ^ *buf++) & 0xFF] ^ (cksum << 8);
    }
    return cksum;
}
3481a05c:	e8bd8010 	pop	{r4, pc}
3481a060:	348215d4 	.word	0x348215d4

3481a064 <crc32_no_comp>:
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
3481a064:	e211c003 	ands	ip, r1, #3
3481a068:	13a0c001 	movne	ip, #1
3481a06c:	e3520000 	cmp	r2, #0
3481a070:	03a0c000 	moveq	ip, #0
3481a074:	120cc001 	andne	ip, ip, #1
3481a078:	e35c0000 	cmp	ip, #0

/* No ones complement version. JFFS2 (and other things ?)
 * don't use ones compliment in their CRC calculations.
 */
uint32_t ZEXPORT crc32_no_comp(uint32_t crc, const Bytef *buf, uInt len)
{
3481a07c:	e92d4070 	push	{r4, r5, r6, lr}
    const uint32_t *tab = crc_table;
    const uint32_t *b =(const uint32_t *)buf;
3481a080:	e1a03001 	mov	r3, r1
    if (crc_table_empty)
      make_crc_table();
#endif
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
3481a084:	0a00000a 	beq	3481a0b4 <crc32_no_comp+0x50>
	 uint8_t *p = (uint8_t *)b;
	 do {
	      DO_CRC(*p++);
3481a088:	e59f30b8 	ldr	r3, [pc, #184]	; 3481a148 <crc32_no_comp+0xe4>
3481a08c:	e4d1c001 	ldrb	ip, [r1], #1
	 } while ((--len) && ((long)p)&3);
3481a090:	e2522001 	subs	r2, r2, #1
    crc = cpu_to_le32(crc);
    /* Align it */
    if (((long)b) & 3 && len) {
	 uint8_t *p = (uint8_t *)b;
	 do {
	      DO_CRC(*p++);
3481a094:	e020c00c 	eor	ip, r0, ip
3481a098:	e20cc0ff 	and	ip, ip, #255	; 0xff
3481a09c:	e793c10c 	ldr	ip, [r3, ip, lsl #2]
3481a0a0:	e02c0420 	eor	r0, ip, r0, lsr #8
	 } while ((--len) && ((long)p)&3);
3481a0a4:	0a000001 	beq	3481a0b0 <crc32_no_comp+0x4c>
3481a0a8:	e3110003 	tst	r1, #3
3481a0ac:	1afffff6 	bne	3481a08c <crc32_no_comp+0x28>
	 b = (uint32_t *)p;
3481a0b0:	e1a03001 	mov	r3, r1
    }

    rem_len = len & 3;
3481a0b4:	e2025003 	and	r5, r2, #3
    len = len >> 2;
3481a0b8:	e1a02122 	lsr	r2, r2, #2
    for (--b; len; --len) {
3481a0bc:	e2431004 	sub	r1, r3, #4
	 } while ((--len) && ((long)p)&3);
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
3481a0c0:	e1a04002 	mov	r4, r2
    for (--b; len; --len) {
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
	 DO_CRC(0);
3481a0c4:	e59fc07c 	ldr	ip, [pc, #124]	; 3481a148 <crc32_no_comp+0xe4>
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
3481a0c8:	ea00000e 	b	3481a108 <crc32_no_comp+0xa4>
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
3481a0cc:	e4936004 	ldr	r6, [r3], #4
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
3481a0d0:	e2444001 	sub	r4, r4, #1
	 /* load data 32 bits wide, xor data 32 bits wide. */
	 crc ^= *++b; /* use pre increment for speed */
3481a0d4:	e0200006 	eor	r0, r0, r6
	 DO_CRC(0);
3481a0d8:	e20060ff 	and	r6, r0, #255	; 0xff
3481a0dc:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
3481a0e0:	e0260420 	eor	r0, r6, r0, lsr #8
	 DO_CRC(0);
3481a0e4:	e20060ff 	and	r6, r0, #255	; 0xff
3481a0e8:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
3481a0ec:	e0260420 	eor	r0, r6, r0, lsr #8
	 DO_CRC(0);
3481a0f0:	e20060ff 	and	r6, r0, #255	; 0xff
3481a0f4:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
3481a0f8:	e0260420 	eor	r0, r6, r0, lsr #8
	 DO_CRC(0);
3481a0fc:	e20060ff 	and	r6, r0, #255	; 0xff
3481a100:	e79c6106 	ldr	r6, [ip, r6, lsl #2]
3481a104:	e0260420 	eor	r0, r6, r0, lsr #8
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
3481a108:	e3540000 	cmp	r4, #0
3481a10c:	1affffee 	bne	3481a0cc <crc32_no_comp+0x68>
	 DO_CRC(0);
	 DO_CRC(0);
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
3481a110:	e3550000 	cmp	r5, #0
	 b = (uint32_t *)p;
    }

    rem_len = len & 3;
    len = len >> 2;
    for (--b; len; --len) {
3481a114:	e0812102 	add	r2, r1, r2, lsl #2
	 DO_CRC(0);
	 DO_CRC(0);
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
3481a118:	08bd8070 	popeq	{r4, r5, r6, pc}
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
3481a11c:	e59f1024 	ldr	r1, [pc, #36]	; 3481a148 <crc32_no_comp+0xe4>
	 DO_CRC(0);
    }
    len = rem_len;
    /* And the last few bytes */
    if (len) {
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
3481a120:	e2822003 	add	r2, r2, #3
3481a124:	e1a03005 	mov	r3, r5
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
3481a128:	e5f2c001 	ldrb	ip, [r2, #1]!
	 } while (--len);
3481a12c:	e2533001 	subs	r3, r3, #1
    len = rem_len;
    /* And the last few bytes */
    if (len) {
	 uint8_t *p = (uint8_t *)(b + 1) - 1;
	 do {
	      DO_CRC(*++p); /* use pre increment for speed */
3481a130:	e020c00c 	eor	ip, r0, ip
3481a134:	e20cc0ff 	and	ip, ip, #255	; 0xff
3481a138:	e791c10c 	ldr	ip, [r1, ip, lsl #2]
3481a13c:	e02c0420 	eor	r0, ip, r0, lsr #8
	 } while (--len);
3481a140:	1afffff8 	bne	3481a128 <crc32_no_comp+0xc4>
    }

    return le32_to_cpu(crc);
}
3481a144:	e8bd8070 	pop	{r4, r5, r6, pc}
3481a148:	348217d4 	.word	0x348217d4

3481a14c <crc32>:
#undef DO_CRC

uint32_t ZEXPORT crc32 (uint32_t crc, const Bytef *p, uInt len)
{
3481a14c:	e92d4008 	push	{r3, lr}
     return crc32_no_comp(crc ^ 0xffffffffL, p, len) ^ 0xffffffffL;
3481a150:	e1e00000 	mvn	r0, r0
3481a154:	ebffffc2 	bl	3481a064 <crc32_no_comp>
}
3481a158:	e1e00000 	mvn	r0, r0
3481a15c:	e8bd8008 	pop	{r3, pc}

3481a160 <crc32_wd>:
		crc = crc32 (crc, curr, chunk);
		curr += chunk;
		WATCHDOG_RESET ();
	}
#else
	crc = crc32 (crc, buf, len);
3481a160:	eafffff9 	b	3481a14c <crc32>

3481a164 <crc7>:

extern const u8 crc7_syndrome_table[256];

static inline u8 crc7_byte(u8 crc, u8 data)
{
	return crc7_syndrome_table[(crc << 1) ^ data];
3481a164:	e59f301c 	ldr	r3, [pc, #28]	; 3481a188 <crc7+0x24>
 *
 * Returns the updated CRC7 value.
 */
u8 crc7(u8 crc, const u8 *buffer, size_t len)
{
	while (len--)
3481a168:	ea000003 	b	3481a17c <crc7+0x18>
		crc = crc7_byte(crc, *buffer++);
3481a16c:	e4d1c001 	ldrb	ip, [r1], #1
3481a170:	e2422001 	sub	r2, r2, #1
3481a174:	e02c0080 	eor	r0, ip, r0, lsl #1
3481a178:	e7d30000 	ldrb	r0, [r3, r0]
 *
 * Returns the updated CRC7 value.
 */
u8 crc7(u8 crc, const u8 *buffer, size_t len)
{
	while (len--)
3481a17c:	e3520000 	cmp	r2, #0
3481a180:	1afffff9 	bne	3481a16c <crc7+0x8>
		crc = crc7_byte(crc, *buffer++);
	return crc;
}
3481a184:	e12fff1e 	bx	lr
3481a188:	34821bd4 	.word	0x34821bd4

3481a18c <display_options>:
#include <version.h>
#include <linux/ctype.h>
#include <asm/io.h>

int display_options (void)
{
3481a18c:	e92d4008 	push	{r3, lr}
#if defined(BUILD_TAG)
	printf ("\n\n%s, Build: %s\n\n", version_string, BUILD_TAG);
#else
	printf ("\n\n%s\n\n", version_string);
3481a190:	e59f100c 	ldr	r1, [pc, #12]	; 3481a1a4 <display_options+0x18>
3481a194:	e59f000c 	ldr	r0, [pc, #12]	; 3481a1a8 <display_options+0x1c>
3481a198:	ebffbbf1 	bl	34809164 <printf>
#endif
	return 0;
}
3481a19c:	e3a00000 	mov	r0, #0
3481a1a0:	e8bd8008 	pop	{r3, pc}
3481a1a4:	34820238 	.word	0x34820238
3481a1a8:	3482286c 	.word	0x3482286c

3481a1ac <print_size>:
 * print sizes as "xxx KiB", "xxx.y KiB", "xxx MiB", "xxx.y MiB",
 * xxx GiB, xxx.y GiB, etc as needed; allow for optional trailing string
 * (like "\n")
 */
void print_size(unsigned long long size, const char *s)
{
3481a1ac:	e92d46f7 	push	{r0, r1, r2, r4, r5, r6, r7, r9, sl, lr}
3481a1b0:	e1a04000 	mov	r4, r0
3481a1b4:	e1a05001 	mov	r5, r1
3481a1b8:	e1a09002 	mov	r9, r2
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
3481a1bc:	e3a0a000 	mov	sl, #0
void print_size(unsigned long long size, const char *s)
{
	unsigned long m = 0, n;
	unsigned long long f;
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
3481a1c0:	e3a0603c 	mov	r6, #60	; 0x3c
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
		if (size >> d) {
3481a1c4:	e1a00004 	mov	r0, r4
3481a1c8:	e1a01005 	mov	r1, r5
3481a1cc:	e1a02006 	mov	r2, r6
3481a1d0:	eb001785 	bl	3481ffec <__lshrdi3>
3481a1d4:	e1901001 	orrs	r1, r0, r1
3481a1d8:	0a000004 	beq	3481a1f0 <print_size+0x44>
			c = names[i];
3481a1dc:	e59f30e0 	ldr	r3, [pc, #224]	; 3481a2c4 <print_size+0x118>
3481a1e0:	e7d3a00a 	ldrb	sl, [r3, sl]
			break;
		}
	}

	if (!c) {
3481a1e4:	e35a0000 	cmp	sl, #0
3481a1e8:	1a00000b 	bne	3481a21c <print_size+0x70>
3481a1ec:	ea000003 	b	3481a200 <print_size+0x54>
	static const char names[] = {'E', 'P', 'T', 'G', 'M', 'K'};
	unsigned long d = 10 * ARRAY_SIZE(names);
	char c = 0;
	unsigned int i;

	for (i = 0; i < ARRAY_SIZE(names); i++, d -= 10) {
3481a1f0:	e28aa001 	add	sl, sl, #1
3481a1f4:	e35a0006 	cmp	sl, #6
3481a1f8:	1246600a 	subne	r6, r6, #10
3481a1fc:	1afffff0 	bne	3481a1c4 <print_size+0x18>
			break;
		}
	}

	if (!c) {
		printf("%llu Bytes%s", size, s);
3481a200:	e1a02004 	mov	r2, r4
3481a204:	e1a03005 	mov	r3, r5
3481a208:	e59f00b8 	ldr	r0, [pc, #184]	; 3481a2c8 <print_size+0x11c>
3481a20c:	e58d9000 	str	r9, [sp]
3481a210:	ebffbbd3 	bl	34809164 <printf>
	printf ("%lu", n);
	if (m) {
		printf (".%ld", m);
	}
	printf (" %ciB%s", c, s);
}
3481a214:	e28dd00c 	add	sp, sp, #12
3481a218:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
		printf("%llu Bytes%s", size, s);
		return;
	}

	n = size >> d;
	f = size & ((1ULL << d) - 1);
3481a21c:	e1a02006 	mov	r2, r6
	if (!c) {
		printf("%llu Bytes%s", size, s);
		return;
	}

	n = size >> d;
3481a220:	e1a07000 	mov	r7, r0
	f = size & ((1ULL << d) - 1);
3481a224:	e3a01000 	mov	r1, #0
3481a228:	e3a00001 	mov	r0, #1
3481a22c:	eb00177c 	bl	34820024 <__ashldi3>
3481a230:	e3e02000 	mvn	r2, #0
3481a234:	e0922000 	adds	r2, r2, r0
3481a238:	e3e03000 	mvn	r3, #0
3481a23c:	e0a33001 	adc	r3, r3, r1
3481a240:	e0022004 	and	r2, r2, r4
3481a244:	e0033005 	and	r3, r3, r5

	/* If there's a remainder, deal with it */
	if (f) {
3481a248:	e1924003 	orrs	r4, r2, r3
3481a24c:	0a00000e 	beq	3481a28c <print_size+0xe0>
		m = (10ULL * f + (1ULL << (d - 1))) >> d;
3481a250:	e3a0100a 	mov	r1, #10
3481a254:	e0854192 	umull	r4, r5, r2, r1
3481a258:	e3a00001 	mov	r0, #1
3481a25c:	e0255391 	mla	r5, r1, r3, r5
3481a260:	e2462001 	sub	r2, r6, #1
3481a264:	e3a01000 	mov	r1, #0
3481a268:	eb00176d 	bl	34820024 <__ashldi3>
3481a26c:	e0900004 	adds	r0, r0, r4
3481a270:	e0a11005 	adc	r1, r1, r5
3481a274:	e1a02006 	mov	r2, r6
3481a278:	eb00175b 	bl	3481ffec <__lshrdi3>

		if (m >= 10) {
3481a27c:	e3500009 	cmp	r0, #9
	n = size >> d;
	f = size & ((1ULL << d) - 1);

	/* If there's a remainder, deal with it */
	if (f) {
		m = (10ULL * f + (1ULL << (d - 1))) >> d;
3481a280:	e1a04000 	mov	r4, r0

		if (m >= 10) {
			m -= 10;
			n += 1;
3481a284:	82877001 	addhi	r7, r7, #1
	/* If there's a remainder, deal with it */
	if (f) {
		m = (10ULL * f + (1ULL << (d - 1))) >> d;

		if (m >= 10) {
			m -= 10;
3481a288:	8240400a 	subhi	r4, r0, #10
			n += 1;
		}
	}

	printf ("%lu", n);
3481a28c:	e59f0038 	ldr	r0, [pc, #56]	; 3481a2cc <print_size+0x120>
3481a290:	e1a01007 	mov	r1, r7
3481a294:	ebffbbb2 	bl	34809164 <printf>
	if (m) {
3481a298:	e3540000 	cmp	r4, #0
3481a29c:	0a000002 	beq	3481a2ac <print_size+0x100>
		printf (".%ld", m);
3481a2a0:	e59f0028 	ldr	r0, [pc, #40]	; 3481a2d0 <print_size+0x124>
3481a2a4:	e1a01004 	mov	r1, r4
3481a2a8:	ebffbbad 	bl	34809164 <printf>
	}
	printf (" %ciB%s", c, s);
3481a2ac:	e59f0020 	ldr	r0, [pc, #32]	; 3481a2d4 <print_size+0x128>
3481a2b0:	e1a0100a 	mov	r1, sl
3481a2b4:	e1a02009 	mov	r2, r9
}
3481a2b8:	e28dd00c 	add	sp, sp, #12
3481a2bc:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}

	printf ("%lu", n);
	if (m) {
		printf (".%ld", m);
	}
	printf (" %ciB%s", c, s);
3481a2c0:	eaffbba7 	b	34809164 <printf>
3481a2c4:	34821dd4 	.word	0x34821dd4
3481a2c8:	34827e8d 	.word	0x34827e8d
3481a2cc:	34827e9a 	.word	0x34827e9a
3481a2d0:	34827e9e 	.word	0x34827e9e
3481a2d4:	34827ea3 	.word	0x34827ea3

3481a2d8 <print_buffer>:
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
{
3481a2d8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481a2dc:	e24dd050 	sub	sp, sp, #80	; 0x50
3481a2e0:	e59d5070 	ldr	r5, [sp, #112]	; 0x70
3481a2e4:	e1a07003 	mov	r7, r3
		uint16_t us[MAX_LINE_LENGTH_BYTES/sizeof(uint16_t) + 1];
		uint8_t  uc[MAX_LINE_LENGTH_BYTES/sizeof(uint8_t) + 1];
	} lb;
	int i;

	if (linelen*width > MAX_LINE_LENGTH_BYTES)
3481a2e8:	e0030592 	mul	r3, r2, r5
3481a2ec:	e3530040 	cmp	r3, #64	; 0x40
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
{
3481a2f0:	e1a0b000 	mov	fp, r0
3481a2f4:	e1a09001 	mov	r9, r1
3481a2f8:	e1a04002 	mov	r4, r2
		uint16_t us[MAX_LINE_LENGTH_BYTES/sizeof(uint16_t) + 1];
		uint8_t  uc[MAX_LINE_LENGTH_BYTES/sizeof(uint8_t) + 1];
	} lb;
	int i;

	if (linelen*width > MAX_LINE_LENGTH_BYTES)
3481a2fc:	9a000003 	bls	3481a310 <print_buffer+0x38>
		linelen = MAX_LINE_LENGTH_BYTES / width;
3481a300:	e3a00040 	mov	r0, #64	; 0x40
3481a304:	e1a01002 	mov	r1, r2
3481a308:	eb001624 	bl	3481fba0 <__udivsi3>
3481a30c:	e1a05000 	mov	r5, r0
	if (linelen < 1)
3481a310:	e3550000 	cmp	r5, #0
3481a314:	1a00003c 	bne	3481a40c <print_buffer+0x134>
		linelen = DEFAULT_LINE_LENGTH_BYTES / width;
3481a318:	e3a00010 	mov	r0, #16
3481a31c:	e1a01004 	mov	r1, r4
3481a320:	eb00161e 	bl	3481fba0 <__udivsi3>
3481a324:	e1a05000 	mov	r5, r0
3481a328:	ea000037 	b	3481a40c <print_buffer+0x134>

	while (count) {
		printf("%08lx:", addr);
3481a32c:	e59f00fc 	ldr	r0, [pc, #252]	; 3481a430 <print_buffer+0x158>
3481a330:	e1a0100b 	mov	r1, fp
3481a334:	ebffbb8a 	bl	34809164 <printf>
3481a338:	e1550007 	cmp	r5, r7
3481a33c:	21a05007 	movcs	r5, r7
		/* check for overflow condition */
		if (count < linelen)
			linelen = count;

		/* Copy from memory into linebuf and print hex values */
		for (i = 0; i < linelen; i++) {
3481a340:	e1a0a009 	mov	sl, r9
3481a344:	e3a06000 	mov	r6, #0
3481a348:	ea000010 	b	3481a390 <print_buffer+0xb8>
			uint32_t x;
			if (width == 4)
3481a34c:	e3540004 	cmp	r4, #4
				x = lb.ui[i] = *(volatile uint32_t *)data;
3481a350:	059a2000 	ldreq	r2, [sl]
3481a354:	028d300c 	addeq	r3, sp, #12
3481a358:	07832106 	streq	r2, [r3, r6, lsl #2]
			linelen = count;

		/* Copy from memory into linebuf and print hex values */
		for (i = 0; i < linelen; i++) {
			uint32_t x;
			if (width == 4)
3481a35c:	0a000006 	beq	3481a37c <print_buffer+0xa4>
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
3481a360:	e3540002 	cmp	r4, #2
				x = lb.us[i] = *(volatile uint16_t *)data;
3481a364:	01da20b0 	ldrheq	r2, [sl]
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
3481a368:	15da2000 	ldrbne	r2, [sl]
3481a36c:	e28d300c 	add	r3, sp, #12
 *    count: number of values to display
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
3481a370:	01a01086 	lsleq	r1, r6, #1
		for (i = 0; i < linelen; i++) {
			uint32_t x;
			if (width == 4)
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
				x = lb.us[i] = *(volatile uint16_t *)data;
3481a374:	018320b1 	strheq	r2, [r3, r1]
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
3481a378:	17c32006 	strbne	r2, [r3, r6]
			printf(" %0*x", width * 2, x);
3481a37c:	e59f00b0 	ldr	r0, [pc, #176]	; 3481a434 <print_buffer+0x15c>
3481a380:	e59d1004 	ldr	r1, [sp, #4]
3481a384:	ebffbb76 	bl	34809164 <printf>
			data += width;
3481a388:	e08aa004 	add	sl, sl, r4
		/* check for overflow condition */
		if (count < linelen)
			linelen = count;

		/* Copy from memory into linebuf and print hex values */
		for (i = 0; i < linelen; i++) {
3481a38c:	e2866001 	add	r6, r6, #1
3481a390:	e1560005 	cmp	r6, r5
3481a394:	3affffec 	bcc	3481a34c <print_buffer+0x74>
 *    count: number of values to display
 *    linelen: Number of values to print per line; specify 0 for default length
 */
#define MAX_LINE_LENGTH_BYTES (64)
#define DEFAULT_LINE_LENGTH_BYTES (16)
int print_buffer (ulong addr, void* data, uint width, uint count, uint linelen)
3481a398:	e0060594 	mul	r6, r4, r5
3481a39c:	e28d300c 	add	r3, sp, #12
3481a3a0:	e0899006 	add	r9, r9, r6
3481a3a4:	e0861003 	add	r1, r6, r3
3481a3a8:	ea000008 	b	3481a3d0 <print_buffer+0xf8>
			data += width;
		}

		/* Print data in ASCII characters */
		for (i = 0; i < linelen * width; i++) {
			if (!isprint(lb.uc[i]) || lb.uc[i] >= 0x80)
3481a3ac:	e4d32001 	ldrb	r2, [r3], #1
3481a3b0:	e59fc080 	ldr	ip, [pc, #128]	; 3481a438 <print_buffer+0x160>
3481a3b4:	e7dc0002 	ldrb	r0, [ip, r2]
3481a3b8:	e3100097 	tst	r0, #151	; 0x97
3481a3bc:	0a000001 	beq	3481a3c8 <print_buffer+0xf0>
3481a3c0:	e3120080 	tst	r2, #128	; 0x80
3481a3c4:	0a000001 	beq	3481a3d0 <print_buffer+0xf8>
				lb.uc[i] = '.';
3481a3c8:	e3a0202e 	mov	r2, #46	; 0x2e
3481a3cc:	e5432001 	strb	r2, [r3, #-1]
			printf(" %0*x", width * 2, x);
			data += width;
		}

		/* Print data in ASCII characters */
		for (i = 0; i < linelen * width; i++) {
3481a3d0:	e1530001 	cmp	r3, r1
3481a3d4:	1afffff4 	bne	3481a3ac <print_buffer+0xd4>
			if (!isprint(lb.uc[i]) || lb.uc[i] >= 0x80)
				lb.uc[i] = '.';
		}
		lb.uc[i] = '\0';
3481a3d8:	e28dc050 	add	ip, sp, #80	; 0x50
3481a3dc:	e08c3006 	add	r3, ip, r6
3481a3e0:	e3a02000 	mov	r2, #0
3481a3e4:	e5432044 	strb	r2, [r3, #-68]	; 0x44
		printf("    %s\n", lb.uc);
3481a3e8:	e28d100c 	add	r1, sp, #12
3481a3ec:	e59f0048 	ldr	r0, [pc, #72]	; 3481a43c <print_buffer+0x164>
3481a3f0:	ebffbb5b 	bl	34809164 <printf>

		/* update references */
		addr += linelen * width;
		count -= linelen;

		if (ctrlc())
3481a3f4:	ebffbb7f 	bl	348091f8 <ctrlc>
3481a3f8:	e3500000 	cmp	r0, #0
3481a3fc:	1a000008 	bne	3481a424 <print_buffer+0x14c>
		}
		lb.uc[i] = '\0';
		printf("    %s\n", lb.uc);

		/* update references */
		addr += linelen * width;
3481a400:	e08bb006 	add	fp, fp, r6
		count -= linelen;
3481a404:	e0657007 	rsb	r7, r5, r7
3481a408:	ea000001 	b	3481a414 <print_buffer+0x13c>
				x = lb.ui[i] = *(volatile uint32_t *)data;
			else if (width == 2)
				x = lb.us[i] = *(volatile uint16_t *)data;
			else
				x = lb.uc[i] = *(volatile uint8_t *)data;
			printf(" %0*x", width * 2, x);
3481a40c:	e1a03084 	lsl	r3, r4, #1
3481a410:	e58d3004 	str	r3, [sp, #4]
	if (linelen*width > MAX_LINE_LENGTH_BYTES)
		linelen = MAX_LINE_LENGTH_BYTES / width;
	if (linelen < 1)
		linelen = DEFAULT_LINE_LENGTH_BYTES / width;

	while (count) {
3481a414:	e3570000 	cmp	r7, #0
3481a418:	1affffc3 	bne	3481a32c <print_buffer+0x54>

		if (ctrlc())
			return -1;
	}

	return 0;
3481a41c:	e1a00007 	mov	r0, r7
3481a420:	ea000000 	b	3481a428 <print_buffer+0x150>
		/* update references */
		addr += linelen * width;
		count -= linelen;

		if (ctrlc())
			return -1;
3481a424:	e3e00000 	mvn	r0, #0
	}

	return 0;
}
3481a428:	e28dd050 	add	sp, sp, #80	; 0x50
3481a42c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481a430:	34823d7f 	.word	0x34823d7f
3481a434:	34827eab 	.word	0x34827eab
3481a438:	34821cd4 	.word	0x34821cd4
3481a43c:	34827eb1 	.word	0x34827eb1

3481a440 <__div64_32>:
 */

#include <linux/types.h>

uint32_t __div64_32(uint64_t *n, uint32_t base)
{
3481a440:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	uint64_t rem = *n;
3481a444:	e1c060d0 	ldrd	r6, [r0]
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
3481a448:	e1510007 	cmp	r1, r7
 */

#include <linux/types.h>

uint32_t __div64_32(uint64_t *n, uint32_t base)
{
3481a44c:	e1a09000 	mov	r9, r0
3481a450:	e1a0a001 	mov	sl, r1
	uint64_t rem = *n;
	uint64_t b = base;
3481a454:	e1a04001 	mov	r4, r1
3481a458:	e3a05000 	mov	r5, #0
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
3481a45c:	8a000009 	bhi	3481a488 <__div64_32+0x48>
		high /= base;
3481a460:	e1a00007 	mov	r0, r7
3481a464:	eb0015cd 	bl	3481fba0 <__udivsi3>
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high*base) << 32;
3481a468:	e003009a 	mul	r3, sl, r0

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
		high /= base;
		res = (uint64_t) high << 32;
3481a46c:	e3a0c000 	mov	ip, #0
		rem -= (uint64_t) (high*base) << 32;
3481a470:	e1a0200c 	mov	r2, ip

	/* Reduce the thing a bit first */
	res = 0;
	if (high >= base) {
		high /= base;
		res = (uint64_t) high << 32;
3481a474:	e58d0004 	str	r0, [sp, #4]
3481a478:	e58dc000 	str	ip, [sp]
		rem -= (uint64_t) (high*base) << 32;
3481a47c:	e0566002 	subs	r6, r6, r2
3481a480:	e0c77003 	sbc	r7, r7, r3
3481a484:	ea000002 	b	3481a494 <__div64_32+0x54>
	uint64_t b = base;
	uint64_t res, d = 1;
	uint32_t high = rem >> 32;

	/* Reduce the thing a bit first */
	res = 0;
3481a488:	e3a02000 	mov	r2, #0
3481a48c:	e3a03000 	mov	r3, #0
3481a490:	e1cd20f0 	strd	r2, [sp]
3481a494:	e3a00001 	mov	r0, #1
3481a498:	e3a01000 	mov	r1, #0
3481a49c:	ea000003 	b	3481a4b0 <__div64_32+0x70>
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high*base) << 32;
	}

	while ((int64_t)b > 0 && b < rem) {
		b = b+b;
3481a4a0:	e0944004 	adds	r4, r4, r4
3481a4a4:	e0a55005 	adc	r5, r5, r5
		d = d+d;
3481a4a8:	e0900000 	adds	r0, r0, r0
3481a4ac:	e0a11001 	adc	r1, r1, r1
		high /= base;
		res = (uint64_t) high << 32;
		rem -= (uint64_t) (high*base) << 32;
	}

	while ((int64_t)b > 0 && b < rem) {
3481a4b0:	e1a0afc5 	asr	sl, r5, #31
3481a4b4:	e1a0200a 	mov	r2, sl
3481a4b8:	e1a0300a 	mov	r3, sl
3481a4bc:	e0522004 	subs	r2, r2, r4
3481a4c0:	e0c33005 	sbc	r3, r3, r5
3481a4c4:	e1570005 	cmp	r7, r5
3481a4c8:	e1a02fa3 	lsr	r2, r3, #31
3481a4cc:	e1a0b00a 	mov	fp, sl
3481a4d0:	e3a03001 	mov	r3, #1
3481a4d4:	8a000003 	bhi	3481a4e8 <__div64_32+0xa8>
3481a4d8:	1a000001 	bne	3481a4e4 <__div64_32+0xa4>
3481a4dc:	e1560004 	cmp	r6, r4
3481a4e0:	8a000000 	bhi	3481a4e8 <__div64_32+0xa8>
3481a4e4:	e3a03000 	mov	r3, #0
3481a4e8:	e1120003 	tst	r2, r3
3481a4ec:	1affffeb 	bne	3481a4a0 <__div64_32+0x60>
3481a4f0:	e1cd20d0 	ldrd	r2, [sp]
		b = b+b;
		d = d+d;
	}

	do {
		if (rem >= b) {
3481a4f4:	e1550007 	cmp	r5, r7
3481a4f8:	8a000006 	bhi	3481a518 <__div64_32+0xd8>
3481a4fc:	1a000001 	bne	3481a508 <__div64_32+0xc8>
3481a500:	e1540006 	cmp	r4, r6
3481a504:	8a000003 	bhi	3481a518 <__div64_32+0xd8>
			rem -= b;
3481a508:	e0566004 	subs	r6, r6, r4
3481a50c:	e0c77005 	sbc	r7, r7, r5
			res += d;
3481a510:	e0922000 	adds	r2, r2, r0
3481a514:	e0a33001 	adc	r3, r3, r1
		}
		b >>= 1;
		d >>= 1;
3481a518:	e1b010a1 	lsrs	r1, r1, #1
3481a51c:	e1a00060 	rrx	r0, r0
	} while (d);
3481a520:	e190c001 	orrs	ip, r0, r1
3481a524:	0a000002 	beq	3481a534 <__div64_32+0xf4>
	do {
		if (rem >= b) {
			rem -= b;
			res += d;
		}
		b >>= 1;
3481a528:	e1b050a5 	lsrs	r5, r5, #1
3481a52c:	e1a04064 	rrx	r4, r4
3481a530:	eaffffef 	b	3481a4f4 <__div64_32+0xb4>
		d >>= 1;
	} while (d);

	*n = res;
3481a534:	e1c920f0 	strd	r2, [r9]
	return rem;
}
3481a538:	e1a00006 	mov	r0, r6
3481a53c:	e28dd010 	add	sp, sp, #16
3481a540:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481a544 <gzfree>:
	return (p);
}

void gzfree(void *x, void *addr, unsigned nb)
{
	free (addr);
3481a544:	e1a00001 	mov	r0, r1
3481a548:	eaffbc43 	b	3480965c <free>

3481a54c <gzalloc>:

void *gzalloc(void *x, unsigned items, unsigned size)
{
	void *p;

	size *= items;
3481a54c:	e0020291 	mul	r2, r1, r2
	size = (size + ZALLOC_ALIGNMENT - 1) & ~(ZALLOC_ALIGNMENT - 1);
3481a550:	e282000f 	add	r0, r2, #15

	p = malloc (size);
3481a554:	e3c0000f 	bic	r0, r0, #15
3481a558:	eaffbcc8 	b	34809880 <malloc>

3481a55c <zunzip>:
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
3481a55c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481a560:	e1a04003 	mov	r4, r3
	z_stream s;
	int r;

	s.zalloc = gzalloc;
3481a564:	e59f30e4 	ldr	r3, [pc, #228]	; 3481a650 <zunzip+0xf4>
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
3481a568:	e24dd040 	sub	sp, sp, #64	; 0x40
	z_stream s;
	int r;

	s.zalloc = gzalloc;
3481a56c:	e58d3024 	str	r3, [sp, #36]	; 0x24
	s.zfree = gzfree;
3481a570:	e59f30dc 	ldr	r3, [pc, #220]	; 3481a654 <zunzip+0xf8>

	r = inflateInit2(&s, -MAX_WBITS);
3481a574:	e28da004 	add	sl, sp, #4
{
	z_stream s;
	int r;

	s.zalloc = gzalloc;
	s.zfree = gzfree;
3481a578:	e58d3028 	str	r3, [sp, #40]	; 0x28
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
3481a57c:	e1a05000 	mov	r5, r0
3481a580:	e1a07001 	mov	r7, r1
3481a584:	e1a09002 	mov	r9, r2
	int r;

	s.zalloc = gzalloc;
	s.zfree = gzfree;

	r = inflateInit2(&s, -MAX_WBITS);
3481a588:	e3e0100e 	mvn	r1, #14
3481a58c:	e1a0000a 	mov	r0, sl
3481a590:	e59f20c0 	ldr	r2, [pc, #192]	; 3481a658 <zunzip+0xfc>
3481a594:	e3a0303c 	mov	r3, #60	; 0x3c
/*
 * Uncompress blocks compressed with zlib without headers
 */
int zunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp,
						int stoponerr, int offset)
{
3481a598:	e59db060 	ldr	fp, [sp, #96]	; 0x60
3481a59c:	e59d6064 	ldr	r6, [sp, #100]	; 0x64
	int r;

	s.zalloc = gzalloc;
	s.zfree = gzfree;

	r = inflateInit2(&s, -MAX_WBITS);
3481a5a0:	eb000cf1 	bl	3481d96c <inflateInit2_>
	if (r != Z_OK) {
3481a5a4:	e2501000 	subs	r1, r0, #0
3481a5a8:	0a000002 	beq	3481a5b8 <zunzip+0x5c>
		printf ("Error: inflateInit2() returned %d\n", r);
3481a5ac:	e59f00a8 	ldr	r0, [pc, #168]	; 3481a65c <zunzip+0x100>
3481a5b0:	ebffbaeb 	bl	34809164 <printf>
3481a5b4:	ea000013 	b	3481a608 <zunzip+0xac>
		return -1;
	}
	s.next_in = src + offset;
	s.avail_in = *lenp - offset;
3481a5b8:	e5943000 	ldr	r3, [r4]
	r = inflateInit2(&s, -MAX_WBITS);
	if (r != Z_OK) {
		printf ("Error: inflateInit2() returned %d\n", r);
		return -1;
	}
	s.next_in = src + offset;
3481a5bc:	e0899006 	add	r9, r9, r6
	s.avail_in = *lenp - offset;
3481a5c0:	e0663003 	rsb	r3, r6, r3
	r = inflateInit2(&s, -MAX_WBITS);
	if (r != Z_OK) {
		printf ("Error: inflateInit2() returned %d\n", r);
		return -1;
	}
	s.next_in = src + offset;
3481a5c4:	e58d9004 	str	r9, [sp, #4]
	s.avail_in = *lenp - offset;
3481a5c8:	e58d3008 	str	r3, [sp, #8]
	s.next_out = dst;
3481a5cc:	e58d5010 	str	r5, [sp, #16]
	s.avail_out = dstlen;
3481a5d0:	e58d7014 	str	r7, [sp, #20]
	do {
		r = inflate(&s, Z_FINISH);
3481a5d4:	e3a01004 	mov	r1, #4
3481a5d8:	e1a0000a 	mov	r0, sl
3481a5dc:	eb000dfd 	bl	3481ddd8 <inflate>
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
3481a5e0:	e3500001 	cmp	r0, #1
3481a5e4:	13700005 	cmnne	r0, #5
	s.next_in = src + offset;
	s.avail_in = *lenp - offset;
	s.next_out = dst;
	s.avail_out = dstlen;
	do {
		r = inflate(&s, Z_FINISH);
3481a5e8:	e1a01000 	mov	r1, r0
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
3481a5ec:	0a000007 	beq	3481a610 <zunzip+0xb4>
3481a5f0:	e35b0001 	cmp	fp, #1
3481a5f4:	1a000005 	bne	3481a610 <zunzip+0xb4>
			printf("Error: inflate() returned %d\n", r);
3481a5f8:	e59f0060 	ldr	r0, [pc, #96]	; 3481a660 <zunzip+0x104>
3481a5fc:	ebffbad8 	bl	34809164 <printf>
			inflateEnd(&s);
3481a600:	e1a0000a 	mov	r0, sl
3481a604:	eb000d1e 	bl	3481da84 <inflateEnd>
			return -1;
3481a608:	e3e00000 	mvn	r0, #0
3481a60c:	ea00000d 	b	3481a648 <zunzip+0xec>
		}
		s.avail_in = *lenp - offset - (int)(s.next_out - (unsigned char*)dst);
3481a610:	e59d3010 	ldr	r3, [sp, #16]
3481a614:	e5942000 	ldr	r2, [r4]
3481a618:	e0630005 	rsb	r0, r3, r5
3481a61c:	e0802002 	add	r2, r0, r2
3481a620:	e0662002 	rsb	r2, r6, r2
		s.avail_out = dstlen;
	} while (r == Z_BUF_ERROR);
3481a624:	e3710005 	cmn	r1, #5
		if (r != Z_STREAM_END && r != Z_BUF_ERROR && stoponerr == 1) {
			printf("Error: inflate() returned %d\n", r);
			inflateEnd(&s);
			return -1;
		}
		s.avail_in = *lenp - offset - (int)(s.next_out - (unsigned char*)dst);
3481a628:	e58d2008 	str	r2, [sp, #8]
		s.avail_out = dstlen;
3481a62c:	e58d7014 	str	r7, [sp, #20]
	} while (r == Z_BUF_ERROR);
3481a630:	0affffe7 	beq	3481a5d4 <zunzip+0x78>
	*lenp = s.next_out - (unsigned char *) dst;
3481a634:	e0655003 	rsb	r5, r5, r3
3481a638:	e5845000 	str	r5, [r4]
	inflateEnd(&s);
3481a63c:	e28d0004 	add	r0, sp, #4
3481a640:	eb000d0f 	bl	3481da84 <inflateEnd>

	return 0;
3481a644:	e3a00000 	mov	r0, #0
}
3481a648:	e28dd040 	add	sp, sp, #64	; 0x40
3481a64c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481a650:	3481a54c 	.word	0x3481a54c
3481a654:	3481a544 	.word	0x3481a544
3481a658:	34827eb9 	.word	0x34827eb9
3481a65c:	34827ebf 	.word	0x34827ebf
3481a660:	34827ee2 	.word	0x34827ee2

3481a664 <gunzip>:
	int i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
3481a664:	e5d2c002 	ldrb	ip, [r2, #2]
{
	free (addr);
}

int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
{
3481a668:	e92d4013 	push	{r0, r1, r4, lr}
	int i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
3481a66c:	e35c0008 	cmp	ip, #8
{
	int i, flags;

	/* skip header */
	i = 10;
	flags = src[3];
3481a670:	e5d2e003 	ldrb	lr, [r2, #3]
	if (src[2] != DEFLATED || (flags & RESERVED) != 0) {
3481a674:	1a000001 	bne	3481a680 <gunzip+0x1c>
3481a678:	e31e00e0 	tst	lr, #224	; 0xe0
3481a67c:	0a000001 	beq	3481a688 <gunzip+0x24>
		puts ("Error: Bad gzipped data\n");
3481a680:	e59f0080 	ldr	r0, [pc, #128]	; 3481a708 <gunzip+0xa4>
3481a684:	ea000017 	b	3481a6e8 <gunzip+0x84>
		return (-1);
	}
	if ((flags & EXTRA_FIELD) != 0)
3481a688:	e31e0004 	tst	lr, #4
		i = 12 + src[10] + (src[11] << 8);
3481a68c:	15d2c00a 	ldrbne	ip, [r2, #10]
3481a690:	15d2400b 	ldrbne	r4, [r2, #11]
3481a694:	128cc00c 	addne	ip, ip, #12
3481a698:	108cc404 	addne	ip, ip, r4, lsl #8
int gunzip(void *dst, int dstlen, unsigned char *src, unsigned long *lenp)
{
	int i, flags;

	/* skip header */
	i = 10;
3481a69c:	03a0c00a 	moveq	ip, #10
		puts ("Error: Bad gzipped data\n");
		return (-1);
	}
	if ((flags & EXTRA_FIELD) != 0)
		i = 12 + src[10] + (src[11] << 8);
	if ((flags & ORIG_NAME) != 0)
3481a6a0:	e31e0008 	tst	lr, #8
3481a6a4:	0a000003 	beq	3481a6b8 <gunzip+0x54>
		while (src[i++] != 0)
3481a6a8:	e7d2400c 	ldrb	r4, [r2, ip]
3481a6ac:	e28cc001 	add	ip, ip, #1
3481a6b0:	e3540000 	cmp	r4, #0
3481a6b4:	1afffffb 	bne	3481a6a8 <gunzip+0x44>
			;
	if ((flags & COMMENT) != 0)
3481a6b8:	e31e0010 	tst	lr, #16
3481a6bc:	0a000003 	beq	3481a6d0 <gunzip+0x6c>
		while (src[i++] != 0)
3481a6c0:	e7d2400c 	ldrb	r4, [r2, ip]
3481a6c4:	e28cc001 	add	ip, ip, #1
3481a6c8:	e3540000 	cmp	r4, #0
3481a6cc:	1afffffb 	bne	3481a6c0 <gunzip+0x5c>
			;
	if ((flags & HEAD_CRC) != 0)
3481a6d0:	e31e0002 	tst	lr, #2
		i += 2;
	if (i >= *lenp) {
3481a6d4:	e593e000 	ldr	lr, [r3]
			;
	if ((flags & COMMENT) != 0)
		while (src[i++] != 0)
			;
	if ((flags & HEAD_CRC) != 0)
		i += 2;
3481a6d8:	128cc002 	addne	ip, ip, #2
	if (i >= *lenp) {
3481a6dc:	e15c000e 	cmp	ip, lr
3481a6e0:	3a000003 	bcc	3481a6f4 <gunzip+0x90>
		puts ("Error: gunzip out of data in header\n");
3481a6e4:	e59f0020 	ldr	r0, [pc, #32]	; 3481a70c <gunzip+0xa8>
3481a6e8:	ebffba93 	bl	3480913c <puts>
		return (-1);
3481a6ec:	e3e00000 	mvn	r0, #0
3481a6f0:	ea000003 	b	3481a704 <gunzip+0xa0>
	}

	return zunzip(dst, dstlen, src, lenp, 1, i);
3481a6f4:	e3a0e001 	mov	lr, #1
3481a6f8:	e58de000 	str	lr, [sp]
3481a6fc:	e58dc004 	str	ip, [sp, #4]
3481a700:	ebffff95 	bl	3481a55c <zunzip>
}
3481a704:	e8bd801c 	pop	{r2, r3, r4, pc}
3481a708:	34827f00 	.word	0x34827f00
3481a70c:	34827f19 	.word	0x34827f19

3481a710 <drop_var_from_set>:
/*
 * Check whether variable 'name' is amongst vars[],
 * and remove all instances by setting the pointer to NULL
 */
static int drop_var_from_set(const char *name, int nvars, char * vars[])
{
3481a710:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int i = 0;
	int res = 0;

	/* No variables specified means process all of them */
	if (nvars == 0)
3481a714:	e251a000 	subs	sl, r1, #0
3481a718:	13a05000 	movne	r5, #0
/*
 * Check whether variable 'name' is amongst vars[],
 * and remove all instances by setting the pointer to NULL
 */
static int drop_var_from_set(const char *name, int nvars, char * vars[])
{
3481a71c:	e1a04000 	mov	r4, r0
	int i = 0;
	int res = 0;

	/* No variables specified means process all of them */
	if (nvars == 0)
3481a720:	11a07002 	movne	r7, r2
3481a724:	11a06005 	movne	r6, r5
3481a728:	1a000009 	bne	3481a754 <drop_var_from_set+0x44>
3481a72c:	ea00000b 	b	3481a760 <drop_var_from_set+0x50>
		return 1;

	for (i = 0; i < nvars; i++) {
		if (vars[i] == NULL)
3481a730:	e4971004 	ldr	r1, [r7], #4
3481a734:	e3510000 	cmp	r1, #0
3481a738:	0a000004 	beq	3481a750 <drop_var_from_set+0x40>
			continue;
		/* If we found it, delete all of them */
		if (!strcmp(name, vars[i])) {
3481a73c:	e1a00004 	mov	r0, r4
3481a740:	eb00050b 	bl	3481bb74 <strcmp>
3481a744:	e3500000 	cmp	r0, #0
			vars[i] = NULL;
3481a748:	05070004 	streq	r0, [r7, #-4]
			res = 1;
3481a74c:	03a05001 	moveq	r5, #1

	/* No variables specified means process all of them */
	if (nvars == 0)
		return 1;

	for (i = 0; i < nvars; i++) {
3481a750:	e2866001 	add	r6, r6, #1
3481a754:	e156000a 	cmp	r6, sl
3481a758:	bafffff4 	blt	3481a730 <drop_var_from_set+0x20>
3481a75c:	ea000000 	b	3481a764 <drop_var_from_set+0x54>
	int i = 0;
	int res = 0;

	/* No variables specified means process all of them */
	if (nvars == 0)
		return 1;
3481a760:	e3a05001 	mov	r5, #1
	}
	if (!res)
		debug("Skipping non-listed variable %s\n", name);

	return res;
}
3481a764:	e1a00005 	mov	r0, r5
3481a768:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

3481a76c <cmpkey>:
static int cmpkey(const void *p1, const void *p2)
{
	ENTRY *e1 = *(ENTRY **) p1;
	ENTRY *e2 = *(ENTRY **) p2;

	return (strcmp(e1->key, e2->key));
3481a76c:	e5902000 	ldr	r2, [r0]
3481a770:	e5913000 	ldr	r3, [r1]
3481a774:	e5920000 	ldr	r0, [r2]
3481a778:	e5931000 	ldr	r1, [r3]
3481a77c:	ea0004fc 	b	3481bb74 <strcmp>

3481a780 <hcreate_r>:
 * The contents of the table is zeroed, especially the field used
 * becomes zero.
 */

int hcreate_r(size_t nel, struct hsearch_data *htab)
{
3481a780:	e92d4070 	push	{r4, r5, r6, lr}
	/* Test for correct arguments.  */
	if (htab == NULL) {
3481a784:	e2516000 	subs	r6, r1, #0
3481a788:	1a000004 	bne	3481a7a0 <hcreate_r+0x20>
		__set_errno(EINVAL);
3481a78c:	e59f3094 	ldr	r3, [pc, #148]	; 3481a828 <hcreate_r+0xa8>
3481a790:	e3a02016 	mov	r2, #22
3481a794:	e5832000 	str	r2, [r3]
		return 0;
3481a798:	e1a00006 	mov	r0, r6
3481a79c:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	/* There is still another table active. Return with error. */
	if (htab->table != NULL)
3481a7a0:	e5963000 	ldr	r3, [r6]
3481a7a4:	e3530000 	cmp	r3, #0
		return 0;

	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
3481a7a8:	03804001 	orreq	r4, r0, #1
		__set_errno(EINVAL);
		return 0;
	}

	/* There is still another table active. Return with error. */
	if (htab->table != NULL)
3481a7ac:	1a00001b 	bne	3481a820 <hcreate_r+0xa0>
3481a7b0:	ea000000 	b	3481a7b8 <hcreate_r+0x38>
		return 0;

	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
	while (!isprime(nel))
		nel += 2;
3481a7b4:	e2844002 	add	r4, r4, #2
 * b)  the number is small because the table must fit in the core
 * */
static int isprime(unsigned int number)
{
	/* no even number will be passed */
	unsigned int div = 3;
3481a7b8:	e3a05003 	mov	r5, #3
3481a7bc:	ea000000 	b	3481a7c4 <hcreate_r+0x44>

	while (div * div < number && number % div != 0)
		div += 2;
3481a7c0:	e2855002 	add	r5, r5, #2
static int isprime(unsigned int number)
{
	/* no even number will be passed */
	unsigned int div = 3;

	while (div * div < number && number % div != 0)
3481a7c4:	e0030595 	mul	r3, r5, r5
3481a7c8:	e1530004 	cmp	r3, r4
3481a7cc:	2a000004 	bcs	3481a7e4 <hcreate_r+0x64>
3481a7d0:	e1a00004 	mov	r0, r4
3481a7d4:	e1a01005 	mov	r1, r5
3481a7d8:	eb00156b 	bl	3481fd8c <__aeabi_uidivmod>
3481a7dc:	e3510000 	cmp	r1, #0
3481a7e0:	1afffff6 	bne	3481a7c0 <hcreate_r+0x40>
		div += 2;

	return number % div != 0;
3481a7e4:	e1a00004 	mov	r0, r4
3481a7e8:	e1a01005 	mov	r1, r5
3481a7ec:	eb001566 	bl	3481fd8c <__aeabi_uidivmod>
	if (htab->table != NULL)
		return 0;

	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
	while (!isprime(nel))
3481a7f0:	e3510000 	cmp	r1, #0
3481a7f4:	0affffee 	beq	3481a7b4 <hcreate_r+0x34>
		nel += 2;

	htab->size = nel;
	htab->filled = 0;
3481a7f8:	e3a03000 	mov	r3, #0
	/* Change nel to the first prime number not smaller as nel. */
	nel |= 1;		/* make odd */
	while (!isprime(nel))
		nel += 2;

	htab->size = nel;
3481a7fc:	e5864004 	str	r4, [r6, #4]
	htab->filled = 0;
3481a800:	e5863008 	str	r3, [r6, #8]

	/* allocate memory and zero out */
	htab->table = (_ENTRY *) calloc(htab->size + 1, sizeof(_ENTRY));
3481a804:	e2840001 	add	r0, r4, #1
3481a808:	e3a0100c 	mov	r1, #12
3481a80c:	ebffbd88 	bl	34809e34 <calloc>
3481a810:	e5860000 	str	r0, [r6]
int hcreate_r(size_t nel, struct hsearch_data *htab)
{
	/* Test for correct arguments.  */
	if (htab == NULL) {
		__set_errno(EINVAL);
		return 0;
3481a814:	e2500000 	subs	r0, r0, #0
3481a818:	13a00001 	movne	r0, #1
3481a81c:	e8bd8070 	pop	{r4, r5, r6, pc}
	}

	/* There is still another table active. Return with error. */
	if (htab->table != NULL)
		return 0;
3481a820:	e3a00000 	mov	r0, #0
	if (htab->table == NULL)
		return 0;

	/* everything went alright */
	return 1;
}
3481a824:	e8bd8070 	pop	{r4, r5, r6, pc}
3481a828:	3482bc40 	.word	0x3482bc40

3481a82c <hdestroy_r>:
 * After using the hash table it has to be destroyed. The used memory can
 * be freed and the local static variable can be marked as not used.
 */

void hdestroy_r(struct hsearch_data *htab, int do_apply)
{
3481a82c:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
3481a830:	e2504000 	subs	r4, r0, #0
 * After using the hash table it has to be destroyed. The used memory can
 * be freed and the local static variable can be marked as not used.
 */

void hdestroy_r(struct hsearch_data *htab, int do_apply)
{
3481a834:	e1a0a001 	mov	sl, r1
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
3481a838:	13a0600c 	movne	r6, #12
3481a83c:	13a07001 	movne	r7, #1
3481a840:	1a000017 	bne	3481a8a4 <hdestroy_r+0x78>
		__set_errno(EINVAL);
3481a844:	e59f3078 	ldr	r3, [pc, #120]	; 3481a8c4 <hdestroy_r+0x98>
3481a848:	e3a02016 	mov	r2, #22
3481a84c:	e5832000 	str	r2, [r3]
		return;
3481a850:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
	}

	/* free used memory */
	for (i = 1; i <= htab->size; ++i) {
		if (htab->table[i].used > 0) {
3481a854:	e5943000 	ldr	r3, [r4]
3481a858:	e0835006 	add	r5, r3, r6
3481a85c:	e7933006 	ldr	r3, [r3, r6]
3481a860:	e3530000 	cmp	r3, #0
3481a864:	da00000c 	ble	3481a89c <hdestroy_r+0x70>
			ENTRY *ep = &htab->table[i].entry;
			if (do_apply && htab->apply != NULL) {
3481a868:	e35a0000 	cmp	sl, #0
3481a86c:	0a000006 	beq	3481a88c <hdestroy_r+0x60>
3481a870:	e594c00c 	ldr	ip, [r4, #12]
3481a874:	e35c0000 	cmp	ip, #0
3481a878:	0a000003 	beq	3481a88c <hdestroy_r+0x60>
				/* deletion is always forced */
				htab->apply(ep->key, ep->data, NULL, H_FORCE);
3481a87c:	e9950003 	ldmib	r5, {r0, r1}
3481a880:	e3a02000 	mov	r2, #0
3481a884:	e3a03002 	mov	r3, #2
3481a888:	e12fff3c 	blx	ip
			}
			free((void *)ep->key);
3481a88c:	e5950004 	ldr	r0, [r5, #4]
3481a890:	ebffbb71 	bl	3480965c <free>
			free(ep->data);
3481a894:	e5950008 	ldr	r0, [r5, #8]
3481a898:	ebffbb6f 	bl	3480965c <free>
		__set_errno(EINVAL);
		return;
	}

	/* free used memory */
	for (i = 1; i <= htab->size; ++i) {
3481a89c:	e2877001 	add	r7, r7, #1
3481a8a0:	e286600c 	add	r6, r6, #12
3481a8a4:	e5943004 	ldr	r3, [r4, #4]
3481a8a8:	e1570003 	cmp	r7, r3
3481a8ac:	9affffe8 	bls	3481a854 <hdestroy_r+0x28>
			}
			free((void *)ep->key);
			free(ep->data);
		}
	}
	free(htab->table);
3481a8b0:	e5940000 	ldr	r0, [r4]
3481a8b4:	ebffbb68 	bl	3480965c <free>

	/* the sign for an existing table is an value != NULL in htable */
	htab->table = NULL;
3481a8b8:	e3a03000 	mov	r3, #0
3481a8bc:	e5843000 	str	r3, [r4]
3481a8c0:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3481a8c4:	3482bc40 	.word	0x3482bc40

3481a8c8 <hstrstr_r>:
/*
 * hstrstr_r - return index to entry whose key and/or data contains match
 */
int hstrstr_r(const char *match, int last_idx, ENTRY ** retval,
	      struct hsearch_data *htab)
{
3481a8c8:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481a8cc:	e2817001 	add	r7, r1, #1
3481a8d0:	e3a0600c 	mov	r6, #12
/*
 * hstrstr_r - return index to entry whose key and/or data contains match
 */
int hstrstr_r(const char *match, int last_idx, ENTRY ** retval,
	      struct hsearch_data *htab)
{
3481a8d4:	e1a04000 	mov	r4, r0
3481a8d8:	e1a05002 	mov	r5, r2
3481a8dc:	e1a0a003 	mov	sl, r3
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481a8e0:	e0060796 	mul	r6, r6, r7
3481a8e4:	ea000018 	b	3481a94c <hstrstr_r+0x84>
		if (htab->table[idx].used <= 0)
3481a8e8:	e59a3000 	ldr	r3, [sl]
3481a8ec:	e0832006 	add	r2, r3, r6
3481a8f0:	e7933006 	ldr	r3, [r3, r6]
3481a8f4:	e3530000 	cmp	r3, #0
3481a8f8:	da000011 	ble	3481a944 <hstrstr_r+0x7c>
			continue;
		if (strstr(htab->table[idx].entry.key, match) ||
3481a8fc:	e5920004 	ldr	r0, [r2, #4]
3481a900:	e1a01004 	mov	r1, r4
3481a904:	eb0005dd 	bl	3481c080 <strstr>
3481a908:	e3500000 	cmp	r0, #0
3481a90c:	1a000006 	bne	3481a92c <hstrstr_r+0x64>
		    strstr(htab->table[idx].entry.data, match)) {
3481a910:	e59a3000 	ldr	r3, [sl]
3481a914:	e1a01004 	mov	r1, r4
3481a918:	e0833006 	add	r3, r3, r6
3481a91c:	e5930008 	ldr	r0, [r3, #8]
3481a920:	eb0005d6 	bl	3481c080 <strstr>
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
		if (htab->table[idx].used <= 0)
			continue;
		if (strstr(htab->table[idx].entry.key, match) ||
3481a924:	e3500000 	cmp	r0, #0
3481a928:	0a000005 	beq	3481a944 <hstrstr_r+0x7c>
		    strstr(htab->table[idx].entry.data, match)) {
			*retval = &htab->table[idx].entry;
3481a92c:	e59a3000 	ldr	r3, [sl]
			return idx;
3481a930:	e1a00007 	mov	r0, r7
	for (idx = last_idx + 1; idx < htab->size; ++idx) {
		if (htab->table[idx].used <= 0)
			continue;
		if (strstr(htab->table[idx].entry.key, match) ||
		    strstr(htab->table[idx].entry.data, match)) {
			*retval = &htab->table[idx].entry;
3481a934:	e0836006 	add	r6, r3, r6
3481a938:	e2866004 	add	r6, r6, #4
3481a93c:	e5856000 	str	r6, [r5]
			return idx;
3481a940:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
int hstrstr_r(const char *match, int last_idx, ENTRY ** retval,
	      struct hsearch_data *htab)
{
	unsigned int idx;

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481a944:	e2877001 	add	r7, r7, #1
3481a948:	e286600c 	add	r6, r6, #12
3481a94c:	e59a3004 	ldr	r3, [sl, #4]
3481a950:	e1570003 	cmp	r7, r3
3481a954:	3affffe3 	bcc	3481a8e8 <hstrstr_r+0x20>
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
3481a958:	e59f3010 	ldr	r3, [pc, #16]	; 3481a970 <hstrstr_r+0xa8>
3481a95c:	e3a02003 	mov	r2, #3
	*retval = NULL;
3481a960:	e3a00000 	mov	r0, #0
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
3481a964:	e5832000 	str	r2, [r3]
	*retval = NULL;
3481a968:	e5850000 	str	r0, [r5]
	return 0;
}
3481a96c:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
3481a970:	3482bc40 	.word	0x3482bc40

3481a974 <hmatch_r>:

int hmatch_r(const char *match, int last_idx, ENTRY ** retval,
	     struct hsearch_data *htab)
{
3481a974:	e92d46f8 	push	{r3, r4, r5, r6, r7, r9, sl, lr}
3481a978:	e1a05001 	mov	r5, r1
3481a97c:	e1a09000 	mov	r9, r0
3481a980:	e1a04002 	mov	r4, r2
3481a984:	e1a07003 	mov	r7, r3
	unsigned int idx;
	size_t key_len = strlen(match);
3481a988:	eb0004ad 	bl	3481bc44 <strlen>

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481a98c:	e2855001 	add	r5, r5, #1
3481a990:	e3a0600c 	mov	r6, #12

int hmatch_r(const char *match, int last_idx, ENTRY ** retval,
	     struct hsearch_data *htab)
{
	unsigned int idx;
	size_t key_len = strlen(match);
3481a994:	e1a0a000 	mov	sl, r0

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481a998:	e0060596 	mul	r6, r6, r5
3481a99c:	ea000012 	b	3481a9ec <hmatch_r+0x78>
		if (htab->table[idx].used <= 0)
3481a9a0:	e5972000 	ldr	r2, [r7]
3481a9a4:	e0823006 	add	r3, r2, r6
3481a9a8:	e7922006 	ldr	r2, [r2, r6]
3481a9ac:	e3520000 	cmp	r2, #0
3481a9b0:	da00000b 	ble	3481a9e4 <hmatch_r+0x70>
			continue;
		if (!strncmp(match, htab->table[idx].entry.key, key_len)) {
3481a9b4:	e1a00009 	mov	r0, r9
3481a9b8:	e5931004 	ldr	r1, [r3, #4]
3481a9bc:	e1a0200a 	mov	r2, sl
3481a9c0:	eb000477 	bl	3481bba4 <strncmp>
3481a9c4:	e3500000 	cmp	r0, #0
3481a9c8:	1a000005 	bne	3481a9e4 <hmatch_r+0x70>
			*retval = &htab->table[idx].entry;
3481a9cc:	e5973000 	ldr	r3, [r7]
			return idx;
3481a9d0:	e1a00005 	mov	r0, r5

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
		if (htab->table[idx].used <= 0)
			continue;
		if (!strncmp(match, htab->table[idx].entry.key, key_len)) {
			*retval = &htab->table[idx].entry;
3481a9d4:	e0836006 	add	r6, r3, r6
3481a9d8:	e2866004 	add	r6, r6, #4
3481a9dc:	e5846000 	str	r6, [r4]
			return idx;
3481a9e0:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
	     struct hsearch_data *htab)
{
	unsigned int idx;
	size_t key_len = strlen(match);

	for (idx = last_idx + 1; idx < htab->size; ++idx) {
3481a9e4:	e2855001 	add	r5, r5, #1
3481a9e8:	e286600c 	add	r6, r6, #12
3481a9ec:	e5973004 	ldr	r3, [r7, #4]
3481a9f0:	e1550003 	cmp	r5, r3
3481a9f4:	3affffe9 	bcc	3481a9a0 <hmatch_r+0x2c>
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
3481a9f8:	e59f3010 	ldr	r3, [pc, #16]	; 3481aa10 <hmatch_r+0x9c>
3481a9fc:	e3a02003 	mov	r2, #3
	*retval = NULL;
3481aa00:	e3a00000 	mov	r0, #0
			*retval = &htab->table[idx].entry;
			return idx;
		}
	}

	__set_errno(ESRCH);
3481aa04:	e5832000 	str	r2, [r3]
	*retval = NULL;
3481aa08:	e5840000 	str	r0, [r4]
	return 0;
}
3481aa0c:	e8bd86f8 	pop	{r3, r4, r5, r6, r7, r9, sl, pc}
3481aa10:	3482bc40 	.word	0x3482bc40

3481aa14 <hsearch_r>:

int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
	      struct hsearch_data *htab)
{
3481aa14:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481aa18:	e24dd018 	sub	sp, sp, #24
3481aa1c:	e28dc010 	add	ip, sp, #16
3481aa20:	e88c0003 	stm	ip, {r0, r1}
3481aa24:	e58d2008 	str	r2, [sp, #8]
		return 1;
	}

	__set_errno(ESRCH);
	*retval = NULL;
	return 0;
3481aa28:	e59d2014 	ldr	r2, [sp, #20]
	return 0;
}

int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
	      struct hsearch_data *htab)
{
3481aa2c:	e1a07003 	mov	r7, r3
3481aa30:	e59d4038 	ldr	r4, [sp, #56]	; 0x38
		return 1;
	}

	__set_errno(ESRCH);
	*retval = NULL;
	return 0;
3481aa34:	e1a0b000 	mov	fp, r0
3481aa38:	e58d2004 	str	r2, [sp, #4]
int hsearch_r(ENTRY item, ACTION action, ENTRY ** retval,
	      struct hsearch_data *htab)
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
3481aa3c:	eb000480 	bl	3481bc44 <strlen>
3481aa40:	e1a0a000 	mov	sl, r0
	unsigned int first_deleted = 0;

	/* Compute an value for the given string. Perhaps use a better method. */
	hval = len;
	count = len;
	while (count-- > 0) {
3481aa44:	ea000002 	b	3481aa54 <hsearch_r+0x40>
3481aa48:	e24aa001 	sub	sl, sl, #1
		hval <<= 4;
		hval += item.key[count];
3481aa4c:	e7db300a 	ldrb	r3, [fp, sl]
3481aa50:	e0830200 	add	r0, r3, r0, lsl #4
	unsigned int first_deleted = 0;

	/* Compute an value for the given string. Perhaps use a better method. */
	hval = len;
	count = len;
	while (count-- > 0) {
3481aa54:	e35a0000 	cmp	sl, #0
3481aa58:	1afffffa 	bne	3481aa48 <hsearch_r+0x34>

	/*
	 * First hash function:
	 * simply take the modul but prevent zero.
	 */
	hval %= htab->size;
3481aa5c:	e5941004 	ldr	r1, [r4, #4]
3481aa60:	eb0014c9 	bl	3481fd8c <__aeabi_uidivmod>
	if (hval == 0)
		++hval;
3481aa64:	e3510000 	cmp	r1, #0
3481aa68:	11a06001 	movne	r6, r1
3481aa6c:	03a06001 	moveq	r6, #1

	/* The first index tried. */
	idx = hval;

	if (htab->table[idx].used) {
3481aa70:	e3a0300c 	mov	r3, #12
3481aa74:	e0090693 	mul	r9, r3, r6
3481aa78:	e5942000 	ldr	r2, [r4]
3481aa7c:	e7925009 	ldr	r5, [r2, r9]
3481aa80:	e0823009 	add	r3, r2, r9
3481aa84:	e3550000 	cmp	r5, #0
3481aa88:	01a05006 	moveq	r5, r6
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
	unsigned int idx;
	unsigned int first_deleted = 0;
3481aa8c:	058da00c 	streq	sl, [sp, #12]
		++hval;

	/* The first index tried. */
	idx = hval;

	if (htab->table[idx].used) {
3481aa90:	0a000067 	beq	3481ac34 <hsearch_r+0x220>
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
	unsigned int idx;
	unsigned int first_deleted = 0;
3481aa94:	e3750001 	cmn	r5, #1
3481aa98:	01a02006 	moveq	r2, r6
3481aa9c:	13a02000 	movne	r2, #0

		if (htab->table[idx].used == -1
		    && !first_deleted)
			first_deleted = idx;

		if (htab->table[idx].used == hval
3481aaa0:	e1550006 	cmp	r5, r6
{
	unsigned int hval;
	unsigned int count;
	unsigned int len = strlen(item.key);
	unsigned int idx;
	unsigned int first_deleted = 0;
3481aaa4:	e58d200c 	str	r2, [sp, #12]

		if (htab->table[idx].used == -1
		    && !first_deleted)
			first_deleted = idx;

		if (htab->table[idx].used == hval
3481aaa8:	1a000023 	bne	3481ab3c <hsearch_r+0x128>
		    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
3481aaac:	e1a0000b 	mov	r0, fp
3481aab0:	e5931004 	ldr	r1, [r3, #4]
3481aab4:	eb00042e 	bl	3481bb74 <strcmp>
3481aab8:	e3500000 	cmp	r0, #0
3481aabc:	1a00001e 	bne	3481ab3c <hsearch_r+0x128>
			/* Overwrite existing value? */
			if ((action == ENTER) && (item.data != NULL)) {
3481aac0:	e59d3008 	ldr	r3, [sp, #8]
3481aac4:	e3530001 	cmp	r3, #1
3481aac8:	1a000016 	bne	3481ab28 <hsearch_r+0x114>
3481aacc:	e59d2004 	ldr	r2, [sp, #4]
3481aad0:	e3520000 	cmp	r2, #0
3481aad4:	0a000013 	beq	3481ab28 <hsearch_r+0x114>
				free(htab->table[idx].entry.data);
3481aad8:	e5943000 	ldr	r3, [r4]
3481aadc:	e0833009 	add	r3, r3, r9
3481aae0:	e5930008 	ldr	r0, [r3, #8]
3481aae4:	ebffbadc 	bl	3480965c <free>
				htab->table[idx].entry.data =
					strdup(item.data);
3481aae8:	e59d0004 	ldr	r0, [sp, #4]
		if (htab->table[idx].used == hval
		    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
			/* Overwrite existing value? */
			if ((action == ENTER) && (item.data != NULL)) {
				free(htab->table[idx].entry.data);
				htab->table[idx].entry.data =
3481aaec:	e5946000 	ldr	r6, [r4]
					strdup(item.data);
3481aaf0:	eb000488 	bl	3481bd18 <strdup>
				if (!htab->table[idx].entry.data) {
3481aaf4:	e5943000 	ldr	r3, [r4]
		if (htab->table[idx].used == hval
		    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
			/* Overwrite existing value? */
			if ((action == ENTER) && (item.data != NULL)) {
				free(htab->table[idx].entry.data);
				htab->table[idx].entry.data =
3481aaf8:	e0866009 	add	r6, r6, r9
3481aafc:	e5860008 	str	r0, [r6, #8]
					strdup(item.data);
				if (!htab->table[idx].entry.data) {
3481ab00:	e0833009 	add	r3, r3, r9
3481ab04:	e5933008 	ldr	r3, [r3, #8]
3481ab08:	e3530000 	cmp	r3, #0
3481ab0c:	1a000005 	bne	3481ab28 <hsearch_r+0x114>
					__set_errno(ENOMEM);
3481ab10:	e59f31dc 	ldr	r3, [pc, #476]	; 3481acf4 <hsearch_r+0x2e0>
3481ab14:	e3a0200c 	mov	r2, #12
3481ab18:	e5832000 	str	r2, [r3]
					*retval = NULL;
					return 0;
3481ab1c:	e1a0500a 	mov	r5, sl
				free(htab->table[idx].entry.data);
				htab->table[idx].entry.data =
					strdup(item.data);
				if (!htab->table[idx].entry.data) {
					__set_errno(ENOMEM);
					*retval = NULL;
3481ab20:	e587a000 	str	sl, [r7]
					return 0;
3481ab24:	ea00006f 	b	3481ace8 <hsearch_r+0x2d4>
				}
			}
			/* return found entry */
			*retval = &htab->table[idx].entry;
3481ab28:	e5943000 	ldr	r3, [r4]
3481ab2c:	e0839009 	add	r9, r3, r9
3481ab30:	e2899004 	add	r9, r9, #4
3481ab34:	e5879000 	str	r9, [r7]
			return idx;
3481ab38:	ea00006a 	b	3481ace8 <hsearch_r+0x2d4>

		/*
		 * Second hash function:
		 * as suggested in [Knuth]
		 */
		hval2 = 1 + hval % (htab->size - 2);
3481ab3c:	e5941004 	ldr	r1, [r4, #4]
3481ab40:	e1a00006 	mov	r0, r6
3481ab44:	e2411002 	sub	r1, r1, #2
3481ab48:	eb00148f 	bl	3481fd8c <__aeabi_uidivmod>
3481ab4c:	e1a05006 	mov	r5, r6
3481ab50:	e2819001 	add	r9, r1, #1
			 */
			if (idx == hval)
				break;

			/* If entry is found use it. */
			if ((htab->table[idx].used == hval)
3481ab54:	e3a0c00c 	mov	ip, #12
		do {
			/*
			 * Because SIZE is prime this guarantees to
			 * step through all available indices.
			 */
			if (idx <= hval2)
3481ab58:	e1550009 	cmp	r5, r9
				idx = htab->size + idx - hval2;
3481ab5c:	95943004 	ldrls	r3, [r4, #4]
			else
				idx -= hval2;
3481ab60:	80695005 	rsbhi	r5, r9, r5
			/*
			 * Because SIZE is prime this guarantees to
			 * step through all available indices.
			 */
			if (idx <= hval2)
				idx = htab->size + idx - hval2;
3481ab64:	90693003 	rsbls	r3, r9, r3
3481ab68:	90855003 	addls	r5, r5, r3

			/*
			 * If we visited all entries leave the loop
			 * unsuccessfully.
			 */
			if (idx == hval)
3481ab6c:	e1550006 	cmp	r5, r6
3481ab70:	0a00002f 	beq	3481ac34 <hsearch_r+0x220>
				break;

			/* If entry is found use it. */
			if ((htab->table[idx].used == hval)
3481ab74:	e00a059c 	mul	sl, ip, r5
3481ab78:	e5942000 	ldr	r2, [r4]
3481ab7c:	e082300a 	add	r3, r2, sl
3481ab80:	e792200a 	ldr	r2, [r2, sl]
3481ab84:	e1520006 	cmp	r2, r6
3481ab88:	1a000025 	bne	3481ac24 <hsearch_r+0x210>
			    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
3481ab8c:	e5931004 	ldr	r1, [r3, #4]
3481ab90:	e1a0000b 	mov	r0, fp
3481ab94:	e58dc000 	str	ip, [sp]
3481ab98:	eb0003f5 	bl	3481bb74 <strcmp>
3481ab9c:	e3500000 	cmp	r0, #0
3481aba0:	e59dc000 	ldr	ip, [sp]
3481aba4:	1a00001e 	bne	3481ac24 <hsearch_r+0x210>
				/* Overwrite existing value? */
				if ((action == ENTER) && (item.data != NULL)) {
3481aba8:	e59d3008 	ldr	r3, [sp, #8]
3481abac:	e3530001 	cmp	r3, #1
3481abb0:	1a000016 	bne	3481ac10 <hsearch_r+0x1fc>
3481abb4:	e59d2004 	ldr	r2, [sp, #4]
3481abb8:	e3520000 	cmp	r2, #0
3481abbc:	0a000013 	beq	3481ac10 <hsearch_r+0x1fc>
					free(htab->table[idx].entry.data);
3481abc0:	e5943000 	ldr	r3, [r4]
3481abc4:	e083300a 	add	r3, r3, sl
3481abc8:	e5930008 	ldr	r0, [r3, #8]
3481abcc:	ebffbaa2 	bl	3480965c <free>
					htab->table[idx].entry.data =
						strdup(item.data);
3481abd0:	e59d0004 	ldr	r0, [sp, #4]
			if ((htab->table[idx].used == hval)
			    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
				/* Overwrite existing value? */
				if ((action == ENTER) && (item.data != NULL)) {
					free(htab->table[idx].entry.data);
					htab->table[idx].entry.data =
3481abd4:	e5946000 	ldr	r6, [r4]
						strdup(item.data);
3481abd8:	eb00044e 	bl	3481bd18 <strdup>
					if (!htab->table[idx].entry.data) {
3481abdc:	e5943000 	ldr	r3, [r4]
			if ((htab->table[idx].used == hval)
			    && strcmp(item.key, htab->table[idx].entry.key) == 0) {
				/* Overwrite existing value? */
				if ((action == ENTER) && (item.data != NULL)) {
					free(htab->table[idx].entry.data);
					htab->table[idx].entry.data =
3481abe0:	e086600a 	add	r6, r6, sl
3481abe4:	e5860008 	str	r0, [r6, #8]
						strdup(item.data);
					if (!htab->table[idx].entry.data) {
3481abe8:	e083300a 	add	r3, r3, sl
3481abec:	e5933008 	ldr	r3, [r3, #8]
3481abf0:	e3530000 	cmp	r3, #0
3481abf4:	1a000005 	bne	3481ac10 <hsearch_r+0x1fc>
						__set_errno(ENOMEM);
3481abf8:	e59f20f4 	ldr	r2, [pc, #244]	; 3481acf4 <hsearch_r+0x2e0>
3481abfc:	e3a0100c 	mov	r1, #12
3481ac00:	e5821000 	str	r1, [r2]
						*retval = NULL;
						return 0;
3481ac04:	e1a05003 	mov	r5, r3
					free(htab->table[idx].entry.data);
					htab->table[idx].entry.data =
						strdup(item.data);
					if (!htab->table[idx].entry.data) {
						__set_errno(ENOMEM);
						*retval = NULL;
3481ac08:	e5873000 	str	r3, [r7]
						return 0;
3481ac0c:	ea000035 	b	3481ace8 <hsearch_r+0x2d4>
					}
				}
				/* return found entry */
				*retval = &htab->table[idx].entry;
3481ac10:	e5943000 	ldr	r3, [r4]
3481ac14:	e083a00a 	add	sl, r3, sl
3481ac18:	e28aa004 	add	sl, sl, #4
3481ac1c:	e587a000 	str	sl, [r7]
				return idx;
3481ac20:	ea000030 	b	3481ace8 <hsearch_r+0x2d4>
			}
		}
		while (htab->table[idx].used);
3481ac24:	e5943000 	ldr	r3, [r4]
3481ac28:	e793300a 	ldr	r3, [r3, sl]
3481ac2c:	e3530000 	cmp	r3, #0
3481ac30:	1affffc8 	bne	3481ab58 <hsearch_r+0x144>
	}

	/* An empty bucket has been found. */
	if (action == ENTER) {
3481ac34:	e59d3008 	ldr	r3, [sp, #8]
3481ac38:	e3530001 	cmp	r3, #1
		/* return new entry */
		*retval = &htab->table[idx].entry;
		return 1;
	}

	__set_errno(ESRCH);
3481ac3c:	13a02003 	movne	r2, #3
		}
		while (htab->table[idx].used);
	}

	/* An empty bucket has been found. */
	if (action == ENTER) {
3481ac40:	1a000024 	bne	3481acd8 <hsearch_r+0x2c4>
		/*
		 * If table is full and another entry should be
		 * entered return with error.
		 */
		if (htab->filled == htab->size) {
3481ac44:	e5942008 	ldr	r2, [r4, #8]
3481ac48:	e5943004 	ldr	r3, [r4, #4]
3481ac4c:	e1520003 	cmp	r2, r3
3481ac50:	0a000017 	beq	3481acb4 <hsearch_r+0x2a0>

		/*
		 * Create new entry;
		 * create copies of item.key and item.data
		 */
		if (first_deleted)
3481ac54:	e59d200c 	ldr	r2, [sp, #12]
			idx = first_deleted;

		htab->table[idx].used = hval;
3481ac58:	e3a0300c 	mov	r3, #12

		/*
		 * Create new entry;
		 * create copies of item.key and item.data
		 */
		if (first_deleted)
3481ac5c:	e3520000 	cmp	r2, #0
3481ac60:	11a05002 	movne	r5, r2
			idx = first_deleted;

		htab->table[idx].used = hval;
3481ac64:	e0050593 	mul	r5, r3, r5
3481ac68:	e5943000 	ldr	r3, [r4]
		htab->table[idx].entry.key = strdup(item.key);
3481ac6c:	e1a0000b 	mov	r0, fp
		 * create copies of item.key and item.data
		 */
		if (first_deleted)
			idx = first_deleted;

		htab->table[idx].used = hval;
3481ac70:	e7836005 	str	r6, [r3, r5]
3481ac74:	e083a005 	add	sl, r3, r5
		htab->table[idx].entry.key = strdup(item.key);
3481ac78:	eb000426 	bl	3481bd18 <strdup>
3481ac7c:	e58a0004 	str	r0, [sl, #4]
		htab->table[idx].entry.data = strdup(item.data);
3481ac80:	e59d0004 	ldr	r0, [sp, #4]
3481ac84:	e5946000 	ldr	r6, [r4]
3481ac88:	eb000422 	bl	3481bd18 <strdup>
		if (!htab->table[idx].entry.key ||
3481ac8c:	e5943000 	ldr	r3, [r4]
		if (first_deleted)
			idx = first_deleted;

		htab->table[idx].used = hval;
		htab->table[idx].entry.key = strdup(item.key);
		htab->table[idx].entry.data = strdup(item.data);
3481ac90:	e0866005 	add	r6, r6, r5
		if (!htab->table[idx].entry.key ||
3481ac94:	e0835005 	add	r5, r3, r5
3481ac98:	e5953004 	ldr	r3, [r5, #4]
		if (first_deleted)
			idx = first_deleted;

		htab->table[idx].used = hval;
		htab->table[idx].entry.key = strdup(item.key);
		htab->table[idx].entry.data = strdup(item.data);
3481ac9c:	e5860008 	str	r0, [r6, #8]
		if (!htab->table[idx].entry.key ||
3481aca0:	e3530000 	cmp	r3, #0
3481aca4:	0a000002 	beq	3481acb4 <hsearch_r+0x2a0>
3481aca8:	e5953008 	ldr	r3, [r5, #8]
3481acac:	e3530000 	cmp	r3, #0
3481acb0:	1a000001 	bne	3481acbc <hsearch_r+0x2a8>
		    !htab->table[idx].entry.data) {
			__set_errno(ENOMEM);
3481acb4:	e3a0200c 	mov	r2, #12
3481acb8:	ea000006 	b	3481acd8 <hsearch_r+0x2c4>
			*retval = NULL;
			return 0;
		}

		++htab->filled;
3481acbc:	e5943008 	ldr	r3, [r4, #8]

		/* return new entry */
		*retval = &htab->table[idx].entry;
3481acc0:	e2855004 	add	r5, r5, #4
			__set_errno(ENOMEM);
			*retval = NULL;
			return 0;
		}

		++htab->filled;
3481acc4:	e2833001 	add	r3, r3, #1
3481acc8:	e5843008 	str	r3, [r4, #8]

		/* return new entry */
		*retval = &htab->table[idx].entry;
3481accc:	e5875000 	str	r5, [r7]
		return 1;
3481acd0:	e59d5008 	ldr	r5, [sp, #8]
3481acd4:	ea000003 	b	3481ace8 <hsearch_r+0x2d4>
	}

	__set_errno(ESRCH);
3481acd8:	e59f3014 	ldr	r3, [pc, #20]	; 3481acf4 <hsearch_r+0x2e0>
	*retval = NULL;
3481acdc:	e3a05000 	mov	r5, #0
		/* return new entry */
		*retval = &htab->table[idx].entry;
		return 1;
	}

	__set_errno(ESRCH);
3481ace0:	e5832000 	str	r2, [r3]
	*retval = NULL;
3481ace4:	e5875000 	str	r5, [r7]
	return 0;
}
3481ace8:	e1a00005 	mov	r0, r5
3481acec:	e28dd018 	add	sp, sp, #24
3481acf0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481acf4:	3482bc40 	.word	0x3482bc40

3481acf8 <hdelete_r>:
 * to delete any entries from the hash table.  We extend the code to
 * do that.
 */

int hdelete_r(const char *key, struct hsearch_data *htab, int do_apply)
{
3481acf8:	e92d4070 	push	{r4, r5, r6, lr}
3481acfc:	e24dd018 	sub	sp, sp, #24
	ENTRY e, *ep;
	int idx;

	debug("hdelete: DELETE key \"%s\"\n", key);

	e.key = (char *)key;
3481ad00:	e58d000c 	str	r0, [sp, #12]

	if ((idx = hsearch_r(e, FIND, &ep, htab)) == 0) {
3481ad04:	e58d1000 	str	r1, [sp]
3481ad08:	e28d300c 	add	r3, sp, #12
 * to delete any entries from the hash table.  We extend the code to
 * do that.
 */

int hdelete_r(const char *key, struct hsearch_data *htab, int do_apply)
{
3481ad0c:	e1a04001 	mov	r4, r1
3481ad10:	e1a06002 	mov	r6, r2

	debug("hdelete: DELETE key \"%s\"\n", key);

	e.key = (char *)key;

	if ((idx = hsearch_r(e, FIND, &ep, htab)) == 0) {
3481ad14:	e8930003 	ldm	r3, {r0, r1}
3481ad18:	e3a02000 	mov	r2, #0
3481ad1c:	e28d3014 	add	r3, sp, #20
3481ad20:	ebffff3b 	bl	3481aa14 <hsearch_r>
3481ad24:	e2505000 	subs	r5, r0, #0
		__set_errno(ESRCH);
3481ad28:	059f3078 	ldreq	r3, [pc, #120]	; 3481ada8 <hdelete_r+0xb0>
3481ad2c:	03a02003 	moveq	r2, #3
3481ad30:	05832000 	streq	r2, [r3]
		return 0;	/* not found */
3481ad34:	01a00005 	moveq	r0, r5
3481ad38:	0a000018 	beq	3481ada0 <hdelete_r+0xa8>
	}

	/* free used ENTRY */
	debug("hdelete: DELETING key \"%s\"\n", key);
	if (do_apply && htab->apply != NULL)
3481ad3c:	e3560000 	cmp	r6, #0
3481ad40:	0a000007 	beq	3481ad64 <hdelete_r+0x6c>
3481ad44:	e594c00c 	ldr	ip, [r4, #12]
3481ad48:	e35c0000 	cmp	ip, #0
3481ad4c:	0a000004 	beq	3481ad64 <hdelete_r+0x6c>
		htab->apply(ep->key, ep->data, NULL, H_FORCE);
3481ad50:	e59d3014 	ldr	r3, [sp, #20]
3481ad54:	e3a02000 	mov	r2, #0
3481ad58:	e8930003 	ldm	r3, {r0, r1}
3481ad5c:	e3a03002 	mov	r3, #2
3481ad60:	e12fff3c 	blx	ip
	free((void *)ep->key);
3481ad64:	e59d3014 	ldr	r3, [sp, #20]
3481ad68:	e5930000 	ldr	r0, [r3]
3481ad6c:	ebffba3a 	bl	3480965c <free>
	free(ep->data);
3481ad70:	e59d3014 	ldr	r3, [sp, #20]
3481ad74:	e5930004 	ldr	r0, [r3, #4]
3481ad78:	ebffba37 	bl	3480965c <free>
	htab->table[idx].used = -1;
3481ad7c:	e3a0200c 	mov	r2, #12
3481ad80:	e0050592 	mul	r5, r2, r5
3481ad84:	e5943000 	ldr	r3, [r4]
3481ad88:	e3e02000 	mvn	r2, #0
3481ad8c:	e7832005 	str	r2, [r3, r5]

	--htab->filled;
3481ad90:	e5943008 	ldr	r3, [r4, #8]

	return 1;
3481ad94:	e3a00001 	mov	r0, #1
		htab->apply(ep->key, ep->data, NULL, H_FORCE);
	free((void *)ep->key);
	free(ep->data);
	htab->table[idx].used = -1;

	--htab->filled;
3481ad98:	e0833002 	add	r3, r3, r2
3481ad9c:	e5843008 	str	r3, [r4, #8]

	return 1;
}
3481ada0:	e28dd018 	add	sp, sp, #24
3481ada4:	e8bd8070 	pop	{r4, r5, r6, pc}
3481ada8:	3482bc40 	.word	0x3482bc40

3481adac <hexport_r>:
}

ssize_t hexport_r(struct hsearch_data *htab, const char sep,
		 char **resp, size_t size,
		 int argc, char * const argv[])
{
3481adac:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481adb0:	e28db01c 	add	fp, sp, #28
3481adb4:	e24dd018 	sub	sp, sp, #24
3481adb8:	e1a04003 	mov	r4, r3
	ENTRY *list[htab->size];
3481adbc:	e5903004 	ldr	r3, [r0, #4]
	char *res, *p;
	size_t totlen;
	int i, n;

	/* Test for correct arguments.  */
	if ((resp == NULL) || (htab == NULL)) {
3481adc0:	e3520000 	cmp	r2, #0

ssize_t hexport_r(struct hsearch_data *htab, const char sep,
		 char **resp, size_t size,
		 int argc, char * const argv[])
{
	ENTRY *list[htab->size];
3481adc4:	e1a03103 	lsl	r3, r3, #2
3481adc8:	e283300e 	add	r3, r3, #14
3481adcc:	e3c33007 	bic	r3, r3, #7
3481add0:	e04dd003 	sub	sp, sp, r3
}

ssize_t hexport_r(struct hsearch_data *htab, const char sep,
		 char **resp, size_t size,
		 int argc, char * const argv[])
{
3481add4:	e1a05000 	mov	r5, r0
3481add8:	e1a07001 	mov	r7, r1
	ENTRY *list[htab->size];
3481addc:	e50bd028 	str	sp, [fp, #-40]	; 0x28
	char *res, *p;
	size_t totlen;
	int i, n;

	/* Test for correct arguments.  */
	if ((resp == NULL) || (htab == NULL)) {
3481ade0:	e50b202c 	str	r2, [fp, #-44]	; 0x2c
3481ade4:	0a000006 	beq	3481ae04 <hexport_r+0x58>
3481ade8:	e3a06000 	mov	r6, #0
3481adec:	e3a02001 	mov	r2, #1
3481adf0:	e3a0900c 	mov	r9, #12
3481adf4:	e50b2024 	str	r2, [fp, #-36]	; 0x24
3481adf8:	e50b6020 	str	r6, [fp, #-32]
3481adfc:	e50b4030 	str	r4, [fp, #-48]	; 0x30
3481ae00:	ea000041 	b	3481af0c <hexport_r+0x160>
		__set_errno(EINVAL);
3481ae04:	e3a02016 	mov	r2, #22
3481ae08:	ea000054 	b	3481af60 <hexport_r+0x1b4>
	 * search used entries,
	 * save addresses and compute total length
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {

		if (htab->table[i].used > 0) {
3481ae0c:	e5953000 	ldr	r3, [r5]
3481ae10:	e0834009 	add	r4, r3, r9
3481ae14:	e7933009 	ldr	r3, [r3, r9]
3481ae18:	e3530000 	cmp	r3, #0
3481ae1c:	da000036 	ble	3481aefc <hexport_r+0x150>
3481ae20:	e59b3008 	ldr	r3, [fp, #8]
3481ae24:	e1a02006 	mov	r2, r6
			ENTRY *ep = &htab->table[i].entry;
			int arg, found = 0;

			for (arg = 0; arg < argc; ++arg) {
3481ae28:	e3a0a000 	mov	sl, #0
3481ae2c:	e1a06003 	mov	r6, r3
3481ae30:	ea000007 	b	3481ae54 <hexport_r+0xa8>
				if (strcmp(argv[arg], ep->key) == 0) {
3481ae34:	e4960004 	ldr	r0, [r6], #4
3481ae38:	e5941004 	ldr	r1, [r4, #4]
3481ae3c:	e50b2034 	str	r2, [fp, #-52]	; 0x34
3481ae40:	eb00034b 	bl	3481bb74 <strcmp>
3481ae44:	e3500000 	cmp	r0, #0
3481ae48:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
3481ae4c:	0a000006 	beq	3481ae6c <hexport_r+0xc0>

		if (htab->table[i].used > 0) {
			ENTRY *ep = &htab->table[i].entry;
			int arg, found = 0;

			for (arg = 0; arg < argc; ++arg) {
3481ae50:	e28aa001 	add	sl, sl, #1
3481ae54:	e59b3004 	ldr	r3, [fp, #4]
3481ae58:	e15a0003 	cmp	sl, r3
3481ae5c:	bafffff4 	blt	3481ae34 <hexport_r+0x88>
3481ae60:	e1a06002 	mov	r6, r2
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {

		if (htab->table[i].used > 0) {
			ENTRY *ep = &htab->table[i].entry;
			int arg, found = 0;
3481ae64:	e3a03000 	mov	r3, #0
3481ae68:	ea000001 	b	3481ae74 <hexport_r+0xc8>
3481ae6c:	e1a06002 	mov	r6, r2

			for (arg = 0; arg < argc; ++arg) {
				if (strcmp(argv[arg], ep->key) == 0) {
					found = 1;
3481ae70:	e3a03001 	mov	r3, #1
					break;
				}
			}
			if ((argc > 0) && (found == 0))
3481ae74:	e59b2004 	ldr	r2, [fp, #4]
3481ae78:	e2233001 	eor	r3, r3, #1
3481ae7c:	e3520000 	cmp	r2, #0
3481ae80:	d3a03000 	movle	r3, #0
3481ae84:	c2033001 	andgt	r3, r3, #1
3481ae88:	e3530000 	cmp	r3, #0
3481ae8c:	1a00001a 	bne	3481aefc <hexport_r+0x150>
				continue;

			list[n++] = ep;
3481ae90:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
	 * save addresses and compute total length
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {

		if (htab->table[i].used > 0) {
			ENTRY *ep = &htab->table[i].entry;
3481ae94:	e2843004 	add	r3, r4, #4
				}
			}
			if ((argc > 0) && (found == 0))
				continue;

			list[n++] = ep;
3481ae98:	e7823106 	str	r3, [r2, r6, lsl #2]

			totlen += strlen(ep->key) + 2;
3481ae9c:	e5940004 	ldr	r0, [r4, #4]
3481aea0:	eb000367 	bl	3481bc44 <strlen>
3481aea4:	e51b3020 	ldr	r3, [fp, #-32]

			if (sep == '\0') {
3481aea8:	e3570000 	cmp	r7, #0
			if ((argc > 0) && (found == 0))
				continue;

			list[n++] = ep;

			totlen += strlen(ep->key) + 2;
3481aeac:	e283a002 	add	sl, r3, #2
				}
			}
			if ((argc > 0) && (found == 0))
				continue;

			list[n++] = ep;
3481aeb0:	e2866001 	add	r6, r6, #1

			totlen += strlen(ep->key) + 2;
3481aeb4:	e08aa000 	add	sl, sl, r0

			if (sep == '\0') {
				totlen += strlen(ep->data);
3481aeb8:	15942008 	ldrne	r2, [r4, #8]

			list[n++] = ep;

			totlen += strlen(ep->key) + 2;

			if (sep == '\0') {
3481aebc:	1a000009 	bne	3481aee8 <hexport_r+0x13c>
				totlen += strlen(ep->data);
3481aec0:	e5940008 	ldr	r0, [r4, #8]
3481aec4:	eb00035e 	bl	3481bc44 <strlen>
3481aec8:	e08aa000 	add	sl, sl, r0
3481aecc:	ea000008 	b	3481aef4 <hexport_r+0x148>
				char *s = ep->data;

				while (*s) {
					++totlen;
					/* add room for needed escape chars */
					if ((*s == sep) || (*s == '\\'))
3481aed0:	e1530007 	cmp	r3, r7
				totlen += strlen(ep->data);
			} else {	/* check if escapes are needed */
				char *s = ep->data;

				while (*s) {
					++totlen;
3481aed4:	e28aa001 	add	sl, sl, #1
					/* add room for needed escape chars */
					if ((*s == sep) || (*s == '\\'))
3481aed8:	0a000001 	beq	3481aee4 <hexport_r+0x138>
3481aedc:	e353005c 	cmp	r3, #92	; 0x5c
3481aee0:	1a000000 	bne	3481aee8 <hexport_r+0x13c>
						++totlen;
3481aee4:	e28aa001 	add	sl, sl, #1
			if (sep == '\0') {
				totlen += strlen(ep->data);
			} else {	/* check if escapes are needed */
				char *s = ep->data;

				while (*s) {
3481aee8:	e4d23001 	ldrb	r3, [r2], #1
3481aeec:	e3530000 	cmp	r3, #0
3481aef0:	1afffff6 	bne	3481aed0 <hexport_r+0x124>
					if ((*s == sep) || (*s == '\\'))
						++totlen;
					++s;
				}
			}
			totlen += 2;	/* for '=' and 'sep' char */
3481aef4:	e28aa002 	add	sl, sl, #2
3481aef8:	e50ba020 	str	sl, [fp, #-32]
	/*
	 * Pass 1:
	 * search used entries,
	 * save addresses and compute total length
	 */
	for (i = 1, n = 0, totlen = 0; i <= htab->size; ++i) {
3481aefc:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
3481af00:	e289900c 	add	r9, r9, #12
3481af04:	e2822001 	add	r2, r2, #1
3481af08:	e50b2024 	str	r2, [fp, #-36]	; 0x24
3481af0c:	e5953004 	ldr	r3, [r5, #4]
3481af10:	e51b2024 	ldr	r2, [fp, #-36]	; 0x24
3481af14:	e1520003 	cmp	r2, r3
3481af18:	9affffbb 	bls	3481ae0c <hexport_r+0x60>
		       i, list[i], list[i]->key, list[i]->data);
	}
#endif

	/* Sort list by keys */
	qsort(list, n, sizeof(ENTRY *), cmpkey);
3481af1c:	e3a02004 	mov	r2, #4
3481af20:	e59f3124 	ldr	r3, [pc, #292]	; 3481b04c <hexport_r+0x2a0>
3481af24:	e51b0028 	ldr	r0, [fp, #-40]	; 0x28
3481af28:	e1a01006 	mov	r1, r6
3481af2c:	e51b4030 	ldr	r4, [fp, #-48]	; 0x30
3481af30:	eb0002a0 	bl	3481b9b8 <qsort>
3481af34:	e51b3020 	ldr	r3, [fp, #-32]

	/* Check if the user supplied buffer size is sufficient */
	if (size) {
3481af38:	e3540000 	cmp	r4, #0
3481af3c:	e2832001 	add	r2, r3, #1
				"but need %zu\n", size, totlen + 1);
			__set_errno(ENOMEM);
			return (-1);
		}
	} else {
		size = totlen + 1;
3481af40:	01a04002 	moveq	r4, r2

	/* Sort list by keys */
	qsort(list, n, sizeof(ENTRY *), cmpkey);

	/* Check if the user supplied buffer size is sufficient */
	if (size) {
3481af44:	0a000009 	beq	3481af70 <hexport_r+0x1c4>
		if (size < totlen + 1) {	/* provided buffer too small */
3481af48:	e1540002 	cmp	r4, r2
3481af4c:	2a000007 	bcs	3481af70 <hexport_r+0x1c4>
			printf("Env export buffer too small: %zu, "
3481af50:	e59f00f8 	ldr	r0, [pc, #248]	; 3481b050 <hexport_r+0x2a4>
3481af54:	e1a01004 	mov	r1, r4
3481af58:	ebffb881 	bl	34809164 <printf>
				"but need %zu\n", size, totlen + 1);
			__set_errno(ENOMEM);
3481af5c:	e3a0200c 	mov	r2, #12
3481af60:	e59f30ec 	ldr	r3, [pc, #236]	; 3481b054 <hexport_r+0x2a8>
			return (-1);
3481af64:	e3e00000 	mvn	r0, #0
	/* Check if the user supplied buffer size is sufficient */
	if (size) {
		if (size < totlen + 1) {	/* provided buffer too small */
			printf("Env export buffer too small: %zu, "
				"but need %zu\n", size, totlen + 1);
			__set_errno(ENOMEM);
3481af68:	e5832000 	str	r2, [r3]
3481af6c:	ea000034 	b	3481b044 <hexport_r+0x298>
	} else {
		size = totlen + 1;
	}

	/* Check if the user provided a buffer */
	if (*resp) {
3481af70:	e51b202c 	ldr	r2, [fp, #-44]	; 0x2c
3481af74:	e5925000 	ldr	r5, [r2]
3481af78:	e3550000 	cmp	r5, #0
3481af7c:	0a000008 	beq	3481afa4 <hexport_r+0x1f8>
		/* yes; clear it */
		res = *resp;
		memset(res, '\0', size);
3481af80:	e1a00005 	mov	r0, r5
3481af84:	e3a01000 	mov	r1, #0
3481af88:	e1a02004 	mov	r2, r4
3481af8c:	eb0003cc 	bl	3481bec4 <memset>
3481af90:	e51b2028 	ldr	r2, [fp, #-40]	; 0x28
	} else {
		/* no, allocate and clear one */
		*resp = res = calloc(1, size);
		if (res == NULL) {
3481af94:	e3a03000 	mov	r3, #0
		const char *s;

		s = list[i]->key;
		while (*s)
			*p++ = *s++;
		*p++ = '=';
3481af98:	e3a0a03d 	mov	sl, #61	; 0x3d

		s = list[i]->data;

		while (*s) {
			if ((*s == sep) || (*s == '\\'))
				*p++ = '\\';	/* escape */
3481af9c:	e3a0905c 	mov	r9, #92	; 0x5c
3481afa0:	ea000022 	b	3481b030 <hexport_r+0x284>
		/* yes; clear it */
		res = *resp;
		memset(res, '\0', size);
	} else {
		/* no, allocate and clear one */
		*resp = res = calloc(1, size);
3481afa4:	e3a00001 	mov	r0, #1
3481afa8:	e1a01004 	mov	r1, r4
3481afac:	ebffbba0 	bl	34809e34 <calloc>
3481afb0:	e51b302c 	ldr	r3, [fp, #-44]	; 0x2c
		if (res == NULL) {
3481afb4:	e3500000 	cmp	r0, #0
		/* yes; clear it */
		res = *resp;
		memset(res, '\0', size);
	} else {
		/* no, allocate and clear one */
		*resp = res = calloc(1, size);
3481afb8:	e5830000 	str	r0, [r3]
		if (res == NULL) {
3481afbc:	11a05000 	movne	r5, r0
3481afc0:	1afffff2 	bne	3481af90 <hexport_r+0x1e4>
3481afc4:	eaffffe4 	b	3481af5c <hexport_r+0x1b0>
	 * export sorted list of result data
	 */
	for (i = 0, p = res; i < n; ++i) {
		const char *s;

		s = list[i]->key;
3481afc8:	e4921004 	ldr	r1, [r2], #4
3481afcc:	e5911000 	ldr	r1, [r1]
		while (*s)
3481afd0:	ea000001 	b	3481afdc <hexport_r+0x230>
			*p++ = *s++;
3481afd4:	e5c50000 	strb	r0, [r5]
3481afd8:	e1a0500c 	mov	r5, ip
	 */
	for (i = 0, p = res; i < n; ++i) {
		const char *s;

		s = list[i]->key;
		while (*s)
3481afdc:	e4d10001 	ldrb	r0, [r1], #1
3481afe0:	e285c001 	add	ip, r5, #1
3481afe4:	e3500000 	cmp	r0, #0
3481afe8:	1afffff9 	bne	3481afd4 <hexport_r+0x228>
			*p++ = *s++;
		*p++ = '=';
3481afec:	e5c5a000 	strb	sl, [r5]

		s = list[i]->data;
3481aff0:	e5121004 	ldr	r1, [r2, #-4]
		const char *s;

		s = list[i]->key;
		while (*s)
			*p++ = *s++;
		*p++ = '=';
3481aff4:	e1a0500c 	mov	r5, ip
3481aff8:	e5911004 	ldr	r1, [r1, #4]

		s = list[i]->data;

		while (*s) {
3481affc:	ea000006 	b	3481b01c <hexport_r+0x270>
			if ((*s == sep) || (*s == '\\'))
3481b000:	e1500007 	cmp	r0, r7
3481b004:	0a000001 	beq	3481b010 <hexport_r+0x264>
3481b008:	e350005c 	cmp	r0, #92	; 0x5c
3481b00c:	1a000000 	bne	3481b014 <hexport_r+0x268>
				*p++ = '\\';	/* escape */
3481b010:	e4c59001 	strb	r9, [r5], #1
			*p++ = *s++;
3481b014:	e5510001 	ldrb	r0, [r1, #-1]
3481b018:	e4c50001 	strb	r0, [r5], #1
			*p++ = *s++;
		*p++ = '=';

		s = list[i]->data;

		while (*s) {
3481b01c:	e4d10001 	ldrb	r0, [r1], #1
3481b020:	e3500000 	cmp	r0, #0
3481b024:	1afffff5 	bne	3481b000 <hexport_r+0x254>
			if ((*s == sep) || (*s == '\\'))
				*p++ = '\\';	/* escape */
			*p++ = *s++;
		}
		*p++ = sep;
3481b028:	e4c57001 	strb	r7, [r5], #1
	}
	/*
	 * Pass 2:
	 * export sorted list of result data
	 */
	for (i = 0, p = res; i < n; ++i) {
3481b02c:	e2833001 	add	r3, r3, #1
3481b030:	e1530006 	cmp	r3, r6
3481b034:	baffffe3 	blt	3481afc8 <hexport_r+0x21c>
				*p++ = '\\';	/* escape */
			*p++ = *s++;
		}
		*p++ = sep;
	}
	*p = '\0';		/* terminate result */
3481b038:	e3a03000 	mov	r3, #0
3481b03c:	e5c53000 	strb	r3, [r5]

	return size;
3481b040:	e1a00004 	mov	r0, r4
}
3481b044:	e24bd01c 	sub	sp, fp, #28
3481b048:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481b04c:	3481a76c 	.word	0x3481a76c
3481b050:	34827f3e 	.word	0x34827f3e
3481b054:	3482bc40 	.word	0x3482bc40

3481b058 <himport_r>:
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481b058:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481b05c:	e28db01c 	add	fp, sp, #28
3481b060:	e24dd028 	sub	sp, sp, #40	; 0x28
3481b064:	e1a06002 	mov	r6, r2
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
3481b068:	e59b2008 	ldr	r2, [fp, #8]
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481b06c:	e1a0a003 	mov	sl, r3
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
3481b070:	e1a05102 	lsl	r5, r2, #2
3481b074:	e285300e 	add	r3, r5, #14
3481b078:	e3c33007 	bic	r3, r3, #7
3481b07c:	e04dd003 	sub	sp, sp, r3
3481b080:	e28d3008 	add	r3, sp, #8
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
3481b084:	e2504000 	subs	r4, r0, #0
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481b088:	e1a07001 	mov	r7, r1
	char *data, *sp, *dp, *name, *value;
	char *localvars[nvars];
3481b08c:	e50b3030 	str	r3, [fp, #-48]	; 0x30
	int i;

	/* Test for correct arguments.  */
	if (htab == NULL) {
		__set_errno(EINVAL);
3481b090:	059f3318 	ldreq	r3, [pc, #792]	; 3481b3b0 <himport_r+0x358>
3481b094:	03a02016 	moveq	r2, #22
3481b098:	05832000 	streq	r2, [r3]
		return 0;
3481b09c:	01a00004 	moveq	r0, r4
3481b0a0:	0a0000c0 	beq	3481b3a8 <himport_r+0x350>
	}

	/* we allocate new space to make sure we can write to the array */
	if ((data = malloc(size)) == NULL) {
3481b0a4:	e1a00006 	mov	r0, r6
3481b0a8:	ebffb9f4 	bl	34809880 <malloc>
3481b0ac:	e2509000 	subs	r9, r0, #0
		debug("himport_r: can't malloc %zu bytes\n", size);
		__set_errno(ENOMEM);
3481b0b0:	059f32f8 	ldreq	r3, [pc, #760]	; 3481b3b0 <himport_r+0x358>
3481b0b4:	03a0200c 	moveq	r2, #12
3481b0b8:	05832000 	streq	r2, [r3]
		return 0;
3481b0bc:	01a00009 	moveq	r0, r9
3481b0c0:	0a0000b8 	beq	3481b3a8 <himport_r+0x350>
	}
	memcpy(data, env, size);
3481b0c4:	e1a02006 	mov	r2, r6
3481b0c8:	e1a01007 	mov	r1, r7
3481b0cc:	eb0003a0 	bl	3481bf54 <memcpy>
	dp = data;

	/* make a local copy of the list of variables */
	if (nvars)
3481b0d0:	e59b2008 	ldr	r2, [fp, #8]
3481b0d4:	e3520000 	cmp	r2, #0
3481b0d8:	0a000003 	beq	3481b0ec <himport_r+0x94>
		memcpy(localvars, vars, sizeof(vars[0]) * nvars);
3481b0dc:	e51b0030 	ldr	r0, [fp, #-48]	; 0x30
3481b0e0:	e59b100c 	ldr	r1, [fp, #12]
3481b0e4:	e1a02005 	mov	r2, r5
3481b0e8:	eb000399 	bl	3481bf54 <memcpy>

	if ((flag & H_NOCLEAR) == 0) {
3481b0ec:	e59b3004 	ldr	r3, [fp, #4]
3481b0f0:	e3130001 	tst	r3, #1
3481b0f4:	1a000005 	bne	3481b110 <himport_r+0xb8>
		/* Destroy old hash table if one exists */
		debug("Destroy Hash Table: %p table = %p\n", htab,
		       htab->table);
		if (htab->table)
3481b0f8:	e5943000 	ldr	r3, [r4]
3481b0fc:	e3530000 	cmp	r3, #0
3481b100:	0a000002 	beq	3481b110 <himport_r+0xb8>
			hdestroy_r(htab, do_apply);
3481b104:	e1a00004 	mov	r0, r4
3481b108:	e59b1010 	ldr	r1, [fp, #16]
3481b10c:	ebfffdc6 	bl	3481a82c <hdestroy_r>
	 * On the other hand we need to add some more entries for free
	 * space when importing very small buffers. Both boundaries can
	 * be overwritten in the board config file if needed.
	 */

	if (!htab->table) {
3481b110:	e5943000 	ldr	r3, [r4]
3481b114:	e3530000 	cmp	r3, #0
3481b118:	0a000003 	beq	3481b12c <himport_r+0xd4>
		}

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
3481b11c:	e0896006 	add	r6, r9, r6
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481b120:	e1a05009 	mov	r5, r9
		}

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
3481b124:	e50b6034 	str	r6, [fp, #-52]	; 0x34
3481b128:	ea00000c 	b	3481b160 <himport_r+0x108>
	 * space when importing very small buffers. Both boundaries can
	 * be overwritten in the board config file if needed.
	 */

	if (!htab->table) {
		int nent = CONFIG_ENV_MIN_ENTRIES + size / 8;
3481b12c:	e1a001a6 	lsr	r0, r6, #3
3481b130:	e2800040 	add	r0, r0, #64	; 0x40
		if (nent > CONFIG_ENV_MAX_ENTRIES)
			nent = CONFIG_ENV_MAX_ENTRIES;

		debug("Create Hash Table: N=%d\n", nent);

		if (hcreate_r(nent, htab) == 0) {
3481b134:	e3500c02 	cmp	r0, #512	; 0x200
3481b138:	a3a00c02 	movge	r0, #512	; 0x200
3481b13c:	e1a01004 	mov	r1, r4
3481b140:	ebfffd8e 	bl	3481a780 <hcreate_r>
3481b144:	e2505000 	subs	r5, r0, #0
3481b148:	1afffff3 	bne	3481b11c <himport_r+0xc4>
			free(data);
3481b14c:	e1a00009 	mov	r0, r9
3481b150:	ebffb941 	bl	3480965c <free>
			return 0;
3481b154:	e1a00005 	mov	r0, r5
3481b158:	ea000092 	b	3481b3a8 <himport_r+0x350>
 */

int himport_r(struct hsearch_data *htab,
		const char *env, size_t size, const char sep, int flag,
		int nvars, char * const vars[], int do_apply)
{
3481b15c:	e1a05006 	mov	r5, r6
	/* Parse environment; allow for '\0' and 'sep' as separators */
	do {
		ENTRY e, *rv;

		/* skip leading white space */
		while (isblank(*dp))
3481b160:	e5d53000 	ldrb	r3, [r5]
3481b164:	e3530020 	cmp	r3, #32
3481b168:	13530009 	cmpne	r3, #9
			++dp;
3481b16c:	02856001 	addeq	r6, r5, #1
	/* Parse environment; allow for '\0' and 'sep' as separators */
	do {
		ENTRY e, *rv;

		/* skip leading white space */
		while (isblank(*dp))
3481b170:	0afffff9 	beq	3481b15c <himport_r+0x104>
			++dp;

		/* skip comment lines */
		if (*dp == '#') {
3481b174:	e3530023 	cmp	r3, #35	; 0x23
3481b178:	11a02005 	movne	r2, r5
3481b17c:	1a000007 	bne	3481b1a0 <himport_r+0x148>
3481b180:	e1a06005 	mov	r6, r5
			while (*dp && (*dp != sep))
3481b184:	e4d53001 	ldrb	r3, [r5], #1
3481b188:	e3530000 	cmp	r3, #0
3481b18c:	0a000001 	beq	3481b198 <himport_r+0x140>
3481b190:	e153000a 	cmp	r3, sl
3481b194:	1afffff9 	bne	3481b180 <himport_r+0x128>
				++dp;
			++dp;
3481b198:	e2866001 	add	r6, r6, #1
			continue;
3481b19c:	ea000066 	b	3481b33c <himport_r+0x2e4>
		}

		/* parse name */
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
3481b1a0:	e5d23000 	ldrb	r3, [r2]
		/* skip comment lines */
		if (*dp == '#') {
			while (*dp && (*dp != sep))
				++dp;
			++dp;
			continue;
3481b1a4:	e1a06002 	mov	r6, r2
		}

		/* parse name */
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
3481b1a8:	e3530000 	cmp	r3, #0
3481b1ac:	1353003d 	cmpne	r3, #61	; 0x3d
3481b1b0:	e2822001 	add	r2, r2, #1
3481b1b4:	1a000002 	bne	3481b1c4 <himport_r+0x16c>
			;

		/* deal with "name" and "name=" entries (delete var) */
		if (*dp == '\0' || *(dp + 1) == '\0' ||
3481b1b8:	e3530000 	cmp	r3, #0
3481b1bc:	0a00000e 	beq	3481b1fc <himport_r+0x1a4>
3481b1c0:	ea000001 	b	3481b1cc <himport_r+0x174>
			++dp;
			continue;
		}

		/* parse name */
		for (name = dp; *dp != '=' && *dp && *dp != sep; ++dp)
3481b1c4:	e153000a 	cmp	r3, sl
3481b1c8:	1afffff4 	bne	3481b1a0 <himport_r+0x148>
			;

		/* deal with "name" and "name=" entries (delete var) */
		if (*dp == '\0' || *(dp + 1) == '\0' ||
3481b1cc:	e5d62001 	ldrb	r2, [r6, #1]
3481b1d0:	e2867001 	add	r7, r6, #1
3481b1d4:	e3520000 	cmp	r2, #0
3481b1d8:	0a000003 	beq	3481b1ec <himport_r+0x194>
3481b1dc:	e153000a 	cmp	r3, sl
3481b1e0:	0a000001 	beq	3481b1ec <himport_r+0x194>
		    *dp == sep || *(dp + 1) == sep) {
3481b1e4:	e152000a 	cmp	r2, sl
3481b1e8:	1a000010 	bne	3481b230 <himport_r+0x1d8>
			if (*dp == '=')
3481b1ec:	e353003d 	cmp	r3, #61	; 0x3d
				*dp++ = '\0';
3481b1f0:	03a02000 	moveq	r2, #0
3481b1f4:	05c62000 	strbeq	r2, [r6]
3481b1f8:	01a06007 	moveq	r6, r7
			*dp++ = '\0';	/* terminate name */
3481b1fc:	e3a03000 	mov	r3, #0
3481b200:	e4c63001 	strb	r3, [r6], #1

			debug("DELETE CANDIDATE: \"%s\"\n", name);
			if (!drop_var_from_set(name, nvars, localvars))
3481b204:	e1a00005 	mov	r0, r5
3481b208:	e59b1008 	ldr	r1, [fp, #8]
3481b20c:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
3481b210:	ebfffd3e 	bl	3481a710 <drop_var_from_set>
3481b214:	e3500000 	cmp	r0, #0
3481b218:	0a000047 	beq	3481b33c <himport_r+0x2e4>
				continue;

			if (hdelete_r(name, htab, do_apply) == 0)
3481b21c:	e1a00005 	mov	r0, r5
3481b220:	e1a01004 	mov	r1, r4
3481b224:	e59b2010 	ldr	r2, [fp, #16]
3481b228:	ebfffeb2 	bl	3481acf8 <hdelete_r>
				debug("DELETE ERROR ##############################\n");

			continue;
3481b22c:	ea000042 	b	3481b33c <himport_r+0x2e4>
		}
		*dp++ = '\0';	/* terminate name */
3481b230:	e3a02000 	mov	r2, #0
3481b234:	e5c62000 	strb	r2, [r6]

		/* parse value; deal with escapes */
		for (value = sp = dp; *dp && (*dp != sep); ++dp) {
3481b238:	e1a03007 	mov	r3, r7
3481b23c:	e1a06007 	mov	r6, r7
3481b240:	ea000006 	b	3481b260 <himport_r+0x208>
			if ((*dp == '\\') && *(dp + 1))
3481b244:	e352005c 	cmp	r2, #92	; 0x5c
3481b248:	1a000002 	bne	3481b258 <himport_r+0x200>
3481b24c:	e5d62001 	ldrb	r2, [r6, #1]
3481b250:	e3520000 	cmp	r2, #0
3481b254:	12866001 	addne	r6, r6, #1
				++dp;
			*sp++ = *dp;
3481b258:	e4d62001 	ldrb	r2, [r6], #1
3481b25c:	e4c32001 	strb	r2, [r3], #1
			continue;
		}
		*dp++ = '\0';	/* terminate name */

		/* parse value; deal with escapes */
		for (value = sp = dp; *dp && (*dp != sep); ++dp) {
3481b260:	e5d62000 	ldrb	r2, [r6]
3481b264:	e3520000 	cmp	r2, #0
3481b268:	0a000001 	beq	3481b274 <himport_r+0x21c>
3481b26c:	e152000a 	cmp	r2, sl
3481b270:	1afffff3 	bne	3481b244 <himport_r+0x1ec>
			if ((*dp == '\\') && *(dp + 1))
				++dp;
			*sp++ = *dp;
		}
		*sp++ = '\0';	/* terminate value */
3481b274:	e3a02000 	mov	r2, #0
3481b278:	e5c32000 	strb	r2, [r3]
		++dp;

		/* Skip variables which are not supposed to be processed */
		if (!drop_var_from_set(name, nvars, localvars))
3481b27c:	e1a00005 	mov	r0, r5
3481b280:	e59b1008 	ldr	r1, [fp, #8]
3481b284:	e51b2030 	ldr	r2, [fp, #-48]	; 0x30
3481b288:	ebfffd20 	bl	3481a710 <drop_var_from_set>
3481b28c:	e3500000 	cmp	r0, #0
			if ((*dp == '\\') && *(dp + 1))
				++dp;
			*sp++ = *dp;
		}
		*sp++ = '\0';	/* terminate value */
		++dp;
3481b290:	e2866001 	add	r6, r6, #1

		/* Skip variables which are not supposed to be processed */
		if (!drop_var_from_set(name, nvars, localvars))
3481b294:	0a000028 	beq	3481b33c <himport_r+0x2e4>
		/* enter into hash table */
		e.key = name;
		e.data = value;

		/* if there is an apply function, check what it has to say */
		if (do_apply && htab->apply != NULL) {
3481b298:	e59b3010 	ldr	r3, [fp, #16]
		/* Skip variables which are not supposed to be processed */
		if (!drop_var_from_set(name, nvars, localvars))
			continue;

		/* enter into hash table */
		e.key = name;
3481b29c:	e50b5028 	str	r5, [fp, #-40]	; 0x28
		e.data = value;

		/* if there is an apply function, check what it has to say */
		if (do_apply && htab->apply != NULL) {
3481b2a0:	e3530000 	cmp	r3, #0
		if (!drop_var_from_set(name, nvars, localvars))
			continue;

		/* enter into hash table */
		e.key = name;
		e.data = value;
3481b2a4:	e50b7024 	str	r7, [fp, #-36]	; 0x24

		/* if there is an apply function, check what it has to say */
		if (do_apply && htab->apply != NULL) {
3481b2a8:	0a000012 	beq	3481b2f8 <himport_r+0x2a0>
3481b2ac:	e594300c 	ldr	r3, [r4, #12]
3481b2b0:	e3530000 	cmp	r3, #0
3481b2b4:	0a00000f 	beq	3481b2f8 <himport_r+0x2a0>
				" for  %s\n", name);
			/*
			 * Search for variable in existing env, so to pass
			 * its previous value to the apply callback
			 */
			hsearch_r(e, FIND, &rv, htab);
3481b2b8:	e58d4000 	str	r4, [sp]
3481b2bc:	e24b3028 	sub	r3, fp, #40	; 0x28
3481b2c0:	e8930003 	ldm	r3, {r0, r1}
3481b2c4:	e3a02000 	mov	r2, #0
3481b2c8:	e24b3020 	sub	r3, fp, #32
3481b2cc:	ebfffdd0 	bl	3481aa14 <hsearch_r>
			debug("previous value was %s\n", rv ? rv->data : "");
			if (htab->apply(name, rv ? rv->data : NULL,
3481b2d0:	e51b1020 	ldr	r1, [fp, #-32]
3481b2d4:	e594c00c 	ldr	ip, [r4, #12]
3481b2d8:	e3510000 	cmp	r1, #0
3481b2dc:	15911004 	ldrne	r1, [r1, #4]
3481b2e0:	e1a00005 	mov	r0, r5
3481b2e4:	e1a02007 	mov	r2, r7
3481b2e8:	e59b3004 	ldr	r3, [fp, #4]
3481b2ec:	e12fff3c 	blx	ip
3481b2f0:	e3500000 	cmp	r0, #0
3481b2f4:	1a000010 	bne	3481b33c <himport_r+0x2e4>
					" variable %s, skipping it!\n", name);
				continue;
			}
		}

		hsearch_r(e, ENTER, &rv, htab);
3481b2f8:	e58d4000 	str	r4, [sp]
3481b2fc:	e24b3028 	sub	r3, fp, #40	; 0x28
3481b300:	e8930003 	ldm	r3, {r0, r1}
3481b304:	e3a02001 	mov	r2, #1
3481b308:	e24b3020 	sub	r3, fp, #32
3481b30c:	ebfffdc0 	bl	3481aa14 <hsearch_r>
		if (rv == NULL) {
3481b310:	e51b3020 	ldr	r3, [fp, #-32]
3481b314:	e3530000 	cmp	r3, #0
3481b318:	1a000007 	bne	3481b33c <himport_r+0x2e4>
			printf("himport_r: can't insert \"%s=%s\" into hash table\n",
3481b31c:	e59f0090 	ldr	r0, [pc, #144]	; 3481b3b4 <himport_r+0x35c>
3481b320:	e1a01005 	mov	r1, r5
3481b324:	e1a02007 	mov	r2, r7
3481b328:	e50b3038 	str	r3, [fp, #-56]	; 0x38
3481b32c:	ebffb78c 	bl	34809164 <printf>
				name, value);
			return 0;
3481b330:	e51b3038 	ldr	r3, [fp, #-56]	; 0x38
3481b334:	e1a00003 	mov	r0, r3
3481b338:	ea00001a 	b	3481b3a8 <himport_r+0x350>
		}

		debug("INSERT: table %p, filled %d/%d rv %p ==> name=\"%s\" value=\"%s\"\n",
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
3481b33c:	e51b2034 	ldr	r2, [fp, #-52]	; 0x34
3481b340:	e1560002 	cmp	r6, r2
3481b344:	2a000002 	bcs	3481b354 <himport_r+0x2fc>
3481b348:	e5d63000 	ldrb	r3, [r6]
3481b34c:	e3530000 	cmp	r3, #0
3481b350:	1affff81 	bne	3481b15c <himport_r+0x104>
						/* without '\0' termination */
	debug("INSERT: free(data = %p)\n", data);
	free(data);
3481b354:	e1a00009 	mov	r0, r9
3481b358:	ebffb8bf 	bl	3480965c <free>

	/* process variables which were not considered */
	for (i = 0; i < nvars; i++) {
3481b35c:	e3a06000 	mov	r6, #0
			htab, htab->filled, htab->size,
			rv, name, value);
	} while ((dp < data + size) && *dp);	/* size check needed for text */
						/* without '\0' termination */
	debug("INSERT: free(data = %p)\n", data);
	free(data);
3481b360:	e51b5030 	ldr	r5, [fp, #-48]	; 0x30

	/* process variables which were not considered */
	for (i = 0; i < nvars; i++) {
3481b364:	ea00000b 	b	3481b398 <himport_r+0x340>
		if (localvars[i] == NULL)
3481b368:	e4950004 	ldr	r0, [r5], #4
3481b36c:	e3500000 	cmp	r0, #0
3481b370:	0a000007 	beq	3481b394 <himport_r+0x33c>
		 * This could mean two things:
		 * a) if the variable was present in current env, we delete it
		 * b) if the variable was not present in current env, we notify
		 *    it might be a typo
		 */
		if (hdelete_r(localvars[i], htab, do_apply) == 0)
3481b374:	e1a01004 	mov	r1, r4
3481b378:	e59b2010 	ldr	r2, [fp, #16]
3481b37c:	ebfffe5d 	bl	3481acf8 <hdelete_r>
3481b380:	e3500000 	cmp	r0, #0
			printf("WARNING: '%s' neither in running nor in imported env!\n", localvars[i]);
3481b384:	059f002c 	ldreq	r0, [pc, #44]	; 3481b3b8 <himport_r+0x360>
		else
			printf("WARNING: '%s' not in imported env, deleting it!\n", localvars[i]);
3481b388:	159f002c 	ldrne	r0, [pc, #44]	; 3481b3bc <himport_r+0x364>
3481b38c:	e5151004 	ldr	r1, [r5, #-4]
3481b390:	ebffb773 	bl	34809164 <printf>
						/* without '\0' termination */
	debug("INSERT: free(data = %p)\n", data);
	free(data);

	/* process variables which were not considered */
	for (i = 0; i < nvars; i++) {
3481b394:	e2866001 	add	r6, r6, #1
3481b398:	e59b3008 	ldr	r3, [fp, #8]
3481b39c:	e1560003 	cmp	r6, r3
3481b3a0:	bafffff0 	blt	3481b368 <himport_r+0x310>
		else
			printf("WARNING: '%s' not in imported env, deleting it!\n", localvars[i]);
	}

	debug("INSERT: done\n");
	return 1;		/* everything OK */
3481b3a4:	e3a00001 	mov	r0, #1
}
3481b3a8:	e24bd01c 	sub	sp, fp, #28
3481b3ac:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481b3b0:	3482bc40 	.word	0x3482bc40
3481b3b4:	34827f6e 	.word	0x34827f6e
3481b3b8:	34827f9f 	.word	0x34827f9f
3481b3bc:	34827fd6 	.word	0x34827fd6

3481b3c0 <ldiv>:
	long    rem;
} ldiv_t;
/* Return the `ldiv_t' representation of NUMER over DENOM.  */
ldiv_t
ldiv (long int numer, long int denom)
{
3481b3c0:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3481b3c4:	e1a05001 	mov	r5, r1
3481b3c8:	e1a04000 	mov	r4, r0
  ldiv_t result;

  result.quot = numer / denom;
3481b3cc:	e1a00001 	mov	r0, r1
3481b3d0:	e1a01002 	mov	r1, r2
	long    rem;
} ldiv_t;
/* Return the `ldiv_t' representation of NUMER over DENOM.  */
ldiv_t
ldiv (long int numer, long int denom)
{
3481b3d4:	e1a07002 	mov	r7, r2
  ldiv_t result;

  result.quot = numer / denom;
3481b3d8:	eb001273 	bl	3481fdac <__divsi3>
  result.rem = numer % denom;
3481b3dc:	e1a01007 	mov	r1, r7
ldiv_t
ldiv (long int numer, long int denom)
{
  ldiv_t result;

  result.quot = numer / denom;
3481b3e0:	e1a06000 	mov	r6, r0
  result.rem = numer % denom;
3481b3e4:	e1a00005 	mov	r0, r5
3481b3e8:	eb0012f7 	bl	3481ffcc <__aeabi_idivmod>
     RESULT will always be positive.  This all boils down to: if
     NUMER >= 0, but REM < 0, we got the wrong answer.  In that
     case, to get the right answer, add 1 to QUOT and subtract
     DENOM from REM.  */

  if (numer >= 0 && result.rem < 0)
3481b3ec:	e3550000 	cmp	r5, #0
3481b3f0:	ba000002 	blt	3481b400 <ldiv+0x40>
3481b3f4:	e3510000 	cmp	r1, #0
    {
      ++result.quot;
3481b3f8:	b2866001 	addlt	r6, r6, #1
      result.rem -= denom;
3481b3fc:	b0671001 	rsblt	r1, r7, r1
3481b400:	e5846000 	str	r6, [r4]
3481b404:	e5841004 	str	r1, [r4, #4]
    }

  return result;
}
3481b408:	e1a00004 	mov	r0, r4
3481b40c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

3481b410 <lmb_add_region>:
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
3481b410:	e590c000 	ldr	ip, [r0]
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
3481b414:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
3481b418:	e35c0001 	cmp	ip, #1
3481b41c:	1a000005 	bne	3481b438 <lmb_add_region+0x28>
3481b420:	e590500c 	ldr	r5, [r0, #12]
3481b424:	e3550000 	cmp	r5, #0
		rgn->region[0].base = base;
3481b428:	05801008 	streq	r1, [r0, #8]
		rgn->region[0].size = size;
3481b42c:	0580200c 	streq	r2, [r0, #12]
		return 0;
3481b430:	01a00005 	moveq	r0, r5
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
	unsigned long coalesced = 0;
	long adjacent, i;

	if ((rgn->cnt == 1) && (rgn->region[0].size == 0)) {
3481b434:	08bd8ef0 	popeq	{r4, r5, r6, r7, r9, sl, fp, pc}
3481b438:	e1a04000 	mov	r4, r0
static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
		return 1;
	else if (base1 == base2 + size2)
3481b43c:	e3a03000 	mov	r3, #0
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481b440:	e0827001 	add	r7, r2, r1
3481b444:	ea000019 	b	3481b4b0 <lmb_add_region+0xa0>
		return 0;
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
		phys_addr_t rgnbase = rgn->region[i].base;
3481b448:	e5946008 	ldr	r6, [r4, #8]
		phys_size_t rgnsize = rgn->region[i].size;
3481b44c:	e594500c 	ldr	r5, [r4, #12]

		if ((rgnbase == base) && (rgnsize == size))
3481b450:	e1550002 	cmp	r5, r2
3481b454:	01560001 	cmpeq	r6, r1
3481b458:	0a000054 	beq	3481b5b0 <lmb_add_region+0x1a0>
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481b45c:	e1560007 	cmp	r6, r7
3481b460:	0a000005 	beq	3481b47c <lmb_add_region+0x6c>
		return 1;
	else if (base1 == base2 + size2)
3481b464:	e0856006 	add	r6, r5, r6
3481b468:	e1510006 	cmp	r1, r6
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481b46c:	e2844008 	add	r4, r4, #8
3481b470:	e2836001 	add	r6, r3, #1
		return 1;
	else if (base1 == base2 + size2)
3481b474:	1a000051 	bne	3481b5c0 <lmb_add_region+0x1b0>
3481b478:	ea000007 	b	3481b49c <lmb_add_region+0x8c>
			/* Already have this region, so we're done */
			return 0;

		adjacent = lmb_addrs_adjacent(base,size,rgnbase,rgnsize);
		if ( adjacent > 0 ) {
			rgn->region[i].base -= size;
3481b47c:	e2834001 	add	r4, r3, #1
3481b480:	e0627007 	rsb	r7, r2, r7
3481b484:	e7807184 	str	r7, [r0, r4, lsl #3]
			rgn->region[i].size += size;
3481b488:	e0804184 	add	r4, r0, r4, lsl #3
3481b48c:	e5945004 	ldr	r5, [r4, #4]
3481b490:	e0825005 	add	r5, r2, r5
3481b494:	e5845004 	str	r5, [r4, #4]
3481b498:	ea000002 	b	3481b4a8 <lmb_add_region+0x98>
			coalesced++;
			break;
		}
		else if ( adjacent < 0 ) {
			rgn->region[i].size += size;
3481b49c:	e0806186 	add	r6, r0, r6, lsl #3
3481b4a0:	e0855002 	add	r5, r5, r2
3481b4a4:	e5865004 	str	r5, [r6, #4]
			coalesced++;
3481b4a8:	e3a05001 	mov	r5, #1
			break;
3481b4ac:	ea000002 	b	3481b4bc <lmb_add_region+0xac>
		rgn->region[0].size = size;
		return 0;
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
3481b4b0:	e153000c 	cmp	r3, ip
3481b4b4:	3affffe3 	bcc	3481b448 <lmb_add_region+0x38>
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
{
	unsigned long coalesced = 0;
3481b4b8:	e3a05000 	mov	r5, #0
			coalesced++;
			break;
		}
	}

	if ((i < rgn->cnt-1) && lmb_regions_adjacent(rgn, i, i+1) ) {
3481b4bc:	e24c4001 	sub	r4, ip, #1
3481b4c0:	e1530004 	cmp	r3, r4
3481b4c4:	2a00001e 	bcs	3481b544 <lmb_add_region+0x134>
3481b4c8:	e2836001 	add	r6, r3, #1

static long lmb_regions_adjacent(struct lmb_region *rgn,
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
	phys_size_t size1 = rgn->region[r1].size;
3481b4cc:	e080a186 	add	sl, r0, r6, lsl #3
}

static long lmb_regions_adjacent(struct lmb_region *rgn,
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
3481b4d0:	e7907186 	ldr	r7, [r0, r6, lsl #3]
	phys_size_t size1 = rgn->region[r1].size;
3481b4d4:	e59ab004 	ldr	fp, [sl, #4]
	phys_addr_t base2 = rgn->region[r2].base;
3481b4d8:	e2866001 	add	r6, r6, #1
3481b4dc:	e790a186 	ldr	sl, [r0, r6, lsl #3]
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481b4e0:	e08b9007 	add	r9, fp, r7
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
	phys_size_t size1 = rgn->region[r1].size;
	phys_addr_t base2 = rgn->region[r2].base;
	phys_size_t size2 = rgn->region[r2].size;
3481b4e4:	e0806186 	add	r6, r0, r6, lsl #3
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481b4e8:	e15a0009 	cmp	sl, r9
		unsigned long r1, unsigned long r2)
{
	phys_addr_t base1 = rgn->region[r1].base;
	phys_size_t size1 = rgn->region[r1].size;
	phys_addr_t base2 = rgn->region[r2].base;
	phys_size_t size2 = rgn->region[r2].size;
3481b4ec:	e5966004 	ldr	r6, [r6, #4]
}

static long lmb_addrs_adjacent(phys_addr_t base1, phys_size_t size1,
		phys_addr_t base2, phys_size_t size2)
{
	if (base2 == base1 + size1)
3481b4f0:	0a000002 	beq	3481b500 <lmb_add_region+0xf0>
		return 1;
	else if (base1 == base2 + size2)
3481b4f4:	e086a00a 	add	sl, r6, sl
3481b4f8:	e157000a 	cmp	r7, sl
3481b4fc:	1a000010 	bne	3481b544 <lmb_add_region+0x134>

/* Assumption: base addr of region 1 < base addr of region 2 */
static void lmb_coalesce_regions(struct lmb_region *rgn,
		unsigned long r1, unsigned long r2)
{
	rgn->region[r1].size += rgn->region[r2].size;
3481b500:	e0802183 	add	r2, r0, r3, lsl #3
3481b504:	e086600b 	add	r6, r6, fp
3481b508:	e582600c 	str	r6, [r2, #12]
	lmb->reserved.cnt = 1;
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
3481b50c:	e2832003 	add	r2, r3, #3
3481b510:	e0802182 	add	r2, r0, r2, lsl #3
3481b514:	ea000003 	b	3481b528 <lmb_add_region+0x118>
static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
		rgn->region[i].base = rgn->region[i + 1].base;
3481b518:	e5121008 	ldr	r1, [r2, #-8]
3481b51c:	e5021010 	str	r1, [r2, #-16]
		rgn->region[i].size = rgn->region[i + 1].size;
3481b520:	e5121004 	ldr	r1, [r2, #-4]
3481b524:	e502100c 	str	r1, [r2, #-12]
3481b528:	e2833001 	add	r3, r3, #1

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
3481b52c:	e1530004 	cmp	r3, r4
		rgn->region[i].base = rgn->region[i + 1].base;
		rgn->region[i].size = rgn->region[i + 1].size;
3481b530:	e2822008 	add	r2, r2, #8

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
3481b534:	3afffff7 	bcc	3481b518 <lmb_add_region+0x108>
		rgn->region[i].base = rgn->region[i + 1].base;
		rgn->region[i].size = rgn->region[i + 1].size;
	}
	rgn->cnt--;
3481b538:	e5804000 	str	r4, [r0]
		}
	}

	if ((i < rgn->cnt-1) && lmb_regions_adjacent(rgn, i, i+1) ) {
		lmb_coalesce_regions(rgn, i, i+1);
		coalesced++;
3481b53c:	e2850001 	add	r0, r5, #1
3481b540:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (coalesced)
3481b544:	e3550000 	cmp	r5, #0
3481b548:	13a00001 	movne	r0, #1
3481b54c:	18bd8ef0 	popne	{r4, r5, r6, r7, r9, sl, fp, pc}
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
3481b550:	e35c0007 	cmp	ip, #7
	lmb->reserved.cnt = 1;
	lmb->reserved.size = 0;
}

/* This routine called with relocation disabled. */
static long lmb_add_region(struct lmb_region *rgn, phys_addr_t base, phys_size_t size)
3481b554:	928c3001 	addls	r3, ip, #1
3481b558:	90803183 	addls	r3, r0, r3, lsl #3
		coalesced++;
	}

	if (coalesced)
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
3481b55c:	9a00000b 	bls	3481b590 <lmb_add_region+0x180>
3481b560:	ea000014 	b	3481b5b8 <lmb_add_region+0x1a8>
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
		if (base < rgn->region[i].base) {
3481b564:	e5335008 	ldr	r5, [r3, #-8]!
3481b568:	e1510005 	cmp	r1, r5
			rgn->region[i+1].base = rgn->region[i].base;
3481b56c:	35835008 	strcc	r5, [r3, #8]
			rgn->region[i+1].size = rgn->region[i].size;
3481b570:	35935004 	ldrcc	r5, [r3, #4]
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
3481b574:	32444001 	subcc	r4, r4, #1
		if (base < rgn->region[i].base) {
			rgn->region[i+1].base = rgn->region[i].base;
			rgn->region[i+1].size = rgn->region[i].size;
3481b578:	3583500c 	strcc	r5, [r3, #12]
		} else {
			rgn->region[i+1].base = base;
3481b57c:	22844002 	addcs	r4, r4, #2
3481b580:	27801184 	strcs	r1, [r0, r4, lsl #3]
			rgn->region[i+1].size = size;
3481b584:	20804184 	addcs	r4, r0, r4, lsl #3
3481b588:	25842004 	strcs	r2, [r4, #4]
			break;
3481b58c:	2a000001 	bcs	3481b598 <lmb_add_region+0x188>
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
		return -1;

	/* Couldn't coalesce the LMB, so add it to the sorted table. */
	for (i = rgn->cnt-1; i >= 0; i--) {
3481b590:	e3540000 	cmp	r4, #0
3481b594:	aafffff2 	bge	3481b564 <lmb_add_region+0x154>
			rgn->region[i+1].size = size;
			break;
		}
	}

	if (base < rgn->region[0].base) {
3481b598:	e5903008 	ldr	r3, [r0, #8]
		rgn->region[0].base = base;
		rgn->region[0].size = size;
	}

	rgn->cnt++;
3481b59c:	e28cc001 	add	ip, ip, #1
			rgn->region[i+1].size = size;
			break;
		}
	}

	if (base < rgn->region[0].base) {
3481b5a0:	e1510003 	cmp	r1, r3
		rgn->region[0].base = base;
3481b5a4:	35801008 	strcc	r1, [r0, #8]
		rgn->region[0].size = size;
3481b5a8:	3580200c 	strcc	r2, [r0, #12]
	}

	rgn->cnt++;
3481b5ac:	e580c000 	str	ip, [r0]
		phys_addr_t rgnbase = rgn->region[i].base;
		phys_size_t rgnsize = rgn->region[i].size;

		if ((rgnbase == base) && (rgnsize == size))
			/* Already have this region, so we're done */
			return 0;
3481b5b0:	e3a00000 	mov	r0, #0
3481b5b4:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
	}

	if (coalesced)
		return coalesced;
	if (rgn->cnt >= MAX_LMB_REGIONS)
		return -1;
3481b5b8:	e3e00000 	mvn	r0, #0
	}

	rgn->cnt++;

	return 0;
}
3481b5bc:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
		rgn->region[0].size = size;
		return 0;
	}

	/* First try and coalesce this LMB with another. */
	for (i=0; i < rgn->cnt; i++) {
3481b5c0:	e1a03006 	mov	r3, r6
3481b5c4:	eaffffb9 	b	3481b4b0 <lmb_add_region+0xa0>

3481b5c8 <lmb_dump_all>:
			(long long unsigned)lmb->reserved.region[i].base);
		debug("		     .size = 0x%llx\n",
			(long long unsigned)lmb->reserved.region[i].size);
	}
#endif /* DEBUG */
}
3481b5c8:	e12fff1e 	bx	lr

3481b5cc <lmb_init>:
void lmb_init(struct lmb *lmb)
{
	/* Create a dummy zero size LMB which will get coalesced away later.
	 * This simplifies the lmb_add() code below...
	 */
	lmb->memory.region[0].base = 0;
3481b5cc:	e3a03000 	mov	r3, #0
	lmb->memory.region[0].size = 0;
	lmb->memory.cnt = 1;
3481b5d0:	e3a02001 	mov	r2, #1
void lmb_init(struct lmb *lmb)
{
	/* Create a dummy zero size LMB which will get coalesced away later.
	 * This simplifies the lmb_add() code below...
	 */
	lmb->memory.region[0].base = 0;
3481b5d4:	e5803008 	str	r3, [r0, #8]
	lmb->memory.region[0].size = 0;
3481b5d8:	e580300c 	str	r3, [r0, #12]
	lmb->memory.cnt = 1;
3481b5dc:	e880000c 	stm	r0, {r2, r3}
	lmb->memory.size = 0;

	/* Ditto. */
	lmb->reserved.region[0].base = 0;
3481b5e0:	e5803058 	str	r3, [r0, #88]	; 0x58
	lmb->reserved.region[0].size = 0;
3481b5e4:	e580305c 	str	r3, [r0, #92]	; 0x5c
	lmb->reserved.cnt = 1;
3481b5e8:	e5802050 	str	r2, [r0, #80]	; 0x50
	lmb->reserved.size = 0;
3481b5ec:	e5803054 	str	r3, [r0, #84]	; 0x54
}
3481b5f0:	e12fff1e 	bx	lr

3481b5f4 <lmb_add>:
/* This routine may be called with relocation disabled. */
long lmb_add(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *_rgn = &(lmb->memory);

	return lmb_add_region(_rgn, base, size);
3481b5f4:	eaffff85 	b	3481b410 <lmb_add_region>

3481b5f8 <lmb_free>:
}

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
3481b5f8:	e92d46f0 	push	{r4, r5, r6, r7, r9, sl, lr}
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
3481b5fc:	e3a04000 	mov	r4, #0

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *rgn = &(lmb->reserved);
	phys_addr_t rgnbegin, rgnend;
	phys_addr_t end = base + size;
3481b600:	e082c001 	add	ip, r2, r1
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
3481b604:	e5907050 	ldr	r7, [r0, #80]	; 0x50
3481b608:	e1a06000 	mov	r6, r0
	struct lmb_region *rgn = &(lmb->reserved);
	phys_addr_t rgnbegin, rgnend;
	phys_addr_t end = base + size;
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */
3481b60c:	e1a03004 	mov	r3, r4
3481b610:	e1a05004 	mov	r5, r4

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
3481b614:	ea000007 	b	3481b638 <lmb_free+0x40>
		rgnbegin = rgn->region[i].base;
3481b618:	e5965058 	ldr	r5, [r6, #88]	; 0x58
		rgnend = rgnbegin + rgn->region[i].size;
3481b61c:	e596305c 	ldr	r3, [r6, #92]	; 0x5c
3481b620:	e2866008 	add	r6, r6, #8
3481b624:	e0853003 	add	r3, r5, r3

		if ((rgnbegin <= base) && (end <= rgnend))
3481b628:	e15c0003 	cmp	ip, r3
3481b62c:	91550001 	cmpls	r5, r1
3481b630:	9a000003 	bls	3481b644 <lmb_free+0x4c>
	int i;

	rgnbegin = rgnend = 0; /* supress gcc warnings */

	/* Find the region where (base, size) belongs to */
	for (i=0; i < rgn->cnt; i++) {
3481b634:	e2844001 	add	r4, r4, #1
3481b638:	e1540007 	cmp	r4, r7
3481b63c:	e1a0a004 	mov	sl, r4
3481b640:	3afffff4 	bcc	3481b618 <lmb_free+0x20>
		if ((rgnbegin <= base) && (end <= rgnend))
			break;
	}

	/* Didn't find the region */
	if (i == rgn->cnt)
3481b644:	e1540007 	cmp	r4, r7
3481b648:	0a000032 	beq	3481b718 <lmb_free+0x120>
		return -1;

	/* Check to see if we are removing entire region */
	if ((rgnbegin == base) && (rgnend == end)) {
3481b64c:	e1550001 	cmp	r5, r1
3481b650:	13a05000 	movne	r5, #0
3481b654:	03a05001 	moveq	r5, #1
3481b658:	e153000c 	cmp	r3, ip
3481b65c:	13a06000 	movne	r6, #0
3481b660:	03a06001 	moveq	r6, #1
3481b664:	e0169005 	ands	r9, r6, r5
3481b668:	0a00000e 	beq	3481b6a8 <lmb_free+0xb0>
	struct lmb_region *_rgn = &(lmb->memory);

	return lmb_add_region(_rgn, base, size);
}

long lmb_free(struct lmb *lmb, phys_addr_t base, phys_size_t size)
3481b66c:	e284400c 	add	r4, r4, #12
3481b670:	e0804184 	add	r4, r0, r4, lsl #3

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
3481b674:	e2477001 	sub	r7, r7, #1
3481b678:	ea000004 	b	3481b690 <lmb_free+0x98>
		rgn->region[i].base = rgn->region[i + 1].base;
3481b67c:	e5143008 	ldr	r3, [r4, #-8]
3481b680:	e28aa001 	add	sl, sl, #1
3481b684:	e5043010 	str	r3, [r4, #-16]
		rgn->region[i].size = rgn->region[i + 1].size;
3481b688:	e5143004 	ldr	r3, [r4, #-4]
3481b68c:	e504300c 	str	r3, [r4, #-12]

static void lmb_remove_region(struct lmb_region *rgn, unsigned long r)
{
	unsigned long i;

	for (i = r; i < rgn->cnt - 1; i++) {
3481b690:	e15a0007 	cmp	sl, r7
3481b694:	e2844008 	add	r4, r4, #8
3481b698:	3afffff7 	bcc	3481b67c <lmb_free+0x84>
		rgn->region[i].base = rgn->region[i + 1].base;
		rgn->region[i].size = rgn->region[i + 1].size;
	}
	rgn->cnt--;
3481b69c:	e5807050 	str	r7, [r0, #80]	; 0x50
		return -1;

	/* Check to see if we are removing entire region */
	if ((rgnbegin == base) && (rgnend == end)) {
		lmb_remove_region(rgn, i);
		return 0;
3481b6a0:	e3a00000 	mov	r0, #0
3481b6a4:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	/* Check to see if region is matching at the front */
	if (rgnbegin == base) {
3481b6a8:	e3550000 	cmp	r5, #0
3481b6ac:	0a000007 	beq	3481b6d0 <lmb_free+0xd8>
		rgn->region[i].base = end;
3481b6b0:	e284400b 	add	r4, r4, #11
3481b6b4:	e780c184 	str	ip, [r0, r4, lsl #3]
		rgn->region[i].size -= size;
3481b6b8:	e0800184 	add	r0, r0, r4, lsl #3
3481b6bc:	e5903004 	ldr	r3, [r0, #4]
3481b6c0:	e0622003 	rsb	r2, r2, r3
3481b6c4:	e5802004 	str	r2, [r0, #4]
		return 0;
3481b6c8:	e1a00009 	mov	r0, r9
3481b6cc:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}
	}

	/* Check to see if the region is matching at the end */
	if (rgnend == end) {
3481b6d0:	e3560000 	cmp	r6, #0
3481b6d4:	e284400b 	add	r4, r4, #11
3481b6d8:	0a000005 	beq	3481b6f4 <lmb_free+0xfc>
		rgn->region[i].size -= size;
3481b6dc:	e0804184 	add	r4, r0, r4, lsl #3
3481b6e0:	e5943004 	ldr	r3, [r4, #4]
		return 0;
3481b6e4:	e1a00005 	mov	r0, r5
		return 0;
	}

	/* Check to see if the region is matching at the end */
	if (rgnend == end) {
		rgn->region[i].size -= size;
3481b6e8:	e0622003 	rsb	r2, r2, r3
3481b6ec:	e5842004 	str	r2, [r4, #4]
		return 0;
3481b6f0:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
3481b6f4:	e0802184 	add	r2, r0, r4, lsl #3
3481b6f8:	e7904184 	ldr	r4, [r0, r4, lsl #3]
	return lmb_add_region(rgn, end, rgnend - end);
3481b6fc:	e2800050 	add	r0, r0, #80	; 0x50

	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
3481b700:	e0641001 	rsb	r1, r4, r1
3481b704:	e5821004 	str	r1, [r2, #4]
	return lmb_add_region(rgn, end, rgnend - end);
3481b708:	e1a0100c 	mov	r1, ip
3481b70c:	e06c2003 	rsb	r2, ip, r3
}
3481b710:	e8bd46f0 	pop	{r4, r5, r6, r7, r9, sl, lr}
	/*
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
	return lmb_add_region(rgn, end, rgnend - end);
3481b714:	eaffff3d 	b	3481b410 <lmb_add_region>
			break;
	}

	/* Didn't find the region */
	if (i == rgn->cnt)
		return -1;
3481b718:	e3e00000 	mvn	r0, #0
	 * We need to split the entry -  adjust the current one to the
	 * beginging of the hole and add the region after hole.
	 */
	rgn->region[i].size = base - rgn->region[i].base;
	return lmb_add_region(rgn, end, rgnend - end);
}
3481b71c:	e8bd86f0 	pop	{r4, r5, r6, r7, r9, sl, pc}

3481b720 <lmb_reserve>:

long lmb_reserve(struct lmb *lmb, phys_addr_t base, phys_size_t size)
{
	struct lmb_region *_rgn = &(lmb->reserved);

	return lmb_add_region(_rgn, base, size);
3481b720:	e2800050 	add	r0, r0, #80	; 0x50
3481b724:	eaffff39 	b	3481b410 <lmb_add_region>

3481b728 <lmb_overlaps_region>:
}

long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
3481b728:	e92d4030 	push	{r4, r5, lr}
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
3481b72c:	e590c000 	ldr	ip, [r0]
3481b730:	e3a03000 	mov	r3, #0
}

static long lmb_addrs_overlap(phys_addr_t base1,
		phys_size_t size1, phys_addr_t base2, phys_size_t size2)
{
	return ((base1 < (base2+size2)) && (base2 < (base1+size1)));
3481b734:	e0822001 	add	r2, r2, r1
long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
3481b738:	ea000008 	b	3481b760 <lmb_overlaps_region+0x38>
		phys_addr_t rgnbase = rgn->region[i].base;
3481b73c:	e5904008 	ldr	r4, [r0, #8]
}

static long lmb_addrs_overlap(phys_addr_t base1,
		phys_size_t size1, phys_addr_t base2, phys_size_t size2)
{
	return ((base1 < (base2+size2)) && (base2 < (base1+size1)));
3481b740:	e590500c 	ldr	r5, [r0, #12]
3481b744:	e0845005 	add	r5, r4, r5
3481b748:	e1510005 	cmp	r1, r5
3481b74c:	2a000007 	bcs	3481b770 <lmb_overlaps_region+0x48>
3481b750:	e1540002 	cmp	r4, r2
3481b754:	2a000005 	bcs	3481b770 <lmb_overlaps_region+0x48>
		if ( lmb_addrs_overlap(base,size,rgnbase,rgnsize) ) {
			break;
		}
	}

	return (i < rgn->cnt) ? i : -1;
3481b758:	e1a00003 	mov	r0, r3
3481b75c:	e8bd8030 	pop	{r4, r5, pc}
long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
3481b760:	e153000c 	cmp	r3, ip
3481b764:	3afffff4 	bcc	3481b73c <lmb_overlaps_region+0x14>
		if ( lmb_addrs_overlap(base,size,rgnbase,rgnsize) ) {
			break;
		}
	}

	return (i < rgn->cnt) ? i : -1;
3481b768:	e3e00000 	mvn	r0, #0
}
3481b76c:	e8bd8030 	pop	{r4, r5, pc}
long lmb_overlaps_region(struct lmb_region *rgn, phys_addr_t base,
				phys_size_t size)
{
	unsigned long i;

	for (i=0; i < rgn->cnt; i++) {
3481b770:	e2833001 	add	r3, r3, #1
3481b774:	e2800008 	add	r0, r0, #8
3481b778:	eafffff8 	b	3481b760 <lmb_overlaps_region+0x38>

3481b77c <__lmb_alloc_base>:
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
3481b77c:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481b780:	e5907000 	ldr	r7, [r0]
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
3481b784:	e1a09003 	mov	r9, r3
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
3481b788:	e2803050 	add	r3, r0, #80	; 0x50
3481b78c:	e58d300c 	str	r3, [sp, #12]
	return alloc;
}

static phys_addr_t lmb_align_down(phys_addr_t addr, phys_size_t size)
{
	return addr & ~(size - 1);
3481b790:	e2623000 	rsb	r3, r2, #0
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
3481b794:	e1a0c002 	mov	ip, r2
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481b798:	e247b001 	sub	fp, r7, #1
3481b79c:	e1a02003 	mov	r2, r3
static phys_addr_t lmb_align_up(phys_addr_t addr, ulong size)
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
3481b7a0:	e2877001 	add	r7, r7, #1
{
3481b7a4:	e1a04001 	mov	r4, r1
static phys_addr_t lmb_align_up(phys_addr_t addr, ulong size)
{
	return (addr + (size - 1)) & ~(size - 1);
}

phys_addr_t __lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
3481b7a8:	e0807187 	add	r7, r0, r7, lsl #3
3481b7ac:	e1a03000 	mov	r3, r0
3481b7b0:	e1a05002 	mov	r5, r2
{
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481b7b4:	ea000036 	b	3481b894 <__lmb_alloc_base+0x118>
		phys_addr_t lmbbase = lmb->memory.region[i].base;
		phys_size_t lmbsize = lmb->memory.region[i].size;
3481b7b8:	e5176004 	ldr	r6, [r7, #-4]
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
		phys_addr_t lmbbase = lmb->memory.region[i].base;
3481b7bc:	e517a008 	ldr	sl, [r7, #-8]
		phys_size_t lmbsize = lmb->memory.region[i].size;

		if (lmbsize < size)
3481b7c0:	e1560004 	cmp	r6, r4
3481b7c4:	3a000030 	bcc	3481b88c <__lmb_alloc_base+0x110>
			continue;
		if (max_addr == LMB_ALLOC_ANYWHERE)
3481b7c8:	e3590000 	cmp	r9, #0
			base = lmb_align_down(lmbbase + lmbsize - size, align);
3481b7cc:	0086600a 	addeq	r6, r6, sl
3481b7d0:	00646006 	rsbeq	r6, r4, r6
		phys_addr_t lmbbase = lmb->memory.region[i].base;
		phys_size_t lmbsize = lmb->memory.region[i].size;

		if (lmbsize < size)
			continue;
		if (max_addr == LMB_ALLOC_ANYWHERE)
3481b7d4:	0a000005 	beq	3481b7f0 <__lmb_alloc_base+0x74>
			base = lmb_align_down(lmbbase + lmbsize - size, align);
		else if (lmbbase < max_addr) {
3481b7d8:	e15a0009 	cmp	sl, r9
3481b7dc:	2a00002a 	bcs	3481b88c <__lmb_alloc_base+0x110>
			base = min(lmbbase + lmbsize, max_addr);
3481b7e0:	e086600a 	add	r6, r6, sl
			base = lmb_align_down(base - size, align);
3481b7e4:	e1590006 	cmp	r9, r6
3481b7e8:	90646009 	rsbls	r6, r4, r9
3481b7ec:	80646006 	rsbhi	r6, r4, r6
3481b7f0:	e58db008 	str	fp, [sp, #8]
	return alloc;
}

static phys_addr_t lmb_align_down(phys_addr_t addr, phys_size_t size)
{
	return addr & ~(size - 1);
3481b7f4:	e0066005 	and	r6, r6, r5
3481b7f8:	e1a0b007 	mov	fp, r7
3481b7fc:	e1a07003 	mov	r7, r3
3481b800:	ea000017 	b	3481b864 <__lmb_alloc_base+0xe8>
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
3481b804:	e59d000c 	ldr	r0, [sp, #12]
3481b808:	e1a01006 	mov	r1, r6
3481b80c:	e1a02004 	mov	r2, r4
3481b810:	e58dc004 	str	ip, [sp, #4]
3481b814:	ebffffc3 	bl	3481b728 <lmb_overlaps_region>
			if (j < 0) {
3481b818:	e3500000 	cmp	r0, #0
3481b81c:	e59dc004 	ldr	ip, [sp, #4]
3481b820:	aa000009 	bge	3481b84c <__lmb_alloc_base+0xd0>
	return addr & ~(size - 1);
}

static phys_addr_t lmb_align_up(phys_addr_t addr, ulong size)
{
	return (addr + (size - 1)) & ~(size - 1);
3481b824:	e2444001 	sub	r4, r4, #1
3481b828:	e26c2000 	rsb	r2, ip, #0
3481b82c:	e084c00c 	add	ip, r4, ip

		while (base && lmbbase <= base) {
			j = lmb_overlaps_region(&lmb->reserved, base, size);
			if (j < 0) {
				/* This area isn't reserved, take it */
				if (lmb_add_region(&lmb->reserved, base,
3481b830:	e1a01006 	mov	r1, r6
3481b834:	e59d000c 	ldr	r0, [sp, #12]
3481b838:	e002200c 	and	r2, r2, ip
3481b83c:	ebfffef3 	bl	3481b410 <lmb_add_region>
							lmb_align_up(size,
								align)) < 0)
					return 0;
3481b840:	e3500000 	cmp	r0, #0
3481b844:	b3a06000 	movlt	r6, #0
3481b848:	ea000014 	b	3481b8a0 <__lmb_alloc_base+0x124>
				return base;
			}
			res_base = lmb->reserved.region[j].base;
3481b84c:	e280000b 	add	r0, r0, #11
3481b850:	e7976180 	ldr	r6, [r7, r0, lsl #3]
			if (res_base < size)
3481b854:	e1560004 	cmp	r6, r4
3481b858:	3a000008 	bcc	3481b880 <__lmb_alloc_base+0x104>
				break;
			base = lmb_align_down(res_base - size, align);
3481b85c:	e0646006 	rsb	r6, r4, r6
	return alloc;
}

static phys_addr_t lmb_align_down(phys_addr_t addr, phys_size_t size)
{
	return addr & ~(size - 1);
3481b860:	e0056006 	and	r6, r5, r6
			base = min(lmbbase + lmbsize, max_addr);
			base = lmb_align_down(base - size, align);
		} else
			continue;

		while (base && lmbbase <= base) {
3481b864:	e15a0006 	cmp	sl, r6
3481b868:	83a02000 	movhi	r2, #0
3481b86c:	93a02001 	movls	r2, #1
3481b870:	e3560000 	cmp	r6, #0
3481b874:	03a02000 	moveq	r2, #0
3481b878:	e3520000 	cmp	r2, #0
3481b87c:	1affffe0 	bne	3481b804 <__lmb_alloc_base+0x88>
3481b880:	e1a03007 	mov	r3, r7
3481b884:	e1a0700b 	mov	r7, fp
3481b888:	e59db008 	ldr	fp, [sp, #8]
{
	long i, j;
	phys_addr_t base = 0;
	phys_addr_t res_base;

	for (i = lmb->memory.cnt-1; i >= 0; i--) {
3481b88c:	e24bb001 	sub	fp, fp, #1
3481b890:	e2477008 	sub	r7, r7, #8
3481b894:	e35b0000 	cmp	fp, #0
3481b898:	aaffffc6 	bge	3481b7b8 <__lmb_alloc_base+0x3c>
			if (res_base < size)
				break;
			base = lmb_align_down(res_base - size, align);
		}
	}
	return 0;
3481b89c:	e3a06000 	mov	r6, #0
}
3481b8a0:	e1a00006 	mov	r0, r6
3481b8a4:	e28dd010 	add	sp, sp, #16
3481b8a8:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481b8ac <lmb_alloc_base>:
{
	return lmb_alloc_base(lmb, size, align, LMB_ALLOC_ANYWHERE);
}

phys_addr_t lmb_alloc_base(struct lmb *lmb, phys_size_t size, ulong align, phys_addr_t max_addr)
{
3481b8ac:	e92d4070 	push	{r4, r5, r6, lr}
3481b8b0:	e1a05001 	mov	r5, r1
3481b8b4:	e1a04003 	mov	r4, r3
	phys_addr_t alloc;

	alloc = __lmb_alloc_base(lmb, size, align, max_addr);
3481b8b8:	ebffffaf 	bl	3481b77c <__lmb_alloc_base>

	if (alloc == 0)
3481b8bc:	e2506000 	subs	r6, r0, #0
3481b8c0:	1a000003 	bne	3481b8d4 <lmb_alloc_base+0x28>
		printf("ERROR: Failed to allocate 0x%lx bytes below 0x%lx.\n",
3481b8c4:	e59f0010 	ldr	r0, [pc, #16]	; 3481b8dc <lmb_alloc_base+0x30>
3481b8c8:	e1a01005 	mov	r1, r5
3481b8cc:	e1a02004 	mov	r2, r4
3481b8d0:	ebffb623 	bl	34809164 <printf>
		      (ulong)size, (ulong)max_addr);

	return alloc;
}
3481b8d4:	e1a00006 	mov	r0, r6
3481b8d8:	e8bd8070 	pop	{r4, r5, r6, pc}
3481b8dc:	34828007 	.word	0x34828007

3481b8e0 <lmb_alloc>:
	return (i < rgn->cnt) ? i : -1;
}

phys_addr_t lmb_alloc(struct lmb *lmb, phys_size_t size, ulong align)
{
	return lmb_alloc_base(lmb, size, align, LMB_ALLOC_ANYWHERE);
3481b8e0:	e3a03000 	mov	r3, #0
3481b8e4:	eafffff0 	b	3481b8ac <lmb_alloc_base>

3481b8e8 <lmb_is_reserved>:
	}
	return 0;
}

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
{
3481b8e8:	e92d4010 	push	{r4, lr}
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
3481b8ec:	e590c050 	ldr	ip, [r0, #80]	; 0x50
3481b8f0:	e3a03000 	mov	r3, #0
3481b8f4:	ea00000d 	b	3481b930 <lmb_is_reserved+0x48>
		}
	}
	return 0;
}

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
3481b8f8:	e1a04000 	mov	r4, r0
{
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
		phys_addr_t upper = lmb->reserved.region[i].base +
3481b8fc:	e5902058 	ldr	r2, [r0, #88]	; 0x58
3481b900:	e594405c 	ldr	r4, [r4, #92]	; 0x5c
3481b904:	e2800008 	add	r0, r0, #8
3481b908:	e0824004 	add	r4, r2, r4
3481b90c:	e2444001 	sub	r4, r4, #1
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
3481b910:	e1510004 	cmp	r1, r4
3481b914:	83a04000 	movhi	r4, #0
3481b918:	93a04001 	movls	r4, #1
3481b91c:	e1510002 	cmp	r1, r2
3481b920:	33a04000 	movcc	r4, #0
3481b924:	e3540000 	cmp	r4, #0
3481b928:	1a000004 	bne	3481b940 <lmb_is_reserved+0x58>

int lmb_is_reserved(struct lmb *lmb, phys_addr_t addr)
{
	int i;

	for (i = 0; i < lmb->reserved.cnt; i++) {
3481b92c:	e2833001 	add	r3, r3, #1
3481b930:	e153000c 	cmp	r3, ip
3481b934:	3affffef 	bcc	3481b8f8 <lmb_is_reserved+0x10>
		phys_addr_t upper = lmb->reserved.region[i].base +
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
			return 1;
	}
	return 0;
3481b938:	e3a00000 	mov	r0, #0
3481b93c:	e8bd8010 	pop	{r4, pc}

	for (i = 0; i < lmb->reserved.cnt; i++) {
		phys_addr_t upper = lmb->reserved.region[i].base +
			lmb->reserved.region[i].size - 1;
		if ((addr >= lmb->reserved.region[i].base) && (addr <= upper))
			return 1;
3481b940:	e3a00001 	mov	r0, #1
	}
	return 0;
}
3481b944:	e8bd8010 	pop	{r4, pc}

3481b948 <__board_lmb_reserve>:

void __board_lmb_reserve(struct lmb *lmb)
{
	/* please define platform specific board_lmb_reserve() */
}
3481b948:	e12fff1e 	bx	lr

3481b94c <__arch_lmb_reserve>:
void board_lmb_reserve(struct lmb *lmb) __attribute__((weak, alias("__board_lmb_reserve")));

void __arch_lmb_reserve(struct lmb *lmb)
{
	/* please define platform specific arch_lmb_reserve() */
}
3481b94c:	e12fff1e 	bx	lr

3481b950 <string_to_ip>:
 */

#include <common.h>

IPaddr_t string_to_ip(const char *s)
{
3481b950:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	IPaddr_t addr;
	char *e;
	int i;

	if (s == NULL)
3481b954:	e2504000 	subs	r4, r0, #0
		return(0);
3481b958:	01a00004 	moveq	r0, r4
{
	IPaddr_t addr;
	char *e;
	int i;

	if (s == NULL)
3481b95c:	0a000014 	beq	3481b9b4 <string_to_ip+0x64>
3481b960:	e3a06004 	mov	r6, #4
3481b964:	e3a05000 	mov	r5, #0
		return(0);

	for (addr=0, i=0; i<4; ++i) {
		ulong val = s ? simple_strtoul(s, &e, 10) : 0;
3481b968:	e08d7006 	add	r7, sp, r6
3481b96c:	e3540000 	cmp	r4, #0
3481b970:	01a00004 	moveq	r0, r4
3481b974:	0a000003 	beq	3481b988 <string_to_ip+0x38>
3481b978:	e1a00004 	mov	r0, r4
3481b97c:	e1a01007 	mov	r1, r7
3481b980:	e3a0200a 	mov	r2, #10
3481b984:	eb000441 	bl	3481ca90 <simple_strtoul>
		addr <<= 8;
		addr |= (val & 0xFF);
3481b988:	e20000ff 	and	r0, r0, #255	; 0xff
		if (s) {
3481b98c:	e3540000 	cmp	r4, #0
		return(0);

	for (addr=0, i=0; i<4; ++i) {
		ulong val = s ? simple_strtoul(s, &e, 10) : 0;
		addr <<= 8;
		addr |= (val & 0xFF);
3481b990:	e1805405 	orr	r5, r0, r5, lsl #8
		if (s) {
3481b994:	0a000003 	beq	3481b9a8 <string_to_ip+0x58>
			s = (*e) ? e+1 : e;
3481b998:	e59d4004 	ldr	r4, [sp, #4]
3481b99c:	e5d43000 	ldrb	r3, [r4]
3481b9a0:	e3530000 	cmp	r3, #0
3481b9a4:	12844001 	addne	r4, r4, #1
	int i;

	if (s == NULL)
		return(0);

	for (addr=0, i=0; i<4; ++i) {
3481b9a8:	e2566001 	subs	r6, r6, #1
3481b9ac:	1affffee 	bne	3481b96c <string_to_ip+0x1c>
3481b9b0:	e6bf0f35 	rev	r0, r5
			s = (*e) ? e+1 : e;
		}
	}

	return (htonl(addr));
}
3481b9b4:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

3481b9b8 <qsort>:

void qsort(void  *base,
	   size_t nel,
	   size_t width,
	   int (*comp)(const void *, const void *))
{
3481b9b8:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
	size_t wgap, i, j, k;
	char tmp;

	if ((nel > 1) && (width > 0)) {
3481b9bc:	e3520000 	cmp	r2, #0
3481b9c0:	13510001 	cmpne	r1, #1

void qsort(void  *base,
	   size_t nel,
	   size_t width,
	   int (*comp)(const void *, const void *))
{
3481b9c4:	e58d0008 	str	r0, [sp, #8]
3481b9c8:	e1a06001 	mov	r6, r1
3481b9cc:	e58d300c 	str	r3, [sp, #12]
	size_t wgap, i, j, k;
	char tmp;

	if ((nel > 1) && (width > 0)) {
3481b9d0:	e1a04002 	mov	r4, r2
3481b9d4:	9a000031 	bls	3481baa0 <qsort+0xe8>
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
3481b9d8:	e2410001 	sub	r0, r1, #1
3481b9dc:	e3a01003 	mov	r1, #3
3481b9e0:	eb00106e 	bl	3481fba0 <__udivsi3>
3481b9e4:	e3a05000 	mov	r5, #0

	if ((nel > 1) && (width > 0)) {
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
3481b9e8:	e0855085 	add	r5, r5, r5, lsl #1
3481b9ec:	e2855001 	add	r5, r5, #1
		} while (wgap < (nel-1)/3);
3481b9f0:	e1550000 	cmp	r5, r0
3481b9f4:	3afffffb 	bcc	3481b9e8 <qsort+0x30>
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
		nel *= width;			/* Convert nel to 'wnel' */
3481b9f8:	e0060496 	mul	r6, r6, r4
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
3481b9fc:	e0050594 	mul	r5, r4, r5
		nel *= width;			/* Convert nel to 'wnel' */
3481ba00:	e58d6004 	str	r6, [sp, #4]

#include <linux/types.h>
#include <common.h>
#include <exports.h>

void qsort(void  *base,
3481ba04:	e2653000 	rsb	r3, r5, #0
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
		/* From the above, we know that either wgap == 1 < nel or */
		/* ((wgap-1)/3 < (int) ((nel-1)/3) <= (nel-1)/3 ==> wgap <  nel. */
		wgap *= width;			/* So this can not overflow if wnel doesn't. */
		nel *= width;			/* Convert nel to 'wnel' */
3481ba08:	e0859004 	add	r9, r5, r4
	if ((nel > 1) && (width > 0)) {
		assert(nel <= ((size_t)(-1)) / width); /* check for overflow */
		wgap = 0;
		do {
			wgap = 3 * wgap + 1;
		} while (wgap < (nel-1)/3);
3481ba0c:	e3a07000 	mov	r7, #0

#include <linux/types.h>
#include <common.h>
#include <exports.h>

void qsort(void  *base,
3481ba10:	e1a0b003 	mov	fp, r3
3481ba14:	e59d2008 	ldr	r2, [sp, #8]
3481ba18:	e1a03007 	mov	r3, r7
3481ba1c:	e0826007 	add	r6, r2, r7
3481ba20:	e086a005 	add	sl, r6, r5
					register char *b;

					j -= wgap;
					a = j + ((char *)base);
					b = a + wgap;
					if ((*comp)(a, b) <= 0) {
3481ba24:	e58d3000 	str	r3, [sp]
3481ba28:	e1a00006 	mov	r0, r6
3481ba2c:	e1a0100a 	mov	r1, sl
3481ba30:	e59d200c 	ldr	r2, [sp, #12]
3481ba34:	e12fff32 	blx	r2
3481ba38:	e3500000 	cmp	r0, #0
3481ba3c:	e59d3000 	ldr	r3, [sp]
3481ba40:	da00000b 	ble	3481ba74 <qsort+0xbc>
3481ba44:	e3a02000 	mov	r2, #0
						break;
					}
					k = width;
					do {
						tmp = *a;
3481ba48:	e7d61002 	ldrb	r1, [r6, r2]
						*a++ = *b;
3481ba4c:	e7da0002 	ldrb	r0, [sl, r2]
3481ba50:	e7c60002 	strb	r0, [r6, r2]
						*b++ = tmp;
3481ba54:	e7ca1002 	strb	r1, [sl, r2]
3481ba58:	e2822001 	add	r2, r2, #1
					} while (--k);
3481ba5c:	e1540002 	cmp	r4, r2
3481ba60:	1afffff8 	bne	3481ba48 <qsort+0x90>
3481ba64:	e087700b 	add	r7, r7, fp
				} while (j >= wgap);
3481ba68:	e1770005 	cmn	r7, r5
					k = width;
					do {
						tmp = *a;
						*a++ = *b;
						*b++ = tmp;
					} while (--k);
3481ba6c:	e086600b 	add	r6, r6, fp
				} while (j >= wgap);
3481ba70:	3affffea 	bcc	3481ba20 <qsort+0x68>
3481ba74:	e0899004 	add	r9, r9, r4
				i += width;
			} while (i < nel);
3481ba78:	e59d2004 	ldr	r2, [sp, #4]
					do {
						tmp = *a;
						*a++ = *b;
						*b++ = tmp;
					} while (--k);
				} while (j >= wgap);
3481ba7c:	e0837004 	add	r7, r3, r4
				i += width;
			} while (i < nel);
3481ba80:	e0643009 	rsb	r3, r4, r9
3481ba84:	e1530002 	cmp	r3, r2
3481ba88:	3affffe1 	bcc	3481ba14 <qsort+0x5c>
			wgap = (wgap - width)/3;
3481ba8c:	e0640005 	rsb	r0, r4, r5
3481ba90:	e3a01003 	mov	r1, #3
3481ba94:	eb001041 	bl	3481fba0 <__udivsi3>
		} while (wgap);
3481ba98:	e2505000 	subs	r5, r0, #0
3481ba9c:	1affffd8 	bne	3481ba04 <qsort+0x4c>
	}
}
3481baa0:	e8bd8eff 	pop	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}

3481baa4 <strcmp_compar>:

int strcmp_compar(const void *p1, const void *p2)
{
	return strcmp(*(const char **)p1, *(const char **)p2);
3481baa4:	e5900000 	ldr	r0, [r0]
3481baa8:	e5911000 	ldr	r1, [r1]
3481baac:	ea000030 	b	3481bb74 <strcmp>

3481bab0 <strcpy>:
 */
char * strcpy(char * dest,const char *src)
{
	char *tmp = dest;

	while ((*dest++ = *src++) != '\0')
3481bab0:	e3a03000 	mov	r3, #0
3481bab4:	e7d12003 	ldrb	r2, [r1, r3]
3481bab8:	e3520000 	cmp	r2, #0
3481babc:	e7c02003 	strb	r2, [r0, r3]
3481bac0:	e2833001 	add	r3, r3, #1
3481bac4:	1afffffa 	bne	3481bab4 <strcpy+0x4>
		/* nothing */;
	return tmp;
}
3481bac8:	e12fff1e 	bx	lr

3481bacc <strncpy>:
 */
char * strncpy(char * dest,const char *src,size_t count)
{
	char *tmp = dest;

	while (count-- && (*dest++ = *src++) != '\0')
3481bacc:	e3a03000 	mov	r3, #0
3481bad0:	e3520000 	cmp	r2, #0
3481bad4:	012fff1e 	bxeq	lr
3481bad8:	e7d1c003 	ldrb	ip, [r1, r3]
3481badc:	e2422001 	sub	r2, r2, #1
3481bae0:	e35c0000 	cmp	ip, #0
3481bae4:	e7c0c003 	strb	ip, [r0, r3]
3481bae8:	e2833001 	add	r3, r3, #1
3481baec:	1afffff7 	bne	3481bad0 <strncpy+0x4>
		/* nothing */;

	return tmp;
}
3481baf0:	e12fff1e 	bx	lr

3481baf4 <strcat>:
 */
char * strcat(char * dest, const char * src)
{
	char *tmp = dest;

	while (*dest)
3481baf4:	e1a0c000 	mov	ip, r0
3481baf8:	e5dc3000 	ldrb	r3, [ip]
3481bafc:	e1a0200c 	mov	r2, ip
3481bb00:	e3530000 	cmp	r3, #0
3481bb04:	e28cc001 	add	ip, ip, #1
3481bb08:	1afffffa 	bne	3481baf8 <strcat+0x4>
		dest++;
	while ((*dest++ = *src++) != '\0')
3481bb0c:	e7d1c003 	ldrb	ip, [r1, r3]
3481bb10:	e35c0000 	cmp	ip, #0
3481bb14:	e7c2c003 	strb	ip, [r2, r3]
3481bb18:	e2833001 	add	r3, r3, #1
3481bb1c:	1afffffa 	bne	3481bb0c <strcat+0x18>
		;

	return tmp;
}
3481bb20:	e12fff1e 	bx	lr

3481bb24 <strncat>:
 */
char * strncat(char *dest, const char *src, size_t count)
{
	char *tmp = dest;

	if (count) {
3481bb24:	e3520000 	cmp	r2, #0
 *
 * Note that in contrast to strncpy, strncat ensures the result is
 * terminated.
 */
char * strncat(char *dest, const char *src, size_t count)
{
3481bb28:	e92d4010 	push	{r4, lr}
	char *tmp = dest;

	if (count) {
3481bb2c:	08bd8010 	popeq	{r4, pc}
3481bb30:	e1a04000 	mov	r4, r0
3481bb34:	e1a0c004 	mov	ip, r4
		while (*dest)
3481bb38:	e4d43001 	ldrb	r3, [r4], #1
3481bb3c:	e3530000 	cmp	r3, #0
3481bb40:	1afffffb 	bne	3481bb34 <strncat+0x10>
3481bb44:	ea000005 	b	3481bb60 <strncat+0x3c>
3481bb48:	e2833001 	add	r3, r3, #1
			dest++;
		while ((*dest++ = *src++)) {
			if (--count == 0) {
3481bb4c:	e1520003 	cmp	r2, r3
3481bb50:	1a000002 	bne	3481bb60 <strncat+0x3c>
				*dest = '\0';
3481bb54:	e3a03000 	mov	r3, #0
3481bb58:	e5cc3000 	strb	r3, [ip]
				break;
3481bb5c:	e8bd8010 	pop	{r4, pc}
	char *tmp = dest;

	if (count) {
		while (*dest)
			dest++;
		while ((*dest++ = *src++)) {
3481bb60:	e7d14003 	ldrb	r4, [r1, r3]
3481bb64:	e3540000 	cmp	r4, #0
3481bb68:	e4cc4001 	strb	r4, [ip], #1
3481bb6c:	1afffff5 	bne	3481bb48 <strncat+0x24>
			}
		}
	}

	return tmp;
}
3481bb70:	e8bd8010 	pop	{r4, pc}

3481bb74 <strcmp>:
 * strcmp - Compare two strings
 * @cs: One string
 * @ct: Another string
 */
int strcmp(const char * cs,const char * ct)
{
3481bb74:	e3a03000 	mov	r3, #0
	register signed char __res;

	while (1) {
		if ((__res = *cs - *ct++) != 0 || !*cs++)
3481bb78:	e7d0c003 	ldrb	ip, [r0, r3]
3481bb7c:	e7d12003 	ldrb	r2, [r1, r3]
3481bb80:	e062200c 	rsb	r2, r2, ip
3481bb84:	e6ef2072 	uxtb	r2, r2
3481bb88:	e3520000 	cmp	r2, #0
3481bb8c:	1a000002 	bne	3481bb9c <strcmp+0x28>
3481bb90:	e35c0000 	cmp	ip, #0
3481bb94:	e2833001 	add	r3, r3, #1
3481bb98:	1afffff6 	bne	3481bb78 <strcmp+0x4>
			break;
	}

	return __res;
}
3481bb9c:	e6af0072 	sxtb	r0, r2
3481bba0:	e12fff1e 	bx	lr

3481bba4 <strncmp>:
 * @cs: One string
 * @ct: Another string
 * @count: The maximum number of bytes to compare
 */
int strncmp(const char * cs,const char * ct,size_t count)
{
3481bba4:	e92d4010 	push	{r4, lr}
	register signed char __res = 0;

	while (count) {
3481bba8:	e3a03000 	mov	r3, #0
3481bbac:	ea000009 	b	3481bbd8 <strncmp+0x34>
		if ((__res = *cs - *ct++) != 0 || !*cs++)
3481bbb0:	e7d04003 	ldrb	r4, [r0, r3]
3481bbb4:	e7d1c003 	ldrb	ip, [r1, r3]
3481bbb8:	e06cc004 	rsb	ip, ip, r4
3481bbbc:	e6efc07c 	uxtb	ip, ip
3481bbc0:	e35c0000 	cmp	ip, #0
3481bbc4:	1a000006 	bne	3481bbe4 <strncmp+0x40>
3481bbc8:	e3540000 	cmp	r4, #0
3481bbcc:	e2833001 	add	r3, r3, #1
3481bbd0:	0a000003 	beq	3481bbe4 <strncmp+0x40>
			break;
		count--;
3481bbd4:	e2422001 	sub	r2, r2, #1
 */
int strncmp(const char * cs,const char * ct,size_t count)
{
	register signed char __res = 0;

	while (count) {
3481bbd8:	e3520000 	cmp	r2, #0
3481bbdc:	1afffff3 	bne	3481bbb0 <strncmp+0xc>
3481bbe0:	e1a0c002 	mov	ip, r2
			break;
		count--;
	}

	return __res;
}
3481bbe4:	e6af007c 	sxtb	r0, ip
3481bbe8:	e8bd8010 	pop	{r4, pc}

3481bbec <strchr>:
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
		if (*s == '\0')
			return NULL;
3481bbec:	e1a03000 	mov	r3, r0
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
3481bbf0:	e6ef1071 	uxtb	r1, r1
3481bbf4:	ea000001 	b	3481bc00 <strchr+0x14>
		if (*s == '\0')
3481bbf8:	e3520000 	cmp	r2, #0
3481bbfc:	0a000005 	beq	3481bc18 <strchr+0x2c>
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
3481bc00:	e5d32000 	ldrb	r2, [r3]
		if (*s == '\0')
3481bc04:	e1a00003 	mov	r0, r3
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strchr(const char * s, int c)
{
	for(; *s != (char) c; ++s)
3481bc08:	e1520001 	cmp	r2, r1
3481bc0c:	e2833001 	add	r3, r3, #1
3481bc10:	1afffff8 	bne	3481bbf8 <strchr+0xc>
3481bc14:	e12fff1e 	bx	lr
		if (*s == '\0')
			return NULL;
3481bc18:	e1a00002 	mov	r0, r2
	return (char *) s;
}
3481bc1c:	e12fff1e 	bx	lr

3481bc20 <skip_spaces>:
 *
 * Returns a pointer to the first non-whitespace character in @str.
 */
char *skip_spaces(const char *str)
{
	while (isspace(*str))
3481bc20:	e59f2018 	ldr	r2, [pc, #24]	; 3481bc40 <skip_spaces+0x20>
 * @str: The string to be stripped.
 *
 * Returns a pointer to the first non-whitespace character in @str.
 */
char *skip_spaces(const char *str)
{
3481bc24:	e1a03000 	mov	r3, r0
	while (isspace(*str))
3481bc28:	e1a00003 	mov	r0, r3
3481bc2c:	e4d31001 	ldrb	r1, [r3], #1
3481bc30:	e7d21001 	ldrb	r1, [r2, r1]
3481bc34:	e3110020 	tst	r1, #32
3481bc38:	1afffffa 	bne	3481bc28 <skip_spaces+0x8>
		++str;
	return (char *)str;
}
3481bc3c:	e12fff1e 	bx	lr
3481bc40:	34821cd4 	.word	0x34821cd4

3481bc44 <strlen>:
/**
 * strlen - Find the length of a string
 * @s: The string to be sized
 */
size_t strlen(const char * s)
{
3481bc44:	e1a03000 	mov	r3, r0
	const char *sc;

	for (sc = s; *sc != '\0'; ++sc)
3481bc48:	e1a02003 	mov	r2, r3
3481bc4c:	e4d31001 	ldrb	r1, [r3], #1
3481bc50:	e3510000 	cmp	r1, #0
3481bc54:	1afffffb 	bne	3481bc48 <strlen+0x4>
		/* nothing */;
	return sc - s;
}
3481bc58:	e0600002 	rsb	r0, r0, r2
3481bc5c:	e12fff1e 	bx	lr

3481bc60 <strim>:
 * Note that the first trailing whitespace is replaced with a %NUL-terminator
 * in the given string @s. Returns a pointer to the first non-whitespace
 * character in @s.
 */
char *strim(char *s)
{
3481bc60:	e92d4010 	push	{r4, lr}
	size_t size;
	char *end;

	s = skip_spaces(s);
3481bc64:	ebffffed 	bl	3481bc20 <skip_spaces>
3481bc68:	e1a04000 	mov	r4, r0
	size = strlen(s);
3481bc6c:	ebfffff4 	bl	3481bc44 <strlen>
	if (!size)
3481bc70:	e2503000 	subs	r3, r0, #0
3481bc74:	0a00000b 	beq	3481bca8 <strim+0x48>
		return s;

	end = s + size - 1;
3481bc78:	e2433001 	sub	r3, r3, #1
	while (end >= s && isspace(*end))
3481bc7c:	e59f102c 	ldr	r1, [pc, #44]	; 3481bcb0 <strim+0x50>
	s = skip_spaces(s);
	size = strlen(s);
	if (!size)
		return s;

	end = s + size - 1;
3481bc80:	e0843003 	add	r3, r4, r3
	while (end >= s && isspace(*end))
3481bc84:	e1530004 	cmp	r3, r4
3481bc88:	e1a02003 	mov	r2, r3
3481bc8c:	3a000003 	bcc	3481bca0 <strim+0x40>
3481bc90:	e4530001 	ldrb	r0, [r3], #-1
3481bc94:	e7d10000 	ldrb	r0, [r1, r0]
3481bc98:	e3100020 	tst	r0, #32
3481bc9c:	1afffff8 	bne	3481bc84 <strim+0x24>
		end--;
	*(end + 1) = '\0';
3481bca0:	e3a03000 	mov	r3, #0
3481bca4:	e5c23001 	strb	r3, [r2, #1]

	return s;
}
3481bca8:	e1a00004 	mov	r0, r4
3481bcac:	e8bd8010 	pop	{r4, pc}
3481bcb0:	34821cd4 	.word	0x34821cd4

3481bcb4 <strrchr>:
 * strrchr - Find the last occurrence of a character in a string
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
3481bcb4:	e92d4038 	push	{r3, r4, r5, lr}
3481bcb8:	e1a04000 	mov	r4, r0
3481bcbc:	e1a05001 	mov	r5, r1
       const char *p = s + strlen(s);
3481bcc0:	ebffffdf 	bl	3481bc44 <strlen>
       do {
	   if (*p == (char)c)
3481bcc4:	e6ef5075 	uxtb	r5, r5
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
       const char *p = s + strlen(s);
3481bcc8:	e0843000 	add	r3, r4, r0
       do {
	   if (*p == (char)c)
3481bccc:	e5d32000 	ldrb	r2, [r3]
 * @s: The string to be searched
 * @c: The character to search for
 */
char * strrchr(const char * s, int c)
{
       const char *p = s + strlen(s);
3481bcd0:	e1a00003 	mov	r0, r3
       do {
	   if (*p == (char)c)
3481bcd4:	e1520005 	cmp	r2, r5
3481bcd8:	e2433001 	sub	r3, r3, #1
3481bcdc:	08bd8038 	popeq	{r3, r4, r5, pc}
	       return (char *)p;
       } while (--p >= s);
3481bce0:	e1540003 	cmp	r4, r3
3481bce4:	9afffff8 	bls	3481bccc <strrchr+0x18>
       return NULL;
3481bce8:	e3a00000 	mov	r0, #0
}
3481bcec:	e8bd8038 	pop	{r3, r4, r5, pc}

3481bcf0 <strnlen>:
 * strnlen - Find the length of a length-limited string
 * @s: The string to be sized
 * @count: The maximum number of bytes to search
 */
size_t strnlen(const char * s, size_t count)
{
3481bcf0:	e1a03000 	mov	r3, r0
	const char *sc;

	for (sc = s; count-- && *sc != '\0'; ++sc)
3481bcf4:	e3510000 	cmp	r1, #0
3481bcf8:	e1a02003 	mov	r2, r3
3481bcfc:	0a000003 	beq	3481bd10 <strnlen+0x20>
3481bd00:	e4d3c001 	ldrb	ip, [r3], #1
3481bd04:	e2411001 	sub	r1, r1, #1
3481bd08:	e35c0000 	cmp	ip, #0
3481bd0c:	1afffff8 	bne	3481bcf4 <strnlen+0x4>
		/* nothing */;
	return sc - s;
}
3481bd10:	e0600002 	rsb	r0, r0, r2
3481bd14:	e12fff1e 	bx	lr

3481bd18 <strdup>:
#endif

#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
3481bd18:	e92d4038 	push	{r3, r4, r5, lr}
	char *new;

	if ((s == NULL)	||
3481bd1c:	e2505000 	subs	r5, r0, #0
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
		return NULL;
3481bd20:	01a04005 	moveq	r4, r5
#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
	char *new;

	if ((s == NULL)	||
3481bd24:	0a000006 	beq	3481bd44 <strdup+0x2c>
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
3481bd28:	ebffffc5 	bl	3481bc44 <strlen>
3481bd2c:	e2800001 	add	r0, r0, #1
3481bd30:	ebffb6d2 	bl	34809880 <malloc>
#ifndef __HAVE_ARCH_STRDUP
char * strdup(const char *s)
{
	char *new;

	if ((s == NULL)	||
3481bd34:	e2504000 	subs	r4, r0, #0
3481bd38:	0a000001 	beq	3481bd44 <strdup+0x2c>
	    ((new = malloc (strlen(s) + 1)) == NULL) ) {
		return NULL;
	}

	strcpy (new, s);
3481bd3c:	e1a01005 	mov	r1, r5
3481bd40:	ebffff5a 	bl	3481bab0 <strcpy>
	return new;
}
3481bd44:	e1a00004 	mov	r0, r4
3481bd48:	e8bd8038 	pop	{r3, r4, r5, pc}

3481bd4c <strspn>:
 *	contain letters in @accept
 * @s: The string to be searched
 * @accept: The string to search for
 */
size_t strspn(const char *s, const char *accept)
{
3481bd4c:	e1a03000 	mov	r3, r0
3481bd50:	e92d4010 	push	{r4, lr}
	const char *p;
	const char *a;
	size_t count = 0;
3481bd54:	e3a00000 	mov	r0, #0

	for (p = s; *p != '\0'; ++p) {
3481bd58:	ea000006 	b	3481bd78 <strspn+0x2c>
		for (a = accept; *a != '\0'; ++a) {
			if (*p == *a)
3481bd5c:	e15c0004 	cmp	ip, r4
				break;
		}
		if (*a == '\0')
			return count;
		++count;
3481bd60:	02800001 	addeq	r0, r0, #1
3481bd64:	0a000003 	beq	3481bd78 <strspn+0x2c>
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
		for (a = accept; *a != '\0'; ++a) {
3481bd68:	e4d24001 	ldrb	r4, [r2], #1
3481bd6c:	e3540000 	cmp	r4, #0
3481bd70:	1afffff9 	bne	3481bd5c <strspn+0x10>
3481bd74:	e8bd8010 	pop	{r4, pc}
{
	const char *p;
	const char *a;
	size_t count = 0;

	for (p = s; *p != '\0'; ++p) {
3481bd78:	e7d3c000 	ldrb	ip, [r3, r0]
3481bd7c:	e35c0000 	cmp	ip, #0
3481bd80:	08bd8010 	popeq	{r4, pc}
3481bd84:	e1a02001 	mov	r2, r1
3481bd88:	eafffff6 	b	3481bd68 <strspn+0x1c>

3481bd8c <strpbrk>:
 * strpbrk - Find the first occurrence of a set of characters
 * @cs: The string to be searched
 * @ct: The characters to search for
 */
char * strpbrk(const char * cs,const char * ct)
{
3481bd8c:	e92d4010 	push	{r4, lr}
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
				return (char *) sc1;
		}
	}
	return NULL;
3481bd90:	e1a02000 	mov	r2, r0
 */
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
3481bd94:	ea000004 	b	3481bdac <strpbrk+0x20>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
3481bd98:	e1530004 	cmp	r3, r4
3481bd9c:	08bd8010 	popeq	{r4, pc}
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
3481bda0:	e4dc4001 	ldrb	r4, [ip], #1
3481bda4:	e3540000 	cmp	r4, #0
3481bda8:	1afffffa 	bne	3481bd98 <strpbrk+0xc>
3481bdac:	e1a00002 	mov	r0, r2
 */
char * strpbrk(const char * cs,const char * ct)
{
	const char *sc1,*sc2;

	for( sc1 = cs; *sc1 != '\0'; ++sc1) {
3481bdb0:	e4d23001 	ldrb	r3, [r2], #1
3481bdb4:	e3530000 	cmp	r3, #0
3481bdb8:	11a0c001 	movne	ip, r1
3481bdbc:	1afffff7 	bne	3481bda0 <strpbrk+0x14>
		for( sc2 = ct; *sc2 != '\0'; ++sc2) {
			if (*sc1 == *sc2)
				return (char *) sc1;
		}
	}
	return NULL;
3481bdc0:	e1a00003 	mov	r0, r3
}
3481bdc4:	e8bd8010 	pop	{r4, pc}

3481bdc8 <strtok>:
 * @ct: The characters to search for
 *
 * WARNING: strtok is deprecated, use strsep instead.
 */
char * strtok(char * s,const char * ct)
{
3481bdc8:	e92d4038 	push	{r3, r4, r5, lr}
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
3481bdcc:	e2504000 	subs	r4, r0, #0
 * @ct: The characters to search for
 *
 * WARNING: strtok is deprecated, use strsep instead.
 */
char * strtok(char * s,const char * ct)
{
3481bdd0:	e1a05001 	mov	r5, r1
	char *sbegin, *send;

	sbegin  = s ? s : ___strtok;
3481bdd4:	1a000003 	bne	3481bde8 <strtok+0x20>
3481bdd8:	e59f3060 	ldr	r3, [pc, #96]	; 3481be40 <strtok+0x78>
3481bddc:	e5934000 	ldr	r4, [r3]
	if (!sbegin) {
3481bde0:	e3540000 	cmp	r4, #0
3481bde4:	0a000013 	beq	3481be38 <strtok+0x70>
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
3481bde8:	e1a00004 	mov	r0, r4
3481bdec:	e1a01005 	mov	r1, r5
3481bdf0:	ebffffd5 	bl	3481bd4c <strspn>
	if (*sbegin == '\0') {
3481bdf4:	e7f43000 	ldrb	r3, [r4, r0]!
3481bdf8:	e3530000 	cmp	r3, #0
		___strtok = NULL;
3481bdfc:	059f203c 	ldreq	r2, [pc, #60]	; 3481be40 <strtok+0x78>
		return( NULL );
3481be00:	01a04003 	moveq	r4, r3
	if (!sbegin) {
		return NULL;
	}
	sbegin += strspn(sbegin,ct);
	if (*sbegin == '\0') {
		___strtok = NULL;
3481be04:	05823000 	streq	r3, [r2]
		return( NULL );
3481be08:	0a00000a 	beq	3481be38 <strtok+0x70>
	}
	send = strpbrk( sbegin, ct);
3481be0c:	e1a00004 	mov	r0, r4
3481be10:	e1a01005 	mov	r1, r5
3481be14:	ebffffdc 	bl	3481bd8c <strpbrk>
	if (send && *send != '\0')
3481be18:	e3500000 	cmp	r0, #0
3481be1c:	0a000003 	beq	3481be30 <strtok+0x68>
3481be20:	e5d03000 	ldrb	r3, [r0]
3481be24:	e3530000 	cmp	r3, #0
		*send++ = '\0';
3481be28:	13a03000 	movne	r3, #0
3481be2c:	14c03001 	strbne	r3, [r0], #1
	___strtok = send;
3481be30:	e59f3008 	ldr	r3, [pc, #8]	; 3481be40 <strtok+0x78>
3481be34:	e5830000 	str	r0, [r3]
	return (sbegin);
}
3481be38:	e1a00004 	mov	r0, r4
3481be3c:	e8bd8038 	pop	{r3, r4, r5, pc}
3481be40:	3482bc44 	.word	0x3482bc44

3481be44 <strsep>:
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
char * strsep(char **s, const char *ct)
{
3481be44:	e92d4038 	push	{r3, r4, r5, lr}
	char *sbegin = *s, *end;
3481be48:	e5904000 	ldr	r4, [r0]
 * It returns empty tokens, too, behaving exactly like the libc function
 * of that name. In fact, it was stolen from glibc2 and de-fancy-fied.
 * Same semantics, slimmer shape. ;)
 */
char * strsep(char **s, const char *ct)
{
3481be4c:	e1a05000 	mov	r5, r0
	char *sbegin = *s, *end;

	if (sbegin == NULL)
3481be50:	e3540000 	cmp	r4, #0
3481be54:	0a000005 	beq	3481be70 <strsep+0x2c>
		return NULL;

	end = strpbrk(sbegin, ct);
3481be58:	e1a00004 	mov	r0, r4
3481be5c:	ebffffca 	bl	3481bd8c <strpbrk>
	if (end)
3481be60:	e3500000 	cmp	r0, #0
		*end++ = '\0';
3481be64:	13a03000 	movne	r3, #0
3481be68:	14c03001 	strbne	r3, [r0], #1
	*s = end;
3481be6c:	e5850000 	str	r0, [r5]

	return sbegin;
}
3481be70:	e1a00004 	mov	r0, r4
3481be74:	e8bd8038 	pop	{r3, r4, r5, pc}

3481be78 <strswab>:
 */
char *strswab(const char *s)
{
	char *p, *q;

	if ((NULL == s) || ('\0' == *s)) {
3481be78:	e3500000 	cmp	r0, #0
3481be7c:	012fff1e 	bxeq	lr
3481be80:	e5d03000 	ldrb	r3, [r0]
3481be84:	e3530000 	cmp	r3, #0
3481be88:	11a03000 	movne	r3, r0
3481be8c:	1a000002 	bne	3481be9c <strswab+0x24>
3481be90:	ea000009 	b	3481bebc <strswab+0x44>

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
		char  tmp;

		tmp = *p;
		*p  = *q;
3481be94:	e5432002 	strb	r2, [r3, #-2]
		*q  = tmp;
3481be98:	e5431001 	strb	r1, [r3, #-1]

	if ((NULL == s) || ('\0' == *s)) {
		return (NULL);
	}

	for (p=(char *)s, q=p+1; (*p != '\0') && (*q != '\0'); p+=2, q+=2) {
3481be9c:	e5d31000 	ldrb	r1, [r3]
3481bea0:	e3510000 	cmp	r1, #0
3481bea4:	012fff1e 	bxeq	lr
3481bea8:	e5d32001 	ldrb	r2, [r3, #1]
3481beac:	e2833002 	add	r3, r3, #2
3481beb0:	e3520000 	cmp	r2, #0
3481beb4:	1afffff6 	bne	3481be94 <strswab+0x1c>
3481beb8:	e12fff1e 	bx	lr
char *strswab(const char *s)
{
	char *p, *q;

	if ((NULL == s) || ('\0' == *s)) {
		return (NULL);
3481bebc:	e1a00003 	mov	r0, r3
		*p  = *q;
		*q  = tmp;
	}

	return (char *) s;
}
3481bec0:	e12fff1e 	bx	lr

3481bec4 <memset>:
	unsigned long cl = 0;
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
3481bec4:	e210c003 	ands	ip, r0, #3
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
{
3481bec8:	e92d4010 	push	{r4, lr}
	unsigned long *sl = (unsigned long *) s;
3481becc:	e1a03000 	mov	r3, r0
	unsigned long cl = 0;
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
3481bed0:	1a000012 	bne	3481bf20 <memset+0x5c>
3481bed4:	e1a0300c 	mov	r3, ip
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
3481bed8:	e20140ff 	and	r4, r1, #255	; 0xff
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
3481bedc:	e2833001 	add	r3, r3, #1
3481bee0:	e3530004 	cmp	r3, #4
			cl <<= 8;
			cl |= c & 0xff;
3481bee4:	e184c40c 	orr	ip, r4, ip, lsl #8
	char *s8;
	int i;

	/* do it one word at a time (32 bits or 64 bits) while possible */
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
3481bee8:	1afffffb 	bne	3481bedc <memset+0x18>
3481beec:	e1a04000 	mov	r4, r0
3481bef0:	e1a03002 	mov	r3, r2
3481bef4:	ea000001 	b	3481bf00 <memset+0x3c>
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
			*sl++ = cl;
3481bef8:	e484c004 	str	ip, [r4], #4
			count -= sizeof(*sl);
3481befc:	e2433004 	sub	r3, r3, #4
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
3481bf00:	e3530003 	cmp	r3, #3
3481bf04:	8afffffb 	bhi	3481bef8 <memset+0x34>
 * @c: The byte to fill the area with
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
3481bf08:	e3c23003 	bic	r3, r2, #3
	if ( ((ulong)s & (sizeof(*sl) - 1)) == 0) {
		for (i = 0; i < sizeof(*sl); i++) {
			cl <<= 8;
			cl |= c & 0xff;
		}
		while (count >= sizeof(*sl)) {
3481bf0c:	e0803003 	add	r3, r0, r3
 * @c: The byte to fill the area with
 * @count: The size of the area.
 *
 * Do not use memset() to access IO space, use memset_io() instead.
 */
void * memset(void * s,int c,size_t count)
3481bf10:	e2022003 	and	r2, r2, #3
			count -= sizeof(*sl);
		}
	}
	/* fill 8 bits at a time */
	s8 = (char *)sl;
	while (count--)
3481bf14:	ea000001 	b	3481bf20 <memset+0x5c>
		*s8++ = c;
3481bf18:	e4c31001 	strb	r1, [r3], #1
3481bf1c:	e2422001 	sub	r2, r2, #1
			count -= sizeof(*sl);
		}
	}
	/* fill 8 bits at a time */
	s8 = (char *)sl;
	while (count--)
3481bf20:	e3520000 	cmp	r2, #0
3481bf24:	1afffffb 	bne	3481bf18 <memset+0x54>
		*s8++ = c;

	return s;
}
3481bf28:	e8bd8010 	pop	{r4, pc}

3481bf2c <bcopy>:
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
char * bcopy(const char * src, char * dest, int count)
{
3481bf2c:	e1a03000 	mov	r3, r0
	char *tmp = dest;

	while (count--)
3481bf30:	e3a00000 	mov	r0, #0
3481bf34:	ea000002 	b	3481bf44 <bcopy+0x18>
		*tmp++ = *src++;
3481bf38:	e7d3c000 	ldrb	ip, [r3, r0]
3481bf3c:	e7c1c000 	strb	ip, [r1, r0]
3481bf40:	e2800001 	add	r0, r0, #1
 */
char * bcopy(const char * src, char * dest, int count)
{
	char *tmp = dest;

	while (count--)
3481bf44:	e2522001 	subs	r2, r2, #1
3481bf48:	2afffffa 	bcs	3481bf38 <bcopy+0xc>
		*tmp++ = *src++;

	return dest;
}
3481bf4c:	e1a00001 	mov	r0, r1
3481bf50:	e12fff1e 	bx	lr

3481bf54 <memcpy>:
void * memcpy(void *dest, const void *src, size_t count)
{
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
	char *d8, *s8;

	if (src == dest)
3481bf54:	e1510000 	cmp	r1, r0
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
{
3481bf58:	e92d4010 	push	{r4, lr}
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
	char *d8, *s8;

	if (src == dest)
3481bf5c:	08bd8010 	popeq	{r4, pc}
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
3481bf60:	e1813000 	orr	r3, r1, r0
3481bf64:	e2133003 	ands	r3, r3, #3
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
{
	unsigned long *dl = (unsigned long *)dest, *sl = (unsigned long *)src;
3481bf68:	e1a0c000 	mov	ip, r0
3481bf6c:	e1a04001 	mov	r4, r1

	if (src == dest)
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
3481bf70:	01a0c002 	moveq	ip, r2
3481bf74:	0a000004 	beq	3481bf8c <memcpy+0x38>
3481bf78:	ea000009 	b	3481bfa4 <memcpy+0x50>
		while (count >= sizeof(*dl)) {
			*dl++ = *sl++;
3481bf7c:	e7914003 	ldr	r4, [r1, r3]
			count -= sizeof(*dl);
3481bf80:	e24cc004 	sub	ip, ip, #4
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
		while (count >= sizeof(*dl)) {
			*dl++ = *sl++;
3481bf84:	e7804003 	str	r4, [r0, r3]
			count -= sizeof(*dl);
3481bf88:	e2833004 	add	r3, r3, #4
	if (src == dest)
		return dest;

	/* while all data is aligned (common case), copy a word at a time */
	if ( (((ulong)dest | (ulong)src) & (sizeof(*dl) - 1)) == 0) {
		while (count >= sizeof(*dl)) {
3481bf8c:	e35c0003 	cmp	ip, #3
3481bf90:	8afffff9 	bhi	3481bf7c <memcpy+0x28>
 * @count: The size of the area.
 *
 * You should not use this function to access IO space, use memcpy_toio()
 * or memcpy_fromio() instead.
 */
void * memcpy(void *dest, const void *src, size_t count)
3481bf94:	e3c24003 	bic	r4, r2, #3
3481bf98:	e080c004 	add	ip, r0, r4
3481bf9c:	e2022003 	and	r2, r2, #3
3481bfa0:	e0814004 	add	r4, r1, r4
		}
	}
	/* copy the reset one byte at a time */
	d8 = (char *)dl;
	s8 = (char *)sl;
	while (count--)
3481bfa4:	e3a03000 	mov	r3, #0
3481bfa8:	ea000003 	b	3481bfbc <memcpy+0x68>
		*d8++ = *s8++;
3481bfac:	e7d41003 	ldrb	r1, [r4, r3]
3481bfb0:	e2422001 	sub	r2, r2, #1
3481bfb4:	e7cc1003 	strb	r1, [ip, r3]
3481bfb8:	e2833001 	add	r3, r3, #1
		}
	}
	/* copy the reset one byte at a time */
	d8 = (char *)dl;
	s8 = (char *)sl;
	while (count--)
3481bfbc:	e3520000 	cmp	r2, #0
3481bfc0:	1afffff9 	bne	3481bfac <memcpy+0x58>
		*d8++ = *s8++;

	return dest;
}
3481bfc4:	e8bd8010 	pop	{r4, pc}

3481bfc8 <memmove>:
 */
void * memmove(void * dest,const void *src,size_t count)
{
	char *tmp, *s;

	if (src == dest)
3481bfc8:	e1510000 	cmp	r1, r0
3481bfcc:	012fff1e 	bxeq	lr
		return dest;

	if (dest <= src) {
3481bfd0:	e1500001 	cmp	r0, r1
3481bfd4:	93a03000 	movls	r3, #0
3481bfd8:	9a000004 	bls	3481bff0 <memmove+0x28>
3481bfdc:	ea000006 	b	3481bffc <memmove+0x34>
		tmp = (char *) dest;
		s = (char *) src;
		while (count--)
			*tmp++ = *s++;
3481bfe0:	e7d1c003 	ldrb	ip, [r1, r3]
3481bfe4:	e2422001 	sub	r2, r2, #1
3481bfe8:	e7c0c003 	strb	ip, [r0, r3]
3481bfec:	e2833001 	add	r3, r3, #1
		return dest;

	if (dest <= src) {
		tmp = (char *) dest;
		s = (char *) src;
		while (count--)
3481bff0:	e3520000 	cmp	r2, #0
3481bff4:	1afffff9 	bne	3481bfe0 <memmove+0x18>
3481bff8:	e12fff1e 	bx	lr
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
		s = (char *) src + count;
3481bffc:	e0811002 	add	r1, r1, r2
		s = (char *) src;
		while (count--)
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
3481c000:	e0803002 	add	r3, r0, r2
		s = (char *) src + count;
		while (count--)
3481c004:	ea000002 	b	3481c014 <memmove+0x4c>
			*--tmp = *--s;
3481c008:	e571c001 	ldrb	ip, [r1, #-1]!
3481c00c:	e2422001 	sub	r2, r2, #1
3481c010:	e563c001 	strb	ip, [r3, #-1]!
			*tmp++ = *s++;
		}
	else {
		tmp = (char *) dest + count;
		s = (char *) src + count;
		while (count--)
3481c014:	e3520000 	cmp	r2, #0
3481c018:	1afffffa 	bne	3481c008 <memmove+0x40>
			*--tmp = *--s;
		}

	return dest;
}
3481c01c:	e12fff1e 	bx	lr

3481c020 <memcmp>:
 * @cs: One area of memory
 * @ct: Another area of memory
 * @count: The size of the area.
 */
int memcmp(const void * cs,const void * ct,size_t count)
{
3481c020:	e92d4010 	push	{r4, lr}
3481c024:	e1a03000 	mov	r3, r0
	const unsigned char *su1, *su2;
	int res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
3481c028:	e3a0c000 	mov	ip, #0
3481c02c:	ea000005 	b	3481c048 <memcmp+0x28>
		if ((res = *su1 - *su2) != 0)
3481c030:	e7d3400c 	ldrb	r4, [r3, ip]
3481c034:	e7d1000c 	ldrb	r0, [r1, ip]
3481c038:	e28cc001 	add	ip, ip, #1
3481c03c:	e0540000 	subs	r0, r4, r0
3481c040:	18bd8010 	popne	{r4, pc}
int memcmp(const void * cs,const void * ct,size_t count)
{
	const unsigned char *su1, *su2;
	int res = 0;

	for( su1 = cs, su2 = ct; 0 < count; ++su1, ++su2, count--)
3481c044:	e2422001 	sub	r2, r2, #1
3481c048:	e3520000 	cmp	r2, #0
3481c04c:	1afffff7 	bne	3481c030 <memcmp+0x10>
3481c050:	e1a00002 	mov	r0, r2
		if ((res = *su1 - *su2) != 0)
			break;
	return res;
}
3481c054:	e8bd8010 	pop	{r4, pc}

3481c058 <memscan>:
 *
 * returns the address of the first occurrence of @c, or 1 byte past
 * the area if @c is not found
 */
void * memscan(void * addr, int c, size_t size)
{
3481c058:	e1a03000 	mov	r3, r0
	unsigned char * p = (unsigned char *) addr;

	while (size) {
3481c05c:	ea000003 	b	3481c070 <memscan+0x18>
		if (*p == c)
3481c060:	e4d3c001 	ldrb	ip, [r3], #1
3481c064:	e15c0001 	cmp	ip, r1
3481c068:	012fff1e 	bxeq	lr
			return (void *) p;
		p++;
		size--;
3481c06c:	e2422001 	sub	r2, r2, #1
 */
void * memscan(void * addr, int c, size_t size)
{
	unsigned char * p = (unsigned char *) addr;

	while (size) {
3481c070:	e3520000 	cmp	r2, #0
		if (*p == c)
			return (void *) p;
		p++;
		size--;
3481c074:	e1a00003 	mov	r0, r3
 */
void * memscan(void * addr, int c, size_t size)
{
	unsigned char * p = (unsigned char *) addr;

	while (size) {
3481c078:	1afffff8 	bne	3481c060 <memscan+0x8>
			return (void *) p;
		p++;
		size--;
	}
	return (void *) p;
}
3481c07c:	e12fff1e 	bx	lr

3481c080 <strstr>:
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
3481c080:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
3481c084:	e1a04000 	mov	r4, r0
	int l1, l2;

	l2 = strlen(s2);
3481c088:	e1a00001 	mov	r0, r1
 * strstr - Find the first substring in a %NUL terminated string
 * @s1: The string to be searched
 * @s2: The string to search for
 */
char * strstr(const char * s1,const char * s2)
{
3481c08c:	e1a07001 	mov	r7, r1
	int l1, l2;

	l2 = strlen(s2);
3481c090:	ebfffeeb 	bl	3481bc44 <strlen>
	if (!l2)
3481c094:	e2506000 	subs	r6, r0, #0
3481c098:	0a00000e 	beq	3481c0d8 <strstr+0x58>
		return (char *) s1;
	l1 = strlen(s1);
3481c09c:	e1a00004 	mov	r0, r4
3481c0a0:	ebfffee7 	bl	3481bc44 <strlen>
3481c0a4:	e1a05000 	mov	r5, r0
	while (l1 >= l2) {
3481c0a8:	ea000007 	b	3481c0cc <strstr+0x4c>
		l1--;
		if (!memcmp(s1,s2,l2))
3481c0ac:	e1a00004 	mov	r0, r4
3481c0b0:	e1a01007 	mov	r1, r7
3481c0b4:	e1a02006 	mov	r2, r6
3481c0b8:	ebffffd8 	bl	3481c020 <memcmp>
3481c0bc:	e3500000 	cmp	r0, #0
3481c0c0:	0a000004 	beq	3481c0d8 <strstr+0x58>
	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
		l1--;
3481c0c4:	e2455001 	sub	r5, r5, #1
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
		s1++;
3481c0c8:	e2844001 	add	r4, r4, #1

	l2 = strlen(s2);
	if (!l2)
		return (char *) s1;
	l1 = strlen(s1);
	while (l1 >= l2) {
3481c0cc:	e1550006 	cmp	r5, r6
3481c0d0:	aafffff5 	bge	3481c0ac <strstr+0x2c>
		l1--;
		if (!memcmp(s1,s2,l2))
			return (char *) s1;
		s1++;
	}
	return NULL;
3481c0d4:	e3a04000 	mov	r4, #0
}
3481c0d8:	e1a00004 	mov	r0, r4
3481c0dc:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}

3481c0e0 <memchr>:
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
		if ((unsigned char)c == *p++) {
3481c0e0:	e6ef1071 	uxtb	r1, r1
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
3481c0e4:	ea000003 	b	3481c0f8 <memchr+0x18>
		if ((unsigned char)c == *p++) {
3481c0e8:	e4d0c001 	ldrb	ip, [r0], #1
3481c0ec:	e2422001 	sub	r2, r2, #1
3481c0f0:	e151000c 	cmp	r1, ip
3481c0f4:	0a000004 	beq	3481c10c <memchr+0x2c>
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
3481c0f8:	e3520000 	cmp	r2, #0
		if ((unsigned char)c == *p++) {
3481c0fc:	e1a03000 	mov	r3, r0
 * if @c is not found
 */
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
3481c100:	1afffff8 	bne	3481c0e8 <memchr+0x8>
		if ((unsigned char)c == *p++) {
			return (void *)(p-1);
		}
	}
	return NULL;
3481c104:	e1a00002 	mov	r0, r2
3481c108:	e12fff1e 	bx	lr
void *memchr(const void *s, int c, size_t n)
{
	const unsigned char *p = s;
	while (n-- != 0) {
		if ((unsigned char)c == *p++) {
			return (void *)(p-1);
3481c10c:	e1a00003 	mov	r0, r3
		}
	}
	return NULL;
}
3481c110:	e12fff1e 	bx	lr

3481c114 <strmhz>:
 * MA 02111-1307 USA
 */
#include <common.h>

char *strmhz (char *buf, unsigned long hz)
{
3481c114:	e92d40f8 	push	{r3, r4, r5, r6, r7, lr}
	long l, n;
	long m;

	n = DIV_ROUND(hz, 1000) / 1000L;
3481c118:	e2815f7d 	add	r5, r1, #500	; 0x1f4
 * MA 02111-1307 USA
 */
#include <common.h>

char *strmhz (char *buf, unsigned long hz)
{
3481c11c:	e1a04000 	mov	r4, r0
	long l, n;
	long m;

	n = DIV_ROUND(hz, 1000) / 1000L;
3481c120:	e59f1048 	ldr	r1, [pc, #72]	; 3481c170 <strmhz+0x5c>
3481c124:	e1a00005 	mov	r0, r5
3481c128:	eb000e9c 	bl	3481fba0 <__udivsi3>
3481c12c:	e1a06000 	mov	r6, r0
	l = sprintf (buf, "%ld", n);
3481c130:	e1a02006 	mov	r2, r6
3481c134:	e59f1038 	ldr	r1, [pc, #56]	; 3481c174 <strmhz+0x60>
3481c138:	e1a00004 	mov	r0, r4
3481c13c:	eb0002f9 	bl	3481cd28 <sprintf>
3481c140:	e1a07000 	mov	r7, r0

	hz -= n * 1000000L;
	m = DIV_ROUND(hz, 1000L);
3481c144:	e59f002c 	ldr	r0, [pc, #44]	; 3481c178 <strmhz+0x64>
3481c148:	e3a01ffa 	mov	r1, #1000	; 0x3e8
3481c14c:	e0205690 	mla	r0, r0, r6, r5
3481c150:	eb000e92 	bl	3481fba0 <__udivsi3>
	if (m != 0)
3481c154:	e2502000 	subs	r2, r0, #0
3481c158:	0a000002 	beq	3481c168 <strmhz+0x54>
		sprintf (buf + l, ".%03ld", m);
3481c15c:	e0840007 	add	r0, r4, r7
3481c160:	e59f1014 	ldr	r1, [pc, #20]	; 3481c17c <strmhz+0x68>
3481c164:	eb0002ef 	bl	3481cd28 <sprintf>
	return (buf);
}
3481c168:	e1a00004 	mov	r0, r4
3481c16c:	e8bd80f8 	pop	{r3, r4, r5, r6, r7, pc}
3481c170:	000f4240 	.word	0x000f4240
3481c174:	34827e9f 	.word	0x34827e9f
3481c178:	fff0bdc0 	.word	0xfff0bdc0
3481c17c:	3482803b 	.word	0x3482803b

3481c180 <udelay>:
#endif

/* ------------------------------------------------------------------------- */

void udelay(unsigned long usec)
{
3481c180:	e92d4070 	push	{r4, r5, r6, lr}
	ulong kv;

	do {
		WATCHDOG_RESET();
		kv = usec > CONFIG_WD_PERIOD ? CONFIG_WD_PERIOD : usec;
3481c184:	e59f6020 	ldr	r6, [pc, #32]	; 3481c1ac <udelay+0x2c>
#endif

/* ------------------------------------------------------------------------- */

void udelay(unsigned long usec)
{
3481c188:	e1a04000 	mov	r4, r0
	ulong kv;

	do {
		WATCHDOG_RESET();
		kv = usec > CONFIG_WD_PERIOD ? CONFIG_WD_PERIOD : usec;
3481c18c:	e1540006 	cmp	r4, r6
3481c190:	31a05004 	movcc	r5, r4
3481c194:	21a05006 	movcs	r5, r6
		__udelay (kv);
3481c198:	e1a00005 	mov	r0, r5
3481c19c:	ebff91e5 	bl	34800938 <__udelay>
		usec -= kv;
	} while(usec);
3481c1a0:	e0544005 	subs	r4, r4, r5
3481c1a4:	1afffff8 	bne	3481c18c <udelay+0xc>
}
3481c1a8:	e8bd8070 	pop	{r4, r5, r6, pc}
3481c1ac:	00989680 	.word	0x00989680

3481c1b0 <mdelay>:

void mdelay(unsigned long msec)
{
3481c1b0:	e92d4010 	push	{r4, lr}
3481c1b4:	e1a04000 	mov	r4, r0
	while (msec--)
3481c1b8:	ea000002 	b	3481c1c8 <mdelay+0x18>
		udelay(1000);
3481c1bc:	e3a00ffa 	mov	r0, #1000	; 0x3e8
3481c1c0:	ebffffee 	bl	3481c180 <udelay>
3481c1c4:	e2444001 	sub	r4, r4, #1
	} while(usec);
}

void mdelay(unsigned long msec)
{
	while (msec--)
3481c1c8:	e3540000 	cmp	r4, #0
3481c1cc:	1afffffa 	bne	3481c1bc <mdelay+0xc>
		udelay(1000);
}
3481c1d0:	e8bd8010 	pop	{r4, pc}

3481c1d4 <put_dec>:
					*buf++ = q + '0';
	return buf;
}
/* No inlining helps gcc to use registers better */
static noinline char* put_dec(char *buf, unsigned NUM_TYPE num)
{
3481c1d4:	e92d4ef3 	push	{r0, r1, r4, r5, r6, r7, r9, sl, fp, lr}
3481c1d8:	e28d5008 	add	r5, sp, #8
3481c1dc:	e16520f8 	strd	r2, [r5, #-8]!
3481c1e0:	e1a04000 	mov	r4, r0
	 * (x * 0x1a) >> 8:     11010 - same
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
3481c1e4:	e3a090cd 	mov	r9, #205	; 0xcd
	d0 = d0 - 10*q;
3481c1e8:	e3a0a00a 	mov	sl, #10
/* No inlining helps gcc to use registers better */
static noinline char* put_dec(char *buf, unsigned NUM_TYPE num)
{
	while (1) {
		unsigned rem;
		if (num < 100000)
3481c1ec:	e89d0840 	ldm	sp, {r6, fp}
3481c1f0:	e35b0000 	cmp	fp, #0
3481c1f4:	1a00003b 	bne	3481c2e8 <put_dec+0x114>
3481c1f8:	e59f0198 	ldr	r0, [pc, #408]	; 3481c398 <put_dec+0x1c4>
3481c1fc:	e1560000 	cmp	r6, r0
3481c200:	8a00002f 	bhi	3481c2c4 <put_dec+0xf0>
 * Outputs from one to five digits depending on input.
 * On i386 gcc 4.1.2 -O2: ~250 bytes of code. */
static char* put_dec_trunc(char *buf, unsigned q)
{
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
3481c204:	e7e37256 	ubfx	r7, r6, #4, #4
	d2 = (q>>8) & 0xf;
3481c208:	e7e31456 	ubfx	r1, r6, #8, #4
	d3 = (q>>12);
3481c20c:	e1a03626 	lsr	r3, r6, #12

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
3481c210:	e0870001 	add	r0, r7, r1
3481c214:	e206200f 	and	r2, r6, #15
3481c218:	e0800003 	add	r0, r0, r3
3481c21c:	e3a06006 	mov	r6, #6
3481c220:	e0262096 	mla	r6, r6, r0, r2
	q = (d0 * 0xcd) >> 11;
3481c224:	e3a0c0cd 	mov	ip, #205	; 0xcd
3481c228:	e005069c 	mul	r5, ip, r6
	d0 = d0 - 10*q;
3481c22c:	e3a0200a 	mov	r2, #10
	d1 = (q>>4) & 0xf;
	d2 = (q>>8) & 0xf;
	d3 = (q>>12);

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
3481c230:	e1a055a5 	lsr	r5, r5, #11
	d0 = d0 - 10*q;
3481c234:	e0666592 	mls	r6, r2, r5, r6
	*buf++ = d0 + '0'; /* least significant digit */
3481c238:	e1a00004 	mov	r0, r4
3481c23c:	e2866030 	add	r6, r6, #48	; 0x30
3481c240:	e4c06001 	strb	r6, [r0], #1
	d1 = q + 9*d3 + 5*d2 + d1;
3481c244:	e0836183 	add	r6, r3, r3, lsl #3
3481c248:	e0866007 	add	r6, r6, r7
3481c24c:	e081a101 	add	sl, r1, r1, lsl #2
3481c250:	e086600a 	add	r6, r6, sl
	if (d1 != 0) {
3481c254:	e0965005 	adds	r5, r6, r5
3481c258:	0a000018 	beq	3481c2c0 <put_dec+0xec>
		q = (d1 * 0xcd) >> 11;
3481c25c:	e006059c 	mul	r6, ip, r5
3481c260:	e1a065a6 	lsr	r6, r6, #11
		d1 = d1 - 10*q;
3481c264:	e0655692 	mls	r5, r2, r6, r5
		*buf++ = d1 + '0'; /* next digit */

		d2 = q + 2*d2;
3481c268:	e0861081 	add	r1, r6, r1, lsl #1
	*buf++ = d0 + '0'; /* least significant digit */
	d1 = q + 9*d3 + 5*d2 + d1;
	if (d1 != 0) {
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0'; /* next digit */
3481c26c:	e2855030 	add	r5, r5, #48	; 0x30
3481c270:	e5c45001 	strb	r5, [r4, #1]

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
3481c274:	e1914003 	orrs	r4, r1, r3
	*buf++ = d0 + '0'; /* least significant digit */
	d1 = q + 9*d3 + 5*d2 + d1;
	if (d1 != 0) {
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0'; /* next digit */
3481c278:	e2800001 	add	r0, r0, #1

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
3481c27c:	0a00000f 	beq	3481c2c0 <put_dec+0xec>
			q = (d2 * 0xd) >> 7;
3481c280:	e3a0400d 	mov	r4, #13
3481c284:	e0040194 	mul	r4, r4, r1
3481c288:	e1a043a4 	lsr	r4, r4, #7
			d2 = d2 - 10*q;
3481c28c:	e0611492 	mls	r1, r2, r4, r1
			*buf++ = d2 + '0'; /* next digit */

			d3 = q + 4*d3;
			if (d3 != 0) {
3481c290:	e0943103 	adds	r3, r4, r3, lsl #2

		d2 = q + 2*d2;
		if ((d2 != 0) || (d3 != 0)) {
			q = (d2 * 0xd) >> 7;
			d2 = d2 - 10*q;
			*buf++ = d2 + '0'; /* next digit */
3481c294:	e2811030 	add	r1, r1, #48	; 0x30
3481c298:	e4c01001 	strb	r1, [r0], #1

			d3 = q + 4*d3;
			if (d3 != 0) {
3481c29c:	0a000007 	beq	3481c2c0 <put_dec+0xec>
				q = (d3 * 0xcd) >> 11;
3481c2a0:	e001039c 	mul	r1, ip, r3
3481c2a4:	e1a015a1 	lsr	r1, r1, #11
				d3 = d3 - 10*q;
3481c2a8:	e0633192 	mls	r3, r2, r1, r3
				*buf++ = d3 + '0';  /* next digit */
				if (q != 0)
3481c2ac:	e3510000 	cmp	r1, #0

			d3 = q + 4*d3;
			if (d3 != 0) {
				q = (d3 * 0xcd) >> 11;
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';  /* next digit */
3481c2b0:	e2833030 	add	r3, r3, #48	; 0x30
3481c2b4:	e4c03001 	strb	r3, [r0], #1
				if (q != 0)
					*buf++ = q + '0';  /* most sign. digit */
3481c2b8:	12811030 	addne	r1, r1, #48	; 0x30
3481c2bc:	14c01001 	strbne	r1, [r0], #1
		if (num < 100000)
			return put_dec_trunc(buf, num);
		rem = do_div(num, 100000);
		buf = put_dec_full(buf, rem);
	}
}
3481c2c0:	e8bd8efc 	pop	{r2, r3, r4, r5, r6, r7, r9, sl, fp, pc}
{
	while (1) {
		unsigned rem;
		if (num < 100000)
			return put_dec_trunc(buf, num);
		rem = do_div(num, 100000);
3481c2c4:	e1a00006 	mov	r0, r6
3481c2c8:	e59f10cc 	ldr	r1, [pc, #204]	; 3481c39c <put_dec+0x1c8>
3481c2cc:	eb000eae 	bl	3481fd8c <__aeabi_uidivmod>
3481c2d0:	e1a00006 	mov	r0, r6
3481c2d4:	e1a07001 	mov	r7, r1
3481c2d8:	e59f10bc 	ldr	r1, [pc, #188]	; 3481c39c <put_dec+0x1c8>
3481c2dc:	eb000e2f 	bl	3481fba0 <__udivsi3>
3481c2e0:	e88d0801 	stm	sp, {r0, fp}
3481c2e4:	ea000003 	b	3481c2f8 <put_dec+0x124>
3481c2e8:	e1a0000d 	mov	r0, sp
3481c2ec:	e59f10a8 	ldr	r1, [pc, #168]	; 3481c39c <put_dec+0x1c8>
3481c2f0:	ebfff852 	bl	3481a440 <__div64_32>
3481c2f4:	e1a07000 	mov	r7, r0
{
	/* BTW, if q is in [0,9999], 8-bit ints will be enough, */
	/* but anyway, gcc produces better code with full-sized ints */
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
	d2 = (q>>8) & 0xf;
3481c2f8:	e7e32457 	ubfx	r2, r7, #8, #4
static char* put_dec_full(char *buf, unsigned q)
{
	/* BTW, if q is in [0,9999], 8-bit ints will be enough, */
	/* but anyway, gcc produces better code with full-sized ints */
	unsigned d3, d2, d1, d0;
	d1 = (q>>4) & 0xf;
3481c2fc:	e7e30257 	ubfx	r0, r7, #4, #4
	d2 = (q>>8) & 0xf;
	d3 = (q>>12);
3481c300:	e1a03627 	lsr	r3, r7, #12
	 * (x * 0x34) >> 9:    110100 - same
	 * (x * 0x1a) >> 8:     11010 - same
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
3481c304:	e0801002 	add	r1, r0, r2
3481c308:	e0811003 	add	r1, r1, r3
3481c30c:	e3a0c006 	mov	ip, #6
3481c310:	e207700f 	and	r7, r7, #15
3481c314:	e027719c 	mla	r7, ip, r1, r7
	q = (d0 * 0xcd) >> 11;
3481c318:	e0010799 	mul	r1, r9, r7
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
3481c31c:	e083c183 	add	ip, r3, r3, lsl #3
3481c320:	e08c0000 	add	r0, ip, r0
3481c324:	e082c102 	add	ip, r2, r2, lsl #2
	 * (x * 0x1a) >> 8:     11010 - same
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
3481c328:	e1a015a1 	lsr	r1, r1, #11
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
3481c32c:	e080000c 	add	r0, r0, ip
	 * (x * 0x0d) >> 7:      1101 - same, shortest code (on i386)
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
3481c330:	e067719a 	mls	r7, sl, r1, r7
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
3481c334:	e0801001 	add	r1, r0, r1
		q = (d1 * 0xcd) >> 11;
3481c338:	e0060199 	mul	r6, r9, r1
3481c33c:	e1a065a6 	lsr	r6, r6, #11
		d1 = d1 - 10*q;
3481c340:	e061169a 	mls	r1, sl, r6, r1
		*buf++ = d1 + '0';

		d2 = q + 2*d2;
3481c344:	e0862082 	add	r2, r6, r2, lsl #1
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0';
3481c348:	e2811030 	add	r1, r1, #48	; 0x30

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
3481c34c:	e3a0000d 	mov	r0, #13
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
	d1 = q + 9*d3 + 5*d2 + d1;
		q = (d1 * 0xcd) >> 11;
		d1 = d1 - 10*q;
		*buf++ = d1 + '0';
3481c350:	e5c41001 	strb	r1, [r4, #1]

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
3481c354:	e0010290 	mul	r1, r0, r2
3481c358:	e1a013a1 	lsr	r1, r1, #7
			d2 = d2 - 10*q;
3481c35c:	e062219a 	mls	r2, sl, r1, r2
			*buf++ = d2 + '0';

			d3 = q + 4*d3;
3481c360:	e0813103 	add	r3, r1, r3, lsl #2
		*buf++ = d1 + '0';

		d2 = q + 2*d2;
			q = (d2 * 0xd) >> 7;
			d2 = d2 - 10*q;
			*buf++ = d2 + '0';
3481c364:	e2822030 	add	r2, r2, #48	; 0x30
3481c368:	e5c42002 	strb	r2, [r4, #2]

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
3481c36c:	e0020399 	mul	r2, r9, r3
3481c370:	e1a025a2 	lsr	r2, r2, #11
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
3481c374:	e063329a 	mls	r3, sl, r2, r3
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
3481c378:	e2877030 	add	r7, r7, #48	; 0x30

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';
3481c37c:	e2833030 	add	r3, r3, #48	; 0x30
					*buf++ = q + '0';
3481c380:	e2822030 	add	r2, r2, #48	; 0x30
	 */

	d0 = 6*(d3 + d2 + d1) + (q & 0xf);
	q = (d0 * 0xcd) >> 11;
	d0 = d0 - 10*q;
	*buf++ = d0 + '0';
3481c384:	e5c47000 	strb	r7, [r4]

			d3 = q + 4*d3;
				q = (d3 * 0xcd) >> 11; /* - shorter code */
				/* q = (d3 * 0x67) >> 10; - would also work */
				d3 = d3 - 10*q;
				*buf++ = d3 + '0';
3481c388:	e5c43003 	strb	r3, [r4, #3]
					*buf++ = q + '0';
3481c38c:	e5c42004 	strb	r2, [r4, #4]
	return buf;
}
/* No inlining helps gcc to use registers better */
static noinline char* put_dec(char *buf, unsigned NUM_TYPE num)
3481c390:	e2844005 	add	r4, r4, #5
		unsigned rem;
		if (num < 100000)
			return put_dec_trunc(buf, num);
		rem = do_div(num, 100000);
		buf = put_dec_full(buf, rem);
	}
3481c394:	eaffff94 	b	3481c1ec <put_dec+0x18>
3481c398:	0001869f 	.word	0x0001869f
3481c39c:	000186a0 	.word	0x000186a0

3481c3a0 <string.clone.0>:
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
3481c3a0:	e92d4070 	push	{r4, r5, r6, lr}
		int precision, int flags)
{
	int len, i;

	if (s == 0)
		s = "<NULL>";
3481c3a4:	e3510000 	cmp	r1, #0
3481c3a8:	e59f607c 	ldr	r6, [pc, #124]	; 3481c42c <string.clone.0+0x8c>
3481c3ac:	11a06001 	movne	r6, r1
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
3481c3b0:	e1a04000 	mov	r4, r0
	int len, i;

	if (s == 0)
		s = "<NULL>";

	len = strnlen(s, precision);
3481c3b4:	e1a01003 	mov	r1, r3
3481c3b8:	e1a00006 	mov	r0, r6
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
3481c3bc:	e1a05002 	mov	r5, r2
	int len, i;

	if (s == 0)
		s = "<NULL>";

	len = strnlen(s, precision);
3481c3c0:	ebfffe4a 	bl	3481bcf0 <strnlen>

	if (!(flags & LEFT))
3481c3c4:	e59d3010 	ldr	r3, [sp, #16]
3481c3c8:	e3130010 	tst	r3, #16
3481c3cc:	1a000007 	bne	3481c3f0 <string.clone.0+0x50>
3481c3d0:	ea000001 	b	3481c3dc <string.clone.0+0x3c>
		while (len < field_width--)
			ADDCH(buf, ' ');
3481c3d4:	e4c43001 	strb	r3, [r4], #1
3481c3d8:	ea000000 	b	3481c3e0 <string.clone.0+0x40>
3481c3dc:	e3a03020 	mov	r3, #32
		s = "<NULL>";

	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
3481c3e0:	e2455001 	sub	r5, r5, #1
	while (--size >= 0)
		ADDCH(buf, ' ');
	return buf;
}

static char *string(char *buf, char *end, char *s, int field_width,
3481c3e4:	e2852001 	add	r2, r5, #1
		s = "<NULL>";

	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
3481c3e8:	e1500002 	cmp	r0, r2
3481c3ec:	bafffff8 	blt	3481c3d4 <string.clone.0+0x34>
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
3481c3f0:	e3a03000 	mov	r3, #0
3481c3f4:	ea000002 	b	3481c404 <string.clone.0+0x64>
		ADDCH(buf, *s++);
3481c3f8:	e7d62003 	ldrb	r2, [r6, r3]
	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
3481c3fc:	e2833001 	add	r3, r3, #1
		ADDCH(buf, *s++);
3481c400:	e4c42001 	strb	r2, [r4], #1
	len = strnlen(s, precision);

	if (!(flags & LEFT))
		while (len < field_width--)
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
3481c404:	e1530000 	cmp	r3, r0
3481c408:	bafffffa 	blt	3481c3f8 <string.clone.0+0x58>
		ADDCH(buf, *s++);
	while (len < field_width--)
		ADDCH(buf, ' ');
3481c40c:	e3a03020 	mov	r3, #32
3481c410:	ea000001 	b	3481c41c <string.clone.0+0x7c>
3481c414:	e4c43001 	strb	r3, [r4], #1
3481c418:	e2455001 	sub	r5, r5, #1
	if (!(flags & LEFT))
		while (len < field_width--)
			ADDCH(buf, ' ');
	for (i = 0; i < len; ++i)
		ADDCH(buf, *s++);
	while (len < field_width--)
3481c41c:	e1500005 	cmp	r0, r5
3481c420:	bafffffb 	blt	3481c414 <string.clone.0+0x74>
		ADDCH(buf, ' ');
	return buf;
}
3481c424:	e1a00004 	mov	r0, r4
3481c428:	e8bd8070 	pop	{r4, r5, r6, pc}
3481c42c:	34828042 	.word	0x34828042

3481c430 <number.clone.1>:
	} while (0)
#else
#define ADDCH(str, ch)	(*(str)++ = (ch))
#endif

static char *number(char *buf, char *end, unsigned NUM_TYPE num,
3481c430:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481c434:	e24dd058 	sub	sp, sp, #88	; 0x58
3481c438:	e59d5084 	ldr	r5, [sp, #132]	; 0x84
3481c43c:	e59d9078 	ldr	r9, [sp, #120]	; 0x78
	int need_pfx = ((type & SPECIAL) && base != 10);
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
3481c440:	e2051020 	and	r1, r5, #32
	static const char digits[16] = "0123456789ABCDEF"; /* "GHIJKLMNOPQRSTUVWXYZ"; */

	char tmp[66];
	char sign;
	char locase;
	int need_pfx = ((type & SPECIAL) && base != 10);
3481c444:	e259b00a 	subs	fp, r9, #10
3481c448:	13a0b001 	movne	fp, #1
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
	if (type & LEFT)
3481c44c:	e3150010 	tst	r5, #16
	static const char digits[16] = "0123456789ABCDEF"; /* "GHIJKLMNOPQRSTUVWXYZ"; */

	char tmp[66];
	char sign;
	char locase;
	int need_pfx = ((type & SPECIAL) && base != 10);
3481c450:	e00bb325 	and	fp, fp, r5, lsr #6

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
	if (type & LEFT)
		type &= ~ZEROPAD;
3481c454:	13c55001 	bicne	r5, r5, #1
	int need_pfx = ((type & SPECIAL) && base != 10);
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
3481c458:	e6ef1071 	uxtb	r1, r1
	if (type & LEFT)
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
3481c45c:	e215a002 	ands	sl, r5, #2
	} while (0)
#else
#define ADDCH(str, ch)	(*(str)++ = (ch))
#endif

static char *number(char *buf, char *end, unsigned NUM_TYPE num,
3481c460:	e1a04000 	mov	r4, r0
3481c464:	e59d607c 	ldr	r6, [sp, #124]	; 0x7c
	int need_pfx = ((type & SPECIAL) && base != 10);
	int i;

	/* locase = 0 or 0x20. ORing digits or letters with 'locase'
	 * produces same digits or (maybe lowercased) letters */
	locase = (type & SMALL);
3481c468:	e58d1004 	str	r1, [sp, #4]
	if (type & LEFT)
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
3481c46c:	0a00000f 	beq	3481c4b0 <number.clone.1+0x80>
		if ((signed NUM_TYPE) num < 0) {
3481c470:	e3530000 	cmp	r3, #0
3481c474:	ba000002 	blt	3481c484 <number.clone.1+0x54>
			sign = '-';
			num = - (signed NUM_TYPE) num;
			size--;
		} else if (type & PLUS) {
3481c478:	e3150004 	tst	r5, #4
3481c47c:	0a000008 	beq	3481c4a4 <number.clone.1+0x74>
3481c480:	ea000004 	b	3481c498 <number.clone.1+0x68>
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
		if ((signed NUM_TYPE) num < 0) {
			sign = '-';
			num = - (signed NUM_TYPE) num;
3481c484:	e2722000 	rsbs	r2, r2, #0
3481c488:	e2e33000 	rsc	r3, r3, #0
			size--;
3481c48c:	e2466001 	sub	r6, r6, #1
	if (type & LEFT)
		type &= ~ZEROPAD;
	sign = 0;
	if (type & SIGN) {
		if ((signed NUM_TYPE) num < 0) {
			sign = '-';
3481c490:	e3a0a02d 	mov	sl, #45	; 0x2d
3481c494:	ea000005 	b	3481c4b0 <number.clone.1+0x80>
			num = - (signed NUM_TYPE) num;
			size--;
		} else if (type & PLUS) {
			sign = '+';
			size--;
3481c498:	e2466001 	sub	r6, r6, #1
		if ((signed NUM_TYPE) num < 0) {
			sign = '-';
			num = - (signed NUM_TYPE) num;
			size--;
		} else if (type & PLUS) {
			sign = '+';
3481c49c:	e3a0a02b 	mov	sl, #43	; 0x2b
3481c4a0:	ea000002 	b	3481c4b0 <number.clone.1+0x80>
			size--;
		} else if (type & SPACE) {
3481c4a4:	e215a008 	ands	sl, r5, #8
			sign = ' ';
			size--;
3481c4a8:	12466001 	subne	r6, r6, #1
			size--;
		} else if (type & PLUS) {
			sign = '+';
			size--;
		} else if (type & SPACE) {
			sign = ' ';
3481c4ac:	13a0a020 	movne	sl, #32
			size--;
		}
	}
	if (need_pfx) {
3481c4b0:	e35b0000 	cmp	fp, #0
3481c4b4:	0a000002 	beq	3481c4c4 <number.clone.1+0x94>
		size--;
3481c4b8:	e2466001 	sub	r6, r6, #1
		if (base == 16)
3481c4bc:	e3590010 	cmp	r9, #16
			size--;
3481c4c0:	02466001 	subeq	r6, r6, #1
	}

	/* generate full string in tmp[], in reverse order */
	i = 0;
	if (num == 0)
3481c4c4:	e1921003 	orrs	r1, r2, r3
		tmp[i++] = '0';
3481c4c8:	03a03030 	moveq	r3, #48	; 0x30
3481c4cc:	05cd3014 	strbeq	r3, [sp, #20]
3481c4d0:	03a07001 	moveq	r7, #1
			size--;
	}

	/* generate full string in tmp[], in reverse order */
	i = 0;
	if (num == 0)
3481c4d4:	0a000023 	beq	3481c568 <number.clone.1+0x138>
	/* Generic code, for any base:
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
3481c4d8:	e359000a 	cmp	r9, #10
3481c4dc:	0a00001d 	beq	3481c558 <number.clone.1+0x128>
		int mask = base - 1;
		int shift = 3;
3481c4e0:	e3590010 	cmp	r9, #16
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
3481c4e4:	e2491001 	sub	r1, r9, #1
		int shift = 3;
3481c4e8:	03a0c004 	moveq	ip, #4
3481c4ec:	13a0c003 	movne	ip, #3
	else do {
		tmp[i++] = (digits[do_div(num,base)] | locase);
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
3481c4f0:	e58d1008 	str	r1, [sp, #8]
		int shift = 3;
		if (base == 16) shift = 4;
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
3481c4f4:	e58db00c 	str	fp, [sp, #12]
	} while (num != 0);
	*/
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
		int shift = 3;
		if (base == 16) shift = 4;
3481c4f8:	e3a07000 	mov	r7, #0
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
3481c4fc:	e1a0b00a 	mov	fp, sl
3481c500:	e1a00002 	mov	r0, r2
3481c504:	e1a0a004 	mov	sl, r4
3481c508:	e1a01003 	mov	r1, r3
3481c50c:	e1a0400c 	mov	r4, ip
3481c510:	e59d3008 	ldr	r3, [sp, #8]
3481c514:	e6ef2070 	uxtb	r2, r0
3481c518:	e0022003 	and	r2, r2, r3
3481c51c:	e59f311c 	ldr	r3, [pc, #284]	; 3481c640 <number.clone.1+0x210>
3481c520:	e7d3c002 	ldrb	ip, [r3, r2]
3481c524:	e59d3004 	ldr	r3, [sp, #4]
3481c528:	e28d2014 	add	r2, sp, #20
3481c52c:	e183c00c 	orr	ip, r3, ip
3481c530:	e7c2c007 	strb	ip, [r2, r7]
			num >>= shift;
3481c534:	e1a02004 	mov	r2, r4
3481c538:	eb000eab 	bl	3481ffec <__lshrdi3>
		} while (num);
3481c53c:	e1903001 	orrs	r3, r0, r1
	else if (base != 10) { /* 8 or 16 */
		int mask = base - 1;
		int shift = 3;
		if (base == 16) shift = 4;
		do {
			tmp[i++] = (digits[((unsigned char)num) & mask] | locase);
3481c540:	e2877001 	add	r7, r7, #1
			num >>= shift;
		} while (num);
3481c544:	1afffff1 	bne	3481c510 <number.clone.1+0xe0>
3481c548:	e1a0400a 	mov	r4, sl
3481c54c:	e1a0a00b 	mov	sl, fp
3481c550:	e59db00c 	ldr	fp, [sp, #12]
3481c554:	ea000003 	b	3481c568 <number.clone.1+0x138>
	} else { /* base 10 */
		i = put_dec(tmp, num) - tmp;
3481c558:	e28d7014 	add	r7, sp, #20
3481c55c:	e1a00007 	mov	r0, r7
3481c560:	ebffff1b 	bl	3481c1d4 <put_dec>
3481c564:	e0677000 	rsb	r7, r7, r0
3481c568:	e59d3080 	ldr	r3, [sp, #128]	; 0x80
3481c56c:	e1570003 	cmp	r7, r3
3481c570:	a1a03007 	movge	r3, r7
3481c574:	b1a03003 	movlt	r3, r3
	/* printing 100 using %2d gives "100", not "00" */
	if (i > precision)
		precision = i;
	/* leading space padding */
	size -= precision;
	if (!(type & (ZEROPAD + LEFT))) {
3481c578:	e3150011 	tst	r5, #17

	/* printing 100 using %2d gives "100", not "00" */
	if (i > precision)
		precision = i;
	/* leading space padding */
	size -= precision;
3481c57c:	e0636006 	rsb	r6, r3, r6
	if (!(type & (ZEROPAD + LEFT))) {
3481c580:	1a000005 	bne	3481c59c <number.clone.1+0x16c>
3481c584:	ea000001 	b	3481c590 <number.clone.1+0x160>
		while (--size >= 0)
			ADDCH(buf, ' ');
3481c588:	e4c42001 	strb	r2, [r4], #1
3481c58c:	ea000000 	b	3481c594 <number.clone.1+0x164>
3481c590:	e3a02020 	mov	r2, #32
	if (i > precision)
		precision = i;
	/* leading space padding */
	size -= precision;
	if (!(type & (ZEROPAD + LEFT))) {
		while (--size >= 0)
3481c594:	e2566001 	subs	r6, r6, #1
3481c598:	5afffffa 	bpl	3481c588 <number.clone.1+0x158>
			ADDCH(buf, ' ');
	}
	/* sign */
	if (sign)
3481c59c:	e35a0000 	cmp	sl, #0
		ADDCH(buf, sign);
3481c5a0:	14c4a001 	strbne	sl, [r4], #1
	/* "0x" / "0" prefix */
	if (need_pfx) {
3481c5a4:	e35b0000 	cmp	fp, #0
3481c5a8:	0a000005 	beq	3481c5c4 <number.clone.1+0x194>
		ADDCH(buf, '0');
3481c5ac:	e3a02030 	mov	r2, #48	; 0x30
3481c5b0:	e4c42001 	strb	r2, [r4], #1
		if (base == 16)
3481c5b4:	e3590010 	cmp	r9, #16
			ADDCH(buf, 'X' | locase);
3481c5b8:	059d1004 	ldreq	r1, [sp, #4]
3481c5bc:	03812058 	orreq	r2, r1, #88	; 0x58
3481c5c0:	04c42001 	strbeq	r2, [r4], #1
	}
	/* zero or space padding */
	if (!(type & LEFT)) {
3481c5c4:	e3150010 	tst	r5, #16
3481c5c8:	1a000009 	bne	3481c5f4 <number.clone.1+0x1c4>
		char c = (type & ZEROPAD) ? '0' : ' ';
3481c5cc:	e3150001 	tst	r5, #1
3481c5d0:	03a02020 	moveq	r2, #32
3481c5d4:	13a02030 	movne	r2, #48	; 0x30
3481c5d8:	ea000000 	b	3481c5e0 <number.clone.1+0x1b0>

		while (--size >= 0)
			ADDCH(buf, c);
3481c5dc:	e4c42001 	strb	r2, [r4], #1
	}
	/* zero or space padding */
	if (!(type & LEFT)) {
		char c = (type & ZEROPAD) ? '0' : ' ';

		while (--size >= 0)
3481c5e0:	e2566001 	subs	r6, r6, #1
3481c5e4:	5afffffc 	bpl	3481c5dc <number.clone.1+0x1ac>
3481c5e8:	ea000001 	b	3481c5f4 <number.clone.1+0x1c4>
			ADDCH(buf, c);
	}
	/* hmm even more zero padding? */
	while (i <= --precision)
		ADDCH(buf, '0');
3481c5ec:	e4c42001 	strb	r2, [r4], #1
3481c5f0:	ea000000 	b	3481c5f8 <number.clone.1+0x1c8>
3481c5f4:	e3a02030 	mov	r2, #48	; 0x30

		while (--size >= 0)
			ADDCH(buf, c);
	}
	/* hmm even more zero padding? */
	while (i <= --precision)
3481c5f8:	e2433001 	sub	r3, r3, #1
3481c5fc:	e1570003 	cmp	r7, r3
3481c600:	dafffff9 	ble	3481c5ec <number.clone.1+0x1bc>
3481c604:	ea000002 	b	3481c614 <number.clone.1+0x1e4>
		ADDCH(buf, '0');
	/* actual digits of result */
	while (--i >= 0)
		ADDCH(buf, tmp[i]);
3481c608:	e28d3014 	add	r3, sp, #20
3481c60c:	e7d33007 	ldrb	r3, [r3, r7]
3481c610:	e4c43001 	strb	r3, [r4], #1
	}
	/* hmm even more zero padding? */
	while (i <= --precision)
		ADDCH(buf, '0');
	/* actual digits of result */
	while (--i >= 0)
3481c614:	e2577001 	subs	r7, r7, #1
3481c618:	5afffffa 	bpl	3481c608 <number.clone.1+0x1d8>
3481c61c:	ea000001 	b	3481c628 <number.clone.1+0x1f8>
		ADDCH(buf, tmp[i]);
	/* trailing space padding */
	while (--size >= 0)
		ADDCH(buf, ' ');
3481c620:	e4c43001 	strb	r3, [r4], #1
3481c624:	ea000000 	b	3481c62c <number.clone.1+0x1fc>
3481c628:	e3a03020 	mov	r3, #32
		ADDCH(buf, '0');
	/* actual digits of result */
	while (--i >= 0)
		ADDCH(buf, tmp[i]);
	/* trailing space padding */
	while (--size >= 0)
3481c62c:	e2566001 	subs	r6, r6, #1
3481c630:	5afffffa 	bpl	3481c620 <number.clone.1+0x1f0>
		ADDCH(buf, ' ');
	return buf;
}
3481c634:	e1a00004 	mov	r0, r4
3481c638:	e28dd058 	add	sp, sp, #88	; 0x58
3481c63c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481c640:	34821ddc 	.word	0x34821ddc

3481c644 <vsnprintf_internal.clone.3>:
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
3481c644:	e92d4eff 	push	{r0, r1, r2, r3, r4, r5, r6, r7, r9, sl, fp, lr}
3481c648:	e1a0a000 	mov	sl, r0
3481c64c:	e1a06001 	mov	r6, r1
				++fmt;
			}
		}

		/* default base */
		base = 10;
3481c650:	e3a0900a 	mov	r9, #10

		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
3481c654:	e3a0b020 	mov	fp, #32
3481c658:	ea000103 	b	3481ca6c <vsnprintf_internal.clone.3+0x428>
	}
#endif
	str = buf;

	for (; *fmt ; ++fmt) {
		if (*fmt != '%') {
3481c65c:	e3530025 	cmp	r3, #37	; 0x25
3481c660:	1a0000cc 	bne	3481c998 <vsnprintf_internal.clone.3+0x354>
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
		      precision, flags);
}

static int vsnprintf_internal(char *buf, size_t size, const char *fmt,
3481c664:	e286c001 	add	ip, r6, #1
3481c668:	e3a01000 	mov	r1, #0
#endif
	str = buf;

	for (; *fmt ; ++fmt) {
		if (*fmt != '%') {
			ADDCH(str, *fmt);
3481c66c:	e1a0600c 	mov	r6, ip

		/* process flags */
		flags = 0;
		repeat:
			++fmt;		/* this also skips first '%' */
			switch (*fmt) {
3481c670:	e4dc3001 	ldrb	r3, [ip], #1
3481c674:	e353002b 	cmp	r3, #43	; 0x2b
3481c678:	0a00000c 	beq	3481c6b0 <vsnprintf_internal.clone.3+0x6c>
3481c67c:	8a000004 	bhi	3481c694 <vsnprintf_internal.clone.3+0x50>
3481c680:	e3530020 	cmp	r3, #32
3481c684:	0a00000b 	beq	3481c6b8 <vsnprintf_internal.clone.3+0x74>
3481c688:	e3530023 	cmp	r3, #35	; 0x23
3481c68c:	1a00000f 	bne	3481c6d0 <vsnprintf_internal.clone.3+0x8c>
3481c690:	ea00000a 	b	3481c6c0 <vsnprintf_internal.clone.3+0x7c>
3481c694:	e353002d 	cmp	r3, #45	; 0x2d
3481c698:	0a000002 	beq	3481c6a8 <vsnprintf_internal.clone.3+0x64>
3481c69c:	e3530030 	cmp	r3, #48	; 0x30
3481c6a0:	1a00000a 	bne	3481c6d0 <vsnprintf_internal.clone.3+0x8c>
3481c6a4:	ea000007 	b	3481c6c8 <vsnprintf_internal.clone.3+0x84>
				case '-': flags |= LEFT; goto repeat;
3481c6a8:	e3811010 	orr	r1, r1, #16
3481c6ac:	eaffffee 	b	3481c66c <vsnprintf_internal.clone.3+0x28>
				case '+': flags |= PLUS; goto repeat;
3481c6b0:	e3811004 	orr	r1, r1, #4
3481c6b4:	eaffffec 	b	3481c66c <vsnprintf_internal.clone.3+0x28>
				case ' ': flags |= SPACE; goto repeat;
3481c6b8:	e3811008 	orr	r1, r1, #8
3481c6bc:	eaffffea 	b	3481c66c <vsnprintf_internal.clone.3+0x28>
				case '#': flags |= SPECIAL; goto repeat;
3481c6c0:	e3811040 	orr	r1, r1, #64	; 0x40
3481c6c4:	eaffffe8 	b	3481c66c <vsnprintf_internal.clone.3+0x28>
				case '0': flags |= ZEROPAD; goto repeat;
3481c6c8:	e3811001 	orr	r1, r1, #1
3481c6cc:	eaffffe6 	b	3481c66c <vsnprintf_internal.clone.3+0x28>
			}

		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
3481c6d0:	e243c030 	sub	ip, r3, #48	; 0x30
3481c6d4:	e6efc07c 	uxtb	ip, ip
3481c6d8:	e35c0009 	cmp	ip, #9
3481c6dc:	91a03006 	movls	r3, r6
3481c6e0:	93a0c000 	movls	ip, #0
3481c6e4:	9a000001 	bls	3481c6f0 <vsnprintf_internal.clone.3+0xac>
3481c6e8:	ea000007 	b	3481c70c <vsnprintf_internal.clone.3+0xc8>
static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
		i = i*10 + *((*s)++) - '0';
3481c6ec:	e02c4c99 	mla	ip, r9, ip, r4
3481c6f0:	e1a06003 	mov	r6, r3

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
3481c6f4:	e4d34001 	ldrb	r4, [r3], #1
3481c6f8:	e2444030 	sub	r4, r4, #48	; 0x30
3481c6fc:	e6ef5074 	uxtb	r5, r4
3481c700:	e3550009 	cmp	r5, #9
3481c704:	9afffff8 	bls	3481c6ec <vsnprintf_internal.clone.3+0xa8>
3481c708:	ea000009 	b	3481c734 <vsnprintf_internal.clone.3+0xf0>

		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
3481c70c:	e353002a 	cmp	r3, #42	; 0x2a
				case '#': flags |= SPECIAL; goto repeat;
				case '0': flags |= ZEROPAD; goto repeat;
			}

		/* get field width */
		field_width = -1;
3481c710:	13e0c000 	mvnne	ip, #0
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
3481c714:	1a000006 	bne	3481c734 <vsnprintf_internal.clone.3+0xf0>
			++fmt;
			/* it's the next argument */
			field_width = va_arg(args, int);
3481c718:	e592c000 	ldr	ip, [r2]
3481c71c:	e2823004 	add	r3, r2, #4
			if (field_width < 0) {
3481c720:	e35c0000 	cmp	ip, #0
		/* get field width */
		field_width = -1;
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
			++fmt;
3481c724:	e2866001 	add	r6, r6, #1
			/* it's the next argument */
			field_width = va_arg(args, int);
			if (field_width < 0) {
				field_width = -field_width;
3481c728:	b26cc000 	rsblt	ip, ip, #0
				flags |= LEFT;
3481c72c:	b3811010 	orrlt	r1, r1, #16
		if (is_digit(*fmt))
			field_width = skip_atoi(&fmt);
		else if (*fmt == '*') {
			++fmt;
			/* it's the next argument */
			field_width = va_arg(args, int);
3481c730:	e1a02003 	mov	r2, r3
			}
		}

		/* get the precision */
		precision = -1;
		if (*fmt == '.') {
3481c734:	e5d63000 	ldrb	r3, [r6]
3481c738:	e353002e 	cmp	r3, #46	; 0x2e
				flags |= LEFT;
			}
		}

		/* get the precision */
		precision = -1;
3481c73c:	13e03000 	mvnne	r3, #0
		if (*fmt == '.') {
3481c740:	1a00001c 	bne	3481c7b8 <vsnprintf_internal.clone.3+0x174>
			++fmt;
			if (is_digit(*fmt))
3481c744:	e5f63001 	ldrb	r3, [r6, #1]!
3481c748:	e2434030 	sub	r4, r3, #48	; 0x30
3481c74c:	e6ef4074 	uxtb	r4, r4
3481c750:	e3540009 	cmp	r4, #9
3481c754:	91a07006 	movls	r7, r6
3481c758:	93a03000 	movls	r3, #0
3481c75c:	9a000001 	bls	3481c768 <vsnprintf_internal.clone.3+0x124>
3481c760:	ea000009 	b	3481c78c <vsnprintf_internal.clone.3+0x148>
static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
		i = i*10 + *((*s)++) - '0';
3481c764:	e0235399 	mla	r3, r9, r3, r5

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
3481c768:	e5d75000 	ldrb	r5, [r7]
		i = i*10 + *((*s)++) - '0';
3481c76c:	e1a06007 	mov	r6, r7

static int skip_atoi(const char **s)
{
	int i=0;

	while (is_digit(**s))
3481c770:	e2455030 	sub	r5, r5, #48	; 0x30
3481c774:	e6ef4075 	uxtb	r4, r5
3481c778:	e3540009 	cmp	r4, #9
3481c77c:	e2877001 	add	r7, r7, #1
3481c780:	9afffff7 	bls	3481c764 <vsnprintf_internal.clone.3+0x120>
3481c784:	e1a04002 	mov	r4, r2
3481c788:	ea000006 	b	3481c7a8 <vsnprintf_internal.clone.3+0x164>
		precision = -1;
		if (*fmt == '.') {
			++fmt;
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
3481c78c:	e353002a 	cmp	r3, #42	; 0x2a
3481c790:	1a000007 	bne	3481c7b4 <vsnprintf_internal.clone.3+0x170>
				++fmt;
				/* it's the next argument */
				precision = va_arg(args, int);
3481c794:	e5923000 	ldr	r3, [r2]
		if (*fmt == '.') {
			++fmt;
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				++fmt;
3481c798:	e2866001 	add	r6, r6, #1
				/* it's the next argument */
				precision = va_arg(args, int);
			}
			if (precision < 0)
3481c79c:	e3530000 	cmp	r3, #0
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				++fmt;
				/* it's the next argument */
				precision = va_arg(args, int);
3481c7a0:	e2824004 	add	r4, r2, #4
			}
			if (precision < 0)
3481c7a4:	ba000001 	blt	3481c7b0 <vsnprintf_internal.clone.3+0x16c>
				flags |= LEFT;
			}
		}

		/* get the precision */
		precision = -1;
3481c7a8:	e1a02004 	mov	r2, r4
3481c7ac:	ea000001 	b	3481c7b8 <vsnprintf_internal.clone.3+0x174>
			if (is_digit(*fmt))
				precision = skip_atoi(&fmt);
			else if (*fmt == '*') {
				++fmt;
				/* it's the next argument */
				precision = va_arg(args, int);
3481c7b0:	e1a02004 	mov	r2, r4
			}
			if (precision < 0)
				precision = 0;
3481c7b4:	e3a03000 	mov	r3, #0
		}

		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
3481c7b8:	e5d64000 	ldrb	r4, [r6]
3481c7bc:	e3540068 	cmp	r4, #104	; 0x68
3481c7c0:	1354006c 	cmpne	r4, #108	; 0x6c
3481c7c4:	0a000008 	beq	3481c7ec <vsnprintf_internal.clone.3+0x1a8>
3481c7c8:	e354004c 	cmp	r4, #76	; 0x4c
3481c7cc:	0a000006 	beq	3481c7ec <vsnprintf_internal.clone.3+0x1a8>
3481c7d0:	e354005a 	cmp	r4, #90	; 0x5a
3481c7d4:	0a000004 	beq	3481c7ec <vsnprintf_internal.clone.3+0x1a8>
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
3481c7d8:	e354007a 	cmp	r4, #122	; 0x7a
3481c7dc:	0a000002 	beq	3481c7ec <vsnprintf_internal.clone.3+0x1a8>
3481c7e0:	e3540074 	cmp	r4, #116	; 0x74
			if (precision < 0)
				precision = 0;
		}

		/* get the conversion qualifier */
		qualifier = -1;
3481c7e4:	13e04000 	mvnne	r4, #0
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
3481c7e8:	1a000006 	bne	3481c808 <vsnprintf_internal.clone.3+0x1c4>
			qualifier = *fmt;
			++fmt;
			if (qualifier == 'l' && *fmt == 'l') {
3481c7ec:	e354006c 	cmp	r4, #108	; 0x6c
		/* get the conversion qualifier */
		qualifier = -1;
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
			qualifier = *fmt;
			++fmt;
3481c7f0:	e2866001 	add	r6, r6, #1
			if (qualifier == 'l' && *fmt == 'l') {
3481c7f4:	1a000003 	bne	3481c808 <vsnprintf_internal.clone.3+0x1c4>
3481c7f8:	e5d65000 	ldrb	r5, [r6]
3481c7fc:	e355006c 	cmp	r5, #108	; 0x6c
				qualifier = 'L';
				++fmt;
3481c800:	02866001 	addeq	r6, r6, #1
		if (*fmt == 'h' || *fmt == 'l' || *fmt == 'L' ||
		    *fmt == 'Z' || *fmt == 'z' || *fmt == 't') {
			qualifier = *fmt;
			++fmt;
			if (qualifier == 'l' && *fmt == 'l') {
				qualifier = 'L';
3481c804:	03a0404c 	moveq	r4, #76	; 0x4c
		}

		/* default base */
		base = 10;

		switch (*fmt) {
3481c808:	e5d65000 	ldrb	r5, [r6]
3481c80c:	e355006e 	cmp	r5, #110	; 0x6e
3481c810:	0a00004f 	beq	3481c954 <vsnprintf_internal.clone.3+0x310>
3481c814:	8a00000d 	bhi	3481c850 <vsnprintf_internal.clone.3+0x20c>
3481c818:	e3550063 	cmp	r5, #99	; 0x63
3481c81c:	0a000018 	beq	3481c884 <vsnprintf_internal.clone.3+0x240>
3481c820:	8a000005 	bhi	3481c83c <vsnprintf_internal.clone.3+0x1f8>
3481c824:	e3550025 	cmp	r5, #37	; 0x25
				*ip = (str - buf);
			}
			continue;

		case '%':
			ADDCH(str, '%');
3481c828:	04c05001 	strbeq	r5, [r0], #1
		}

		/* default base */
		base = 10;

		switch (*fmt) {
3481c82c:	0a00008d 	beq	3481ca68 <vsnprintf_internal.clone.3+0x424>
3481c830:	e3550058 	cmp	r5, #88	; 0x58
3481c834:	1a000051 	bne	3481c980 <vsnprintf_internal.clone.3+0x33c>
3481c838:	ea00005a 	b	3481c9a8 <vsnprintf_internal.clone.3+0x364>
3481c83c:	e3550064 	cmp	r5, #100	; 0x64
3481c840:	0a00004c 	beq	3481c978 <vsnprintf_internal.clone.3+0x334>
3481c844:	e3550069 	cmp	r5, #105	; 0x69
3481c848:	1a00004c 	bne	3481c980 <vsnprintf_internal.clone.3+0x33c>
3481c84c:	ea000049 	b	3481c978 <vsnprintf_internal.clone.3+0x334>
3481c850:	e3550073 	cmp	r5, #115	; 0x73
3481c854:	0a00001b 	beq	3481c8c8 <vsnprintf_internal.clone.3+0x284>
3481c858:	8a000004 	bhi	3481c870 <vsnprintf_internal.clone.3+0x22c>
3481c85c:	e355006f 	cmp	r5, #111	; 0x6f
3481c860:	0a000040 	beq	3481c968 <vsnprintf_internal.clone.3+0x324>
3481c864:	e3550070 	cmp	r5, #112	; 0x70
3481c868:	1a000044 	bne	3481c980 <vsnprintf_internal.clone.3+0x33c>
3481c86c:	ea00001b 	b	3481c8e0 <vsnprintf_internal.clone.3+0x29c>
3481c870:	e3550075 	cmp	r5, #117	; 0x75
3481c874:	0a000049 	beq	3481c9a0 <vsnprintf_internal.clone.3+0x35c>
3481c878:	e3550078 	cmp	r5, #120	; 0x78
3481c87c:	1a00003f 	bne	3481c980 <vsnprintf_internal.clone.3+0x33c>
3481c880:	ea00003a 	b	3481c970 <vsnprintf_internal.clone.3+0x32c>
		case 'c':
			if (!(flags & LEFT)) {
3481c884:	e3110010 	tst	r1, #16
3481c888:	1a000004 	bne	3481c8a0 <vsnprintf_internal.clone.3+0x25c>
3481c88c:	ea000000 	b	3481c894 <vsnprintf_internal.clone.3+0x250>
				while (--field_width > 0)
					ADDCH(str, ' ');
3481c890:	e4c0b001 	strb	fp, [r0], #1
		base = 10;

		switch (*fmt) {
		case 'c':
			if (!(flags & LEFT)) {
				while (--field_width > 0)
3481c894:	e24cc001 	sub	ip, ip, #1
3481c898:	e35c0000 	cmp	ip, #0
3481c89c:	cafffffb 	bgt	3481c890 <vsnprintf_internal.clone.3+0x24c>
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
3481c8a0:	e2823004 	add	r3, r2, #4
3481c8a4:	e5922000 	ldr	r2, [r2]
3481c8a8:	ea000000 	b	3481c8b0 <vsnprintf_internal.clone.3+0x26c>
			while (--field_width > 0)
				ADDCH(str, ' ');
3481c8ac:	e1a0200b 	mov	r2, fp
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
			while (--field_width > 0)
3481c8b0:	e24cc001 	sub	ip, ip, #1
3481c8b4:	e35c0000 	cmp	ip, #0
				ADDCH(str, ' ');
3481c8b8:	e4c02001 	strb	r2, [r0], #1
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
			while (--field_width > 0)
3481c8bc:	cafffffa 	bgt	3481c8ac <vsnprintf_internal.clone.3+0x268>
		case 'c':
			if (!(flags & LEFT)) {
				while (--field_width > 0)
					ADDCH(str, ' ');
			}
			ADDCH(str, (unsigned char) va_arg(args, int));
3481c8c0:	e1a02003 	mov	r2, r3
3481c8c4:	ea000067 	b	3481ca68 <vsnprintf_internal.clone.3+0x424>
			while (--field_width > 0)
				ADDCH(str, ' ');
			continue;

		case 's':
			str = string(str, end, va_arg(args, char *),
3481c8c8:	e58d1000 	str	r1, [sp]
3481c8cc:	e2824004 	add	r4, r2, #4
3481c8d0:	e5921000 	ldr	r1, [r2]
3481c8d4:	e1a0200c 	mov	r2, ip
3481c8d8:	ebfffeb0 	bl	3481c3a0 <string.clone.0>
3481c8dc:	ea00001a 	b	3481c94c <vsnprintf_internal.clone.3+0x308>
				     field_width, precision, flags);
			continue;

		case 'p':
			str = pointer(fmt+1, str, end,
3481c8e0:	e2824004 	add	r4, r2, #4
3481c8e4:	e5922000 	ldr	r2, [r2]
 * pointer to the real address.
 */
static char *pointer(const char *fmt, char *buf, char *end, void *ptr,
		int field_width, int precision, int flags)
{
	if (!ptr)
3481c8e8:	e3520000 	cmp	r2, #0
3481c8ec:	1a000004 	bne	3481c904 <vsnprintf_internal.clone.3+0x2c0>
		return string(buf, end, "(null)", field_width, precision,
3481c8f0:	e58d1000 	str	r1, [sp]
3481c8f4:	e1a0200c 	mov	r2, ip
3481c8f8:	e59f1188 	ldr	r1, [pc, #392]	; 3481ca88 <vsnprintf_internal.clone.3+0x444>
3481c8fc:	ebfffea7 	bl	3481c3a0 <string.clone.0>
3481c900:	ea000009 	b	3481c92c <vsnprintf_internal.clone.3+0x2e8>
		flags &= ~SPECIAL;
		break;
	}
#endif
	flags |= SMALL;
	if (field_width == -1) {
3481c904:	e37c0001 	cmn	ip, #1
					       precision, flags);
		flags &= ~SPECIAL;
		break;
	}
#endif
	flags |= SMALL;
3481c908:	e381e020 	orr	lr, r1, #32
	if (field_width == -1) {
		field_width = 2*sizeof(void *);
3481c90c:	028cc009 	addeq	ip, ip, #9
		flags |= ZEROPAD;
3481c910:	0381e021 	orreq	lr, r1, #33	; 0x21
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
3481c914:	e58d3008 	str	r3, [sp, #8]
3481c918:	e3a01010 	mov	r1, #16
3481c91c:	e3a03000 	mov	r3, #0
3481c920:	e88d1002 	stm	sp, {r1, ip}
3481c924:	e58de00c 	str	lr, [sp, #12]
3481c928:	ebfffec0 	bl	3481c430 <number.clone.1>
3481c92c:	e1a03006 	mov	r3, r6
		case 'p':
			str = pointer(fmt+1, str, end,
					va_arg(args, void *),
					field_width, precision, flags);
			/* Skip all alphanumeric pointer suffixes */
			while (isalnum(fmt[1]))
3481c930:	e5d32001 	ldrb	r2, [r3, #1]
3481c934:	e59f1150 	ldr	r1, [pc, #336]	; 3481ca8c <vsnprintf_internal.clone.3+0x448>
	flags |= SMALL;
	if (field_width == -1) {
		field_width = 2*sizeof(void *);
		flags |= ZEROPAD;
	}
	return number(buf, end, (unsigned long)ptr, 16, field_width,
3481c938:	e1a06003 	mov	r6, r3
		case 'p':
			str = pointer(fmt+1, str, end,
					va_arg(args, void *),
					field_width, precision, flags);
			/* Skip all alphanumeric pointer suffixes */
			while (isalnum(fmt[1]))
3481c93c:	e7d12002 	ldrb	r2, [r1, r2]
3481c940:	e2833001 	add	r3, r3, #1
3481c944:	e3120007 	tst	r2, #7
3481c948:	1afffff8 	bne	3481c930 <vsnprintf_internal.clone.3+0x2ec>
			str = string(str, end, va_arg(args, char *),
				     field_width, precision, flags);
			continue;

		case 'p':
			str = pointer(fmt+1, str, end,
3481c94c:	e1a02004 	mov	r2, r4
3481c950:	ea000044 	b	3481ca68 <vsnprintf_internal.clone.3+0x424>
3481c954:	e2827004 	add	r7, r2, #4
			if (qualifier == 'l') {
				long * ip = va_arg(args, long *);
				*ip = (str - buf);
			} else {
				int * ip = va_arg(args, int *);
				*ip = (str - buf);
3481c958:	e5922000 	ldr	r2, [r2]
3481c95c:	e06a3000 	rsb	r3, sl, r0
3481c960:	e5823000 	str	r3, [r2]
3481c964:	ea00003e 	b	3481ca64 <vsnprintf_internal.clone.3+0x420>
			ADDCH(str, '%');
			continue;

		/* integer number formats - set up the flags and "break" */
		case 'o':
			base = 8;
3481c968:	e3a0e008 	mov	lr, #8
3481c96c:	ea00000e 	b	3481c9ac <vsnprintf_internal.clone.3+0x368>
			break;

		case 'x':
			flags |= SMALL;
3481c970:	e3811020 	orr	r1, r1, #32
3481c974:	ea00000b 	b	3481c9a8 <vsnprintf_internal.clone.3+0x364>
			base = 16;
			break;

		case 'd':
		case 'i':
			flags |= SIGN;
3481c978:	e3811002 	orr	r1, r1, #2
3481c97c:	ea000007 	b	3481c9a0 <vsnprintf_internal.clone.3+0x35c>
		case 'u':
			break;

		default:
			ADDCH(str, '%');
3481c980:	e3a03025 	mov	r3, #37	; 0x25
3481c984:	e4c03001 	strb	r3, [r0], #1
			if (*fmt)
3481c988:	e5d63000 	ldrb	r3, [r6]
3481c98c:	e3530000 	cmp	r3, #0
				ADDCH(str, *fmt);
			else
				--fmt;
3481c990:	02466001 	subeq	r6, r6, #1
		case 'u':
			break;

		default:
			ADDCH(str, '%');
			if (*fmt)
3481c994:	0a000033 	beq	3481ca68 <vsnprintf_internal.clone.3+0x424>
				ADDCH(str, *fmt);
3481c998:	e4c03001 	strb	r3, [r0], #1
3481c99c:	ea000031 	b	3481ca68 <vsnprintf_internal.clone.3+0x424>
				++fmt;
			}
		}

		/* default base */
		base = 10;
3481c9a0:	e3a0e00a 	mov	lr, #10
3481c9a4:	ea000000 	b	3481c9ac <vsnprintf_internal.clone.3+0x368>
			break;

		case 'x':
			flags |= SMALL;
		case 'X':
			base = 16;
3481c9a8:	e3a0e010 	mov	lr, #16
				ADDCH(str, *fmt);
			else
				--fmt;
			continue;
		}
		if (qualifier == 'L')  /* "quad" for 64 bit variables */
3481c9ac:	e354004c 	cmp	r4, #76	; 0x4c
			num = va_arg(args, unsigned long long);
3481c9b0:	02822007 	addeq	r2, r2, #7
3481c9b4:	03c22007 	biceq	r2, r2, #7
3481c9b8:	02827008 	addeq	r7, r2, #8
3481c9bc:	01c240d0 	ldrdeq	r4, [r2]
3481c9c0:	0a000020 	beq	3481ca48 <vsnprintf_internal.clone.3+0x404>
		else if (qualifier == 'l') {
3481c9c4:	e354006c 	cmp	r4, #108	; 0x6c
3481c9c8:	1a000005 	bne	3481c9e4 <vsnprintf_internal.clone.3+0x3a0>
			num = va_arg(args, unsigned long);
3481c9cc:	e5924000 	ldr	r4, [r2]
			if (flags & SIGN)
3481c9d0:	e3110002 	tst	r1, #2
			continue;
		}
		if (qualifier == 'L')  /* "quad" for 64 bit variables */
			num = va_arg(args, unsigned long long);
		else if (qualifier == 'l') {
			num = va_arg(args, unsigned long);
3481c9d4:	e2827004 	add	r7, r2, #4
3481c9d8:	e3a05000 	mov	r5, #0
			if (flags & SIGN)
3481c9dc:	0a000019 	beq	3481ca48 <vsnprintf_internal.clone.3+0x404>
3481c9e0:	ea000017 	b	3481ca44 <vsnprintf_internal.clone.3+0x400>
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
3481c9e4:	e354005a 	cmp	r4, #90	; 0x5a
3481c9e8:	1354007a 	cmpne	r4, #122	; 0x7a
			num = va_arg(args, size_t);
3481c9ec:	05924000 	ldreq	r4, [r2]
3481c9f0:	02827004 	addeq	r7, r2, #4
3481c9f4:	03a05000 	moveq	r5, #0
			num = va_arg(args, unsigned long long);
		else if (qualifier == 'l') {
			num = va_arg(args, unsigned long);
			if (flags & SIGN)
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
3481c9f8:	0a000012 	beq	3481ca48 <vsnprintf_internal.clone.3+0x404>
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
3481c9fc:	e3540074 	cmp	r4, #116	; 0x74
			num = va_arg(args, ptrdiff_t);
3481ca00:	02827004 	addeq	r7, r2, #4
3481ca04:	05924000 	ldreq	r4, [r2]
			num = va_arg(args, unsigned long);
			if (flags & SIGN)
				num = (signed long) num;
		} else if (qualifier == 'Z' || qualifier == 'z') {
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
3481ca08:	0a00000d 	beq	3481ca44 <vsnprintf_internal.clone.3+0x400>
			num = va_arg(args, ptrdiff_t);
		} else if (qualifier == 'h') {
3481ca0c:	e3540068 	cmp	r4, #104	; 0x68
3481ca10:	e2827004 	add	r7, r2, #4
3481ca14:	e5924000 	ldr	r4, [r2]
3481ca18:	e2012002 	and	r2, r1, #2
3481ca1c:	1a000005 	bne	3481ca38 <vsnprintf_internal.clone.3+0x3f4>
			num = (unsigned short) va_arg(args, int);
3481ca20:	e6ff4074 	uxth	r4, r4
3481ca24:	e3a05000 	mov	r5, #0
			if (flags & SIGN)
3481ca28:	e3520000 	cmp	r2, #0
				num = (signed short) num;
3481ca2c:	16bf4074 	sxthne	r4, r4
			num = va_arg(args, size_t);
		} else if (qualifier == 't') {
			num = va_arg(args, ptrdiff_t);
		} else if (qualifier == 'h') {
			num = (unsigned short) va_arg(args, int);
			if (flags & SIGN)
3481ca30:	1a000003 	bne	3481ca44 <vsnprintf_internal.clone.3+0x400>
3481ca34:	ea000003 	b	3481ca48 <vsnprintf_internal.clone.3+0x404>
				num = (signed short) num;
		} else {
			num = va_arg(args, unsigned int);
			if (flags & SIGN)
3481ca38:	e3520000 	cmp	r2, #0
		} else if (qualifier == 'h') {
			num = (unsigned short) va_arg(args, int);
			if (flags & SIGN)
				num = (signed short) num;
		} else {
			num = va_arg(args, unsigned int);
3481ca3c:	e3a05000 	mov	r5, #0
			if (flags & SIGN)
3481ca40:	0a000000 	beq	3481ca48 <vsnprintf_internal.clone.3+0x404>
				num = (signed int) num;
3481ca44:	e1a05fc4 	asr	r5, r4, #31
		}
		str = number(str, end, num, base, field_width, precision,
3481ca48:	e58d3008 	str	r3, [sp, #8]
3481ca4c:	e1a02004 	mov	r2, r4
3481ca50:	e1a03005 	mov	r3, r5
3481ca54:	e58de000 	str	lr, [sp]
3481ca58:	e58dc004 	str	ip, [sp, #4]
3481ca5c:	e58d100c 	str	r1, [sp, #12]
3481ca60:	ebfffe72 	bl	3481c430 <number.clone.1>
3481ca64:	e1a02007 	mov	r2, r7
		size = end - buf;
	}
#endif
	str = buf;

	for (; *fmt ; ++fmt) {
3481ca68:	e2866001 	add	r6, r6, #1
3481ca6c:	e5d63000 	ldrb	r3, [r6]
3481ca70:	e3530000 	cmp	r3, #0
3481ca74:	1afffef8 	bne	3481c65c <vsnprintf_internal.clone.3+0x18>
		ADDCH(str, '\0');
		if (str > end)
			end[-1] = '\0';
	}
#else
	*str = '\0';
3481ca78:	e5c03000 	strb	r3, [r0]
#endif
	/* the trailing null byte doesn't count towards the total */
	return str-buf;
}
3481ca7c:	e06a0000 	rsb	r0, sl, r0
3481ca80:	e28dd010 	add	sp, sp, #16
3481ca84:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481ca88:	34828049 	.word	0x34828049
3481ca8c:	34821cd4 	.word	0x34821cd4

3481ca90 <simple_strtoul>:
	*buf++ = hex_asc_lo(byte);
	return buf;
}

unsigned long simple_strtoul(const char *cp,char **endp,unsigned int base)
{
3481ca90:	e92d4070 	push	{r4, r5, r6, lr}
	unsigned long result = 0,value;

	if (*cp == '0') {
3481ca94:	e5d03000 	ldrb	r3, [r0]
3481ca98:	e3530030 	cmp	r3, #48	; 0x30
3481ca9c:	1a00000d 	bne	3481cad8 <simple_strtoul+0x48>
		cp++;
		if ((*cp == 'x') && isxdigit(cp[1])) {
3481caa0:	e5f03001 	ldrb	r3, [r0, #1]!
3481caa4:	e3530078 	cmp	r3, #120	; 0x78
3481caa8:	1a000007 	bne	3481cacc <simple_strtoul+0x3c>
3481caac:	e5d0c001 	ldrb	ip, [r0, #1]
3481cab0:	e59f4080 	ldr	r4, [pc, #128]	; 3481cb38 <simple_strtoul+0xa8>
3481cab4:	e2803001 	add	r3, r0, #1
3481cab8:	e7d4c00c 	ldrb	ip, [r4, ip]
3481cabc:	e31c0044 	tst	ip, #68	; 0x44
3481cac0:	11a00003 	movne	r0, r3
			base = 16;
3481cac4:	13a02010 	movne	r2, #16
{
	unsigned long result = 0,value;

	if (*cp == '0') {
		cp++;
		if ((*cp == 'x') && isxdigit(cp[1])) {
3481cac8:	1a000004 	bne	3481cae0 <simple_strtoul+0x50>
			base = 16;
			cp++;
		}
		if (!base) {
			base = 8;
3481cacc:	e3520000 	cmp	r2, #0
3481cad0:	03a02008 	moveq	r2, #8
3481cad4:	ea000001 	b	3481cae0 <simple_strtoul+0x50>
		}
	}
	if (!base) {
		base = 10;
3481cad8:	e3520000 	cmp	r2, #0
3481cadc:	03a0200a 	moveq	r2, #10
		}
		if (!base) {
			base = 8;
		}
	}
	if (!base) {
3481cae0:	e1a0c000 	mov	ip, r0
		base = 10;
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
3481cae4:	e59f604c 	ldr	r6, [pc, #76]	; 3481cb38 <simple_strtoul+0xa8>
		if (!base) {
			base = 8;
		}
	}
	if (!base) {
		base = 10;
3481cae8:	e3a00000 	mov	r0, #0
3481caec:	ea000000 	b	3481caf4 <simple_strtoul+0x64>
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
		result = result*base + value;
3481caf0:	e0203092 	mla	r0, r2, r0, r3
3481caf4:	e1a0500c 	mov	r5, ip
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
3481caf8:	e4dc3001 	ldrb	r3, [ip], #1
3481cafc:	e7d64003 	ldrb	r4, [r6, r3]
3481cb00:	e3140044 	tst	r4, #68	; 0x44
3481cb04:	0a000008 	beq	3481cb2c <simple_strtoul+0x9c>
3481cb08:	e3140004 	tst	r4, #4
3481cb0c:	12433030 	subne	r3, r3, #48	; 0x30
3481cb10:	1a000003 	bne	3481cb24 <simple_strtoul+0x94>
3481cb14:	e3140002 	tst	r4, #2
}

static inline unsigned char __toupper(unsigned char c)
{
	if (islower(c))
		c -= 'a'-'A';
3481cb18:	12433020 	subne	r3, r3, #32
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
3481cb1c:	16ef3073 	uxtbne	r3, r3
3481cb20:	e2433037 	sub	r3, r3, #55	; 0x37
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit(*cp) && (value = isdigit(*cp) ? *cp-'0' : (islower(*cp)
3481cb24:	e1530002 	cmp	r3, r2
3481cb28:	3afffff0 	bcc	3481caf0 <simple_strtoul+0x60>
	    ? toupper(*cp) : *cp)-'A'+10) < base) {
		result = result*base + value;
		cp++;
	}
	if (endp)
3481cb2c:	e3510000 	cmp	r1, #0
		*endp = (char *)cp;
3481cb30:	15815000 	strne	r5, [r1]
	return result;
}
3481cb34:	e8bd8070 	pop	{r4, r5, r6, pc}
3481cb38:	34821cd4 	.word	0x34821cd4

3481cb3c <strict_strtoul>:
{
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
3481cb3c:	e3a03000 	mov	r3, #0
		*endp = (char *)cp;
	return result;
}

int strict_strtoul(const char *cp, unsigned int base, unsigned long *res)
{
3481cb40:	e92d40f7 	push	{r0, r1, r2, r4, r5, r6, r7, lr}
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
3481cb44:	e5823000 	str	r3, [r2]
		*endp = (char *)cp;
	return result;
}

int strict_strtoul(const char *cp, unsigned int base, unsigned long *res)
{
3481cb48:	e1a04000 	mov	r4, r0
3481cb4c:	e1a07001 	mov	r7, r1
3481cb50:	e1a05002 	mov	r5, r2
	char *tail;
	unsigned long val;
	size_t len;

	*res = 0;
	len = strlen(cp);
3481cb54:	ebfffc3a 	bl	3481bc44 <strlen>
	if (len == 0)
3481cb58:	e2506000 	subs	r6, r0, #0
3481cb5c:	0a000012 	beq	3481cbac <strict_strtoul+0x70>
		return -EINVAL;

	val = simple_strtoul(cp, &tail, base);
3481cb60:	e1a00004 	mov	r0, r4
3481cb64:	e28d1004 	add	r1, sp, #4
3481cb68:	e1a02007 	mov	r2, r7
3481cb6c:	ebffffc7 	bl	3481ca90 <simple_strtoul>
	if (tail == cp)
3481cb70:	e59d3004 	ldr	r3, [sp, #4]
3481cb74:	e1530004 	cmp	r3, r4
3481cb78:	0a00000b 	beq	3481cbac <strict_strtoul+0x70>
		return -EINVAL;

	if ((*tail == '\0') ||
3481cb7c:	e5d32000 	ldrb	r2, [r3]
3481cb80:	e3520000 	cmp	r2, #0
3481cb84:	0a000005 	beq	3481cba0 <strict_strtoul+0x64>
		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
3481cb88:	e0643003 	rsb	r3, r4, r3
3481cb8c:	e2833001 	add	r3, r3, #1

	val = simple_strtoul(cp, &tail, base);
	if (tail == cp)
		return -EINVAL;

	if ((*tail == '\0') ||
3481cb90:	e1560003 	cmp	r6, r3
3481cb94:	1a000004 	bne	3481cbac <strict_strtoul+0x70>
		((len == (size_t)(tail - cp) + 1) && (*tail == '\n'))) {
3481cb98:	e352000a 	cmp	r2, #10
3481cb9c:	1a000002 	bne	3481cbac <strict_strtoul+0x70>
		*res = val;
3481cba0:	e5850000 	str	r0, [r5]
		return 0;
3481cba4:	e3a00000 	mov	r0, #0
3481cba8:	ea000000 	b	3481cbb0 <strict_strtoul+0x74>
	}

	return -EINVAL;
3481cbac:	e3e00015 	mvn	r0, #21
}
3481cbb0:	e8bd80fe 	pop	{r1, r2, r3, r4, r5, r6, r7, pc}

3481cbb4 <simple_strtol>:

long simple_strtol(const char *cp,char **endp,unsigned int base)
{
3481cbb4:	e92d4010 	push	{r4, lr}
	if(*cp=='-')
3481cbb8:	e5d0c000 	ldrb	ip, [r0]
3481cbbc:	e35c002d 	cmp	ip, #45	; 0x2d
3481cbc0:	1a000003 	bne	3481cbd4 <simple_strtol+0x20>
		return -simple_strtoul(cp+1,endp,base);
3481cbc4:	e2800001 	add	r0, r0, #1
3481cbc8:	ebffffb0 	bl	3481ca90 <simple_strtoul>
	return simple_strtoul(cp,endp,base);
}
3481cbcc:	e2600000 	rsb	r0, r0, #0
3481cbd0:	e8bd8010 	pop	{r4, pc}
3481cbd4:	e8bd4010 	pop	{r4, lr}

long simple_strtol(const char *cp,char **endp,unsigned int base)
{
	if(*cp=='-')
		return -simple_strtoul(cp+1,endp,base);
	return simple_strtoul(cp,endp,base);
3481cbd8:	eaffffac 	b	3481ca90 <simple_strtoul>

3481cbdc <ustrtoul>:
}

int ustrtoul(const char *cp, char **endp, unsigned int base)
{
3481cbdc:	e92d4010 	push	{r4, lr}
3481cbe0:	e1a04001 	mov	r4, r1
	unsigned long result = simple_strtoul(cp, endp, base);
3481cbe4:	ebffffa9 	bl	3481ca90 <simple_strtoul>
	switch (**endp) {
3481cbe8:	e5943000 	ldr	r3, [r4]
3481cbec:	e5d32000 	ldrb	r2, [r3]
3481cbf0:	e352004b 	cmp	r2, #75	; 0x4b
3481cbf4:	0a00000a 	beq	3481cc24 <ustrtoul+0x48>
3481cbf8:	8a000002 	bhi	3481cc08 <ustrtoul+0x2c>
3481cbfc:	e3520047 	cmp	r2, #71	; 0x47
3481cc00:	18bd8010 	popne	{r4, pc}
3481cc04:	ea000004 	b	3481cc1c <ustrtoul+0x40>
3481cc08:	e352004d 	cmp	r2, #77	; 0x4d
3481cc0c:	0a000003 	beq	3481cc20 <ustrtoul+0x44>
3481cc10:	e352006b 	cmp	r2, #107	; 0x6b
3481cc14:	18bd8010 	popne	{r4, pc}
3481cc18:	ea000001 	b	3481cc24 <ustrtoul+0x48>
	case 'G' :
		result *= 1024;
3481cc1c:	e1a00500 	lsl	r0, r0, #10
		/* fall through */
	case 'M':
		result *= 1024;
3481cc20:	e1a00500 	lsl	r0, r0, #10
		/* fall through */
	case 'K':
	case 'k':
		result *= 1024;
		if ((*endp)[1] == 'i') {
3481cc24:	e5d32001 	ldrb	r2, [r3, #1]
	case 'M':
		result *= 1024;
		/* fall through */
	case 'K':
	case 'k':
		result *= 1024;
3481cc28:	e1a00500 	lsl	r0, r0, #10
		if ((*endp)[1] == 'i') {
3481cc2c:	e3520069 	cmp	r2, #105	; 0x69
3481cc30:	18bd8010 	popne	{r4, pc}
			if ((*endp)[2] == 'B')
3481cc34:	e5d31002 	ldrb	r1, [r3, #2]
3481cc38:	e2832002 	add	r2, r3, #2
3481cc3c:	e3510042 	cmp	r1, #66	; 0x42
				(*endp) += 3;
3481cc40:	02833003 	addeq	r3, r3, #3
3481cc44:	05843000 	streq	r3, [r4]
			else
				(*endp) += 2;
3481cc48:	15842000 	strne	r2, [r4]
		}
	}
	return result;
}
3481cc4c:	e8bd8010 	pop	{r4, pc}

3481cc50 <simple_strtoull>:

unsigned long long simple_strtoull (const char *cp, char **endp, unsigned int base)
{
3481cc50:	e92d4cf0 	push	{r4, r5, r6, r7, sl, fp, lr}
	unsigned long long result = 0, value;

	if (*cp == '0') {
3481cc54:	e5d03000 	ldrb	r3, [r0]
3481cc58:	e3530030 	cmp	r3, #48	; 0x30
3481cc5c:	1a00000d 	bne	3481cc98 <simple_strtoull+0x48>
		cp++;
		if ((*cp == 'x') && isxdigit (cp[1])) {
3481cc60:	e5f03001 	ldrb	r3, [r0, #1]!
3481cc64:	e3530078 	cmp	r3, #120	; 0x78
3481cc68:	1a000007 	bne	3481cc8c <simple_strtoull+0x3c>
3481cc6c:	e5d0c001 	ldrb	ip, [r0, #1]
3481cc70:	e59f40a8 	ldr	r4, [pc, #168]	; 3481cd20 <simple_strtoull+0xd0>
3481cc74:	e2803001 	add	r3, r0, #1
3481cc78:	e7d4c00c 	ldrb	ip, [r4, ip]
3481cc7c:	e31c0044 	tst	ip, #68	; 0x44
3481cc80:	11a00003 	movne	r0, r3
			base = 16;
3481cc84:	13a02010 	movne	r2, #16
{
	unsigned long long result = 0, value;

	if (*cp == '0') {
		cp++;
		if ((*cp == 'x') && isxdigit (cp[1])) {
3481cc88:	1a000004 	bne	3481cca0 <simple_strtoull+0x50>
			base = 16;
			cp++;
		}
		if (!base) {
			base = 8;
3481cc8c:	e3520000 	cmp	r2, #0
3481cc90:	03a02008 	moveq	r2, #8
3481cc94:	ea000001 	b	3481cca0 <simple_strtoull+0x50>
		}
	}
	if (!base) {
		base = 10;
3481cc98:	e3520000 	cmp	r2, #0
3481cc9c:	03a0200a 	moveq	r2, #10
3481cca0:	e3a04000 	mov	r4, #0
3481cca4:	e3a05000 	mov	r5, #0
	}
	while (isxdigit (*cp) && (value = isdigit (*cp)
3481cca8:	e59fc070 	ldr	ip, [pc, #112]	; 3481cd20 <simple_strtoull+0xd0>
				? *cp - '0'
				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
3481ccac:	e3a03000 	mov	r3, #0
3481ccb0:	ea000003 	b	3481ccc4 <simple_strtoull+0x74>
		result = result * base + value;
3481ccb4:	e0876294 	umull	r6, r7, r4, r2
3481ccb8:	e0277592 	mla	r7, r2, r5, r7
3481ccbc:	e09a4006 	adds	r4, sl, r6
3481ccc0:	e0ab5007 	adc	r5, fp, r7
3481ccc4:	e1a07000 	mov	r7, r0
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit (*cp) && (value = isdigit (*cp)
3481ccc8:	e4d06001 	ldrb	r6, [r0], #1
3481cccc:	e7dca006 	ldrb	sl, [ip, r6]
3481ccd0:	e31a0044 	tst	sl, #68	; 0x44
3481ccd4:	0a00000c 	beq	3481cd0c <simple_strtoull+0xbc>
3481ccd8:	e31a0004 	tst	sl, #4
3481ccdc:	12466030 	subne	r6, r6, #48	; 0x30
3481cce0:	1a000003 	bne	3481ccf4 <simple_strtoull+0xa4>
3481cce4:	e31a0002 	tst	sl, #2
3481cce8:	12466020 	subne	r6, r6, #32
				? *cp - '0'
				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
3481ccec:	16ef6076 	uxtbne	r6, r6
		}
	}
	if (!base) {
		base = 10;
	}
	while (isxdigit (*cp) && (value = isdigit (*cp)
3481ccf0:	e2466037 	sub	r6, r6, #55	; 0x37
3481ccf4:	e1a0a006 	mov	sl, r6
3481ccf8:	e1a0bfca 	asr	fp, sl, #31
3481ccfc:	e153000b 	cmp	r3, fp
3481cd00:	1a000001 	bne	3481cd0c <simple_strtoull+0xbc>
3481cd04:	e1520006 	cmp	r2, r6
3481cd08:	8affffe9 	bhi	3481ccb4 <simple_strtoull+0x64>
				? *cp - '0'
				: (islower (*cp) ? toupper (*cp) : *cp) - 'A' + 10) < base) {
		result = result * base + value;
		cp++;
	}
	if (endp)
3481cd0c:	e3510000 	cmp	r1, #0
		*endp = (char *) cp;
3481cd10:	15817000 	strne	r7, [r1]
	return result;
}
3481cd14:	e1a00004 	mov	r0, r4
3481cd18:	e1a01005 	mov	r1, r5
3481cd1c:	e8bd8cf0 	pop	{r4, r5, r6, r7, sl, fp, pc}
3481cd20:	34821cd4 	.word	0x34821cd4

3481cd24 <vsprintf>:
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
3481cd24:	eafffe46 	b	3481c644 <vsnprintf_internal.clone.3>

3481cd28 <sprintf>:
}

int sprintf(char * buf, const char *fmt, ...)
{
3481cd28:	e92d000e 	push	{r1, r2, r3}
3481cd2c:	e92d4003 	push	{r0, r1, lr}
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
3481cd30:	e59d100c 	ldr	r1, [sp, #12]
int sprintf(char * buf, const char *fmt, ...)
{
	va_list args;
	int i;

	va_start(args, fmt);
3481cd34:	e28d2010 	add	r2, sp, #16
3481cd38:	e58d2004 	str	r2, [sp, #4]
 *
 * If you're not already dealing with a va_list consider using sprintf().
 */
int vsprintf(char *buf, const char *fmt, va_list args)
{
	return vsnprintf_internal(buf, INT_MAX, fmt, args);
3481cd3c:	ebfffe40 	bl	3481c644 <vsnprintf_internal.clone.3>

	va_start(args, fmt);
	i=vsprintf(buf,fmt,args);
	va_end(args);
	return i;
}
3481cd40:	e8bd400c 	pop	{r2, r3, lr}
3481cd44:	e28dd00c 	add	sp, sp, #12
3481cd48:	e12fff1e 	bx	lr

3481cd4c <panic>:

void panic(const char *fmt, ...)
{
3481cd4c:	e92d000f 	push	{r0, r1, r2, r3}
3481cd50:	e92d4007 	push	{r0, r1, r2, lr}
	va_list	args;
	va_start(args, fmt);
	vprintf(fmt, args);
3481cd54:	e59d0010 	ldr	r0, [sp, #16]
}

void panic(const char *fmt, ...)
{
	va_list	args;
	va_start(args, fmt);
3481cd58:	e28d1014 	add	r1, sp, #20
3481cd5c:	e58d1004 	str	r1, [sp, #4]
	vprintf(fmt, args);
3481cd60:	ebffb113 	bl	348091b4 <vprintf>
	putc('\n');
3481cd64:	e3a0000a 	mov	r0, #10
3481cd68:	ebffb0e9 	bl	34809114 <putc>
	va_end(args);
#if defined (CONFIG_PANIC_HANG)
	hang();
#else
	udelay (100000);	/* allow messages to go out */
3481cd6c:	e59f0018 	ldr	r0, [pc, #24]	; 3481cd8c <panic+0x40>
3481cd70:	ebfffd02 	bl	3481c180 <udelay>
	do_reset (NULL, 0, 0, NULL);
3481cd74:	e3a00000 	mov	r0, #0
3481cd78:	e1a01000 	mov	r1, r0
3481cd7c:	e1a02000 	mov	r2, r0
3481cd80:	e1a03000 	mov	r3, r0
3481cd84:	ebff928c 	bl	348017bc <do_reset>
3481cd88:	eafffffe 	b	3481cd88 <panic+0x3c>
3481cd8c:	000186a0 	.word	0x000186a0

3481cd90 <__assert_fail>:
		;
}

void __assert_fail(const char *assertion, const char *file, unsigned line,
		   const char *function)
{
3481cd90:	e92d4007 	push	{r0, r1, r2, lr}
	/* This will not return */
	panic("%s:%u: %s: Assertion `%s' failed.", file, line, function,
3481cd94:	e58d0000 	str	r0, [sp]
3481cd98:	e59f0000 	ldr	r0, [pc, #0]	; 3481cda0 <__assert_fail+0x10>
3481cd9c:	ebffffea 	bl	3481cd4c <panic>
3481cda0:	34828050 	.word	0x34828050

3481cda4 <simple_itoa>:
	      assertion);
}

char *simple_itoa(ulong i)
{
3481cda4:	e92d4070 	push	{r4, r5, r6, lr}
	/* 21 digits plus null terminator, good for 64-bit or smaller ints */
	static char local[22];
	char *p = &local[21];

	*p-- = '\0';
3481cda8:	e59f4048 	ldr	r4, [pc, #72]	; 3481cdf8 <simple_itoa+0x54>
3481cdac:	e3a03000 	mov	r3, #0
3481cdb0:	e5c43015 	strb	r3, [r4, #21]
	panic("%s:%u: %s: Assertion `%s' failed.", file, line, function,
	      assertion);
}

char *simple_itoa(ulong i)
{
3481cdb4:	e1a05000 	mov	r5, r0
	/* 21 digits plus null terminator, good for 64-bit or smaller ints */
	static char local[22];
	char *p = &local[21];

	*p-- = '\0';
3481cdb8:	e2844014 	add	r4, r4, #20
3481cdbc:	ea000000 	b	3481cdc4 <simple_itoa+0x20>
	do {
		*p-- = '0' + i % 10;
3481cdc0:	e1a04006 	mov	r4, r6
3481cdc4:	e1a00005 	mov	r0, r5
3481cdc8:	e3a0100a 	mov	r1, #10
3481cdcc:	eb000bee 	bl	3481fd8c <__aeabi_uidivmod>
3481cdd0:	e1a06004 	mov	r6, r4
3481cdd4:	e2811030 	add	r1, r1, #48	; 0x30
3481cdd8:	e4461001 	strb	r1, [r6], #-1
		i /= 10;
3481cddc:	e1a00005 	mov	r0, r5
3481cde0:	e3a0100a 	mov	r1, #10
3481cde4:	eb000b6d 	bl	3481fba0 <__udivsi3>
	} while (i > 0);
3481cde8:	e2505000 	subs	r5, r0, #0
3481cdec:	1afffff3 	bne	3481cdc0 <simple_itoa+0x1c>
	return p + 1;
}
3481cdf0:	e1a00004 	mov	r0, r4
3481cdf4:	e8bd8070 	pop	{r4, r5, r6, pc}
3481cdf8:	3482bc48 	.word	0x3482bc48

3481cdfc <zcfree>:
void  zcfree (opaque, ptr, nb)
	voidpf opaque;
	voidpf ptr;
	unsigned nb;
{
	free(ptr);
3481cdfc:	e1a00001 	mov	r0, r1
3481ce00:	eaffb215 	b	3480965c <free>

3481ce04 <zcalloc>:
	unsigned items;
	unsigned size;
{
	if (opaque)
		items += size - size; /* make compiler happy */
	return sizeof(uInt) > 2 ? (voidpf)malloc(items * size) :
3481ce04:	e0000291 	mul	r0, r1, r2
3481ce08:	eaffb29c 	b	34809880 <malloc>

3481ce0c <inflate_fast>:
      output space.
 */
void inflate_fast(strm, start)
z_streamp strm;
unsigned start;         /* inflate()'s starting value for strm->avail_out */
{
3481ce0c:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
3481ce10:	e5903004 	ldr	r3, [r0, #4]
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
3481ce14:	e5904000 	ldr	r4, [r0]
    last = in + (strm->avail_in - 5);
3481ce18:	e2432005 	sub	r2, r3, #5
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
3481ce1c:	e2444001 	sub	r4, r4, #1
      output space.
 */
void inflate_fast(strm, start)
z_streamp strm;
unsigned start;         /* inflate()'s starting value for strm->avail_out */
{
3481ce20:	e24dd048 	sub	sp, sp, #72	; 0x48

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
    if (in > last && strm->avail_in > 5) {
3481ce24:	e0942002 	adds	r2, r4, r2
    unsigned len;               /* match length, unused bytes */
    unsigned dist;              /* match distance */
    unsigned char FAR *from;    /* where to copy match from */

    /* copy state to local variables */
    state = (struct inflate_state FAR *)strm->state;
3481ce28:	e590501c 	ldr	r5, [r0, #28]
    in = strm->next_in - OFF;
    last = in + (strm->avail_in - 5);
    if (in > last && strm->avail_in > 5) {
3481ce2c:	e58d201c 	str	r2, [sp, #28]
3481ce30:	3a000005 	bcc	3481ce4c <inflate_fast+0x40>
3481ce34:	e3530005 	cmp	r3, #5
        /*
         * overflow detected, limit strm->avail_in to the
         * max. possible size and recalculate last
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
3481ce38:	81e03004 	mvnhi	r3, r4
3481ce3c:	85803004 	strhi	r3, [r0, #4]
        last = in + (strm->avail_in - 5);
3481ce40:	82433005 	subhi	r3, r3, #5
3481ce44:	80843003 	addhi	r3, r4, r3
3481ce48:	858d301c 	strhi	r3, [sp, #28]
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
3481ce4c:	e595602c 	ldr	r6, [r5, #44]	; 0x2c
    write = state->write;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
3481ce50:	e595c050 	ldr	ip, [r5, #80]	; 0x50
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
3481ce54:	e58d6038 	str	r6, [sp, #56]	; 0x38
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
3481ce58:	e5956054 	ldr	r6, [r5, #84]	; 0x54
    write = state->write;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
3481ce5c:	e58dc024 	str	ip, [sp, #36]	; 0x24
    lmask = (1U << state->lenbits) - 1;
3481ce60:	e3a0c001 	mov	ip, #1
3481ce64:	e1a0661c 	lsl	r6, ip, r6
3481ce68:	e2466001 	sub	r6, r6, #1
3481ce6c:	e58d603c 	str	r6, [sp, #60]	; 0x3c
    dmask = (1U << state->distbits) - 1;
3481ce70:	e5956058 	ldr	r6, [r5, #88]	; 0x58
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
3481ce74:	e5902010 	ldr	r2, [r0, #16]
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;
3481ce78:	e1a0661c 	lsl	r6, ip, r6
         * max. possible size and recalculate last
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
3481ce7c:	e590300c 	ldr	r3, [r0, #12]
    beg = out - (start - strm->avail_out);
3481ce80:	e0611002 	rsb	r1, r1, r2
    end = out + (strm->avail_out - 257);
3481ce84:	e2422c01 	sub	r2, r2, #256	; 0x100
         * max. possible size and recalculate last
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
3481ce88:	e2433001 	sub	r3, r3, #1
    beg = out - (start - strm->avail_out);
    end = out + (strm->avail_out - 257);
3481ce8c:	e2422001 	sub	r2, r2, #1
3481ce90:	e0832002 	add	r2, r3, r2
3481ce94:	e58d2028 	str	r2, [sp, #40]	; 0x28
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
3481ce98:	e5952028 	ldr	r2, [r5, #40]	; 0x28
    whave = state->whave;
    write = state->write;
    window = state->window;
3481ce9c:	e5959034 	ldr	r9, [r5, #52]	; 0x34
    beg = out - (start - strm->avail_out);
    end = out + (strm->avail_out - 257);
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
3481cea0:	e58d202c 	str	r2, [sp, #44]	; 0x2c
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;
3481cea4:	e2466001 	sub	r6, r6, #1
#ifdef INFLATE_STRICT
    dmax = state->dmax;
#endif
    wsize = state->wsize;
    whave = state->whave;
    write = state->write;
3481cea8:	e5957030 	ldr	r7, [r5, #48]	; 0x30
    window = state->window;
3481ceac:	e58d9030 	str	r9, [sp, #48]	; 0x30
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
    dcode = state->distcode;
    lmask = (1U << state->lenbits) - 1;
    dmask = (1U << state->distbits) - 1;
3481ceb0:	e58d6040 	str	r6, [sp, #64]	; 0x40
                    if (op > whave) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
3481ceb4:	e2496001 	sub	r6, r9, #1
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481ceb8:	e59d902c 	ldr	r9, [sp, #44]	; 0x2c
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
3481cebc:	e0831001 	add	r1, r3, r1
    whave = state->whave;
    write = state->write;
    window = state->window;
    hold = state->hold;
    bits = state->bits;
    lcode = state->lencode;
3481cec0:	e595a04c 	ldr	sl, [r5, #76]	; 0x4c
         */
	strm->avail_in = 0xffffffff - (uintptr_t)in;
        last = in + (strm->avail_in - 5);
    }
    out = strm->next_out - OFF;
    beg = out - (start - strm->avail_out);
3481cec4:	e58d1034 	str	r1, [sp, #52]	; 0x34
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481cec8:	e0879009 	add	r9, r7, r9
#endif
    wsize = state->wsize;
    whave = state->whave;
    write = state->write;
    window = state->window;
    hold = state->hold;
3481cecc:	e5951038 	ldr	r1, [r5, #56]	; 0x38
    bits = state->bits;
3481ced0:	e595203c 	ldr	r2, [r5, #60]	; 0x3c
    lcode = state->lencode;
3481ced4:	e58da020 	str	sl, [sp, #32]
                    if (op > whave) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
3481ced8:	e58d600c 	str	r6, [sp, #12]
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481cedc:	e58d9044 	str	r9, [sp, #68]	; 0x44
3481cee0:	e58d5010 	str	r5, [sp, #16]
3481cee4:	e58d0014 	str	r0, [sp, #20]
    dmask = (1U << state->distbits) - 1;

    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */
    do {
        if (bits < 15) {
3481cee8:	e352000e 	cmp	r2, #14
3481ceec:	8a000007 	bhi	3481cf10 <inflate_fast+0x104>
            hold += (unsigned long)(PUP(in)) << bits;
3481cef0:	e5d4c001 	ldrb	ip, [r4, #1]
3481cef4:	e2840001 	add	r0, r4, #1
3481cef8:	e081121c 	add	r1, r1, ip, lsl r2
            bits += 8;
            hold += (unsigned long)(PUP(in)) << bits;
3481cefc:	e2804001 	add	r4, r0, #1
3481cf00:	e5d00001 	ldrb	r0, [r0, #1]
    /* decode literals and length/distances until end-of-block or not enough
       input data or output space */
    do {
        if (bits < 15) {
            hold += (unsigned long)(PUP(in)) << bits;
            bits += 8;
3481cf04:	e2822008 	add	r2, r2, #8
            hold += (unsigned long)(PUP(in)) << bits;
3481cf08:	e0811210 	add	r1, r1, r0, lsl r2
            bits += 8;
3481cf0c:	e2822008 	add	r2, r2, #8
        }
        this = lcode[hold & lmask];
3481cf10:	e59da03c 	ldr	sl, [sp, #60]	; 0x3c
3481cf14:	e59d5020 	ldr	r5, [sp, #32]
3481cf18:	e001000a 	and	r0, r1, sl
3481cf1c:	e085c100 	add	ip, r5, r0, lsl #2
3481cf20:	e7d56100 	ldrb	r6, [r5, r0, lsl #2]
3481cf24:	e5dc0001 	ldrb	r0, [ip, #1]
3481cf28:	e1dcc0b2 	ldrh	ip, [ip, #2]
3481cf2c:	e1a0a005 	mov	sl, r5
      dolen:
        op = (unsigned)(this.bits);
        hold >>= op;
        bits -= op;
        op = (unsigned)(this.op);
        if (op == 0) {                          /* literal */
3481cf30:	e3560000 	cmp	r6, #0
            bits += 8;
        }
        this = lcode[hold & lmask];
      dolen:
        op = (unsigned)(this.bits);
        hold >>= op;
3481cf34:	e1a01031 	lsr	r1, r1, r0
        bits -= op;
3481cf38:	e0602002 	rsb	r2, r0, r2
        op = (unsigned)(this.op);
        if (op == 0) {                          /* literal */
            Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
                    "inflate:         literal '%c'\n" :
                    "inflate:         literal 0x%02x\n", this.val));
            PUP(out) = (unsigned char)(this.val);
3481cf3c:	05e3c001 	strbeq	ip, [r3, #1]!
3481cf40:	0a0000ed 	beq	3481d2fc <inflate_fast+0x4f0>
        }
        else if (op & 16) {                     /* length base */
3481cf44:	e3160010 	tst	r6, #16
3481cf48:	0a0000d8 	beq	3481d2b0 <inflate_fast+0x4a4>
            len = (unsigned)(this.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
3481cf4c:	e216600f 	ands	r6, r6, #15
                    "inflate:         literal '%c'\n" :
                    "inflate:         literal 0x%02x\n", this.val));
            PUP(out) = (unsigned char)(this.val);
        }
        else if (op & 16) {                     /* length base */
            len = (unsigned)(this.val);
3481cf50:	e1a0000c 	mov	r0, ip
            op &= 15;                           /* number of extra bits */
            if (op) {
3481cf54:	0a00000a 	beq	3481cf84 <inflate_fast+0x178>
                if (bits < op) {
3481cf58:	e1520006 	cmp	r2, r6
                    hold += (unsigned long)(PUP(in)) << bits;
3481cf5c:	35f40001 	ldrbcc	r0, [r4, #1]!
                    bits += 8;
                }
                len += (unsigned)hold & ((1U << op) - 1);
3481cf60:	e3a09001 	mov	r9, #1
        else if (op & 16) {                     /* length base */
            len = (unsigned)(this.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
3481cf64:	30811210 	addcc	r1, r1, r0, lsl r2
                    bits += 8;
                }
                len += (unsigned)hold & ((1U << op) - 1);
3481cf68:	e1a00619 	lsl	r0, r9, r6
3481cf6c:	e2400001 	sub	r0, r0, #1
3481cf70:	e0010000 	and	r0, r1, r0
                hold >>= op;
3481cf74:	e1a01631 	lsr	r1, r1, r6
            len = (unsigned)(this.val);
            op &= 15;                           /* number of extra bits */
            if (op) {
                if (bits < op) {
                    hold += (unsigned long)(PUP(in)) << bits;
                    bits += 8;
3481cf78:	32822008 	addcc	r2, r2, #8
                }
                len += (unsigned)hold & ((1U << op) - 1);
3481cf7c:	e08c0000 	add	r0, ip, r0
                hold >>= op;
                bits -= op;
3481cf80:	e0662002 	rsb	r2, r6, r2
            }
            Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
3481cf84:	e352000e 	cmp	r2, #14
3481cf88:	8a000007 	bhi	3481cfac <inflate_fast+0x1a0>
                hold += (unsigned long)(PUP(in)) << bits;
3481cf8c:	e284c001 	add	ip, r4, #1
3481cf90:	e5d44001 	ldrb	r4, [r4, #1]
3481cf94:	e0811214 	add	r1, r1, r4, lsl r2
                bits += 8;
                hold += (unsigned long)(PUP(in)) << bits;
3481cf98:	e28c4001 	add	r4, ip, #1
3481cf9c:	e5dcc001 	ldrb	ip, [ip, #1]
                bits -= op;
            }
            Tracevv((stderr, "inflate:         length %u\n", len));
            if (bits < 15) {
                hold += (unsigned long)(PUP(in)) << bits;
                bits += 8;
3481cfa0:	e2822008 	add	r2, r2, #8
                hold += (unsigned long)(PUP(in)) << bits;
3481cfa4:	e081121c 	add	r1, r1, ip, lsl r2
                bits += 8;
3481cfa8:	e2822008 	add	r2, r2, #8
            }
            this = dcode[hold & dmask];
3481cfac:	e59da040 	ldr	sl, [sp, #64]	; 0x40
3481cfb0:	e59d5024 	ldr	r5, [sp, #36]	; 0x24
3481cfb4:	e001c00a 	and	ip, r1, sl
3481cfb8:	e085610c 	add	r6, r5, ip, lsl #2
3481cfbc:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
3481cfc0:	e7d5c10c 	ldrb	ip, [r5, ip, lsl #2]
3481cfc4:	e5d65001 	ldrb	r5, [r6, #1]
3481cfc8:	e1d660b2 	ldrh	r6, [r6, #2]
          dodist:
            op = (unsigned)(this.bits);
            hold >>= op;
            bits -= op;
            op = (unsigned)(this.op);
            if (op & 16) {                      /* distance base */
3481cfcc:	e31c0010 	tst	ip, #16
                bits += 8;
            }
            this = dcode[hold & dmask];
          dodist:
            op = (unsigned)(this.bits);
            hold >>= op;
3481cfd0:	e1a01531 	lsr	r1, r1, r5
            bits -= op;
3481cfd4:	e0652002 	rsb	r2, r5, r2
            op = (unsigned)(this.op);
            if (op & 16) {                      /* distance base */
3481cfd8:	0a0000a1 	beq	3481d264 <inflate_fast+0x458>
                dist = (unsigned)(this.val);
                op &= 15;                       /* number of extra bits */
3481cfdc:	e20cc00f 	and	ip, ip, #15
                if (bits < op) {
3481cfe0:	e152000c 	cmp	r2, ip
3481cfe4:	2a000006 	bcs	3481d004 <inflate_fast+0x1f8>
                    hold += (unsigned long)(PUP(in)) << bits;
3481cfe8:	e5f45001 	ldrb	r5, [r4, #1]!
3481cfec:	e0811215 	add	r1, r1, r5, lsl r2
                    bits += 8;
3481cff0:	e2822008 	add	r2, r2, #8
                    if (bits < op) {
3481cff4:	e152000c 	cmp	r2, ip
                        hold += (unsigned long)(PUP(in)) << bits;
3481cff8:	35f45001 	ldrbcc	r5, [r4, #1]!
3481cffc:	30811215 	addcc	r1, r1, r5, lsl r2
                        bits += 8;
3481d000:	32822008 	addcc	r2, r2, #8
                    }
                }
                dist += (unsigned)hold & ((1U << op) - 1);
3481d004:	e3a09001 	mov	r9, #1
3481d008:	e1a05c19 	lsl	r5, r9, ip
                }
#endif
                hold >>= op;
                bits -= op;
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
3481d00c:	e59da034 	ldr	sl, [sp, #52]	; 0x34
                    if (bits < op) {
                        hold += (unsigned long)(PUP(in)) << bits;
                        bits += 8;
                    }
                }
                dist += (unsigned)hold & ((1U << op) - 1);
3481d010:	e2455001 	sub	r5, r5, #1
3481d014:	e0015005 	and	r5, r1, r5
3481d018:	e0855006 	add	r5, r5, r6
                    strm->msg = (char *)"invalid distance too far back";
                    state->mode = BAD;
                    break;
                }
#endif
                hold >>= op;
3481d01c:	e1a01c31 	lsr	r1, r1, ip
                bits -= op;
3481d020:	e06c2002 	rsb	r2, ip, r2
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
3481d024:	e06ac003 	rsb	ip, sl, r3
                if (dist > op) {                /* see if copy from window */
3481d028:	e155000c 	cmp	r5, ip
3481d02c:	9a000062 	bls	3481d1bc <inflate_fast+0x3b0>
                    op = dist - op;             /* distance back in window */
                    if (op > whave) {
3481d030:	e59d6038 	ldr	r6, [sp, #56]	; 0x38
                hold >>= op;
                bits -= op;
                Tracevv((stderr, "inflate:         distance %u\n", dist));
                op = (unsigned)(out - beg);     /* max distance in output */
                if (dist > op) {                /* see if copy from window */
                    op = dist - op;             /* distance back in window */
3481d034:	e06cc005 	rsb	ip, ip, r5
                    if (op > whave) {
3481d038:	e15c0006 	cmp	ip, r6
3481d03c:	859d5010 	ldrhi	r5, [sp, #16]
3481d040:	859d0014 	ldrhi	r0, [sp, #20]
                        strm->msg = (char *)"invalid distance too far back";
3481d044:	859fc328 	ldrhi	ip, [pc, #808]	; 3481d374 <inflate_fast+0x568>
3481d048:	8a000094 	bhi	3481d2a0 <inflate_fast+0x494>
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
                    if (write == 0) {           /* very common case */
3481d04c:	e3570000 	cmp	r7, #0
                    if (op > whave) {
                        strm->msg = (char *)"invalid distance too far back";
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
3481d050:	e59da00c 	ldr	sl, [sp, #12]
                    if (write == 0) {           /* very common case */
3481d054:	1a000010 	bne	3481d09c <inflate_fast+0x290>
                        from += wsize - op;
3481d058:	e59d902c 	ldr	r9, [sp, #44]	; 0x2c
3481d05c:	e59d600c 	ldr	r6, [sp, #12]
3481d060:	e06ca009 	rsb	sl, ip, r9
                        if (op < len) {         /* some from window */
3481d064:	e15c0000 	cmp	ip, r0
                        state->mode = BAD;
                        break;
                    }
                    from = window - OFF;
                    if (write == 0) {           /* very common case */
                        from += wsize - op;
3481d068:	e086a00a 	add	sl, r6, sl
                        if (op < len) {         /* some from window */
3481d06c:	2a000008 	bcs	3481d094 <inflate_fast+0x288>
                            len -= op;
3481d070:	e06c0000 	rsb	r0, ip, r0
3481d074:	e1a06003 	mov	r6, r3
3481d078:	e1a0b00c 	mov	fp, ip
3481d07c:	e1a09004 	mov	r9, r4
                            do {
                                PUP(out) = PUP(from);
3481d080:	e5fa4001 	ldrb	r4, [sl, #1]!
                            } while (--op);
3481d084:	e25bb001 	subs	fp, fp, #1
                    if (write == 0) {           /* very common case */
                        from += wsize - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
3481d088:	e5e64001 	strb	r4, [r6, #1]!
                            } while (--op);
3481d08c:	1afffffb 	bne	3481d080 <inflate_fast+0x274>
3481d090:	ea000033 	b	3481d164 <inflate_fast+0x358>
                            from = out - dist;  /* rest from output */
3481d094:	e1a0c003 	mov	ip, r3
3481d098:	ea00003b 	b	3481d18c <inflate_fast+0x380>
                        }
                    }
                    else if (write < op) {      /* wrap around window */
3481d09c:	e157000c 	cmp	r7, ip
3481d0a0:	2a000022 	bcs	3481d130 <inflate_fast+0x324>
                        from += wsize + write - op;
3481d0a4:	e59d9044 	ldr	r9, [sp, #68]	; 0x44
3481d0a8:	e59d600c 	ldr	r6, [sp, #12]
3481d0ac:	e06cb009 	rsb	fp, ip, r9
                        op -= write;
3481d0b0:	e067c00c 	rsb	ip, r7, ip
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481d0b4:	e086b00b 	add	fp, r6, fp
                        op -= write;
                        if (op < len) {         /* some from end of window */
3481d0b8:	e15c0000 	cmp	ip, r0
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    else if (write < op) {      /* wrap around window */
                        from += wsize + write - op;
3481d0bc:	21a0a00b 	movcs	sl, fp
                        op -= write;
                        if (op < len) {         /* some from end of window */
3481d0c0:	2afffff3 	bcs	3481d094 <inflate_fast+0x288>
                            len -= op;
3481d0c4:	e06c0000 	rsb	r0, ip, r0
3481d0c8:	e58d3018 	str	r3, [sp, #24]
3481d0cc:	e1a0600c 	mov	r6, ip
3481d0d0:	e1a09004 	mov	r9, r4
3481d0d4:	e58d3004 	str	r3, [sp, #4]
                            do {
                                PUP(out) = PUP(from);
3481d0d8:	e5fb4001 	ldrb	r4, [fp, #1]!
3481d0dc:	e59d3018 	ldr	r3, [sp, #24]
                            } while (--op);
3481d0e0:	e2566001 	subs	r6, r6, #1
                        from += wsize + write - op;
                        op -= write;
                        if (op < len) {         /* some from end of window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
3481d0e4:	e5e34001 	strb	r4, [r3, #1]!
3481d0e8:	e58d3018 	str	r3, [sp, #24]
                            } while (--op);
3481d0ec:	1afffff9 	bne	3481d0d8 <inflate_fast+0x2cc>
3481d0f0:	e59d3004 	ldr	r3, [sp, #4]
                            from = window - OFF;
                            if (write < len) {  /* some from start of window */
3481d0f4:	e1570000 	cmp	r7, r0
3481d0f8:	e1a04009 	mov	r4, r9
                        op -= write;
                        if (op < len) {         /* some from end of window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
                            } while (--op);
3481d0fc:	e083300c 	add	r3, r3, ip
                            from = window - OFF;
                            if (write < len) {  /* some from start of window */
3481d100:	2affffe3 	bcs	3481d094 <inflate_fast+0x288>
                                op = write;
                                len -= op;
3481d104:	e0670000 	rsb	r0, r7, r0
3481d108:	e1a0c003 	mov	ip, r3
                                do {
                                    PUP(out) = PUP(from);
3481d10c:	e59d9030 	ldr	r9, [sp, #48]	; 0x30
3481d110:	e7d9a006 	ldrb	sl, [r9, r6]
3481d114:	e2866001 	add	r6, r6, #1
                                } while (--op);
3481d118:	e1570006 	cmp	r7, r6
                            from = window - OFF;
                            if (write < len) {  /* some from start of window */
                                op = write;
                                len -= op;
                                do {
                                    PUP(out) = PUP(from);
3481d11c:	e5eca001 	strb	sl, [ip, #1]!
                                } while (--op);
3481d120:	1afffff9 	bne	3481d10c <inflate_fast+0x300>
3481d124:	e0833007 	add	r3, r3, r7
                                from = out - dist;      /* rest from output */
3481d128:	e065a003 	rsb	sl, r5, r3
3481d12c:	eaffffd8 	b	3481d094 <inflate_fast+0x288>
                            }
                        }
                    }
                    else {                      /* contiguous in window */
                        from += write - op;
3481d130:	e59d600c 	ldr	r6, [sp, #12]
3481d134:	e06ca007 	rsb	sl, ip, r7
                        if (op < len) {         /* some from window */
3481d138:	e15c0000 	cmp	ip, r0
                                from = out - dist;      /* rest from output */
                            }
                        }
                    }
                    else {                      /* contiguous in window */
                        from += write - op;
3481d13c:	e086a00a 	add	sl, r6, sl
                        if (op < len) {         /* some from window */
3481d140:	2affffd3 	bcs	3481d094 <inflate_fast+0x288>
                            len -= op;
3481d144:	e06c0000 	rsb	r0, ip, r0
3481d148:	e1a06003 	mov	r6, r3
3481d14c:	e1a0b00c 	mov	fp, ip
3481d150:	e1a09004 	mov	r9, r4
                            do {
                                PUP(out) = PUP(from);
3481d154:	e5fa4001 	ldrb	r4, [sl, #1]!
                            } while (--op);
3481d158:	e25bb001 	subs	fp, fp, #1
                    else {                      /* contiguous in window */
                        from += write - op;
                        if (op < len) {         /* some from window */
                            len -= op;
                            do {
                                PUP(out) = PUP(from);
3481d15c:	e5e64001 	strb	r4, [r6, #1]!
                            } while (--op);
3481d160:	1afffffb 	bne	3481d154 <inflate_fast+0x348>
3481d164:	e1a04009 	mov	r4, r9
3481d168:	e083300c 	add	r3, r3, ip
3481d16c:	eaffffed 	b	3481d128 <inflate_fast+0x31c>
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
                        PUP(out) = PUP(from);
3481d170:	e5da3001 	ldrb	r3, [sl, #1]
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
3481d174:	e2400003 	sub	r0, r0, #3
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
                        PUP(out) = PUP(from);
3481d178:	e5cc3001 	strb	r3, [ip, #1]
                        PUP(out) = PUP(from);
3481d17c:	e5da3002 	ldrb	r3, [sl, #2]
3481d180:	e5cc3002 	strb	r3, [ip, #2]
                        PUP(out) = PUP(from);
3481d184:	e5fa3003 	ldrb	r3, [sl, #3]!
3481d188:	e5ec3003 	strb	r3, [ip, #3]!
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
3481d18c:	e3500002 	cmp	r0, #2
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
3481d190:	e1a0300c 	mov	r3, ip
                                PUP(out) = PUP(from);
                            } while (--op);
                            from = out - dist;  /* rest from output */
                        }
                    }
                    while (len > 2) {
3481d194:	8afffff5 	bhi	3481d170 <inflate_fast+0x364>
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        PUP(out) = PUP(from);
                        len -= 3;
                    }
                    if (len) {
3481d198:	e3500000 	cmp	r0, #0
3481d19c:	0a000056 	beq	3481d2fc <inflate_fast+0x4f0>
                        PUP(out) = PUP(from);
3481d1a0:	e5da5001 	ldrb	r5, [sl, #1]
3481d1a4:	e28ac001 	add	ip, sl, #1
3481d1a8:	e5e35001 	strb	r5, [r3, #1]!
                        if (len > 1)
3481d1ac:	e3500002 	cmp	r0, #2
                            PUP(out) = PUP(from);
3481d1b0:	05dc0001 	ldrbeq	r0, [ip, #1]
                        PUP(out) = PUP(from);
                        len -= 3;
                    }
                    if (len) {
                        PUP(out) = PUP(from);
                        if (len > 1)
3481d1b4:	0a000028 	beq	3481d25c <inflate_fast+0x450>
3481d1b8:	ea00004f 	b	3481d2fc <inflate_fast+0x4f0>
		    unsigned long loops;

                    from = out - dist;          /* copy direct from output */
                    /* minimum length is three */
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
3481d1bc:	e3130001 	tst	r3, #1
                }
                else {
		    unsigned short *sout;
		    unsigned long loops;

                    from = out - dist;          /* copy direct from output */
3481d1c0:	e0656003 	rsb	r6, r5, r3
                    /* minimum length is three */
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
			PUP(out) = PUP(from);
3481d1c4:	05f6c001 	ldrbeq	ip, [r6, #1]!
			len--;
3481d1c8:	02400001 	subeq	r0, r0, #1

                    from = out - dist;          /* copy direct from output */
                    /* minimum length is three */
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
			PUP(out) = PUP(from);
3481d1cc:	05e3c001 	strbeq	ip, [r3, #1]!
			len--;
		    }
		    sout = (unsigned short *)(out - OFF);
		    if (dist > 2 ) {
3481d1d0:	e3550002 	cmp	r5, #2
		    /* Align out addr */
		    if (!((long)(out - 1 + OFF) & 1)) {
			PUP(out) = PUP(from);
			len--;
		    }
		    sout = (unsigned short *)(out - OFF);
3481d1d4:	e243c001 	sub	ip, r3, #1
		    if (dist > 2 ) {
3481d1d8:	9a000010 	bls	3481d220 <inflate_fast+0x414>
			unsigned short *sfrom;

			sfrom = (unsigned short *)(from - OFF);
3481d1dc:	e2469001 	sub	r9, r6, #1
			loops = len >> 1;
3481d1e0:	e1a030a0 	lsr	r3, r0, #1
3481d1e4:	e1a05006 	mov	r5, r6
		    }
		    sout = (unsigned short *)(out - OFF);
		    if (dist > 2 ) {
			unsigned short *sfrom;

			sfrom = (unsigned short *)(from - OFF);
3481d1e8:	e58d9018 	str	r9, [sp, #24]
			loops = len >> 1;
3481d1ec:	e1a0a00c 	mov	sl, ip
3481d1f0:	e1a06003 	mov	r6, r3

#include <linux/types.h>

static inline u16 __get_unaligned_le16(const u8 *p)
{
	return p[0] | p[1] << 8;
3481d1f4:	e5d5b002 	ldrb	fp, [r5, #2]
3481d1f8:	e5d59001 	ldrb	r9, [r5, #1]
			do
			    PUP(sout) = get_unaligned(++sfrom);
			while (--loops);
3481d1fc:	e2566001 	subs	r6, r6, #1
3481d200:	e189940b 	orr	r9, r9, fp, lsl #8
			unsigned short *sfrom;

			sfrom = (unsigned short *)(from - OFF);
			loops = len >> 1;
			do
			    PUP(sout) = get_unaligned(++sfrom);
3481d204:	e1ea90b2 	strh	r9, [sl, #2]!
			while (--loops);
3481d208:	e2855002 	add	r5, r5, #2
3481d20c:	1afffff8 	bne	3481d1f4 <inflate_fast+0x3e8>
    - The maximum bytes that a single length/distance pair can output is 258
      bytes, which is the maximum length that can be coded.  inflate_fast()
      requires strm->avail_out >= 258 for each loop to avoid checking for
      output space.
 */
void inflate_fast(strm, start)
3481d210:	e59da018 	ldr	sl, [sp, #24]
3481d214:	e08a6083 	add	r6, sl, r3, lsl #1

			sfrom = (unsigned short *)(from - OFF);
			loops = len >> 1;
			do
			    PUP(sout) = get_unaligned(++sfrom);
			while (--loops);
3481d218:	e2866001 	add	r6, r6, #1
3481d21c:	ea000009 	b	3481d248 <inflate_fast+0x43c>
			out = (unsigned char *)sout + OFF;
			from = (unsigned char *)sfrom + OFF;
		    } else { /* dist == 1 or dist == 2 */
			unsigned short pat16;

			pat16 = *(sout-2+2*OFF);
3481d220:	e153a0b1 	ldrh	sl, [r3, #-1]
			if (dist == 1)
3481d224:	e3550001 	cmp	r5, #1
#if defined(__BIG_ENDIAN)
			    pat16 = (pat16 & 0xff) | ((pat16 & 0xff ) << 8);
#elif defined(__LITTLE_ENDIAN)
			    pat16 = (pat16 & 0xff00) | ((pat16 & 0xff00 ) >> 8);
3481d228:	03ca30ff 	biceq	r3, sl, #255	; 0xff
3481d22c:	0183a42a 	orreq	sl, r3, sl, lsr #8
#else
#error __BIG_ENDIAN nor __LITTLE_ENDIAN is defined
#endif
			loops = len >> 1;
3481d230:	e1a030a0 	lsr	r3, r0, #1
3481d234:	e1a0900c 	mov	r9, ip
3481d238:	e1a05003 	mov	r5, r3
			do
			    PUP(sout) = pat16;
			while (--loops);
3481d23c:	e2555001 	subs	r5, r5, #1
#else
#error __BIG_ENDIAN nor __LITTLE_ENDIAN is defined
#endif
			loops = len >> 1;
			do
			    PUP(sout) = pat16;
3481d240:	e1e9a0b2 	strh	sl, [r9, #2]!
			while (--loops);
3481d244:	1afffffc 	bne	3481d23c <inflate_fast+0x430>
			out = (unsigned char *)sout + OFF;
3481d248:	e08c3083 	add	r3, ip, r3, lsl #1
		    }
		    if (len & 1)
3481d24c:	e3100001 	tst	r0, #1
#endif
			loops = len >> 1;
			do
			    PUP(sout) = pat16;
			while (--loops);
			out = (unsigned char *)sout + OFF;
3481d250:	e2833001 	add	r3, r3, #1
		    }
		    if (len & 1)
3481d254:	0a000028 	beq	3481d2fc <inflate_fast+0x4f0>
			PUP(out) = PUP(from);
3481d258:	e5d60001 	ldrb	r0, [r6, #1]
3481d25c:	e5e30001 	strb	r0, [r3, #1]!
3481d260:	ea000025 	b	3481d2fc <inflate_fast+0x4f0>
                }
            }
            else if ((op & 64) == 0) {          /* 2nd level distance code */
3481d264:	e31c0040 	tst	ip, #64	; 0x40
3481d268:	1a000009 	bne	3481d294 <inflate_fast+0x488>
                this = dcode[this.val + (hold & ((1U << op) - 1))];
3481d26c:	e3a05001 	mov	r5, #1
3481d270:	e1a0cc15 	lsl	ip, r5, ip
3481d274:	e24cc001 	sub	ip, ip, #1
3481d278:	e00cc001 	and	ip, ip, r1
3481d27c:	e08c6006 	add	r6, ip, r6
3481d280:	e089a106 	add	sl, r9, r6, lsl #2
3481d284:	e7d9c106 	ldrb	ip, [r9, r6, lsl #2]
3481d288:	e5da5001 	ldrb	r5, [sl, #1]
3481d28c:	e1da60b2 	ldrh	r6, [sl, #2]
                goto dodist;
3481d290:	eaffff4d 	b	3481cfcc <inflate_fast+0x1c0>
3481d294:	e59d5010 	ldr	r5, [sp, #16]
3481d298:	e59d0014 	ldr	r0, [sp, #20]
            }
            else {
                strm->msg = (char *)"invalid distance code";
3481d29c:	e59fc0d4 	ldr	ip, [pc, #212]	; 3481d378 <inflate_fast+0x56c>
3481d2a0:	e580c018 	str	ip, [r0, #24]
                state->mode = BAD;
3481d2a4:	e3a0c01b 	mov	ip, #27
3481d2a8:	e585c000 	str	ip, [r5]
                break;
3481d2ac:	ea000019 	b	3481d318 <inflate_fast+0x50c>
            }
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
3481d2b0:	e3160040 	tst	r6, #64	; 0x40
3481d2b4:	1a000009 	bne	3481d2e0 <inflate_fast+0x4d4>
            this = lcode[this.val + (hold & ((1U << op) - 1))];
3481d2b8:	e3a09001 	mov	r9, #1
3481d2bc:	e1a06619 	lsl	r6, r9, r6
3481d2c0:	e2466001 	sub	r6, r6, #1
3481d2c4:	e0066001 	and	r6, r6, r1
3481d2c8:	e086c00c 	add	ip, r6, ip
3481d2cc:	e08a510c 	add	r5, sl, ip, lsl #2
3481d2d0:	e7da610c 	ldrb	r6, [sl, ip, lsl #2]
3481d2d4:	e5d50001 	ldrb	r0, [r5, #1]
3481d2d8:	e1d5c0b2 	ldrh	ip, [r5, #2]
            goto dolen;
3481d2dc:	eaffff13 	b	3481cf30 <inflate_fast+0x124>
        }
        else if (op & 32) {                     /* end-of-block */
3481d2e0:	e3160020 	tst	r6, #32
3481d2e4:	e59d5010 	ldr	r5, [sp, #16]
3481d2e8:	e59d0014 	ldr	r0, [sp, #20]
            Tracevv((stderr, "inflate:         end of block\n"));
            state->mode = TYPE;
3481d2ec:	13a0c00b 	movne	ip, #11
            break;
        }
        else {
            strm->msg = (char *)"invalid literal/length code";
3481d2f0:	059fc084 	ldreq	ip, [pc, #132]	; 3481d37c <inflate_fast+0x570>
        }
        else if ((op & 64) == 0) {              /* 2nd level length code */
            this = lcode[this.val + (hold & ((1U << op) - 1))];
            goto dolen;
        }
        else if (op & 32) {                     /* end-of-block */
3481d2f4:	0affffe9 	beq	3481d2a0 <inflate_fast+0x494>
3481d2f8:	eaffffea 	b	3481d2a8 <inflate_fast+0x49c>
        else {
            strm->msg = (char *)"invalid literal/length code";
            state->mode = BAD;
            break;
        }
    } while (in < last && out < end);
3481d2fc:	e59da028 	ldr	sl, [sp, #40]	; 0x28
3481d300:	e59dc01c 	ldr	ip, [sp, #28]
3481d304:	e153000a 	cmp	r3, sl
3481d308:	3154000c 	cmpcc	r4, ip
3481d30c:	3afffef5 	bcc	3481cee8 <inflate_fast+0xdc>
3481d310:	e59d5010 	ldr	r5, [sp, #16]
3481d314:	e59d0014 	ldr	r0, [sp, #20]

    /* return unused bytes (on entry, bits < 8, so in won't go too far back) */
    len = bits >> 3;
3481d318:	e1a0c1a2 	lsr	ip, r2, #3
    in -= len;
3481d31c:	e06c4004 	rsb	r4, ip, r4
    bits -= len << 3;
3481d320:	e1a0c18c 	lsl	ip, ip, #3
3481d324:	e06c2002 	rsb	r2, ip, r2
    hold &= (1U << bits) - 1;
3481d328:	e3e0c000 	mvn	ip, #0
3481d32c:	e1c1121c 	bic	r1, r1, ip, lsl r2
3481d330:	e59d601c 	ldr	r6, [sp, #28]

    /* update state and return */
    strm->next_in = in + OFF;
3481d334:	e284c001 	add	ip, r4, #1
3481d338:	e580c000 	str	ip, [r0]
3481d33c:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
    strm->next_out = out + OFF;
3481d340:	e283c001 	add	ip, r3, #1
3481d344:	e580c00c 	str	ip, [r0, #12]
3481d348:	e286c005 	add	ip, r6, #5
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
3481d34c:	e064400c 	rsb	r4, r4, ip
3481d350:	e289cc01 	add	ip, r9, #256	; 0x100
3481d354:	e28cc001 	add	ip, ip, #1
    strm->avail_out = (unsigned)(out < end ?
                                 257 + (end - out) : 257 - (out - end));
3481d358:	e063300c 	rsb	r3, r3, ip
    hold &= (1U << bits) - 1;

    /* update state and return */
    strm->next_in = in + OFF;
    strm->next_out = out + OFF;
    strm->avail_in = (unsigned)(in < last ? 5 + (last - in) : 5 - (in - last));
3481d35c:	e5804004 	str	r4, [r0, #4]
    strm->avail_out = (unsigned)(out < end ?
3481d360:	e5803010 	str	r3, [r0, #16]
                                 257 + (end - out) : 257 - (out - end));
    state->hold = hold;
3481d364:	e5851038 	str	r1, [r5, #56]	; 0x38
    state->bits = bits;
3481d368:	e585203c 	str	r2, [r5, #60]	; 0x3c
    return;
}
3481d36c:	e28dd048 	add	sp, sp, #72	; 0x48
3481d370:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481d374:	34828072 	.word	0x34828072
3481d378:	34828090 	.word	0x34828090
3481d37c:	348280a6 	.word	0x348280a6

3481d380 <inflate_table>:
unsigned short FAR *lens;
unsigned codes;
code FAR * FAR *table;
unsigned FAR *bits;
unsigned short FAR *work;
{
3481d380:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
3481d384:	e24dd088 	sub	sp, sp, #136	; 0x88
    }

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
3481d388:	e28d4068 	add	r4, sp, #104	; 0x68
unsigned short FAR *lens;
unsigned codes;
code FAR * FAR *table;
unsigned FAR *bits;
unsigned short FAR *work;
{
3481d38c:	e58d1030 	str	r1, [sp, #48]	; 0x30
3481d390:	e59d10ac 	ldr	r1, [sp, #172]	; 0xac
    }

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
3481d394:	e28dc066 	add	ip, sp, #102	; 0x66
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481d398:	e1a05004 	mov	r5, r4
3481d39c:	e284701e 	add	r7, r4, #30
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
3481d3a0:	e3a06000 	mov	r6, #0
3481d3a4:	e1ec60b2 	strh	r6, [ip, #2]!
       at length counts to determine sub-table sizes when building the
       decoding tables.
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
3481d3a8:	e15c0007 	cmp	ip, r7
3481d3ac:	1afffffb 	bne	3481d3a0 <inflate_table+0x20>
3481d3b0:	e59db030 	ldr	fp, [sp, #48]	; 0x30
3481d3b4:	e3a0c000 	mov	ip, #0
3481d3b8:	e1a0600b 	mov	r6, fp
3481d3bc:	ea000006 	b	3481d3dc <inflate_table+0x5c>
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
        count[lens[sym]]++;
3481d3c0:	e0d690b2 	ldrh	r9, [r6], #2
3481d3c4:	e28da088 	add	sl, sp, #136	; 0x88
3481d3c8:	e08a9089 	add	r9, sl, r9, lsl #1
3481d3cc:	e159a2b0 	ldrh	sl, [r9, #-32]	; 0xffffffe0
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
3481d3d0:	e28cc001 	add	ip, ip, #1
        count[lens[sym]]++;
3481d3d4:	e28aa001 	add	sl, sl, #1
3481d3d8:	e149a2b0 	strh	sl, [r9, #-32]	; 0xffffffe0
     */

    /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */
    for (len = 0; len <= MAXBITS; len++)
        count[len] = 0;
    for (sym = 0; sym < codes; sym++)
3481d3dc:	e15c0002 	cmp	ip, r2
3481d3e0:	3afffff6 	bcc	3481d3c0 <inflate_table+0x40>
        count[lens[sym]]++;

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
3481d3e4:	e59d60a8 	ldr	r6, [sp, #168]	; 0xa8
3481d3e8:	e28da088 	add	sl, sp, #136	; 0x88
3481d3ec:	e596c000 	ldr	ip, [r6]
    for (max = MAXBITS; max >= 1; max--)
3481d3f0:	e3a0600f 	mov	r6, #15
        if (count[max] != 0) break;
3481d3f4:	e17a90b2 	ldrh	r9, [sl, #-2]!
3481d3f8:	e3590000 	cmp	r9, #0
3481d3fc:	0a000004 	beq	3481d414 <inflate_table+0x94>
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
3481d400:	e3560000 	cmp	r6, #0
3481d404:	11a0a004 	movne	sl, r4
3481d408:	13a04001 	movne	r4, #1
3481d40c:	1a000013 	bne	3481d460 <inflate_table+0xe0>
3481d410:	ea000001 	b	3481d41c <inflate_table+0x9c>
    for (sym = 0; sym < codes; sym++)
        count[lens[sym]]++;

    /* bound code lengths, force root to be within code lengths */
    root = *bits;
    for (max = MAXBITS; max >= 1; max--)
3481d414:	e2566001 	subs	r6, r6, #1
3481d418:	1afffff5 	bne	3481d3f4 <inflate_table+0x74>
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
        this.op = (unsigned char)64;    /* invalid code marker */
        this.bits = (unsigned char)1;
        this.val = (unsigned short)0;
        *(*table)++ = this;             /* make a table to force an error */
3481d41c:	e5932000 	ldr	r2, [r3]
3481d420:	e3a01001 	mov	r1, #1
3481d424:	e2820004 	add	r0, r2, #4
3481d428:	e3a0c040 	mov	ip, #64	; 0x40
3481d42c:	e5c21001 	strb	r1, [r2, #1]
3481d430:	e5c2c000 	strb	ip, [r2]
3481d434:	e5c01001 	strb	r1, [r0, #1]
3481d438:	e5c2c004 	strb	ip, [r2, #4]
3481d43c:	e3a07000 	mov	r7, #0
        *(*table)++ = this;
        *bits = 1;
3481d440:	e59d90a8 	ldr	r9, [sp, #168]	; 0xa8
    if (root > max) root = max;
    if (max == 0) {                     /* no symbols to code at all */
        this.op = (unsigned char)64;    /* invalid code marker */
        this.bits = (unsigned char)1;
        this.val = (unsigned short)0;
        *(*table)++ = this;             /* make a table to force an error */
3481d444:	e1c270b2 	strh	r7, [r2, #2]
3481d448:	e1c070b2 	strh	r7, [r0, #2]
        *(*table)++ = this;
3481d44c:	e2800004 	add	r0, r0, #4
3481d450:	e5830000 	str	r0, [r3]
        *bits = 1;
3481d454:	e5891000 	str	r1, [r9]
        return 0;     /* no symbols, but wait for decoding to report error */
3481d458:	e3a00000 	mov	r0, #0
3481d45c:	ea00011e 	b	3481d8dc <inflate_table+0x55c>
    }
    for (min = 1; min <= MAXBITS; min++)
        if (count[min] != 0) break;
3481d460:	e1fa90b2 	ldrh	r9, [sl, #2]!
3481d464:	e3590000 	cmp	r9, #0
3481d468:	1a000004 	bne	3481d480 <inflate_table+0x100>
        *(*table)++ = this;             /* make a table to force an error */
        *(*table)++ = this;
        *bits = 1;
        return 0;     /* no symbols, but wait for decoding to report error */
    }
    for (min = 1; min <= MAXBITS; min++)
3481d46c:	e2844001 	add	r4, r4, #1
3481d470:	e3540010 	cmp	r4, #16
3481d474:	1afffff9 	bne	3481d460 <inflate_table+0xe0>
3481d478:	e1a0c004 	mov	ip, r4
3481d47c:	ea000003 	b	3481d490 <inflate_table+0x110>
3481d480:	e156000c 	cmp	r6, ip
3481d484:	31a0c006 	movcc	ip, r6
        if (count[min] != 0) break;
    if (root < min) root = min;
3481d488:	e15c0004 	cmp	ip, r4
3481d48c:	31a0c004 	movcc	ip, r4

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
3481d490:	e3a09001 	mov	r9, #1
    for (len = 1; len <= MAXBITS; len++) {
        left <<= 1;
3481d494:	e1a0a089 	lsl	sl, r9, #1
        left -= count[len];
3481d498:	e1f590b2 	ldrh	r9, [r5, #2]!
        if (left < 0) return -1;        /* over-subscribed */
3481d49c:	e05a9009 	subs	r9, sl, r9
3481d4a0:	4a00010a 	bmi	3481d8d0 <inflate_table+0x550>
        if (count[min] != 0) break;
    if (root < min) root = min;

    /* check for an over-subscribed or incomplete set of lengths */
    left = 1;
    for (len = 1; len <= MAXBITS; len++) {
3481d4a4:	e1550007 	cmp	r5, r7
3481d4a8:	1afffff9 	bne	3481d494 <inflate_table+0x114>
        left <<= 1;
        left -= count[len];
        if (left < 0) return -1;        /* over-subscribed */
    }
    if (left > 0 && (type == CODES || max != 1))
3481d4ac:	e3590000 	cmp	r9, #0
3481d4b0:	0a000005 	beq	3481d4cc <inflate_table+0x14c>
3481d4b4:	e2705001 	rsbs	r5, r0, #1
3481d4b8:	33a05000 	movcc	r5, #0
3481d4bc:	e3560001 	cmp	r6, #1
3481d4c0:	13855001 	orrne	r5, r5, #1
3481d4c4:	e3550000 	cmp	r5, #0
3481d4c8:	1a000100 	bne	3481d8d0 <inflate_table+0x550>
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
3481d4cc:	e3a0a000 	mov	sl, #0
3481d4d0:	e1cda4ba 	strh	sl, [sp, #74]	; 0x4a
3481d4d4:	e28d7048 	add	r7, sp, #72	; 0x48
3481d4d8:	e3a05000 	mov	r5, #0
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481d4dc:	e2855002 	add	r5, r5, #2
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];
3481d4e0:	e28da068 	add	sl, sp, #104	; 0x68
3481d4e4:	e19a90b5 	ldrh	r9, [sl, r5]
3481d4e8:	e1d7a0b2 	ldrh	sl, [r7, #2]
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
3481d4ec:	e355001c 	cmp	r5, #28
        offs[len + 1] = offs[len] + count[len];
3481d4f0:	e089a00a 	add	sl, r9, sl
3481d4f4:	e1c7a0b4 	strh	sl, [r7, #4]
3481d4f8:	e2877002 	add	r7, r7, #2
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */

    /* generate offsets into symbol table for each length for sorting */
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
3481d4fc:	1afffff6 	bne	3481d4dc <inflate_table+0x15c>
3481d500:	e3a05000 	mov	r5, #0
3481d504:	ea00000a 	b	3481d534 <inflate_table+0x1b4>
        offs[len + 1] = offs[len] + count[len];

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++)
        if (lens[sym] != 0) work[offs[lens[sym]]++] = (unsigned short)sym;
3481d508:	e0db90b2 	ldrh	r9, [fp], #2
3481d50c:	e3590000 	cmp	r9, #0
3481d510:	0a000006 	beq	3481d530 <inflate_table+0x1b0>
3481d514:	e28d7088 	add	r7, sp, #136	; 0x88
3481d518:	e0879089 	add	r9, r7, r9, lsl #1
3481d51c:	e15974b0 	ldrh	r7, [r9, #-64]	; 0xffffffc0
3481d520:	e1a0a087 	lsl	sl, r7, #1
3481d524:	e2877001 	add	r7, r7, #1
3481d528:	e18150ba 	strh	r5, [r1, sl]
3481d52c:	e14974b0 	strh	r7, [r9, #-64]	; 0xffffffc0
    offs[1] = 0;
    for (len = 1; len < MAXBITS; len++)
        offs[len + 1] = offs[len] + count[len];

    /* sort symbols by length, by symbol order within each length */
    for (sym = 0; sym < codes; sym++)
3481d530:	e2855001 	add	r5, r5, #1
3481d534:	e1550002 	cmp	r5, r2
3481d538:	3afffff2 	bcc	3481d508 <inflate_table+0x188>
       routine permits incomplete codes, so another loop after this one fills
       in the rest of the decoding tables with invalid code markers.
     */

    /* set up for code type */
    switch (type) {
3481d53c:	e3500000 	cmp	r0, #0
3481d540:	0a00000f 	beq	3481d584 <inflate_table+0x204>
3481d544:	e3500001 	cmp	r0, #1
3481d548:	1a000006 	bne	3481d568 <inflate_table+0x1e8>
        break;
    case LENS:
        base = lbase;
        base -= 257;
        extra = lext;
        extra -= 257;
3481d54c:	e59fa390 	ldr	sl, [pc, #912]	; 3481d8e4 <inflate_table+0x564>
        end = 256;
3481d550:	e3a09c01 	mov	r9, #256	; 0x100
        base = extra = work;    /* dummy value--not used */
        end = 19;
        break;
    case LENS:
        base = lbase;
        base -= 257;
3481d554:	e28a2040 	add	r2, sl, #64	; 0x40
        extra = lext;
        extra -= 257;
        end = 256;
3481d558:	e58d9020 	str	r9, [sp, #32]
        break;
    case LENS:
        base = lbase;
        base -= 257;
        extra = lext;
        extra -= 257;
3481d55c:	e58da010 	str	sl, [sp, #16]
        base = extra = work;    /* dummy value--not used */
        end = 19;
        break;
    case LENS:
        base = lbase;
        base -= 257;
3481d560:	e58d201c 	str	r2, [sp, #28]
3481d564:	ea00000a 	b	3481d594 <inflate_table+0x214>
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
        extra = dext;
3481d568:	e59f7378 	ldr	r7, [pc, #888]	; 3481d8e8 <inflate_table+0x568>
        end = -1;
3481d56c:	e3e05000 	mvn	r5, #0
        extra = lext;
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
3481d570:	e2879040 	add	r9, r7, #64	; 0x40
        extra = dext;
        end = -1;
3481d574:	e58d5020 	str	r5, [sp, #32]
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
        extra = dext;
3481d578:	e58d7010 	str	r7, [sp, #16]
        extra = lext;
        extra -= 257;
        end = 256;
        break;
    default:            /* DISTS */
        base = dbase;
3481d57c:	e58d901c 	str	r9, [sp, #28]
3481d580:	ea000003 	b	3481d594 <inflate_table+0x214>

    /* set up for code type */
    switch (type) {
    case CODES:
        base = extra = work;    /* dummy value--not used */
        end = 19;
3481d584:	e3a0a013 	mov	sl, #19
     */

    /* set up for code type */
    switch (type) {
    case CODES:
        base = extra = work;    /* dummy value--not used */
3481d588:	e58d1010 	str	r1, [sp, #16]
3481d58c:	e58d101c 	str	r1, [sp, #28]
        end = 19;
3481d590:	e58da020 	str	sl, [sp, #32]
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
3481d594:	e3a0a001 	mov	sl, #1
3481d598:	e1a02c1a 	lsl	r2, sl, ip
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481d59c:	e150000a 	cmp	r0, sl
3481d5a0:	13a00000 	movne	r0, #0
3481d5a4:	03a00001 	moveq	r0, #1

    /* initialize state for loop */
    huff = 0;                   /* starting code */
    sym = 0;                    /* starting code symbol */
    len = min;                  /* starting code length */
    next = *table;              /* current table to fill in */
3481d5a8:	e5937000 	ldr	r7, [r3]
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
3481d5ac:	e58d200c 	str	r2, [sp, #12]
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481d5b0:	e58d0038 	str	r0, [sp, #56]	; 0x38
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */
3481d5b4:	e2425001 	sub	r5, r2, #1

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481d5b8:	e59d900c 	ldr	r9, [sp, #12]
3481d5bc:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
3481d5c0:	e30005af 	movw	r0, #1455	; 0x5af
3481d5c4:	e1590000 	cmp	r9, r0
3481d5c8:	93a02000 	movls	r2, #0
3481d5cc:	82022001 	andhi	r2, r2, #1
3481d5d0:	e3520000 	cmp	r2, #0
    next = *table;              /* current table to fill in */
    curr = root;                /* current table index bits */
    drop = 0;                   /* current bits to drop from code for index */
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */
3481d5d4:	e58d5034 	str	r5, [sp, #52]	; 0x34

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
        return 1;
3481d5d8:	11a0000a 	movne	r0, sl
    low = (unsigned)(-1);       /* trigger new sub-table when len > root */
    used = 1U << root;          /* use root table entries */
    mask = used - 1;            /* mask for comparing low */

    /* check available table space */
    if (type == LENS && used >= ENOUGH - MAXD)
3481d5dc:	1a0000be 	bne	3481d8dc <inflate_table+0x55c>
3481d5e0:	e58d1018 	str	r1, [sp, #24]
3481d5e4:	e3e01000 	mvn	r1, #0
3481d5e8:	e58d1014 	str	r1, [sp, #20]
3481d5ec:	e1a0500c 	mov	r5, ip
3481d5f0:	e1a01002 	mov	r1, r2
3481d5f4:	e1a0b006 	mov	fp, r6
3481d5f8:	ea000000 	b	3481d600 <inflate_table+0x280>
3481d5fc:	e58d0014 	str	r0, [sp, #20]

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
        if ((int)(work[sym]) < end) {
3481d600:	e59d6018 	ldr	r6, [sp, #24]
3481d604:	e59d9020 	ldr	r9, [sp, #32]
3481d608:	e0d6a0b2 	ldrh	sl, [r6], #2
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
3481d60c:	e0610004 	rsb	r0, r1, r4
        if ((int)(work[sym]) < end) {
3481d610:	e15a0009 	cmp	sl, r9
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
3481d614:	e6ef0070 	uxtb	r0, r0
        if ((int)(work[sym]) < end) {
            this.op = (unsigned char)0;
3481d618:	b3a09000 	movlt	r9, #0
        return 1;

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
3481d61c:	e58d003c 	str	r0, [sp, #60]	; 0x3c
        if ((int)(work[sym]) < end) {
3481d620:	e58d6018 	str	r6, [sp, #24]
            this.op = (unsigned char)0;
3481d624:	b58d902c 	strlt	r9, [sp, #44]	; 0x2c

    /* process all codes and make table entries */
    for (;;) {
        /* create table entry */
        this.bits = (unsigned char)(len - drop);
        if ((int)(work[sym]) < end) {
3481d628:	ba000008 	blt	3481d650 <inflate_table+0x2d0>
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
3481d62c:	c59d0010 	ldrgt	r0, [sp, #16]
3481d630:	c1a0a08a 	lslgt	sl, sl, #1
            this.val = base[work[sym]];
3481d634:	c59d601c 	ldrgt	r6, [sp, #28]
        if ((int)(work[sym]) < end) {
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
3481d638:	c7d0000a 	ldrbgt	r0, [r0, sl]
            this.val = base[work[sym]];
        }
        else {
            this.op = (unsigned char)(32 + 64);         /* end of block */
3481d63c:	d3a00060 	movle	r0, #96	; 0x60
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
            this.val = base[work[sym]];
3481d640:	c196a0ba 	ldrhgt	sl, [r6, sl]
        if ((int)(work[sym]) < end) {
            this.op = (unsigned char)0;
            this.val = work[sym];
        }
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
3481d644:	c58d002c 	strgt	r0, [sp, #44]	; 0x2c
            this.val = base[work[sym]];
        }
        else {
            this.op = (unsigned char)(32 + 64);         /* end of block */
            this.val = 0;
3481d648:	d3a0a000 	movle	sl, #0
        else if ((int)(work[sym]) > end) {
            this.op = (unsigned char)(extra[work[sym]]);
            this.val = base[work[sym]];
        }
        else {
            this.op = (unsigned char)(32 + 64);         /* end of block */
3481d64c:	d58d002c 	strle	r0, [sp, #44]	; 0x2c
            this.val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1U << (len - drop);
3481d650:	e3a09001 	mov	r9, #1
3481d654:	e0616004 	rsb	r6, r1, r4
3481d658:	e1a06619 	lsl	r6, r9, r6
        fill = 1U << curr;
3481d65c:	e1a00519 	lsl	r0, r9, r5
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481d660:	e2669000 	rsb	r9, r6, #0
3481d664:	e58d9040 	str	r9, [sp, #64]	; 0x40
3481d668:	e3e09003 	mvn	r9, #3
3481d66c:	e0090699 	mul	r9, r9, r6
            this.val = 0;
        }

        /* replicate for those indices with low len bits equal to huff */
        incr = 1U << (len - drop);
        fill = 1U << curr;
3481d670:	e58d0024 	str	r0, [sp, #36]	; 0x24
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481d674:	e58d9044 	str	r9, [sp, #68]	; 0x44
        incr = 1U << (len - drop);
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
3481d678:	e59d9024 	ldr	r9, [sp, #36]	; 0x24
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481d67c:	e0660000 	rsb	r0, r6, r0
3481d680:	e58d0028 	str	r0, [sp, #40]	; 0x28
        incr = 1U << (len - drop);
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
3481d684:	e0890132 	add	r0, r9, r2, lsr r1
3481d688:	e0660000 	rsb	r0, r6, r0
3481d68c:	e0870100 	add	r0, r7, r0, lsl #2
3481d690:	e1a0900c 	mov	r9, ip
3481d694:	e58d3004 	str	r3, [sp, #4]
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481d698:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
3481d69c:	e5c0c000 	strb	ip, [r0]
3481d6a0:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3481d6a4:	e1c0a0b2 	strh	sl, [r0, #2]
3481d6a8:	e5c03001 	strb	r3, [r0, #1]
3481d6ac:	e59dc028 	ldr	ip, [sp, #40]	; 0x28
3481d6b0:	e59d3040 	ldr	r3, [sp, #64]	; 0x40
3481d6b4:	e08cc003 	add	ip, ip, r3
3481d6b8:	e58dc028 	str	ip, [sp, #40]	; 0x28
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
        } while (fill != 0);
3481d6bc:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481d6c0:	e59dc044 	ldr	ip, [sp, #68]	; 0x44
3481d6c4:	e080000c 	add	r0, r0, ip
        fill = 1U << curr;
        min = fill;                 /* save offset to next table */
        do {
            fill -= incr;
            next[(huff >> drop) + fill] = this;
        } while (fill != 0);
3481d6c8:	e083c006 	add	ip, r3, r6
3481d6cc:	e35c0000 	cmp	ip, #0
3481d6d0:	1afffff0 	bne	3481d698 <inflate_table+0x318>

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481d6d4:	e2440001 	sub	r0, r4, #1
3481d6d8:	e3a06001 	mov	r6, #1
3481d6dc:	e1a0c009 	mov	ip, r9
3481d6e0:	e59d3004 	ldr	r3, [sp, #4]
3481d6e4:	e1a00016 	lsl	r0, r6, r0
        while (huff & incr)
3481d6e8:	ea000000 	b	3481d6f0 <inflate_table+0x370>
            incr >>= 1;
3481d6ec:	e1a000a0 	lsr	r0, r0, #1
            next[(huff >> drop) + fill] = this;
        } while (fill != 0);

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
3481d6f0:	e1100002 	tst	r0, r2
3481d6f4:	1afffffc 	bne	3481d6ec <inflate_table+0x36c>
            incr >>= 1;
        if (incr != 0) {
3481d6f8:	e3500000 	cmp	r0, #0
            huff &= incr - 1;
3481d6fc:	12406001 	subne	r6, r0, #1
        else
            huff = 0;

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
3481d700:	e28d9088 	add	r9, sp, #136	; 0x88
        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
            incr >>= 1;
        if (incr != 0) {
            huff &= incr - 1;
3481d704:	10062002 	andne	r2, r6, r2
        else
            huff = 0;

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
3481d708:	e0896084 	add	r6, r9, r4, lsl #1
        incr = 1U << (len - 1);
        while (huff & incr)
            incr >>= 1;
        if (incr != 0) {
            huff &= incr - 1;
            huff += incr;
3481d70c:	10822000 	addne	r2, r2, r0
        }
        else
            huff = 0;
3481d710:	01a02000 	moveq	r2, r0

        /* go to next symbol, update count, len */
        sym++;
        if (--(count[len]) == 0) {
3481d714:	e15602b0 	ldrh	r0, [r6, #-32]	; 0xffffffe0
3481d718:	e2400001 	sub	r0, r0, #1
3481d71c:	e6ff0070 	uxth	r0, r0
3481d720:	e3500000 	cmp	r0, #0
3481d724:	e14602b0 	strh	r0, [r6, #-32]	; 0xffffffe0
3481d728:	1a000006 	bne	3481d748 <inflate_table+0x3c8>
            if (len == max) break;
3481d72c:	e154000b 	cmp	r4, fp
3481d730:	0a000058 	beq	3481d898 <inflate_table+0x518>
            len = lens[work[sym]];
3481d734:	e59da018 	ldr	sl, [sp, #24]
3481d738:	e59d6030 	ldr	r6, [sp, #48]	; 0x30
3481d73c:	e1da00b0 	ldrh	r0, [sl]
3481d740:	e1a00080 	lsl	r0, r0, #1
3481d744:	e19640b0 	ldrh	r4, [r6, r0]
        }

        /* create new sub-table if needed */
        if (len > root && (huff & mask) != low) {
3481d748:	e154000c 	cmp	r4, ip
3481d74c:	959d0014 	ldrls	r0, [sp, #20]
3481d750:	9affffa9 	bls	3481d5fc <inflate_table+0x27c>
3481d754:	e59d9034 	ldr	r9, [sp, #52]	; 0x34
3481d758:	e59da014 	ldr	sl, [sp, #20]
3481d75c:	e0020009 	and	r0, r2, r9
3481d760:	e150000a 	cmp	r0, sl
3481d764:	0affffa4 	beq	3481d5fc <inflate_table+0x27c>
            /* if first time, transition to sub-tables */
            if (drop == 0)
3481d768:	e3510000 	cmp	r1, #0
3481d76c:	01a0100c 	moveq	r1, ip

            /* increment past last table */
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
3481d770:	e0615004 	rsb	r5, r1, r4
            left = (int)(1 << curr);
3481d774:	e3a09001 	mov	r9, #1
3481d778:	e1a06519 	lsl	r6, r9, r5
   on return points to the next available entry's address.  bits is the
   requested root table index bits, and on return it is the actual root
   table index bits.  It will differ if the request is greater than the
   longest code or if it is less than the shortest code.
 */
int inflate_table(type, lens, codes, table, bits, work)
3481d77c:	e2419001 	sub	r9, r1, #1
3481d780:	e28da068 	add	sl, sp, #104	; 0x68
3481d784:	e0899005 	add	r9, r9, r5
3481d788:	e08a9089 	add	r9, sl, r9, lsl #1
3481d78c:	e1a0a00c 	mov	sl, ip
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (int)(1 << curr);
            while (curr + drop < max) {
3481d790:	ea000005 	b	3481d7ac <inflate_table+0x42c>
                left -= count[curr + drop];
3481d794:	e1f9c0b2 	ldrh	ip, [r9, #2]!
3481d798:	e06c6006 	rsb	r6, ip, r6
                if (left <= 0) break;
3481d79c:	e3560000 	cmp	r6, #0
3481d7a0:	da000004 	ble	3481d7b8 <inflate_table+0x438>
                curr++;
3481d7a4:	e2855001 	add	r5, r5, #1
                left <<= 1;
3481d7a8:	e1a06086 	lsl	r6, r6, #1
            next += min;            /* here min is 1 << curr */

            /* determine length of next table */
            curr = len - drop;
            left = (int)(1 << curr);
            while (curr + drop < max) {
3481d7ac:	e085c001 	add	ip, r5, r1
3481d7b0:	e15c000b 	cmp	ip, fp
3481d7b4:	3afffff6 	bcc	3481d794 <inflate_table+0x414>
                curr++;
                left <<= 1;
            }

            /* check for enough space */
            used += 1U << curr;
3481d7b8:	e59d600c 	ldr	r6, [sp, #12]
3481d7bc:	e3a09001 	mov	r9, #1
3481d7c0:	e0866519 	add	r6, r6, r9, lsl r5
3481d7c4:	e58d600c 	str	r6, [sp, #12]
3481d7c8:	e1a0c00a 	mov	ip, sl
            if (type == LENS && used >= ENOUGH - MAXD)
3481d7cc:	e59d6038 	ldr	r6, [sp, #56]	; 0x38
3481d7d0:	e59da00c 	ldr	sl, [sp, #12]
3481d7d4:	e30095af 	movw	r9, #1455	; 0x5af
3481d7d8:	e15a0009 	cmp	sl, r9
3481d7dc:	93a06000 	movls	r6, #0
3481d7e0:	82066001 	andhi	r6, r6, #1
3481d7e4:	e3560000 	cmp	r6, #0
3481d7e8:	1a00003a 	bne	3481d8d8 <inflate_table+0x558>
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
3481d7ec:	e5936000 	ldr	r6, [r3]
            /* if first time, transition to sub-tables */
            if (drop == 0)
                drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */
3481d7f0:	e59da024 	ldr	sl, [sp, #36]	; 0x24
            if (type == LENS && used >= ENOUGH - MAXD)
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
3481d7f4:	e7c65100 	strb	r5, [r6, r0, lsl #2]
            (*table)[low].bits = (unsigned char)root;
3481d7f8:	e5936000 	ldr	r6, [r3]
            /* if first time, transition to sub-tables */
            if (drop == 0)
                drop = root;

            /* increment past last table */
            next += min;            /* here min is 1 << curr */
3481d7fc:	e087710a 	add	r7, r7, sl, lsl #2
            if (type == LENS && used >= ENOUGH - MAXD)
                return 1;

            /* point entry in root table to sub-table */
            low = huff & mask;
            (*table)[low].op = (unsigned char)curr;
3481d800:	e1a0a100 	lsl	sl, r0, #2
            (*table)[low].bits = (unsigned char)root;
3481d804:	e086600a 	add	r6, r6, sl
3481d808:	e5c6c001 	strb	ip, [r6, #1]
            (*table)[low].val = (unsigned short)(next - *table);
3481d80c:	e5936000 	ldr	r6, [r3]
3481d810:	e086a00a 	add	sl, r6, sl
3481d814:	e0666007 	rsb	r6, r6, r7
3481d818:	e1a06146 	asr	r6, r6, #2
3481d81c:	e1ca60b2 	strh	r6, [sl, #2]
3481d820:	eaffff75 	b	3481d5fc <inflate_table+0x27c>
    this.op = (unsigned char)64;                /* invalid code marker */
    this.bits = (unsigned char)(len - drop);
    this.val = (unsigned short)0;
    while (huff != 0) {
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
3481d824:	e3510000 	cmp	r1, #0
3481d828:	0a000007 	beq	3481d84c <inflate_table+0x4cc>
3481d82c:	e59d9034 	ldr	r9, [sp, #52]	; 0x34
3481d830:	e0020009 	and	r0, r2, r9
3481d834:	e59d9014 	ldr	r9, [sp, #20]
3481d838:	e1500009 	cmp	r0, r9
            drop = 0;
            len = root;
            next = *table;
3481d83c:	15937000 	ldrne	r7, [r3]
            this.bits = (unsigned char)len;
3481d840:	11a0b00a 	movne	fp, sl
3481d844:	11a0400c 	movne	r4, ip
    this.bits = (unsigned char)(len - drop);
    this.val = (unsigned short)0;
    while (huff != 0) {
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
            drop = 0;
3481d848:	13a01000 	movne	r1, #0
            next = *table;
            this.bits = (unsigned char)len;
        }

        /* put invalid code marker in table */
        next[huff >> drop] = this;
3481d84c:	e1a09132 	lsr	r9, r2, r1
3481d850:	e0870109 	add	r0, r7, r9, lsl #2
3481d854:	e7c76109 	strb	r6, [r7, r9, lsl #2]
3481d858:	e3a09000 	mov	r9, #0
3481d85c:	e5c0b001 	strb	fp, [r0, #1]
3481d860:	e1c090b2 	strh	r9, [r0, #2]

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481d864:	e2440001 	sub	r0, r4, #1
3481d868:	e1a00015 	lsl	r0, r5, r0
        while (huff & incr)
3481d86c:	ea000000 	b	3481d874 <inflate_table+0x4f4>
            incr >>= 1;
3481d870:	e1a000a0 	lsr	r0, r0, #1
        /* put invalid code marker in table */
        next[huff >> drop] = this;

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
        while (huff & incr)
3481d874:	e1100002 	tst	r0, r2
3481d878:	1afffffc 	bne	3481d870 <inflate_table+0x4f0>
            incr >>= 1;
        if (incr != 0) {
3481d87c:	e3500000 	cmp	r0, #0
            huff &= incr - 1;
3481d880:	12409001 	subne	r9, r0, #1
3481d884:	10092002 	andne	r2, r9, r2
            huff += incr;
3481d888:	10822000 	addne	r2, r2, r0
3481d88c:	1a000005 	bne	3481d8a8 <inflate_table+0x528>
        }
        else
            huff = 0;
3481d890:	e1a02000 	mov	r2, r0
3481d894:	ea000005 	b	3481d8b0 <inflate_table+0x530>

        /* put invalid code marker in table */
        next[huff >> drop] = this;

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481d898:	e59db03c 	ldr	fp, [sp, #60]	; 0x3c
        /* when done with sub-table, drop back to root table */
        if (drop != 0 && (huff & mask) != low) {
            drop = 0;
            len = root;
            next = *table;
            this.bits = (unsigned char)len;
3481d89c:	e6efa07c 	uxtb	sl, ip
        }

        /* put invalid code marker in table */
        next[huff >> drop] = this;
3481d8a0:	e3a06040 	mov	r6, #64	; 0x40

        /* backwards increment the len-bit code huff */
        incr = 1U << (len - 1);
3481d8a4:	e3a05001 	mov	r5, #1
       drops back to the root table to fill in any remaining entries there.
     */
    this.op = (unsigned char)64;                /* invalid code marker */
    this.bits = (unsigned char)(len - drop);
    this.val = (unsigned short)0;
    while (huff != 0) {
3481d8a8:	e3520000 	cmp	r2, #0
3481d8ac:	1affffdc 	bne	3481d824 <inflate_table+0x4a4>
        else
            huff = 0;
    }

    /* set return parameters */
    *table += used;
3481d8b0:	e5931000 	ldr	r1, [r3]
3481d8b4:	e59da00c 	ldr	sl, [sp, #12]
    *bits = root;
3481d8b8:	e59d00a8 	ldr	r0, [sp, #168]	; 0xa8
        else
            huff = 0;
    }

    /* set return parameters */
    *table += used;
3481d8bc:	e081110a 	add	r1, r1, sl, lsl #2
3481d8c0:	e5831000 	str	r1, [r3]
    *bits = root;
3481d8c4:	e580c000 	str	ip, [r0]
    return 0;
3481d8c8:	e1a00002 	mov	r0, r2
3481d8cc:	ea000002 	b	3481d8dc <inflate_table+0x55c>
        left <<= 1;
        left -= count[len];
        if (left < 0) return -1;        /* over-subscribed */
    }
    if (left > 0 && (type == CODES || max != 1))
        return -1;                      /* incomplete set */
3481d8d0:	e3e00000 	mvn	r0, #0
3481d8d4:	ea000000 	b	3481d8dc <inflate_table+0x55c>
            }

            /* check for enough space */
            used += 1U << curr;
            if (type == LENS && used >= ENOUGH - MAXD)
                return 1;
3481d8d8:	e3a00001 	mov	r0, #1

    /* set return parameters */
    *table += used;
    *bits = root;
    return 0;
}
3481d8dc:	e28dd088 	add	sp, sp, #136	; 0x88
3481d8e0:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}
3481d8e4:	34821c02 	.word	0x34821c02
3481d8e8:	34821e84 	.word	0x34821e84

3481d8ec <inflateReset>:
int ZEXPORT inflateReset(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
3481d8ec:	e3500000 	cmp	r0, #0
3481d8f0:	03e00001 	mvneq	r0, #1
3481d8f4:	012fff1e 	bxeq	lr
3481d8f8:	e590301c 	ldr	r3, [r0, #28]
3481d8fc:	e3530000 	cmp	r3, #0
3481d900:	0a000017 	beq	3481d964 <inflateReset+0x78>
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
3481d904:	e3a02000 	mov	r2, #0
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
3481d908:	e3a01001 	mov	r1, #1
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
3481d90c:	e583201c 	str	r2, [r3, #28]
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
3481d910:	e5801034 	str	r1, [r0, #52]	; 0x34
    state->mode = HEAD;
    state->last = 0;
    state->havedict = 0;
    state->dmax = 32768U;
3481d914:	e3a01902 	mov	r1, #32768	; 0x8000
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
3481d918:	e5802014 	str	r2, [r0, #20]
3481d91c:	e5802008 	str	r2, [r0, #8]
    strm->msg = Z_NULL;
3481d920:	e5802018 	str	r2, [r0, #24]
    strm->adler = 1;        /* to support ill-conceived Java test suite */
    state->mode = HEAD;
    state->last = 0;
    state->havedict = 0;
    state->dmax = 32768U;
3481d924:	e5831014 	str	r1, [r3, #20]
    state->wsize = 0;
    state->whave = 0;
    state->write = 0;
    state->hold = 0;
    state->bits = 0;
    state->lencode = state->distcode = state->next = state->codes;
3481d928:	e2831e53 	add	r1, r3, #1328	; 0x530
    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    strm->total_in = strm->total_out = state->total = 0;
    strm->msg = Z_NULL;
    strm->adler = 1;        /* to support ill-conceived Java test suite */
    state->mode = HEAD;
3481d92c:	e5832000 	str	r2, [r3]
    state->last = 0;
3481d930:	e5832004 	str	r2, [r3, #4]
    state->havedict = 0;
3481d934:	e583200c 	str	r2, [r3, #12]
    state->dmax = 32768U;
    state->head = Z_NULL;
3481d938:	e5832020 	str	r2, [r3, #32]
    state->wsize = 0;
3481d93c:	e5832028 	str	r2, [r3, #40]	; 0x28
    state->whave = 0;
3481d940:	e583202c 	str	r2, [r3, #44]	; 0x2c
    state->write = 0;
3481d944:	e5832030 	str	r2, [r3, #48]	; 0x30
    state->hold = 0;
3481d948:	e5832038 	str	r2, [r3, #56]	; 0x38
    state->bits = 0;
3481d94c:	e583203c 	str	r2, [r3, #60]	; 0x3c
    state->lencode = state->distcode = state->next = state->codes;
3481d950:	e583106c 	str	r1, [r3, #108]	; 0x6c
3481d954:	e5831050 	str	r1, [r3, #80]	; 0x50
3481d958:	e583104c 	str	r1, [r3, #76]	; 0x4c
    WATCHDOG_RESET();
    Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
3481d95c:	e1a00002 	mov	r0, r2
3481d960:	e12fff1e 	bx	lr
int ZEXPORT inflateReset(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;

    if (strm == Z_NULL || strm->state == Z_NULL) return Z_STREAM_ERROR;
3481d964:	e3e00001 	mvn	r0, #1
    state->bits = 0;
    state->lencode = state->distcode = state->next = state->codes;
    WATCHDOG_RESET();
    Tracev((stderr, "inflate: reset\n"));
    return Z_OK;
}
3481d968:	e12fff1e 	bx	lr

3481d96c <inflateInit2_>:
const char *version;
int stream_size;
{
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
3481d96c:	e3520000 	cmp	r2, #0
int ZEXPORT inflateInit2_(strm, windowBits, version, stream_size)
z_streamp strm;
int windowBits;
const char *version;
int stream_size;
{
3481d970:	e92d4070 	push	{r4, r5, r6, lr}
3481d974:	e1a04000 	mov	r4, r0
3481d978:	e1a05001 	mov	r5, r1
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
3481d97c:	0a000033 	beq	3481da50 <inflateInit2_+0xe4>
3481d980:	e5d22000 	ldrb	r2, [r2]
3481d984:	e3520031 	cmp	r2, #49	; 0x31
3481d988:	0353003c 	cmpeq	r3, #60	; 0x3c
3481d98c:	03a03000 	moveq	r3, #0
3481d990:	13a03001 	movne	r3, #1
3481d994:	1a00002d 	bne	3481da50 <inflateInit2_+0xe4>
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
3481d998:	e3500000 	cmp	r0, #0
3481d99c:	0a00002d 	beq	3481da58 <inflateInit2_+0xec>
    strm->msg = Z_NULL;                 /* in case we return an error */
3481d9a0:	e5803018 	str	r3, [r0, #24]
    if (strm->zalloc == (alloc_func)0) {
3481d9a4:	e5903020 	ldr	r3, [r0, #32]
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
3481d9a8:	e3a01001 	mov	r1, #1
    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
3481d9ac:	e3530000 	cmp	r3, #0
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
3481d9b0:	05803028 	streq	r3, [r0, #40]	; 0x28
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
        strm->zalloc = zcalloc;
3481d9b4:	059f20ac 	ldreq	r2, [pc, #172]	; 3481da68 <inflateInit2_+0xfc>
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
3481d9b8:	e5903024 	ldr	r3, [r0, #36]	; 0x24
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
    if (strm == Z_NULL) return Z_STREAM_ERROR;
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
        strm->zalloc = zcalloc;
3481d9bc:	05802020 	streq	r2, [r0, #32]
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
3481d9c0:	e3530000 	cmp	r3, #0
3481d9c4:	059f30a0 	ldreq	r3, [pc, #160]	; 3481da6c <inflateInit2_+0x100>
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
3481d9c8:	e3022530 	movw	r2, #9520	; 0x2530
    strm->msg = Z_NULL;                 /* in case we return an error */
    if (strm->zalloc == (alloc_func)0) {
        strm->zalloc = zcalloc;
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
3481d9cc:	05803024 	streq	r3, [r0, #36]	; 0x24
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
3481d9d0:	e5903020 	ldr	r3, [r0, #32]
3481d9d4:	e5900028 	ldr	r0, [r0, #40]	; 0x28
3481d9d8:	e12fff33 	blx	r3
    if (state == Z_NULL) return Z_MEM_ERROR;
3481d9dc:	e2501000 	subs	r1, r0, #0
3481d9e0:	0a00001e 	beq	3481da60 <inflateInit2_+0xf4>
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
3481d9e4:	e3550000 	cmp	r5, #0
        state->wrap = 0;
3481d9e8:	b3a03000 	movlt	r3, #0
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
3481d9ec:	e584101c 	str	r1, [r4, #28]
    if (windowBits < 0) {
        state->wrap = 0;
        windowBits = -windowBits;
3481d9f0:	b2655000 	rsblt	r5, r5, #0
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
        state->wrap = 0;
3481d9f4:	b5813008 	strlt	r3, [r1, #8]
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
    Tracev((stderr, "inflate: allocated\n"));
    strm->state = (struct internal_state FAR *)state;
    if (windowBits < 0) {
3481d9f8:	ba000004 	blt	3481da10 <inflateInit2_+0xa4>
        state->wrap = 0;
        windowBits = -windowBits;
    }
    else {
        state->wrap = (windowBits >> 4) + 1;
3481d9fc:	e1a03245 	asr	r3, r5, #4
3481da00:	e2833001 	add	r3, r3, #1
#ifdef GUNZIP
        if (windowBits < 48) windowBits &= 15;
3481da04:	e355002f 	cmp	r5, #47	; 0x2f
    if (windowBits < 0) {
        state->wrap = 0;
        windowBits = -windowBits;
    }
    else {
        state->wrap = (windowBits >> 4) + 1;
3481da08:	e5813008 	str	r3, [r1, #8]
#ifdef GUNZIP
        if (windowBits < 48) windowBits &= 15;
3481da0c:	d205500f 	andle	r5, r5, #15
#endif
    }
    if (windowBits < 8 || windowBits > 15) {
3481da10:	e2453008 	sub	r3, r5, #8
3481da14:	e3530007 	cmp	r3, #7
3481da18:	9a000006 	bls	3481da38 <inflateInit2_+0xcc>
        ZFREE(strm, state);
3481da1c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481da20:	e5940028 	ldr	r0, [r4, #40]	; 0x28
3481da24:	e3a02000 	mov	r2, #0
3481da28:	e12fff33 	blx	r3
        strm->state = Z_NULL;
3481da2c:	e3a03000 	mov	r3, #0
3481da30:	e584301c 	str	r3, [r4, #28]
3481da34:	ea000007 	b	3481da58 <inflateInit2_+0xec>
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
3481da38:	e3a03000 	mov	r3, #0
    return inflateReset(strm);
3481da3c:	e1a00004 	mov	r0, r4
    if (windowBits < 8 || windowBits > 15) {
        ZFREE(strm, state);
        strm->state = Z_NULL;
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
3481da40:	e5815024 	str	r5, [r1, #36]	; 0x24
    state->window = Z_NULL;
3481da44:	e5813034 	str	r3, [r1, #52]	; 0x34
    return inflateReset(strm);
}
3481da48:	e8bd4070 	pop	{r4, r5, r6, lr}
        strm->state = Z_NULL;
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
    return inflateReset(strm);
3481da4c:	eaffffa6 	b	3481d8ec <inflateReset>
{
    struct inflate_state FAR *state;

    if (version == Z_NULL || version[0] != ZLIB_VERSION[0] ||
        stream_size != (int)(sizeof(z_stream)))
        return Z_VERSION_ERROR;
3481da50:	e3e00005 	mvn	r0, #5
3481da54:	e8bd8070 	pop	{r4, r5, r6, pc}
    if (strm == Z_NULL) return Z_STREAM_ERROR;
3481da58:	e3e00001 	mvn	r0, #1
3481da5c:	e8bd8070 	pop	{r4, r5, r6, pc}
        strm->opaque = (voidpf)0;
    }
    if (strm->zfree == (free_func)0) strm->zfree = zcfree;
    state = (struct inflate_state FAR *)
            ZALLOC(strm, 1, sizeof(struct inflate_state));
    if (state == Z_NULL) return Z_MEM_ERROR;
3481da60:	e3e00003 	mvn	r0, #3
        return Z_STREAM_ERROR;
    }
    state->wbits = (unsigned)windowBits;
    state->window = Z_NULL;
    return inflateReset(strm);
}
3481da64:	e8bd8070 	pop	{r4, r5, r6, pc}
3481da68:	3481ce04 	.word	0x3481ce04
3481da6c:	3481cdfc 	.word	0x3481cdfc

3481da70 <inflateInit_>:

int ZEXPORT inflateInit_(strm, version, stream_size)
z_streamp strm;
const char *version;
int stream_size;
{
3481da70:	e1a0c001 	mov	ip, r1
3481da74:	e1a03002 	mov	r3, r2
    return inflateInit2_(strm, DEF_WBITS, version, stream_size);
3481da78:	e3a0100f 	mov	r1, #15
3481da7c:	e1a0200c 	mov	r2, ip
3481da80:	eaffffb9 	b	3481d96c <inflateInit2_>

3481da84 <inflateEnd>:
    return ret;
}

int ZEXPORT inflateEnd(strm)
z_streamp strm;
{
3481da84:	e92d4010 	push	{r4, lr}
    struct inflate_state FAR *state;
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
3481da88:	e2504000 	subs	r4, r0, #0
3481da8c:	0a000013 	beq	3481dae0 <inflateEnd+0x5c>
3481da90:	e594201c 	ldr	r2, [r4, #28]
3481da94:	e3520000 	cmp	r2, #0
3481da98:	0a000010 	beq	3481dae0 <inflateEnd+0x5c>
3481da9c:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481daa0:	e3530000 	cmp	r3, #0
3481daa4:	0a00000f 	beq	3481dae8 <inflateEnd+0x64>
        return Z_STREAM_ERROR;
    state = (struct inflate_state FAR *)strm->state;
    if (state->window != Z_NULL) {
3481daa8:	e5921034 	ldr	r1, [r2, #52]	; 0x34
3481daac:	e3510000 	cmp	r1, #0
3481dab0:	0a000002 	beq	3481dac0 <inflateEnd+0x3c>
	WATCHDOG_RESET();
	ZFREE(strm, state->window);
3481dab4:	e5940028 	ldr	r0, [r4, #40]	; 0x28
3481dab8:	e3a02000 	mov	r2, #0
3481dabc:	e12fff33 	blx	r3
    }
    ZFREE(strm, strm->state);
3481dac0:	e5940028 	ldr	r0, [r4, #40]	; 0x28
3481dac4:	e5943024 	ldr	r3, [r4, #36]	; 0x24
3481dac8:	e594101c 	ldr	r1, [r4, #28]
3481dacc:	e3a02000 	mov	r2, #0
3481dad0:	e12fff33 	blx	r3
    strm->state = Z_NULL;
3481dad4:	e3a00000 	mov	r0, #0
3481dad8:	e584001c 	str	r0, [r4, #28]
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
3481dadc:	e8bd8010 	pop	{r4, pc}
int ZEXPORT inflateEnd(strm)
z_streamp strm;
{
    struct inflate_state FAR *state;
    if (strm == Z_NULL || strm->state == Z_NULL || strm->zfree == (free_func)0)
        return Z_STREAM_ERROR;
3481dae0:	e3e00001 	mvn	r0, #1
3481dae4:	e8bd8010 	pop	{r4, pc}
3481dae8:	e3e00001 	mvn	r0, #1
    }
    ZFREE(strm, strm->state);
    strm->state = Z_NULL;
    Tracev((stderr, "inflate: end\n"));
    return Z_OK;
}
3481daec:	e8bd8010 	pop	{r4, pc}

3481daf0 <adler32>:
    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
    adler &= 0xffff;

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
3481daf0:	e3520001 	cmp	r2, #1
/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
    uLong adler;
    const Bytef *buf;
    uInt len;
{
3481daf4:	e92d44f0 	push	{r4, r5, r6, r7, sl, lr}
3481daf8:	e1a04001 	mov	r4, r1
3481dafc:	e1a07002 	mov	r7, r2
    unsigned long sum2;
    unsigned n;

    /* split Adler-32 into component sums */
    sum2 = (adler >> 16) & 0xffff;
3481db00:	e1a06820 	lsr	r6, r0, #16
    adler &= 0xffff;
3481db04:	e6ff5070 	uxth	r5, r0

    /* in case user likes doing a byte at a time, keep it fast */
    if (len == 1) {
3481db08:	1a00000b 	bne	3481db3c <adler32+0x4c>
        adler += buf[0];
3481db0c:	e5d13000 	ldrb	r3, [r1]
3481db10:	e0835005 	add	r5, r3, r5
        if (adler >= BASE)
3481db14:	e30f3ff0 	movw	r3, #65520	; 0xfff0
3481db18:	e1550003 	cmp	r5, r3
            adler -= BASE;
3481db1c:	82455cff 	subhi	r5, r5, #65280	; 0xff00
3481db20:	824550f1 	subhi	r5, r5, #241	; 0xf1
        sum2 += adler;
3481db24:	e0856006 	add	r6, r5, r6
        if (sum2 >= BASE)
3481db28:	e30f3ff0 	movw	r3, #65520	; 0xfff0
3481db2c:	e1560003 	cmp	r6, r3
            sum2 -= BASE;
3481db30:	82466cff 	subhi	r6, r6, #65280	; 0xff00
3481db34:	824660f1 	subhi	r6, r6, #241	; 0xf1
3481db38:	ea0000a2 	b	3481ddc8 <adler32+0x2d8>
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
3481db3c:	e3510000 	cmp	r1, #0
3481db40:	0a0000a2 	beq	3481ddd0 <adler32+0x2e0>
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
3481db44:	e352000f 	cmp	r2, #15
3481db48:	9a000004 	bls	3481db60 <adler32+0x70>
3481db4c:	ea000050 	b	3481dc94 <adler32+0x1a4>
        while (len--) {
            adler += *buf++;
3481db50:	e4d43001 	ldrb	r3, [r4], #1
            sum2 += adler;
3481db54:	e2477001 	sub	r7, r7, #1
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
        while (len--) {
            adler += *buf++;
3481db58:	e0855003 	add	r5, r5, r3
            sum2 += adler;
3481db5c:	e0866005 	add	r6, r6, r5
    if (buf == Z_NULL)
        return 1L;

    /* in case short lengths are provided, keep it somewhat fast */
    if (len < 16) {
        while (len--) {
3481db60:	e3570000 	cmp	r7, #0
3481db64:	1afffff9 	bne	3481db50 <adler32+0x60>
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
3481db68:	e30f3ff0 	movw	r3, #65520	; 0xfff0
3481db6c:	e1550003 	cmp	r5, r3
            adler -= BASE;
3481db70:	82455cff 	subhi	r5, r5, #65280	; 0xff00
        MOD4(sum2);             /* only added so many BASE's */
3481db74:	e1a00006 	mov	r0, r6
3481db78:	e30f1ff1 	movw	r1, #65521	; 0xfff1
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        if (adler >= BASE)
            adler -= BASE;
3481db7c:	824550f1 	subhi	r5, r5, #241	; 0xf1
        MOD4(sum2);             /* only added so many BASE's */
3481db80:	eb000881 	bl	3481fd8c <__aeabi_uidivmod>
        return adler | (sum2 << 16);
3481db84:	e1850801 	orr	r0, r5, r1, lsl #16
3481db88:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
3481db8c:	e2477d56 	sub	r7, r7, #5504	; 0x1580
3481db90:	e2477030 	sub	r7, r7, #48	; 0x30
3481db94:	e1a03004 	mov	r3, r4
        n = NMAX / 16;          /* NMAX is divisible by 16 */
3481db98:	e300215b 	movw	r2, #347	; 0x15b
        do {
            DO16(buf);          /* 16 sums unrolled */
3481db9c:	e5d31000 	ldrb	r1, [r3]
            buf += 16;
        } while (--n);
3481dba0:	e2522001 	subs	r2, r2, #1
    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
3481dba4:	e0855001 	add	r5, r5, r1
3481dba8:	e5d31001 	ldrb	r1, [r3, #1]
3481dbac:	e0856006 	add	r6, r5, r6
3481dbb0:	e0855001 	add	r5, r5, r1
3481dbb4:	e5d31002 	ldrb	r1, [r3, #2]
3481dbb8:	e0866005 	add	r6, r6, r5
3481dbbc:	e0855001 	add	r5, r5, r1
3481dbc0:	e5d31003 	ldrb	r1, [r3, #3]
3481dbc4:	e0866005 	add	r6, r6, r5
3481dbc8:	e0855001 	add	r5, r5, r1
3481dbcc:	e5d31004 	ldrb	r1, [r3, #4]
3481dbd0:	e0866005 	add	r6, r6, r5
3481dbd4:	e0855001 	add	r5, r5, r1
3481dbd8:	e5d31005 	ldrb	r1, [r3, #5]
3481dbdc:	e0866005 	add	r6, r6, r5
3481dbe0:	e0855001 	add	r5, r5, r1
3481dbe4:	e5d31006 	ldrb	r1, [r3, #6]
3481dbe8:	e0866005 	add	r6, r6, r5
3481dbec:	e0855001 	add	r5, r5, r1
3481dbf0:	e5d31007 	ldrb	r1, [r3, #7]
3481dbf4:	e0866005 	add	r6, r6, r5
3481dbf8:	e0855001 	add	r5, r5, r1
3481dbfc:	e5d31008 	ldrb	r1, [r3, #8]
3481dc00:	e0866005 	add	r6, r6, r5
3481dc04:	e0855001 	add	r5, r5, r1
3481dc08:	e5d31009 	ldrb	r1, [r3, #9]
3481dc0c:	e0866005 	add	r6, r6, r5
3481dc10:	e0855001 	add	r5, r5, r1
3481dc14:	e5d3100a 	ldrb	r1, [r3, #10]
3481dc18:	e0866005 	add	r6, r6, r5
3481dc1c:	e0855001 	add	r5, r5, r1
3481dc20:	e5d3100b 	ldrb	r1, [r3, #11]
3481dc24:	e0866005 	add	r6, r6, r5
3481dc28:	e0855001 	add	r5, r5, r1
3481dc2c:	e5d3100c 	ldrb	r1, [r3, #12]
3481dc30:	e0866005 	add	r6, r6, r5
3481dc34:	e0855001 	add	r5, r5, r1
3481dc38:	e5d3100d 	ldrb	r1, [r3, #13]
3481dc3c:	e0866005 	add	r6, r6, r5
3481dc40:	e0855001 	add	r5, r5, r1
3481dc44:	e5d3100e 	ldrb	r1, [r3, #14]
3481dc48:	e0866005 	add	r6, r6, r5
3481dc4c:	e0855001 	add	r5, r5, r1
3481dc50:	e5d3100f 	ldrb	r1, [r3, #15]
3481dc54:	e0866005 	add	r6, r6, r5
3481dc58:	e0855001 	add	r5, r5, r1
3481dc5c:	e0866005 	add	r6, r6, r5
            buf += 16;
3481dc60:	e2833010 	add	r3, r3, #16
        } while (--n);
3481dc64:	1affffcc 	bne	3481db9c <adler32+0xac>
        MOD(adler);
3481dc68:	e1a00005 	mov	r0, r5
3481dc6c:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481dc70:	eb000845 	bl	3481fd8c <__aeabi_uidivmod>
        MOD(sum2);
3481dc74:	e1a00006 	mov	r0, r6
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
        MOD(adler);
3481dc78:	e1a05001 	mov	r5, r1
        MOD(sum2);
3481dc7c:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481dc80:	eb000841 	bl	3481fd8c <__aeabi_uidivmod>
        len -= NMAX;
        n = NMAX / 16;          /* NMAX is divisible by 16 */
        do {
            DO16(buf);          /* 16 sums unrolled */
            buf += 16;
        } while (--n);
3481dc84:	e2844d56 	add	r4, r4, #5504	; 0x1580
3481dc88:	e2844030 	add	r4, r4, #48	; 0x30
        MOD(adler);
        MOD(sum2);
3481dc8c:	e1a06001 	mov	r6, r1
3481dc90:	ea000000 	b	3481dc98 <adler32+0x1a8>
        MOD4(sum2);             /* only added so many BASE's */
        return adler | (sum2 << 16);
    }

    /* do length NMAX blocks -- requires just one modulo operation */
    while (len >= NMAX) {
3481dc94:	e301a5af 	movw	sl, #5551	; 0x15af
3481dc98:	e157000a 	cmp	r7, sl
3481dc9c:	8affffba 	bhi	3481db8c <adler32+0x9c>
        MOD(adler);
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
3481dca0:	e2573000 	subs	r3, r7, #0
3481dca4:	11a02004 	movne	r2, r4
3481dca8:	1a000031 	bne	3481dd74 <adler32+0x284>
3481dcac:	ea000045 	b	3481ddc8 <adler32+0x2d8>
        while (len >= 16) {
            len -= 16;
            DO16(buf);
3481dcb0:	e5521010 	ldrb	r1, [r2, #-16]
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
            len -= 16;
3481dcb4:	e2477010 	sub	r7, r7, #16
            DO16(buf);
3481dcb8:	e0855001 	add	r5, r5, r1
3481dcbc:	e552100f 	ldrb	r1, [r2, #-15]
3481dcc0:	e0856006 	add	r6, r5, r6
3481dcc4:	e0855001 	add	r5, r5, r1
3481dcc8:	e552100e 	ldrb	r1, [r2, #-14]
3481dccc:	e0866005 	add	r6, r6, r5
3481dcd0:	e0855001 	add	r5, r5, r1
3481dcd4:	e552100d 	ldrb	r1, [r2, #-13]
3481dcd8:	e0866005 	add	r6, r6, r5
3481dcdc:	e0855001 	add	r5, r5, r1
3481dce0:	e552100c 	ldrb	r1, [r2, #-12]
3481dce4:	e0866005 	add	r6, r6, r5
3481dce8:	e0855001 	add	r5, r5, r1
3481dcec:	e552100b 	ldrb	r1, [r2, #-11]
3481dcf0:	e0866005 	add	r6, r6, r5
3481dcf4:	e0855001 	add	r5, r5, r1
3481dcf8:	e552100a 	ldrb	r1, [r2, #-10]
3481dcfc:	e0866005 	add	r6, r6, r5
3481dd00:	e0855001 	add	r5, r5, r1
3481dd04:	e5521009 	ldrb	r1, [r2, #-9]
3481dd08:	e0866005 	add	r6, r6, r5
3481dd0c:	e0855001 	add	r5, r5, r1
3481dd10:	e5521008 	ldrb	r1, [r2, #-8]
3481dd14:	e0866005 	add	r6, r6, r5
3481dd18:	e0855001 	add	r5, r5, r1
3481dd1c:	e5521007 	ldrb	r1, [r2, #-7]
3481dd20:	e0866005 	add	r6, r6, r5
3481dd24:	e0855001 	add	r5, r5, r1
3481dd28:	e5521006 	ldrb	r1, [r2, #-6]
3481dd2c:	e0866005 	add	r6, r6, r5
3481dd30:	e0855001 	add	r5, r5, r1
3481dd34:	e5521005 	ldrb	r1, [r2, #-5]
3481dd38:	e0866005 	add	r6, r6, r5
3481dd3c:	e0855001 	add	r5, r5, r1
3481dd40:	e5521004 	ldrb	r1, [r2, #-4]
3481dd44:	e0866005 	add	r6, r6, r5
3481dd48:	e0855001 	add	r5, r5, r1
3481dd4c:	e5521003 	ldrb	r1, [r2, #-3]
3481dd50:	e0866005 	add	r6, r6, r5
3481dd54:	e0855001 	add	r5, r5, r1
3481dd58:	e5521002 	ldrb	r1, [r2, #-2]
3481dd5c:	e0866005 	add	r6, r6, r5
3481dd60:	e0855001 	add	r5, r5, r1
3481dd64:	e5521001 	ldrb	r1, [r2, #-1]
3481dd68:	e0866005 	add	r6, r6, r5
3481dd6c:	e0855001 	add	r5, r5, r1
3481dd70:	e0866005 	add	r6, r6, r5
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
3481dd74:	e357000f 	cmp	r7, #15
            len -= 16;
            DO16(buf);
3481dd78:	e2822010 	add	r2, r2, #16
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
3481dd7c:	8affffcb 	bhi	3481dcb0 <adler32+0x1c0>
#  define MOD(a) a %= BASE
#  define MOD4(a) a %= BASE
#endif

/* ========================================================================= */
uLong ZEXPORT adler32(adler, buf, len)
3481dd80:	e3c3200f 	bic	r2, r3, #15
        MOD(sum2);
    }

    /* do remaining bytes (less than NMAX, still just one modulo) */
    if (len) {                  /* avoid modulos if none remaining */
        while (len >= 16) {
3481dd84:	e0844002 	add	r4, r4, r2
3481dd88:	e203300f 	and	r3, r3, #15
3481dd8c:	ea000003 	b	3481dda0 <adler32+0x2b0>
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
            adler += *buf++;
3481dd90:	e4d42001 	ldrb	r2, [r4], #1
            sum2 += adler;
3481dd94:	e2433001 	sub	r3, r3, #1
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
            adler += *buf++;
3481dd98:	e0855002 	add	r5, r5, r2
            sum2 += adler;
3481dd9c:	e0866005 	add	r6, r6, r5
        while (len >= 16) {
            len -= 16;
            DO16(buf);
            buf += 16;
        }
        while (len--) {
3481dda0:	e3530000 	cmp	r3, #0
3481dda4:	1afffff9 	bne	3481dd90 <adler32+0x2a0>
            adler += *buf++;
            sum2 += adler;
        }
        MOD(adler);
3481dda8:	e1a00005 	mov	r0, r5
3481ddac:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481ddb0:	eb0007f5 	bl	3481fd8c <__aeabi_uidivmod>
        MOD(sum2);
3481ddb4:	e1a00006 	mov	r0, r6
        }
        while (len--) {
            adler += *buf++;
            sum2 += adler;
        }
        MOD(adler);
3481ddb8:	e1a05001 	mov	r5, r1
        MOD(sum2);
3481ddbc:	e30f1ff1 	movw	r1, #65521	; 0xfff1
3481ddc0:	eb0007f1 	bl	3481fd8c <__aeabi_uidivmod>
3481ddc4:	e1a06001 	mov	r6, r1
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
3481ddc8:	e1850806 	orr	r0, r5, r6, lsl #16
3481ddcc:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}
        return adler | (sum2 << 16);
    }

    /* initial Adler-32 value (deferred check for len == 1 speed) */
    if (buf == Z_NULL)
        return 1L;
3481ddd0:	e3a00001 	mov	r0, #1
        MOD(sum2);
    }

    /* return recombined sums */
    return adler | (sum2 << 16);
}
3481ddd4:	e8bd84f0 	pop	{r4, r5, r6, r7, sl, pc}

3481ddd8 <inflate>:
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */
int ZEXPORT inflate(strm, flush)
z_streamp strm;
int flush;
{
3481ddd8:	e92d4ef0 	push	{r4, r5, r6, r7, r9, sl, fp, lr}
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
3481dddc:	e250a000 	subs	sl, r0, #0
   will return Z_BUF_ERROR if it has not reached the end of the stream.
 */
int ZEXPORT inflate(strm, flush)
z_streamp strm;
int flush;
{
3481dde0:	e24dd048 	sub	sp, sp, #72	; 0x48
3481dde4:	e58d103c 	str	r1, [sp, #60]	; 0x3c
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;
3481dde8:	03e01001 	mvneq	r1, #1
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
3481ddec:	0a00058b 	beq	3481f420 <inflate+0x1648>
3481ddf0:	e59a401c 	ldr	r4, [sl, #28]
3481ddf4:	e3540000 	cmp	r4, #0
3481ddf8:	0a00058a 	beq	3481f428 <inflate+0x1650>
        (strm->next_in == Z_NULL && strm->avail_in != 0))
3481ddfc:	e59a9000 	ldr	r9, [sl]
    unsigned char hbuf[4];      /* buffer for gzip header crc calculation */
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
3481de00:	e3590000 	cmp	r9, #0
3481de04:	1a000003 	bne	3481de18 <inflate+0x40>
        (strm->next_in == Z_NULL && strm->avail_in != 0))
3481de08:	e59a3004 	ldr	r3, [sl, #4]
3481de0c:	e3530000 	cmp	r3, #0
        return Z_STREAM_ERROR;
3481de10:	13e03001 	mvnne	r3, #1
#endif
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
3481de14:	1a000586 	bne	3481f434 <inflate+0x165c>
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481de18:	e5943000 	ldr	r3, [r4]
    LOAD();
3481de1c:	e59a1004 	ldr	r1, [sl, #4]
    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481de20:	e353000b 	cmp	r3, #11
    LOAD();
3481de24:	e59a000c 	ldr	r0, [sl, #12]
3481de28:	e59ab010 	ldr	fp, [sl, #16]
    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481de2c:	02833001 	addeq	r3, r3, #1
    LOAD();
    in = have;
    out = left;
    ret = Z_OK;
3481de30:	e3a02000 	mov	r2, #0
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
    LOAD();
3481de34:	e5946038 	ldr	r6, [r4, #56]	; 0x38
3481de38:	e594503c 	ldr	r5, [r4, #60]	; 0x3c
    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
3481de3c:	05843000 	streq	r3, [r4]
    LOAD();
3481de40:	e58d0020 	str	r0, [sp, #32]
3481de44:	e58d1038 	str	r1, [sp, #56]	; 0x38
    in = have;
    out = left;
3481de48:	e58db02c 	str	fp, [sp, #44]	; 0x2c
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;

    state = (struct inflate_state FAR *)strm->state;
    if (state->mode == TYPE) state->mode = TYPEDO;      /* skip check */
    LOAD();
3481de4c:	e1a07001 	mov	r7, r1
    in = have;
    out = left;
    ret = Z_OK;
3481de50:	e58d201c 	str	r2, [sp, #28]
    for (;;)
        switch (state->mode) {
3481de54:	e5943000 	ldr	r3, [r4]
3481de58:	e353001c 	cmp	r3, #28
3481de5c:	979ff103 	ldrls	pc, [pc, r3, lsl #2]
3481de60:	ea000575 	b	3481f43c <inflate+0x1664>
3481de64:	3481def8 	.word	0x3481def8
3481de68:	3481def0 	.word	0x3481def0
3481de6c:	3481e0d4 	.word	0x3481e0d4
3481de70:	3481e158 	.word	0x3481e158
3481de74:	3481e1d8 	.word	0x3481e1d8
3481de78:	3481e270 	.word	0x3481e270
3481de7c:	3481e334 	.word	0x3481e334
3481de80:	3481e3f0 	.word	0x3481e3f0
3481de84:	3481e4a4 	.word	0x3481e4a4
3481de88:	3481dee8 	.word	0x3481dee8
3481de8c:	3481e580 	.word	0x3481e580
3481de90:	3481e5d0 	.word	0x3481e5d0
3481de94:	3481e5dc 	.word	0x3481e5dc
3481de98:	3481e694 	.word	0x3481e694
3481de9c:	3481e6fc 	.word	0x3481e6fc
3481dea0:	3481dee0 	.word	0x3481dee0
3481dea4:	3481e7e0 	.word	0x3481e7e0
3481dea8:	3481e8d4 	.word	0x3481e8d4
3481deac:	3481eb7c 	.word	0x3481eb7c
3481deb0:	3481ed1c 	.word	0x3481ed1c
3481deb4:	3481ed80 	.word	0x3481ed80
3481deb8:	3481eea8 	.word	0x3481eea8
3481debc:	3481ef7c 	.word	0x3481ef7c
3481dec0:	3481f024 	.word	0x3481f024
3481dec4:	3481f048 	.word	0x3481f048
3481dec8:	3481f144 	.word	0x3481f144
3481decc:	3481f1d0 	.word	0x3481f1d0
3481ded0:	3481f1c4 	.word	0x3481f1c4
3481ded4:	3481ded8 	.word	0x3481ded8
            goto inf_leave;
        case BAD:
            ret = Z_DATA_ERROR;
            goto inf_leave;
        case MEM:
            return Z_MEM_ERROR;
3481ded8:	e3e03003 	mvn	r3, #3
3481dedc:	ea000554 	b	3481f434 <inflate+0x165c>
    LOAD();
    in = have;
    out = left;
    ret = Z_OK;
    for (;;)
        switch (state->mode) {
3481dee0:	e1a03009 	mov	r3, r9
3481dee4:	ea000223 	b	3481e778 <inflate+0x9a0>
3481dee8:	e1a03009 	mov	r3, r9
3481deec:	ea000193 	b	3481e540 <inflate+0x768>
3481def0:	e1a03009 	mov	r3, r9
3481def4:	ea000058 	b	3481e05c <inflate+0x284>
        case HEAD:
            if (state->wrap == 0) {
3481def8:	e5943008 	ldr	r3, [r4, #8]
3481defc:	e3530000 	cmp	r3, #0
3481df00:	11a02009 	movne	r2, r9
                state->mode = TYPEDO;
3481df04:	03a0300c 	moveq	r3, #12
    out = left;
    ret = Z_OK;
    for (;;)
        switch (state->mode) {
        case HEAD:
            if (state->wrap == 0) {
3481df08:	1a000006 	bne	3481df28 <inflate+0x150>
3481df0c:	ea0004a3 	b	3481f1a0 <inflate+0x13c8>
                state->mode = TYPEDO;
                break;
            }
            NEEDBITS(16);
3481df10:	e3570000 	cmp	r7, #0
3481df14:	0a0004af 	beq	3481f1d8 <inflate+0x1400>
3481df18:	e4d21001 	ldrb	r1, [r2], #1
3481df1c:	e2477001 	sub	r7, r7, #1
3481df20:	e0866511 	add	r6, r6, r1, lsl r5
3481df24:	e2855008 	add	r5, r5, #8
3481df28:	e355000f 	cmp	r5, #15
3481df2c:	e1a09002 	mov	r9, r2
3481df30:	9afffff6 	bls	3481df10 <inflate+0x138>
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
3481df34:	e7e020d3 	ubfx	r2, r3, #1, #1
3481df38:	e3081b1f 	movw	r1, #35615	; 0x8b1f
3481df3c:	e1560001 	cmp	r6, r1
3481df40:	13a02000 	movne	r2, #0
3481df44:	02022001 	andeq	r2, r2, #1
3481df48:	e3520000 	cmp	r2, #0
3481df4c:	0a000010 	beq	3481df94 <inflate+0x1bc>
                state->check = crc32(0L, Z_NULL, 0);
3481df50:	e3a00000 	mov	r0, #0
3481df54:	e1a01000 	mov	r1, r0
3481df58:	e1a02000 	mov	r2, r0
3481df5c:	ebfff07a 	bl	3481a14c <crc32>
                CRC2(state->check, hold);
3481df60:	e3a0301f 	mov	r3, #31
3481df64:	e5cd3044 	strb	r3, [sp, #68]	; 0x44
                break;
            }
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
3481df68:	e5840018 	str	r0, [r4, #24]
                CRC2(state->check, hold);
3481df6c:	e3e03074 	mvn	r3, #116	; 0x74
3481df70:	e28d1044 	add	r1, sp, #68	; 0x44
3481df74:	e3a02002 	mov	r2, #2
3481df78:	e5cd3045 	strb	r3, [sp, #69]	; 0x45
3481df7c:	ebfff072 	bl	3481a14c <crc32>
                INITBITS();
                state->mode = FLAGS;
3481df80:	e3a0c001 	mov	ip, #1
            }
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
                CRC2(state->check, hold);
3481df84:	e5840018 	str	r0, [r4, #24]
                INITBITS();
                state->mode = FLAGS;
3481df88:	e584c000 	str	ip, [r4]
            NEEDBITS(16);
#ifdef GUNZIP
            if ((state->wrap & 2) && hold == 0x8b1f) {  /* gzip header */
                state->check = crc32(0L, Z_NULL, 0);
                CRC2(state->check, hold);
                INITBITS();
3481df8c:	e3a05000 	mov	r5, #0
3481df90:	ea000029 	b	3481e03c <inflate+0x264>
                state->mode = FLAGS;
                break;
            }
            state->flags = 0;           /* expect zlib header */
3481df94:	e5842010 	str	r2, [r4, #16]
            if (state->head != Z_NULL)
3481df98:	e5942020 	ldr	r2, [r4, #32]
3481df9c:	e3520000 	cmp	r2, #0
                state->head->done = -1;
3481dfa0:	13e01000 	mvnne	r1, #0
3481dfa4:	15821030 	strne	r1, [r2, #48]	; 0x30
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
3481dfa8:	e3130001 	tst	r3, #1
3481dfac:	0a000006 	beq	3481dfcc <inflate+0x1f4>
#else
            if (
#endif
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
3481dfb0:	e1a03426 	lsr	r3, r6, #8
3481dfb4:	e1a00c06 	lsl	r0, r6, #24
3481dfb8:	e0830820 	add	r0, r3, r0, lsr #16
3481dfbc:	e3a0101f 	mov	r1, #31
3481dfc0:	eb000771 	bl	3481fd8c <__aeabi_uidivmod>
                break;
            }
            state->flags = 0;           /* expect zlib header */
            if (state->head != Z_NULL)
                state->head->done = -1;
            if (!(state->wrap & 1) ||   /* check if zlib header allowed */
3481dfc4:	e2513000 	subs	r3, r1, #0
3481dfc8:	0a000001 	beq	3481dfd4 <inflate+0x1fc>
#else
            if (
#endif
                ((BITS(8) << 8) + (hold >> 8)) % 31) {
                strm->msg = (char *)"incorrect header check";
3481dfcc:	e59f3ee8 	ldr	r3, [pc, #3816]	; 3481eebc <inflate+0x10e4>
3481dfd0:	ea000470 	b	3481f198 <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
            if (BITS(4) != Z_DEFLATED) {
3481dfd4:	e206200f 	and	r2, r6, #15
3481dfd8:	e3520008 	cmp	r2, #8
3481dfdc:	1a000025 	bne	3481e078 <inflate+0x2a0>
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
3481dfe0:	e1a06226 	lsr	r6, r6, #4
            len = BITS(4) + 8;
3481dfe4:	e206000f 	and	r0, r6, #15
            if (len > state->wbits) {
3481dfe8:	e5942024 	ldr	r2, [r4, #36]	; 0x24
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
            len = BITS(4) + 8;
3481dfec:	e2800008 	add	r0, r0, #8
            if (len > state->wbits) {
3481dff0:	e1500002 	cmp	r0, r2
            if (BITS(4) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            DROPBITS(4);
3481dff4:	82455004 	subhi	r5, r5, #4
            len = BITS(4) + 8;
            if (len > state->wbits) {
                strm->msg = (char *)"invalid window size";
3481dff8:	859f3ec0 	ldrhi	r3, [pc, #3776]	; 3481eec0 <inflate+0x10e8>
3481dffc:	8a000465 	bhi	3481f198 <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
3481e000:	e3a02001 	mov	r2, #1
3481e004:	e1a00012 	lsl	r0, r2, r0
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481e008:	e1a02003 	mov	r2, r3
            if (len > state->wbits) {
                strm->msg = (char *)"invalid window size";
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
3481e00c:	e5840014 	str	r0, [r4, #20]
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481e010:	e1a00003 	mov	r0, r3
3481e014:	e58d3014 	str	r3, [sp, #20]
3481e018:	ebfffeb4 	bl	3481daf0 <adler32>
            state->mode = hold & 0x200 ? DICTID : TYPE;
3481e01c:	e3160c02 	tst	r6, #512	; 0x200
            INITBITS();
3481e020:	e59d3014 	ldr	r3, [sp, #20]
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
            state->mode = hold & 0x200 ? DICTID : TYPE;
3481e024:	03a0200b 	moveq	r2, #11
3481e028:	13a02009 	movne	r2, #9
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481e02c:	e5840018 	str	r0, [r4, #24]
            state->mode = hold & 0x200 ? DICTID : TYPE;
            INITBITS();
3481e030:	e1a05003 	mov	r5, r3
                state->mode = BAD;
                break;
            }
            state->dmax = 1U << len;
            Tracev((stderr, "inflate:   zlib header ok\n"));
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481e034:	e58a0034 	str	r0, [sl, #52]	; 0x34
            state->mode = hold & 0x200 ? DICTID : TYPE;
3481e038:	e5842000 	str	r2, [r4]
            INITBITS();
3481e03c:	e1a06005 	mov	r6, r5
            break;
3481e040:	eaffff83 	b	3481de54 <inflate+0x7c>
#ifdef GUNZIP
        case FLAGS:
            NEEDBITS(16);
3481e044:	e3570000 	cmp	r7, #0
3481e048:	0a000462 	beq	3481f1d8 <inflate+0x1400>
3481e04c:	e4d32001 	ldrb	r2, [r3], #1
3481e050:	e2477001 	sub	r7, r7, #1
3481e054:	e0866512 	add	r6, r6, r2, lsl r5
3481e058:	e2855008 	add	r5, r5, #8
3481e05c:	e355000f 	cmp	r5, #15
3481e060:	e1a09003 	mov	r9, r3
3481e064:	9afffff6 	bls	3481e044 <inflate+0x26c>
            state->flags = (int)(hold);
            if ((state->flags & 0xff) != Z_DEFLATED) {
3481e068:	e20630ff 	and	r3, r6, #255	; 0xff
3481e06c:	e3530008 	cmp	r3, #8
            INITBITS();
            break;
#ifdef GUNZIP
        case FLAGS:
            NEEDBITS(16);
            state->flags = (int)(hold);
3481e070:	e5846010 	str	r6, [r4, #16]
            if ((state->flags & 0xff) != Z_DEFLATED) {
3481e074:	0a000001 	beq	3481e080 <inflate+0x2a8>
                strm->msg = (char *)"unknown compression method";
3481e078:	e59f3e44 	ldr	r3, [pc, #3652]	; 3481eec4 <inflate+0x10ec>
3481e07c:	ea000445 	b	3481f198 <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
            if (state->flags & 0xe000) {
3481e080:	e3160a0e 	tst	r6, #57344	; 0xe000
                strm->msg = (char *)"unknown header flags set";
3481e084:	159f3e3c 	ldrne	r3, [pc, #3644]	; 3481eec8 <inflate+0x10f0>
            if ((state->flags & 0xff) != Z_DEFLATED) {
                strm->msg = (char *)"unknown compression method";
                state->mode = BAD;
                break;
            }
            if (state->flags & 0xe000) {
3481e088:	1a000442 	bne	3481f198 <inflate+0x13c0>
                strm->msg = (char *)"unknown header flags set";
                state->mode = BAD;
                break;
            }
            if (state->head != Z_NULL)
3481e08c:	e5943020 	ldr	r3, [r4, #32]
3481e090:	e3530000 	cmp	r3, #0
                state->head->text = (int)((hold >> 8) & 1);
3481e094:	17e02456 	ubfxne	r2, r6, #8, #1
3481e098:	15832000 	strne	r2, [r3]
            if (state->flags & 0x0200) CRC2(state->check, hold);
3481e09c:	e3160c02 	tst	r6, #512	; 0x200
3481e0a0:	0a000007 	beq	3481e0c4 <inflate+0x2ec>
3481e0a4:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481e0a8:	e1a06426 	lsr	r6, r6, #8
3481e0ac:	e5cd6045 	strb	r6, [sp, #69]	; 0x45
3481e0b0:	e5940018 	ldr	r0, [r4, #24]
3481e0b4:	e28d1044 	add	r1, sp, #68	; 0x44
3481e0b8:	e3a02002 	mov	r2, #2
3481e0bc:	ebfff022 	bl	3481a14c <crc32>
3481e0c0:	e5840018 	str	r0, [r4, #24]
            INITBITS();
            state->mode = TIME;
3481e0c4:	e3a03002 	mov	r3, #2
                break;
            }
            if (state->head != Z_NULL)
                state->head->text = (int)((hold >> 8) & 1);
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481e0c8:	e3a05000 	mov	r5, #0
            state->mode = TIME;
3481e0cc:	e5843000 	str	r3, [r4]
                break;
            }
            if (state->head != Z_NULL)
                state->head->text = (int)((hold >> 8) & 1);
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481e0d0:	e1a06005 	mov	r6, r5
            state->mode = TIME;
3481e0d4:	e1a03009 	mov	r3, r9
3481e0d8:	ea000005 	b	3481e0f4 <inflate+0x31c>
        case TIME:
            NEEDBITS(32);
3481e0dc:	e3570000 	cmp	r7, #0
3481e0e0:	0a00043c 	beq	3481f1d8 <inflate+0x1400>
3481e0e4:	e4d32001 	ldrb	r2, [r3], #1
3481e0e8:	e2477001 	sub	r7, r7, #1
3481e0ec:	e0866512 	add	r6, r6, r2, lsl r5
3481e0f0:	e2855008 	add	r5, r5, #8
3481e0f4:	e355001f 	cmp	r5, #31
3481e0f8:	e1a09003 	mov	r9, r3
3481e0fc:	9afffff6 	bls	3481e0dc <inflate+0x304>
            if (state->head != Z_NULL)
3481e100:	e5943020 	ldr	r3, [r4, #32]
3481e104:	e3530000 	cmp	r3, #0
                state->head->time = hold;
3481e108:	15836004 	strne	r6, [r3, #4]
            if (state->flags & 0x0200) CRC4(state->check, hold);
3481e10c:	e5943010 	ldr	r3, [r4, #16]
3481e110:	e3130c02 	tst	r3, #512	; 0x200
3481e114:	0a00000b 	beq	3481e148 <inflate+0x370>
3481e118:	e1a03426 	lsr	r3, r6, #8
3481e11c:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481e120:	e5cd3045 	strb	r3, [sp, #69]	; 0x45
3481e124:	e1a03826 	lsr	r3, r6, #16
3481e128:	e1a06c26 	lsr	r6, r6, #24
3481e12c:	e5cd3046 	strb	r3, [sp, #70]	; 0x46
3481e130:	e5cd6047 	strb	r6, [sp, #71]	; 0x47
3481e134:	e5940018 	ldr	r0, [r4, #24]
3481e138:	e28d1044 	add	r1, sp, #68	; 0x44
3481e13c:	e3a02004 	mov	r2, #4
3481e140:	ebfff001 	bl	3481a14c <crc32>
3481e144:	e5840018 	str	r0, [r4, #24]
            INITBITS();
            state->mode = OS;
3481e148:	e3a03003 	mov	r3, #3
        case TIME:
            NEEDBITS(32);
            if (state->head != Z_NULL)
                state->head->time = hold;
            if (state->flags & 0x0200) CRC4(state->check, hold);
            INITBITS();
3481e14c:	e3a05000 	mov	r5, #0
            state->mode = OS;
3481e150:	e5843000 	str	r3, [r4]
        case TIME:
            NEEDBITS(32);
            if (state->head != Z_NULL)
                state->head->time = hold;
            if (state->flags & 0x0200) CRC4(state->check, hold);
            INITBITS();
3481e154:	e1a06005 	mov	r6, r5
            state->mode = OS;
3481e158:	e1a03009 	mov	r3, r9
3481e15c:	ea000005 	b	3481e178 <inflate+0x3a0>
        case OS:
            NEEDBITS(16);
3481e160:	e3570000 	cmp	r7, #0
3481e164:	0a00041b 	beq	3481f1d8 <inflate+0x1400>
3481e168:	e4d32001 	ldrb	r2, [r3], #1
3481e16c:	e2477001 	sub	r7, r7, #1
3481e170:	e0866512 	add	r6, r6, r2, lsl r5
3481e174:	e2855008 	add	r5, r5, #8
3481e178:	e355000f 	cmp	r5, #15
3481e17c:	e1a09003 	mov	r9, r3
3481e180:	9afffff6 	bls	3481e160 <inflate+0x388>
            if (state->head != Z_NULL) {
3481e184:	e5943020 	ldr	r3, [r4, #32]
3481e188:	e3530000 	cmp	r3, #0
                state->head->xflags = (int)(hold & 0xff);
3481e18c:	120620ff 	andne	r2, r6, #255	; 0xff
3481e190:	15832008 	strne	r2, [r3, #8]
                state->head->os = (int)(hold >> 8);
3481e194:	11a02426 	lsrne	r2, r6, #8
3481e198:	1583200c 	strne	r2, [r3, #12]
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
3481e19c:	e5943010 	ldr	r3, [r4, #16]
3481e1a0:	e3130c02 	tst	r3, #512	; 0x200
3481e1a4:	0a000007 	beq	3481e1c8 <inflate+0x3f0>
3481e1a8:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481e1ac:	e1a06426 	lsr	r6, r6, #8
3481e1b0:	e5cd6045 	strb	r6, [sp, #69]	; 0x45
3481e1b4:	e5940018 	ldr	r0, [r4, #24]
3481e1b8:	e28d1044 	add	r1, sp, #68	; 0x44
3481e1bc:	e3a02002 	mov	r2, #2
3481e1c0:	ebffefe1 	bl	3481a14c <crc32>
3481e1c4:	e5840018 	str	r0, [r4, #24]
            INITBITS();
            state->mode = EXLEN;
3481e1c8:	e3a03004 	mov	r3, #4
            if (state->head != Z_NULL) {
                state->head->xflags = (int)(hold & 0xff);
                state->head->os = (int)(hold >> 8);
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481e1cc:	e3a05000 	mov	r5, #0
            state->mode = EXLEN;
3481e1d0:	e5843000 	str	r3, [r4]
            if (state->head != Z_NULL) {
                state->head->xflags = (int)(hold & 0xff);
                state->head->os = (int)(hold >> 8);
            }
            if (state->flags & 0x0200) CRC2(state->check, hold);
            INITBITS();
3481e1d4:	e1a06005 	mov	r6, r5
            state->mode = EXLEN;
        case EXLEN:
            if (state->flags & 0x0400) {
3481e1d8:	e5943010 	ldr	r3, [r4, #16]
3481e1dc:	e2132b01 	ands	r2, r3, #1024	; 0x400
3481e1e0:	11a02009 	movne	r2, r9
3481e1e4:	1a000006 	bne	3481e204 <inflate+0x42c>
3481e1e8:	ea000019 	b	3481e254 <inflate+0x47c>
                NEEDBITS(16);
3481e1ec:	e3570000 	cmp	r7, #0
3481e1f0:	0a0003f8 	beq	3481f1d8 <inflate+0x1400>
3481e1f4:	e4d21001 	ldrb	r1, [r2], #1
3481e1f8:	e2477001 	sub	r7, r7, #1
3481e1fc:	e0866511 	add	r6, r6, r1, lsl r5
3481e200:	e2855008 	add	r5, r5, #8
3481e204:	e355000f 	cmp	r5, #15
3481e208:	e1a09002 	mov	r9, r2
3481e20c:	9afffff6 	bls	3481e1ec <inflate+0x414>
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
3481e210:	e5942020 	ldr	r2, [r4, #32]
            INITBITS();
            state->mode = EXLEN;
        case EXLEN:
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
3481e214:	e5846040 	str	r6, [r4, #64]	; 0x40
                if (state->head != Z_NULL)
3481e218:	e3520000 	cmp	r2, #0
                    state->head->extra_len = (unsigned)hold;
3481e21c:	15826014 	strne	r6, [r2, #20]
                if (state->flags & 0x0200) CRC2(state->check, hold);
3481e220:	e2133c02 	ands	r3, r3, #512	; 0x200
                INITBITS();
3481e224:	01a06003 	moveq	r6, r3
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
3481e228:	0a00000d 	beq	3481e264 <inflate+0x48c>
3481e22c:	e5cd6044 	strb	r6, [sp, #68]	; 0x44
3481e230:	e1a06426 	lsr	r6, r6, #8
3481e234:	e5cd6045 	strb	r6, [sp, #69]	; 0x45
3481e238:	e5940018 	ldr	r0, [r4, #24]
3481e23c:	e28d1044 	add	r1, sp, #68	; 0x44
3481e240:	e3a02002 	mov	r2, #2
3481e244:	ebffefc0 	bl	3481a14c <crc32>
                INITBITS();
3481e248:	e3a06000 	mov	r6, #0
            if (state->flags & 0x0400) {
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
3481e24c:	e5840018 	str	r0, [r4, #24]
3481e250:	ea000003 	b	3481e264 <inflate+0x48c>
                INITBITS();
            }
            else if (state->head != Z_NULL)
3481e254:	e5943020 	ldr	r3, [r4, #32]
3481e258:	e3530000 	cmp	r3, #0
                state->head->extra = Z_NULL;
3481e25c:	15832010 	strne	r2, [r3, #16]
3481e260:	ea000000 	b	3481e268 <inflate+0x490>
                NEEDBITS(16);
                state->length = (unsigned)(hold);
                if (state->head != Z_NULL)
                    state->head->extra_len = (unsigned)hold;
                if (state->flags & 0x0200) CRC2(state->check, hold);
                INITBITS();
3481e264:	e1a05006 	mov	r5, r6
            }
            else if (state->head != Z_NULL)
                state->head->extra = Z_NULL;
            state->mode = EXTRA;
3481e268:	e3a03005 	mov	r3, #5
3481e26c:	e5843000 	str	r3, [r4]
        case EXTRA:
            if (state->flags & 0x0400) {
3481e270:	e5943010 	ldr	r3, [r4, #16]
3481e274:	e3130b01 	tst	r3, #1024	; 0x400
3481e278:	0a000029 	beq	3481e324 <inflate+0x54c>
                copy = state->length;
3481e27c:	e5942040 	ldr	r2, [r4, #64]	; 0x40
3481e280:	e1570002 	cmp	r7, r2
3481e284:	31a03007 	movcc	r3, r7
3481e288:	21a03002 	movcs	r3, r2
                if (copy > have) copy = have;
                if (copy) {
3481e28c:	e3530000 	cmp	r3, #0
3481e290:	0a000020 	beq	3481e318 <inflate+0x540>
                    if (state->head != Z_NULL &&
3481e294:	e5941020 	ldr	r1, [r4, #32]
3481e298:	e3510000 	cmp	r1, #0
3481e29c:	0a00000e 	beq	3481e2dc <inflate+0x504>
                        state->head->extra != Z_NULL) {
3481e2a0:	e5910010 	ldr	r0, [r1, #16]
        case EXTRA:
            if (state->flags & 0x0400) {
                copy = state->length;
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
3481e2a4:	e3500000 	cmp	r0, #0
3481e2a8:	0a00000b 	beq	3481e2dc <inflate+0x504>
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
3481e2ac:	e591c014 	ldr	ip, [r1, #20]
                        zmemcpy(state->head->extra + len, next,
                                len + copy > state->head->extra_max ?
3481e2b0:	e5911018 	ldr	r1, [r1, #24]
                copy = state->length;
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
3481e2b4:	e062200c 	rsb	r2, r2, ip
                        zmemcpy(state->head->extra + len, next,
                                len + copy > state->head->extra_max ?
3481e2b8:	e083c002 	add	ip, r3, r2
                if (copy > have) copy = have;
                if (copy) {
                    if (state->head != Z_NULL &&
                        state->head->extra != Z_NULL) {
                        len = state->head->extra_len - state->length;
                        zmemcpy(state->head->extra + len, next,
3481e2bc:	e15c0001 	cmp	ip, r1
3481e2c0:	e0800002 	add	r0, r0, r2
3481e2c4:	80622001 	rsbhi	r2, r2, r1
3481e2c8:	91a02003 	movls	r2, r3
3481e2cc:	e1a01009 	mov	r1, r9
3481e2d0:	e58d3014 	str	r3, [sp, #20]
3481e2d4:	ebfff71e 	bl	3481bf54 <memcpy>
3481e2d8:	e59d3014 	ldr	r3, [sp, #20]
                                len + copy > state->head->extra_max ?
                                state->head->extra_max - len : copy);
                    }
                    if (state->flags & 0x0200)
3481e2dc:	e5942010 	ldr	r2, [r4, #16]
3481e2e0:	e3120c02 	tst	r2, #512	; 0x200
3481e2e4:	0a000006 	beq	3481e304 <inflate+0x52c>
                        state->check = crc32(state->check, next, copy);
3481e2e8:	e5940018 	ldr	r0, [r4, #24]
3481e2ec:	e1a02003 	mov	r2, r3
3481e2f0:	e1a01009 	mov	r1, r9
3481e2f4:	e58d3014 	str	r3, [sp, #20]
3481e2f8:	ebffef93 	bl	3481a14c <crc32>
3481e2fc:	e59d3014 	ldr	r3, [sp, #20]
3481e300:	e5840018 	str	r0, [r4, #24]
                    have -= copy;
                    next += copy;
                    state->length -= copy;
3481e304:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                                len + copy > state->head->extra_max ?
                                state->head->extra_max - len : copy);
                    }
                    if (state->flags & 0x0200)
                        state->check = crc32(state->check, next, copy);
                    have -= copy;
3481e308:	e0637007 	rsb	r7, r3, r7
                    next += copy;
3481e30c:	e0899003 	add	r9, r9, r3
                    state->length -= copy;
3481e310:	e0633002 	rsb	r3, r3, r2
3481e314:	e5843040 	str	r3, [r4, #64]	; 0x40
                }
                if (state->length) goto inf_leave;
3481e318:	e5943040 	ldr	r3, [r4, #64]	; 0x40
3481e31c:	e3530000 	cmp	r3, #0
3481e320:	1a0003ac 	bne	3481f1d8 <inflate+0x1400>
            }
            state->length = 0;
3481e324:	e3a03000 	mov	r3, #0
3481e328:	e5843040 	str	r3, [r4, #64]	; 0x40
            state->mode = NAME;
3481e32c:	e2833006 	add	r3, r3, #6
3481e330:	e5843000 	str	r3, [r4]
        case NAME:
            if (state->flags & 0x0800) {
3481e334:	e5942010 	ldr	r2, [r4, #16]
3481e338:	e2122b02 	ands	r2, r2, #2048	; 0x800
3481e33c:	0a000024 	beq	3481e3d4 <inflate+0x5fc>
                if (have == 0) goto inf_leave;
3481e340:	e3570000 	cmp	r7, #0
3481e344:	0a0003a3 	beq	3481f1d8 <inflate+0x1400>
3481e348:	e3a03000 	mov	r3, #0
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481e34c:	e5941020 	ldr	r1, [r4, #32]
        case NAME:
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481e350:	e7d9c003 	ldrb	ip, [r9, r3]
                    if (state->head != Z_NULL &&
3481e354:	e3510000 	cmp	r1, #0
        case NAME:
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481e358:	e2833001 	add	r3, r3, #1
                    if (state->head != Z_NULL &&
3481e35c:	0a000008 	beq	3481e384 <inflate+0x5ac>
                            state->head->name != Z_NULL &&
3481e360:	e591001c 	ldr	r0, [r1, #28]
            if (state->flags & 0x0800) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481e364:	e3500000 	cmp	r0, #0
3481e368:	0a000005 	beq	3481e384 <inflate+0x5ac>
                            state->head->name != Z_NULL &&
                            state->length < state->head->name_max)
3481e36c:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->name != Z_NULL &&
3481e370:	e5911020 	ldr	r1, [r1, #32]
3481e374:	e1520001 	cmp	r2, r1
                            state->length < state->head->name_max)
                        state->head->name[state->length++] = len;
3481e378:	37c0c002 	strbcc	ip, [r0, r2]
3481e37c:	32822001 	addcc	r2, r2, #1
3481e380:	35842040 	strcc	r2, [r4, #64]	; 0x40
                } while (len && copy < have);
3481e384:	e35c0000 	cmp	ip, #0
3481e388:	11530007 	cmpne	r3, r7
3481e38c:	3affffee 	bcc	3481e34c <inflate+0x574>
                if (state->flags & 0x0200)
3481e390:	e5942010 	ldr	r2, [r4, #16]
3481e394:	e3120c02 	tst	r2, #512	; 0x200
3481e398:	0a000008 	beq	3481e3c0 <inflate+0x5e8>
                    state->check = crc32(state->check, next, copy);
3481e39c:	e5940018 	ldr	r0, [r4, #24]
3481e3a0:	e1a02003 	mov	r2, r3
3481e3a4:	e1a01009 	mov	r1, r9
3481e3a8:	e58d3014 	str	r3, [sp, #20]
3481e3ac:	e58dc018 	str	ip, [sp, #24]
3481e3b0:	ebffef65 	bl	3481a14c <crc32>
3481e3b4:	e59dc018 	ldr	ip, [sp, #24]
3481e3b8:	e59d3014 	ldr	r3, [sp, #20]
3481e3bc:	e5840018 	str	r0, [r4, #24]
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
3481e3c0:	e35c0000 	cmp	ip, #0
                            state->length < state->head->name_max)
                        state->head->name[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
3481e3c4:	e0637007 	rsb	r7, r3, r7
                next += copy;
3481e3c8:	e0899003 	add	r9, r9, r3
                if (len) goto inf_leave;
3481e3cc:	0a000003 	beq	3481e3e0 <inflate+0x608>
3481e3d0:	ea000380 	b	3481f1d8 <inflate+0x1400>
            }
            else if (state->head != Z_NULL)
3481e3d4:	e5943020 	ldr	r3, [r4, #32]
3481e3d8:	e3530000 	cmp	r3, #0
                state->head->name = Z_NULL;
3481e3dc:	1583201c 	strne	r2, [r3, #28]
            state->length = 0;
3481e3e0:	e3a0c000 	mov	ip, #0
            state->mode = COMMENT;
3481e3e4:	e3a03007 	mov	r3, #7
                next += copy;
                if (len) goto inf_leave;
            }
            else if (state->head != Z_NULL)
                state->head->name = Z_NULL;
            state->length = 0;
3481e3e8:	e584c040 	str	ip, [r4, #64]	; 0x40
            state->mode = COMMENT;
3481e3ec:	e5843000 	str	r3, [r4]
        case COMMENT:
            if (state->flags & 0x1000) {
3481e3f0:	e5942010 	ldr	r2, [r4, #16]
3481e3f4:	e2122a01 	ands	r2, r2, #4096	; 0x1000
3481e3f8:	0a000024 	beq	3481e490 <inflate+0x6b8>
                if (have == 0) goto inf_leave;
3481e3fc:	e3570000 	cmp	r7, #0
3481e400:	0a000374 	beq	3481f1d8 <inflate+0x1400>
3481e404:	e3a03000 	mov	r3, #0
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481e408:	e5941020 	ldr	r1, [r4, #32]
        case COMMENT:
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481e40c:	e7d9c003 	ldrb	ip, [r9, r3]
                    if (state->head != Z_NULL &&
3481e410:	e3510000 	cmp	r1, #0
        case COMMENT:
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
3481e414:	e2833001 	add	r3, r3, #1
                    if (state->head != Z_NULL &&
3481e418:	0a000008 	beq	3481e440 <inflate+0x668>
                            state->head->comment != Z_NULL &&
3481e41c:	e5910024 	ldr	r0, [r1, #36]	; 0x24
            if (state->flags & 0x1000) {
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
3481e420:	e3500000 	cmp	r0, #0
3481e424:	0a000005 	beq	3481e440 <inflate+0x668>
                            state->head->comment != Z_NULL &&
                            state->length < state->head->comm_max)
3481e428:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                if (have == 0) goto inf_leave;
                copy = 0;
                do {
                    len = (unsigned)(next[copy++]);
                    if (state->head != Z_NULL &&
                            state->head->comment != Z_NULL &&
3481e42c:	e5911028 	ldr	r1, [r1, #40]	; 0x28
3481e430:	e1520001 	cmp	r2, r1
                            state->length < state->head->comm_max)
                        state->head->comment[state->length++] = len;
3481e434:	37c0c002 	strbcc	ip, [r0, r2]
3481e438:	32822001 	addcc	r2, r2, #1
3481e43c:	35842040 	strcc	r2, [r4, #64]	; 0x40
                } while (len && copy < have);
3481e440:	e35c0000 	cmp	ip, #0
3481e444:	11530007 	cmpne	r3, r7
3481e448:	3affffee 	bcc	3481e408 <inflate+0x630>
                if (state->flags & 0x0200)
3481e44c:	e5942010 	ldr	r2, [r4, #16]
3481e450:	e3120c02 	tst	r2, #512	; 0x200
3481e454:	0a000008 	beq	3481e47c <inflate+0x6a4>
                    state->check = crc32(state->check, next, copy);
3481e458:	e5940018 	ldr	r0, [r4, #24]
3481e45c:	e1a02003 	mov	r2, r3
3481e460:	e1a01009 	mov	r1, r9
3481e464:	e58d3014 	str	r3, [sp, #20]
3481e468:	e58dc018 	str	ip, [sp, #24]
3481e46c:	ebffef36 	bl	3481a14c <crc32>
3481e470:	e59dc018 	ldr	ip, [sp, #24]
3481e474:	e59d3014 	ldr	r3, [sp, #20]
3481e478:	e5840018 	str	r0, [r4, #24]
                have -= copy;
                next += copy;
                if (len) goto inf_leave;
3481e47c:	e35c0000 	cmp	ip, #0
                            state->length < state->head->comm_max)
                        state->head->comment[state->length++] = len;
                } while (len && copy < have);
                if (state->flags & 0x0200)
                    state->check = crc32(state->check, next, copy);
                have -= copy;
3481e480:	e0637007 	rsb	r7, r3, r7
                next += copy;
3481e484:	e0899003 	add	r9, r9, r3
                if (len) goto inf_leave;
3481e488:	0a000003 	beq	3481e49c <inflate+0x6c4>
3481e48c:	ea000351 	b	3481f1d8 <inflate+0x1400>
            }
            else if (state->head != Z_NULL)
3481e490:	e5943020 	ldr	r3, [r4, #32]
3481e494:	e3530000 	cmp	r3, #0
                state->head->comment = Z_NULL;
3481e498:	15832024 	strne	r2, [r3, #36]	; 0x24
            state->mode = HCRC;
3481e49c:	e3a03008 	mov	r3, #8
3481e4a0:	e5843000 	str	r3, [r4]
        case HCRC:
            if (state->flags & 0x0200) {
3481e4a4:	e5942010 	ldr	r2, [r4, #16]
3481e4a8:	e3120c02 	tst	r2, #512	; 0x200
3481e4ac:	11a03009 	movne	r3, r9
3481e4b0:	1a000006 	bne	3481e4d0 <inflate+0x6f8>
3481e4b4:	ea00000e 	b	3481e4f4 <inflate+0x71c>
                NEEDBITS(16);
3481e4b8:	e3570000 	cmp	r7, #0
3481e4bc:	0a000345 	beq	3481f1d8 <inflate+0x1400>
3481e4c0:	e4d31001 	ldrb	r1, [r3], #1
3481e4c4:	e2477001 	sub	r7, r7, #1
3481e4c8:	e0866511 	add	r6, r6, r1, lsl r5
3481e4cc:	e2855008 	add	r5, r5, #8
3481e4d0:	e355000f 	cmp	r5, #15
3481e4d4:	e1a09003 	mov	r9, r3
3481e4d8:	9afffff6 	bls	3481e4b8 <inflate+0x6e0>
                if (hold != (state->check & 0xffff)) {
3481e4dc:	e1d431b8 	ldrh	r3, [r4, #24]
3481e4e0:	e1560003 	cmp	r6, r3
                    strm->msg = (char *)"header crc mismatch";
3481e4e4:	159f39e0 	ldrne	r3, [pc, #2528]	; 3481eecc <inflate+0x10f4>
                state->head->comment = Z_NULL;
            state->mode = HCRC;
        case HCRC:
            if (state->flags & 0x0200) {
                NEEDBITS(16);
                if (hold != (state->check & 0xffff)) {
3481e4e8:	1a00032a 	bne	3481f198 <inflate+0x13c0>
                    strm->msg = (char *)"header crc mismatch";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
3481e4ec:	e3a05000 	mov	r5, #0
3481e4f0:	e1a06005 	mov	r6, r5
            }
            if (state->head != Z_NULL) {
3481e4f4:	e5943020 	ldr	r3, [r4, #32]
3481e4f8:	e3530000 	cmp	r3, #0
                state->head->hcrc = (int)((state->flags >> 9) & 1);
                state->head->done = 1;
3481e4fc:	13a00001 	movne	r0, #1
                    break;
                }
                INITBITS();
            }
            if (state->head != Z_NULL) {
                state->head->hcrc = (int)((state->flags >> 9) & 1);
3481e500:	17e024d2 	ubfxne	r2, r2, #9, #1
                state->head->done = 1;
3481e504:	15830030 	strne	r0, [r3, #48]	; 0x30
            }
            strm->adler = state->check = crc32(0L, Z_NULL, 0);
3481e508:	e3a00000 	mov	r0, #0
                    break;
                }
                INITBITS();
            }
            if (state->head != Z_NULL) {
                state->head->hcrc = (int)((state->flags >> 9) & 1);
3481e50c:	1583202c 	strne	r2, [r3, #44]	; 0x2c
                state->head->done = 1;
            }
            strm->adler = state->check = crc32(0L, Z_NULL, 0);
3481e510:	e1a01000 	mov	r1, r0
3481e514:	e1a02000 	mov	r2, r0
3481e518:	ebffef0b 	bl	3481a14c <crc32>
3481e51c:	e5840018 	str	r0, [r4, #24]
3481e520:	e58a0034 	str	r0, [sl, #52]	; 0x34
3481e524:	ea0001f3 	b	3481ecf8 <inflate+0xf20>
            state->mode = TYPE;
            break;
#endif
        case DICTID:
            NEEDBITS(32);
3481e528:	e3570000 	cmp	r7, #0
3481e52c:	0a000329 	beq	3481f1d8 <inflate+0x1400>
3481e530:	e4d32001 	ldrb	r2, [r3], #1
3481e534:	e2477001 	sub	r7, r7, #1
3481e538:	e0866512 	add	r6, r6, r2, lsl r5
3481e53c:	e2855008 	add	r5, r5, #8
3481e540:	e355001f 	cmp	r5, #31
3481e544:	e1a09003 	mov	r9, r3
3481e548:	9afffff6 	bls	3481e528 <inflate+0x750>
            strm->adler = state->check = REVERSE(hold);
3481e54c:	e1a02c26 	lsr	r2, r6, #24
3481e550:	e1a03426 	lsr	r3, r6, #8
3481e554:	e0822c06 	add	r2, r2, r6, lsl #24
3481e558:	e2033cff 	and	r3, r3, #65280	; 0xff00
3481e55c:	e2066cff 	and	r6, r6, #65280	; 0xff00
3481e560:	e0823003 	add	r3, r2, r3
3481e564:	e0833406 	add	r3, r3, r6, lsl #8
3481e568:	e5843018 	str	r3, [r4, #24]
            INITBITS();
3481e56c:	e3a06000 	mov	r6, #0
            state->mode = TYPE;
            break;
#endif
        case DICTID:
            NEEDBITS(32);
            strm->adler = state->check = REVERSE(hold);
3481e570:	e58a3034 	str	r3, [sl, #52]	; 0x34
            INITBITS();
            state->mode = DICT;
3481e574:	e3a0300a 	mov	r3, #10
3481e578:	e5843000 	str	r3, [r4]
            break;
#endif
        case DICTID:
            NEEDBITS(32);
            strm->adler = state->check = REVERSE(hold);
            INITBITS();
3481e57c:	e1a05006 	mov	r5, r6
            state->mode = DICT;
        case DICT:
            if (state->havedict == 0) {
3481e580:	e594300c 	ldr	r3, [r4, #12]
3481e584:	e3530000 	cmp	r3, #0
3481e588:	1a000008 	bne	3481e5b0 <inflate+0x7d8>
                RESTORE();
3481e58c:	e59d1020 	ldr	r1, [sp, #32]
3481e590:	e58ab010 	str	fp, [sl, #16]
3481e594:	e58a100c 	str	r1, [sl, #12]
3481e598:	e58a9000 	str	r9, [sl]
3481e59c:	e58a7004 	str	r7, [sl, #4]
                return Z_NEED_DICT;
3481e5a0:	e3a02002 	mov	r2, #2
            strm->adler = state->check = REVERSE(hold);
            INITBITS();
            state->mode = DICT;
        case DICT:
            if (state->havedict == 0) {
                RESTORE();
3481e5a4:	e5846038 	str	r6, [r4, #56]	; 0x38
3481e5a8:	e584503c 	str	r5, [r4, #60]	; 0x3c
3481e5ac:	ea00039e 	b	3481f42c <inflate+0x1654>
                return Z_NEED_DICT;
            }
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481e5b0:	e3a00000 	mov	r0, #0
3481e5b4:	e1a01000 	mov	r1, r0
3481e5b8:	e1a02000 	mov	r2, r0
3481e5bc:	ebfffd4b 	bl	3481daf0 <adler32>
            state->mode = TYPE;
3481e5c0:	e3a0300b 	mov	r3, #11
        case DICT:
            if (state->havedict == 0) {
                RESTORE();
                return Z_NEED_DICT;
            }
            strm->adler = state->check = adler32(0L, Z_NULL, 0);
3481e5c4:	e5840018 	str	r0, [r4, #24]
3481e5c8:	e58a0034 	str	r0, [sl, #52]	; 0x34
            state->mode = TYPE;
3481e5cc:	e5843000 	str	r3, [r4]
        case TYPE:
	    WATCHDOG_RESET();
            if (flush == Z_BLOCK) goto inf_leave;
3481e5d0:	e59d303c 	ldr	r3, [sp, #60]	; 0x3c
3481e5d4:	e3530005 	cmp	r3, #5
3481e5d8:	0a0002fe 	beq	3481f1d8 <inflate+0x1400>
        case TYPEDO:
            if (state->last) {
3481e5dc:	e5943004 	ldr	r3, [r4, #4]
3481e5e0:	e3530000 	cmp	r3, #0
3481e5e4:	01a03009 	moveq	r3, r9
3481e5e8:	0a00000a 	beq	3481e618 <inflate+0x840>
                BYTEBITS();
3481e5ec:	e2053007 	and	r3, r5, #7
3481e5f0:	e1a06336 	lsr	r6, r6, r3
3481e5f4:	e3c55007 	bic	r5, r5, #7
                state->mode = CHECK;
3481e5f8:	e3a03018 	mov	r3, #24
3481e5fc:	ea0002e7 	b	3481f1a0 <inflate+0x13c8>
                break;
            }
            NEEDBITS(3);
3481e600:	e3570000 	cmp	r7, #0
3481e604:	0a0002f3 	beq	3481f1d8 <inflate+0x1400>
3481e608:	e4d32001 	ldrb	r2, [r3], #1
3481e60c:	e2477001 	sub	r7, r7, #1
3481e610:	e0866512 	add	r6, r6, r2, lsl r5
3481e614:	e2855008 	add	r5, r5, #8
3481e618:	e3550002 	cmp	r5, #2
3481e61c:	e1a09003 	mov	r9, r3
3481e620:	9afffff6 	bls	3481e600 <inflate+0x828>
            state->last = BITS(1);
3481e624:	e2063001 	and	r3, r6, #1
            DROPBITS(1);
3481e628:	e1a060a6 	lsr	r6, r6, #1
                BYTEBITS();
                state->mode = CHECK;
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
3481e62c:	e5843004 	str	r3, [r4, #4]
            DROPBITS(1);
            switch (BITS(2)) {
3481e630:	e2063003 	and	r3, r6, #3
3481e634:	e3530002 	cmp	r3, #2
                state->mode = LEN;              /* decode codes */
                break;
            case 2:                             /* dynamic block */
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
3481e638:	03a0300f 	moveq	r3, #15
                break;
            }
            NEEDBITS(3);
            state->last = BITS(1);
            DROPBITS(1);
            switch (BITS(2)) {
3481e63c:	0a000010 	beq	3481e684 <inflate+0x8ac>
3481e640:	e3530003 	cmp	r3, #3
3481e644:	0a00000b 	beq	3481e678 <inflate+0x8a0>
3481e648:	e3530001 	cmp	r3, #1

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
    state->lenbits = 9;
3481e64c:	03a03009 	moveq	r3, #9
}

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
3481e650:	059fc878 	ldreq	ip, [pc, #2168]	; 3481eed0 <inflate+0x10f8>
    state->lenbits = 9;
    state->distcode = distfix;
3481e654:	059f0878 	ldreq	r0, [pc, #2168]	; 3481eed4 <inflate+0x10fc>

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
    state->lenbits = 9;
3481e658:	05843054 	streq	r3, [r4, #84]	; 0x54
    state->distcode = distfix;
    state->distbits = 5;
3481e65c:	03a03005 	moveq	r3, #5
3481e660:	05843058 	streq	r3, [r4, #88]	; 0x58
            DROPBITS(1);
            switch (BITS(2)) {
            case 0:                             /* stored block */
                Tracev((stderr, "inflate:     stored block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = STORED;
3481e664:	13a0300d 	movne	r3, #13
}

local void fixedtables(state)
struct inflate_state FAR *state;
{
    state->lencode = lenfix;
3481e668:	0584c04c 	streq	ip, [r4, #76]	; 0x4c
    state->lenbits = 9;
    state->distcode = distfix;
3481e66c:	05840050 	streq	r0, [r4, #80]	; 0x50
                break;
            case 1:                             /* fixed block */
                fixedtables(state);
                Tracev((stderr, "inflate:     fixed codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = LEN;              /* decode codes */
3481e670:	0283300d 	addeq	r3, r3, #13
3481e674:	ea000002 	b	3481e684 <inflate+0x8ac>
                Tracev((stderr, "inflate:     dynamic codes block%s\n",
                        state->last ? " (last)" : ""));
                state->mode = TABLE;
                break;
            case 3:
                strm->msg = (char *)"invalid block type";
3481e678:	e59f3858 	ldr	r3, [pc, #2136]	; 3481eed8 <inflate+0x1100>
3481e67c:	e58a3018 	str	r3, [sl, #24]
                state->mode = BAD;
3481e680:	e3a0301b 	mov	r3, #27
3481e684:	e5843000 	str	r3, [r4]
            }
            DROPBITS(2);
3481e688:	e1a06126 	lsr	r6, r6, #2
3481e68c:	e2455003 	sub	r5, r5, #3
            break;
3481e690:	eafffdef 	b	3481de54 <inflate+0x7c>
        case STORED:
            BYTEBITS();                         /* go to byte boundary */
3481e694:	e2053007 	and	r3, r5, #7
3481e698:	e1a06336 	lsr	r6, r6, r3
3481e69c:	e3c55007 	bic	r5, r5, #7
3481e6a0:	e1a03009 	mov	r3, r9
            NEEDBITS(32);
3481e6a4:	ea000005 	b	3481e6c0 <inflate+0x8e8>
3481e6a8:	e3570000 	cmp	r7, #0
3481e6ac:	0a0002c9 	beq	3481f1d8 <inflate+0x1400>
3481e6b0:	e4d32001 	ldrb	r2, [r3], #1
3481e6b4:	e2477001 	sub	r7, r7, #1
3481e6b8:	e0866512 	add	r6, r6, r2, lsl r5
3481e6bc:	e2855008 	add	r5, r5, #8
3481e6c0:	e355001f 	cmp	r5, #31
3481e6c4:	e1a09003 	mov	r9, r3
3481e6c8:	9afffff6 	bls	3481e6a8 <inflate+0x8d0>
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
3481e6cc:	e1a02826 	lsr	r2, r6, #16
3481e6d0:	e2222cff 	eor	r2, r2, #65280	; 0xff00
3481e6d4:	e6ff3076 	uxth	r3, r6
3481e6d8:	e22220ff 	eor	r2, r2, #255	; 0xff
3481e6dc:	e1530002 	cmp	r3, r2
                strm->msg = (char *)"invalid stored block lengths";
3481e6e0:	159f37f4 	ldrne	r3, [pc, #2036]	; 3481eedc <inflate+0x1104>
            DROPBITS(2);
            break;
        case STORED:
            BYTEBITS();                         /* go to byte boundary */
            NEEDBITS(32);
            if ((hold & 0xffff) != ((hold >> 16) ^ 0xffff)) {
3481e6e4:	1a0002ab 	bne	3481f198 <inflate+0x13c0>
                strm->msg = (char *)"invalid stored block lengths";
                state->mode = BAD;
                break;
            }
            state->length = (unsigned)hold & 0xffff;
3481e6e8:	e5843040 	str	r3, [r4, #64]	; 0x40
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();
3481e6ec:	e3a05000 	mov	r5, #0
            state->mode = COPY;
3481e6f0:	e3a0300e 	mov	r3, #14
3481e6f4:	e5843000 	str	r3, [r4]
                break;
            }
            state->length = (unsigned)hold & 0xffff;
            Tracev((stderr, "inflate:       stored length %u\n",
                    state->length));
            INITBITS();
3481e6f8:	e1a06005 	mov	r6, r5
            state->mode = COPY;
        case COPY:
            copy = state->length;
3481e6fc:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            if (copy) {
3481e700:	e3530000 	cmp	r3, #0
3481e704:	0a00017b 	beq	3481ecf8 <inflate+0xf20>
3481e708:	e15b0003 	cmp	fp, r3
3481e70c:	31a0300b 	movcc	r3, fp
3481e710:	e1530007 	cmp	r3, r7
3481e714:	21a03007 	movcs	r3, r7
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                if (copy == 0) goto inf_leave;
3481e718:	e3530000 	cmp	r3, #0
3481e71c:	0a0002ad 	beq	3481f1d8 <inflate+0x1400>
                zmemcpy(put, next, copy);
3481e720:	e1a01009 	mov	r1, r9
3481e724:	e1a02003 	mov	r2, r3
3481e728:	e59d0020 	ldr	r0, [sp, #32]
3481e72c:	e58d3014 	str	r3, [sp, #20]
3481e730:	ebfff607 	bl	3481bf54 <memcpy>
                have -= copy;
3481e734:	e59d3014 	ldr	r3, [sp, #20]
                next += copy;
                left -= copy;
                put += copy;
3481e738:	e59d1020 	ldr	r1, [sp, #32]
                state->length -= copy;
3481e73c:	e5942040 	ldr	r2, [r4, #64]	; 0x40
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
3481e740:	e0811003 	add	r1, r1, r3
            if (copy) {
                if (copy > have) copy = have;
                if (copy > left) copy = left;
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
3481e744:	e0637007 	rsb	r7, r3, r7
                next += copy;
3481e748:	e0899003 	add	r9, r9, r3
                left -= copy;
3481e74c:	e063b00b 	rsb	fp, r3, fp
                put += copy;
                state->length -= copy;
3481e750:	e0633002 	rsb	r3, r3, r2
                if (copy == 0) goto inf_leave;
                zmemcpy(put, next, copy);
                have -= copy;
                next += copy;
                left -= copy;
                put += copy;
3481e754:	e58d1020 	str	r1, [sp, #32]
                state->length -= copy;
3481e758:	e5843040 	str	r3, [r4, #64]	; 0x40
                break;
3481e75c:	eafffdbc 	b	3481de54 <inflate+0x7c>
            }
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
3481e760:	e3570000 	cmp	r7, #0
3481e764:	0a00029b 	beq	3481f1d8 <inflate+0x1400>
3481e768:	e4d32001 	ldrb	r2, [r3], #1
3481e76c:	e2477001 	sub	r7, r7, #1
3481e770:	e0866512 	add	r6, r6, r2, lsl r5
3481e774:	e2855008 	add	r5, r5, #8
3481e778:	e355000d 	cmp	r5, #13
3481e77c:	e1a09003 	mov	r9, r3
3481e780:	9afffff6 	bls	3481e760 <inflate+0x988>
            state->nlen = BITS(5) + 257;
3481e784:	e206201f 	and	r2, r6, #31
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
3481e788:	e7e31556 	ubfx	r1, r6, #10, #4
3481e78c:	e2811004 	add	r1, r1, #4
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
3481e790:	e2822c01 	add	r2, r2, #256	; 0x100
3481e794:	e2822001 	add	r2, r2, #1
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
3481e798:	e7e432d6 	ubfx	r3, r6, #5, #5
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
3481e79c:	e584105c 	str	r1, [r4, #92]	; 0x5c
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
3481e7a0:	e300111e 	movw	r1, #286	; 0x11e
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
3481e7a4:	e2833001 	add	r3, r3, #1
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
3481e7a8:	e1520001 	cmp	r2, r1
            Tracev((stderr, "inflate:       stored end\n"));
            state->mode = TYPE;
            break;
        case TABLE:
            NEEDBITS(14);
            state->nlen = BITS(5) + 257;
3481e7ac:	e5842060 	str	r2, [r4, #96]	; 0x60
            DROPBITS(5);
            state->ndist = BITS(5) + 1;
3481e7b0:	e5843064 	str	r3, [r4, #100]	; 0x64
            DROPBITS(5);
            state->ncode = BITS(4) + 4;
            DROPBITS(4);
3481e7b4:	e1a06726 	lsr	r6, r6, #14
3481e7b8:	e245500e 	sub	r5, r5, #14
#ifndef PKZIP_BUG_WORKAROUND
            if (state->nlen > 286 || state->ndist > 30) {
3481e7bc:	8a000001 	bhi	3481e7c8 <inflate+0x9f0>
3481e7c0:	e353001e 	cmp	r3, #30
3481e7c4:	9a000001 	bls	3481e7d0 <inflate+0x9f8>
                strm->msg = (char *)"too many length or distance symbols";
3481e7c8:	e59f3710 	ldr	r3, [pc, #1808]	; 3481eee0 <inflate+0x1108>
3481e7cc:	ea000271 	b	3481f198 <inflate+0x13c0>
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
3481e7d0:	e3a02000 	mov	r2, #0
            state->mode = LENLENS;
3481e7d4:	e3a03010 	mov	r3, #16
                state->mode = BAD;
                break;
            }
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
3481e7d8:	e5842068 	str	r2, [r4, #104]	; 0x68
            state->mode = LENLENS;
3481e7dc:	e5843000 	str	r3, [r4]
        case LENLENS:
            while (state->have < state->ncode) {
3481e7e0:	e594205c 	ldr	r2, [r4, #92]	; 0x5c
3481e7e4:	ea000013 	b	3481e838 <inflate+0xa60>
                NEEDBITS(3);
3481e7e8:	e3570000 	cmp	r7, #0
3481e7ec:	0a000279 	beq	3481f1d8 <inflate+0x1400>
3481e7f0:	e4d10001 	ldrb	r0, [r1], #1
3481e7f4:	e2477001 	sub	r7, r7, #1
3481e7f8:	e0866510 	add	r6, r6, r0, lsl r5
3481e7fc:	e2855008 	add	r5, r5, #8
3481e800:	e3550002 	cmp	r5, #2
3481e804:	e1a09001 	mov	r9, r1
3481e808:	9afffff6 	bls	3481e7e8 <inflate+0xa10>
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
3481e80c:	e59fc6d0 	ldr	ip, [pc, #1744]	; 3481eee4 <inflate+0x110c>
3481e810:	e2060007 	and	r0, r6, #7
3481e814:	e08c1083 	add	r1, ip, r3, lsl #1
3481e818:	e2811d26 	add	r1, r1, #2432	; 0x980
3481e81c:	e1d110b0 	ldrh	r1, [r1]
3481e820:	e2833001 	add	r3, r3, #1
3481e824:	e0841081 	add	r1, r4, r1, lsl #1
3481e828:	e1c107b0 	strh	r0, [r1, #112]	; 0x70
3481e82c:	e5843068 	str	r3, [r4, #104]	; 0x68
                DROPBITS(3);
3481e830:	e1a061a6 	lsr	r6, r6, #3
3481e834:	e2455003 	sub	r5, r5, #3
#endif
            Tracev((stderr, "inflate:       table sizes ok\n"));
            state->have = 0;
            state->mode = LENLENS;
        case LENLENS:
            while (state->have < state->ncode) {
3481e838:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481e83c:	e1530002 	cmp	r3, r2
3481e840:	2a00000a 	bcs	3481e870 <inflate+0xa98>
3481e844:	e1a01009 	mov	r1, r9
3481e848:	eaffffec 	b	3481e800 <inflate+0xa28>
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
                state->lens[order[state->have++]] = 0;
3481e84c:	e59f0690 	ldr	r0, [pc, #1680]	; 3481eee4 <inflate+0x110c>
3481e850:	e3a01000 	mov	r1, #0
3481e854:	e0802083 	add	r2, r0, r3, lsl #1
3481e858:	e2822d26 	add	r2, r2, #2432	; 0x980
3481e85c:	e1d220b0 	ldrh	r2, [r2]
3481e860:	e2833001 	add	r3, r3, #1
3481e864:	e0842082 	add	r2, r4, r2, lsl #1
3481e868:	e1c217b0 	strh	r1, [r2, #112]	; 0x70
3481e86c:	e5843068 	str	r3, [r4, #104]	; 0x68
            while (state->have < state->ncode) {
                NEEDBITS(3);
                state->lens[order[state->have++]] = (unsigned short)BITS(3);
                DROPBITS(3);
            }
            while (state->have < 19)
3481e870:	e5943068 	ldr	r3, [r4, #104]	; 0x68
3481e874:	e3530012 	cmp	r3, #18
3481e878:	9afffff3 	bls	3481e84c <inflate+0xa74>
                state->lens[order[state->have++]] = 0;
            state->next = state->codes;
3481e87c:	e2843e53 	add	r3, r4, #1328	; 0x530
3481e880:	e584306c 	str	r3, [r4, #108]	; 0x6c
            state->lencode = (code const FAR *)(state->next);
3481e884:	e584304c 	str	r3, [r4, #76]	; 0x4c
            state->lenbits = 7;
3481e888:	e3a03007 	mov	r3, #7
3481e88c:	e5843054 	str	r3, [r4, #84]	; 0x54
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
3481e890:	e2843054 	add	r3, r4, #84	; 0x54
3481e894:	e58d3000 	str	r3, [sp]
3481e898:	e2843e2f 	add	r3, r4, #752	; 0x2f0
3481e89c:	e58d3004 	str	r3, [sp, #4]
3481e8a0:	e3a00000 	mov	r0, #0
3481e8a4:	e284306c 	add	r3, r4, #108	; 0x6c
3481e8a8:	e2841070 	add	r1, r4, #112	; 0x70
3481e8ac:	e3a02013 	mov	r2, #19
3481e8b0:	ebfffab2 	bl	3481d380 <inflate_table>
                                &(state->lenbits), state->work);
            if (ret) {
3481e8b4:	e3500000 	cmp	r0, #0
3481e8b8:	e58d001c 	str	r0, [sp, #28]
                strm->msg = (char *)"invalid code lengths set";
3481e8bc:	159f3624 	ldrne	r3, [pc, #1572]	; 3481eee8 <inflate+0x1110>
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 7;
            ret = inflate_table(CODES, state->lens, 19, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
3481e8c0:	1a000234 	bne	3481f198 <inflate+0x13c0>
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
3481e8c4:	e59d201c 	ldr	r2, [sp, #28]
            state->mode = CODELENS;
3481e8c8:	e3a03011 	mov	r3, #17
                strm->msg = (char *)"invalid code lengths set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
3481e8cc:	e5842068 	str	r2, [r4, #104]	; 0x68
            state->mode = CODELENS;
3481e8d0:	e5843000 	str	r3, [r4]
        case CODELENS:
            while (state->have < state->nlen + state->ndist) {
3481e8d4:	e5942064 	ldr	r2, [r4, #100]	; 0x64
3481e8d8:	e5943060 	ldr	r3, [r4, #96]	; 0x60
3481e8dc:	e0823003 	add	r3, r2, r3
3481e8e0:	e58d3024 	str	r3, [sp, #36]	; 0x24
3481e8e4:	ea000075 	b	3481eac0 <inflate+0xce8>
                for (;;) {
                    this = state->lencode[BITS(state->lenbits)];
3481e8e8:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481e8ec:	e3a00001 	mov	r0, #1
3481e8f0:	e1a03310 	lsl	r3, r0, r3
3481e8f4:	e594c04c 	ldr	ip, [r4, #76]	; 0x4c
3481e8f8:	e2433001 	sub	r3, r3, #1
3481e8fc:	e58d3028 	str	r3, [sp, #40]	; 0x28
3481e900:	e1a02009 	mov	r2, r9
3481e904:	e59d3028 	ldr	r3, [sp, #40]	; 0x28
3481e908:	e1a09002 	mov	r9, r2
3481e90c:	e0060003 	and	r0, r6, r3
3481e910:	e08c0100 	add	r0, ip, r0, lsl #2
3481e914:	e5d03001 	ldrb	r3, [r0, #1]
3481e918:	e1d000b2 	ldrh	r0, [r0, #2]
                    if ((unsigned)(this.bits) <= bits) break;
3481e91c:	e1530005 	cmp	r3, r5
3481e920:	9a000006 	bls	3481e940 <inflate+0xb68>
                    PULLBYTE();
3481e924:	e3570000 	cmp	r7, #0
3481e928:	0a00022a 	beq	3481f1d8 <inflate+0x1400>
3481e92c:	e4d23001 	ldrb	r3, [r2], #1
3481e930:	e2477001 	sub	r7, r7, #1
3481e934:	e0866513 	add	r6, r6, r3, lsl r5
3481e938:	e2855008 	add	r5, r5, #8
                }
3481e93c:	eafffff0 	b	3481e904 <inflate+0xb2c>
                if (this.val < 16) {
3481e940:	e350000f 	cmp	r0, #15
3481e944:	8a000010 	bhi	3481e98c <inflate+0xbb4>
3481e948:	ea000005 	b	3481e964 <inflate+0xb8c>
                    NEEDBITS(this.bits);
3481e94c:	e3570000 	cmp	r7, #0
3481e950:	0a000220 	beq	3481f1d8 <inflate+0x1400>
3481e954:	e4d2c001 	ldrb	ip, [r2], #1
3481e958:	e2477001 	sub	r7, r7, #1
3481e95c:	e086651c 	add	r6, r6, ip, lsl r5
3481e960:	e2855008 	add	r5, r5, #8
3481e964:	e1550003 	cmp	r5, r3
3481e968:	e1a09002 	mov	r9, r2
3481e96c:	3afffff6 	bcc	3481e94c <inflate+0xb74>
                    DROPBITS(this.bits);
3481e970:	e1a06336 	lsr	r6, r6, r3
3481e974:	e0635005 	rsb	r5, r3, r5
                    state->lens[state->have++] = this.val;
3481e978:	e0843081 	add	r3, r4, r1, lsl #1
3481e97c:	e2811001 	add	r1, r1, #1
3481e980:	e1c307b0 	strh	r0, [r3, #112]	; 0x70
3481e984:	e5841068 	str	r1, [r4, #104]	; 0x68
3481e988:	ea00004c 	b	3481eac0 <inflate+0xce8>
                }
                else {
                    if (this.val == 16) {
3481e98c:	e3500010 	cmp	r0, #16
                        NEEDBITS(this.bits + 2);
3481e990:	02830002 	addeq	r0, r3, #2
                    NEEDBITS(this.bits);
                    DROPBITS(this.bits);
                    state->lens[state->have++] = this.val;
                }
                else {
                    if (this.val == 16) {
3481e994:	1a000014 	bne	3481e9ec <inflate+0xc14>
3481e998:	ea000005 	b	3481e9b4 <inflate+0xbdc>
                        NEEDBITS(this.bits + 2);
3481e99c:	e3570000 	cmp	r7, #0
3481e9a0:	0a00020c 	beq	3481f1d8 <inflate+0x1400>
3481e9a4:	e4d2c001 	ldrb	ip, [r2], #1
3481e9a8:	e2477001 	sub	r7, r7, #1
3481e9ac:	e086651c 	add	r6, r6, ip, lsl r5
3481e9b0:	e2855008 	add	r5, r5, #8
3481e9b4:	e1550000 	cmp	r5, r0
3481e9b8:	e1a09002 	mov	r9, r2
3481e9bc:	3afffff6 	bcc	3481e99c <inflate+0xbc4>
                        DROPBITS(this.bits);
                        if (state->have == 0) {
3481e9c0:	e3510000 	cmp	r1, #0
                    state->lens[state->have++] = this.val;
                }
                else {
                    if (this.val == 16) {
                        NEEDBITS(this.bits + 2);
                        DROPBITS(this.bits);
3481e9c4:	e1a06336 	lsr	r6, r6, r3
3481e9c8:	e0635005 	rsb	r5, r3, r5
                        if (state->have == 0) {
3481e9cc:	0a00002f 	beq	3481ea90 <inflate+0xcb8>
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
3481e9d0:	e2062003 	and	r2, r6, #3
                        if (state->have == 0) {
                            strm->msg = (char *)"invalid bit length repeat";
                            state->mode = BAD;
                            break;
                        }
                        len = state->lens[state->have - 1];
3481e9d4:	e0843081 	add	r3, r4, r1, lsl #1
3481e9d8:	e1d336be 	ldrh	r3, [r3, #110]	; 0x6e
                        copy = 3 + BITS(2);
3481e9dc:	e2822003 	add	r2, r2, #3
                        DROPBITS(2);
3481e9e0:	e1a06126 	lsr	r6, r6, #2
3481e9e4:	e2455002 	sub	r5, r5, #2
3481e9e8:	ea000024 	b	3481ea80 <inflate+0xca8>
                    }
                    else if (this.val == 17) {
3481e9ec:	e3500011 	cmp	r0, #17
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
3481e9f0:	12830007 	addne	r0, r3, #7
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (this.val == 17) {
                        NEEDBITS(this.bits + 3);
3481e9f4:	02830003 	addeq	r0, r3, #3
                        }
                        len = state->lens[state->have - 1];
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (this.val == 17) {
3481e9f8:	1a000015 	bne	3481ea54 <inflate+0xc7c>
3481e9fc:	ea000005 	b	3481ea18 <inflate+0xc40>
                        NEEDBITS(this.bits + 3);
3481ea00:	e3570000 	cmp	r7, #0
3481ea04:	0a0001f3 	beq	3481f1d8 <inflate+0x1400>
3481ea08:	e4d2c001 	ldrb	ip, [r2], #1
3481ea0c:	e2477001 	sub	r7, r7, #1
3481ea10:	e086651c 	add	r6, r6, ip, lsl r5
3481ea14:	e2855008 	add	r5, r5, #8
3481ea18:	e1550000 	cmp	r5, r0
3481ea1c:	e1a09002 	mov	r9, r2
3481ea20:	3afffff6 	bcc	3481ea00 <inflate+0xc28>
                        DROPBITS(this.bits);
3481ea24:	e1a06336 	lsr	r6, r6, r3
                        len = 0;
                        copy = 3 + BITS(3);
3481ea28:	e2062007 	and	r2, r6, #7
3481ea2c:	e2822003 	add	r2, r2, #3
                        DROPBITS(3);
3481ea30:	e1a061a6 	lsr	r6, r6, #3
                        copy = 3 + BITS(2);
                        DROPBITS(2);
                    }
                    else if (this.val == 17) {
                        NEEDBITS(this.bits + 3);
                        DROPBITS(this.bits);
3481ea34:	e3e00002 	mvn	r0, #2
3481ea38:	ea00000d 	b	3481ea74 <inflate+0xc9c>
                        len = 0;
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
3481ea3c:	e3570000 	cmp	r7, #0
3481ea40:	0a0001e4 	beq	3481f1d8 <inflate+0x1400>
3481ea44:	e4d2c001 	ldrb	ip, [r2], #1
3481ea48:	e2477001 	sub	r7, r7, #1
3481ea4c:	e086651c 	add	r6, r6, ip, lsl r5
3481ea50:	e2855008 	add	r5, r5, #8
3481ea54:	e1550000 	cmp	r5, r0
3481ea58:	e1a09002 	mov	r9, r2
3481ea5c:	3afffff6 	bcc	3481ea3c <inflate+0xc64>
                        DROPBITS(this.bits);
3481ea60:	e1a06336 	lsr	r6, r6, r3
                        len = 0;
                        copy = 11 + BITS(7);
3481ea64:	e206207f 	and	r2, r6, #127	; 0x7f
3481ea68:	e282200b 	add	r2, r2, #11
                        DROPBITS(7);
3481ea6c:	e1a063a6 	lsr	r6, r6, #7
                        copy = 3 + BITS(3);
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
                        DROPBITS(this.bits);
3481ea70:	e3e00006 	mvn	r0, #6
3481ea74:	e0630000 	rsb	r0, r3, r0
                        len = 0;
                        copy = 11 + BITS(7);
                        DROPBITS(7);
3481ea78:	e0855000 	add	r5, r5, r0
                        DROPBITS(3);
                    }
                    else {
                        NEEDBITS(this.bits + 7);
                        DROPBITS(this.bits);
                        len = 0;
3481ea7c:	e3a03000 	mov	r3, #0
                        copy = 11 + BITS(7);
                        DROPBITS(7);
                    }
                    if (state->have + copy > state->nlen + state->ndist) {
3481ea80:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
3481ea84:	e0821001 	add	r1, r2, r1
3481ea88:	e151000c 	cmp	r1, ip
3481ea8c:	9a000004 	bls	3481eaa4 <inflate+0xccc>
                        strm->msg = (char *)"invalid bit length repeat";
3481ea90:	e59f3454 	ldr	r3, [pc, #1108]	; 3481eeec <inflate+0x1114>
3481ea94:	e58a3018 	str	r3, [sl, #24]
                        state->mode = BAD;
3481ea98:	e3a0301b 	mov	r3, #27
3481ea9c:	e5843000 	str	r3, [r4]
                        break;
3481eaa0:	ea00000a 	b	3481ead0 <inflate+0xcf8>
                    }
                    while (copy--)
                        state->lens[state->have++] = (unsigned short)len;
3481eaa4:	e5941068 	ldr	r1, [r4, #104]	; 0x68
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
3481eaa8:	e2522001 	subs	r2, r2, #1
                        state->lens[state->have++] = (unsigned short)len;
3481eaac:	e0840081 	add	r0, r4, r1, lsl #1
3481eab0:	e2811001 	add	r1, r1, #1
3481eab4:	e1c037b0 	strh	r3, [r0, #112]	; 0x70
3481eab8:	e5841068 	str	r1, [r4, #104]	; 0x68
                    if (state->have + copy > state->nlen + state->ndist) {
                        strm->msg = (char *)"invalid bit length repeat";
                        state->mode = BAD;
                        break;
                    }
                    while (copy--)
3481eabc:	1afffff8 	bne	3481eaa4 <inflate+0xccc>
            }
            Tracev((stderr, "inflate:       code lengths ok\n"));
            state->have = 0;
            state->mode = CODELENS;
        case CODELENS:
            while (state->have < state->nlen + state->ndist) {
3481eac0:	e5941068 	ldr	r1, [r4, #104]	; 0x68
3481eac4:	e59d0024 	ldr	r0, [sp, #36]	; 0x24
3481eac8:	e1510000 	cmp	r1, r0
3481eacc:	3affff85 	bcc	3481e8e8 <inflate+0xb10>
                        state->lens[state->have++] = (unsigned short)len;
                }
            }

            /* handle error breaks in while */
            if (state->mode == BAD) break;
3481ead0:	e5943000 	ldr	r3, [r4]
3481ead4:	e353001b 	cmp	r3, #27
3481ead8:	0afffcdd 	beq	3481de54 <inflate+0x7c>

            /* build code tables */
            state->next = state->codes;
3481eadc:	e2843e53 	add	r3, r4, #1328	; 0x530
3481eae0:	e584306c 	str	r3, [r4, #108]	; 0x6c
            state->lencode = (code const FAR *)(state->next);
3481eae4:	e584304c 	str	r3, [r4, #76]	; 0x4c
            state->lenbits = 9;
3481eae8:	e3a03009 	mov	r3, #9
3481eaec:	e5843054 	str	r3, [r4, #84]	; 0x54
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
3481eaf0:	e284ce2f 	add	ip, r4, #752	; 0x2f0
3481eaf4:	e284106c 	add	r1, r4, #108	; 0x6c
3481eaf8:	e2843054 	add	r3, r4, #84	; 0x54
3481eafc:	e58d1024 	str	r1, [sp, #36]	; 0x24
3481eb00:	e88d1008 	stm	sp, {r3, ip}
3481eb04:	e5942060 	ldr	r2, [r4, #96]	; 0x60
3481eb08:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3481eb0c:	e3a00001 	mov	r0, #1
3481eb10:	e2841070 	add	r1, r4, #112	; 0x70
3481eb14:	e58dc018 	str	ip, [sp, #24]
3481eb18:	ebfffa18 	bl	3481d380 <inflate_table>
                                &(state->lenbits), state->work);
            if (ret) {
3481eb1c:	e3500000 	cmp	r0, #0
3481eb20:	e58d001c 	str	r0, [sp, #28]
3481eb24:	e59dc018 	ldr	ip, [sp, #24]
                strm->msg = (char *)"invalid literal/lengths set";
3481eb28:	159f33c0 	ldrne	r3, [pc, #960]	; 3481eef0 <inflate+0x1118>
            state->next = state->codes;
            state->lencode = (code const FAR *)(state->next);
            state->lenbits = 9;
            ret = inflate_table(LENS, state->lens, state->nlen, &(state->next),
                                &(state->lenbits), state->work);
            if (ret) {
3481eb2c:	1a000199 	bne	3481f198 <inflate+0x13c0>
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (code const FAR *)(state->next);
3481eb30:	e594306c 	ldr	r3, [r4, #108]	; 0x6c
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
3481eb34:	e5941060 	ldr	r1, [r4, #96]	; 0x60
            if (ret) {
                strm->msg = (char *)"invalid literal/lengths set";
                state->mode = BAD;
                break;
            }
            state->distcode = (code const FAR *)(state->next);
3481eb38:	e5843050 	str	r3, [r4, #80]	; 0x50
            state->distbits = 6;
3481eb3c:	e3a03006 	mov	r3, #6
3481eb40:	e5843058 	str	r3, [r4, #88]	; 0x58
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
3481eb44:	e2843058 	add	r3, r4, #88	; 0x58
3481eb48:	e88d1008 	stm	sp, {r3, ip}
3481eb4c:	e3a00002 	mov	r0, #2
3481eb50:	e2811038 	add	r1, r1, #56	; 0x38
3481eb54:	e59d3024 	ldr	r3, [sp, #36]	; 0x24
3481eb58:	e0214091 	mla	r1, r1, r0, r4
3481eb5c:	e5942064 	ldr	r2, [r4, #100]	; 0x64
3481eb60:	ebfffa06 	bl	3481d380 <inflate_table>
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
3481eb64:	e3500000 	cmp	r0, #0
3481eb68:	e58d001c 	str	r0, [sp, #28]
                strm->msg = (char *)"invalid distances set";
3481eb6c:	159f3380 	ldrne	r3, [pc, #896]	; 3481eef4 <inflate+0x111c>
            }
            state->distcode = (code const FAR *)(state->next);
            state->distbits = 6;
            ret = inflate_table(DISTS, state->lens + state->nlen, state->ndist,
                            &(state->next), &(state->distbits), state->work);
            if (ret) {
3481eb70:	1a000188 	bne	3481f198 <inflate+0x13c0>
                strm->msg = (char *)"invalid distances set";
                state->mode = BAD;
                break;
            }
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN;
3481eb74:	e3a03012 	mov	r3, #18
3481eb78:	e5843000 	str	r3, [r4]
        case LEN:
	    WATCHDOG_RESET();
            if (have >= 6 && left >= 258) {
3481eb7c:	e3003101 	movw	r3, #257	; 0x101
3481eb80:	e3570005 	cmp	r7, #5
3481eb84:	815b0003 	cmphi	fp, r3
3481eb88:	9a000011 	bls	3481ebd4 <inflate+0xdfc>
                RESTORE();
3481eb8c:	e59d2020 	ldr	r2, [sp, #32]
3481eb90:	e58ab010 	str	fp, [sl, #16]
3481eb94:	e58a9000 	str	r9, [sl]
3481eb98:	e58a7004 	str	r7, [sl, #4]
3481eb9c:	e58a200c 	str	r2, [sl, #12]
                inflate_fast(strm, out);
3481eba0:	e1a0000a 	mov	r0, sl
            Tracev((stderr, "inflate:       codes ok\n"));
            state->mode = LEN;
        case LEN:
	    WATCHDOG_RESET();
            if (have >= 6 && left >= 258) {
                RESTORE();
3481eba4:	e5846038 	str	r6, [r4, #56]	; 0x38
3481eba8:	e584503c 	str	r5, [r4, #60]	; 0x3c
                inflate_fast(strm, out);
3481ebac:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
3481ebb0:	ebfff895 	bl	3481ce0c <inflate_fast>
                LOAD();
3481ebb4:	e59a300c 	ldr	r3, [sl, #12]
3481ebb8:	e59ab010 	ldr	fp, [sl, #16]
3481ebbc:	e58d3020 	str	r3, [sp, #32]
3481ebc0:	e59a9000 	ldr	r9, [sl]
3481ebc4:	e59a7004 	ldr	r7, [sl, #4]
3481ebc8:	e5946038 	ldr	r6, [r4, #56]	; 0x38
3481ebcc:	e594503c 	ldr	r5, [r4, #60]	; 0x3c
                break;
3481ebd0:	eafffc9f 	b	3481de54 <inflate+0x7c>
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
3481ebd4:	e5943054 	ldr	r3, [r4, #84]	; 0x54
3481ebd8:	e3a00001 	mov	r0, #1
3481ebdc:	e1a03310 	lsl	r3, r0, r3
3481ebe0:	e594c04c 	ldr	ip, [r4, #76]	; 0x4c
3481ebe4:	e2433001 	sub	r3, r3, #1
3481ebe8:	e58dc00c 	str	ip, [sp, #12]
3481ebec:	e58d3028 	str	r3, [sp, #40]	; 0x28
3481ebf0:	e1a00009 	mov	r0, r9
3481ebf4:	e59d1028 	ldr	r1, [sp, #40]	; 0x28
3481ebf8:	e1a09000 	mov	r9, r0
3481ebfc:	e0063001 	and	r3, r6, r1
3481ec00:	e08c1103 	add	r1, ip, r3, lsl #2
3481ec04:	e5d12001 	ldrb	r2, [r1, #1]
3481ec08:	e1d110b2 	ldrh	r1, [r1, #2]
                if ((unsigned)(this.bits) <= bits) break;
3481ec0c:	e1520005 	cmp	r2, r5
                inflate_fast(strm, out);
                LOAD();
                break;
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
3481ec10:	e58d1024 	str	r1, [sp, #36]	; 0x24
3481ec14:	e7dc3103 	ldrb	r3, [ip, r3, lsl #2]
                if ((unsigned)(this.bits) <= bits) break;
3481ec18:	e1a01002 	mov	r1, r2
3481ec1c:	9a000006 	bls	3481ec3c <inflate+0xe64>
                PULLBYTE();
3481ec20:	e3570000 	cmp	r7, #0
3481ec24:	0a00016b 	beq	3481f1d8 <inflate+0x1400>
3481ec28:	e4d03001 	ldrb	r3, [r0], #1
3481ec2c:	e2477001 	sub	r7, r7, #1
3481ec30:	e0866513 	add	r6, r6, r3, lsl r5
3481ec34:	e2855008 	add	r5, r5, #8
            }
3481ec38:	eaffffed 	b	3481ebf4 <inflate+0xe1c>
3481ec3c:	e58dc00c 	str	ip, [sp, #12]
                LOAD();
                break;
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481ec40:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
3481ec44:	e3530000 	cmp	r3, #0
                LOAD();
                break;
            }
            for (;;) {
                this = state->lencode[BITS(state->lenbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481ec48:	e58dc034 	str	ip, [sp, #52]	; 0x34
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
3481ec4c:	0a000020 	beq	3481ecd4 <inflate+0xefc>
3481ec50:	e31300f0 	tst	r3, #240	; 0xf0
3481ec54:	1a00001e 	bne	3481ecd4 <inflate+0xefc>
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
3481ec58:	e0823003 	add	r3, r2, r3
3481ec5c:	e3a02001 	mov	r2, #1
3481ec60:	e1a03312 	lsl	r3, r2, r3
3481ec64:	e59dc00c 	ldr	ip, [sp, #12]
3481ec68:	e2433001 	sub	r3, r3, #1
3481ec6c:	e58d3030 	str	r3, [sp, #48]	; 0x30
3481ec70:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481ec74:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481ec78:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
                            (BITS(last.bits + last.op) >> last.bits)];
3481ec7c:	e0063000 	and	r3, r6, r0
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481ec80:	e0823133 	add	r3, r2, r3, lsr r1
3481ec84:	e08c0103 	add	r0, ip, r3, lsl #2
3481ec88:	e5d02001 	ldrb	r2, [r0, #1]
3481ec8c:	e1d000b2 	ldrh	r0, [r0, #2]
                            (BITS(last.bits + last.op) >> last.bits)];
3481ec90:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481ec94:	e58d0024 	str	r0, [sp, #36]	; 0x24
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
3481ec98:	e0810002 	add	r0, r1, r2
3481ec9c:	e1500005 	cmp	r0, r5
                PULLBYTE();
            }
            if (this.op && (this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->lencode[last.val +
3481eca0:	e7dc3103 	ldrb	r3, [ip, r3, lsl #2]
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
3481eca4:	9a000008 	bls	3481eccc <inflate+0xef4>
                    PULLBYTE();
3481eca8:	e3570000 	cmp	r7, #0
3481ecac:	0a000149 	beq	3481f1d8 <inflate+0x1400>
3481ecb0:	e1a00009 	mov	r0, r9
3481ecb4:	e4d03001 	ldrb	r3, [r0], #1
3481ecb8:	e2477001 	sub	r7, r7, #1
3481ecbc:	e0866513 	add	r6, r6, r3, lsl r5
3481ecc0:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481ecc4:	e2855008 	add	r5, r5, #8
                }
3481ecc8:	eaffffe9 	b	3481ec74 <inflate+0xe9c>
                DROPBITS(last.bits);
3481eccc:	e1a06136 	lsr	r6, r6, r1
3481ecd0:	e0615005 	rsb	r5, r1, r5
            }
            DROPBITS(this.bits);
            state->length = (unsigned)this.val;
3481ecd4:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
            if ((int)(this.op) == 0) {
3481ecd8:	e3530000 	cmp	r3, #0
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
3481ecdc:	e1a06236 	lsr	r6, r6, r2
3481ece0:	e0625005 	rsb	r5, r2, r5
            state->length = (unsigned)this.val;
3481ece4:	e5841040 	str	r1, [r4, #64]	; 0x40
            if ((int)(this.op) == 0) {
                Tracevv((stderr, this.val >= 0x20 && this.val < 0x7f ?
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", this.val));
                state->mode = LIT;
3481ece8:	02833017 	addeq	r3, r3, #23
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
            state->length = (unsigned)this.val;
            if ((int)(this.op) == 0) {
3481ecec:	0a00012b 	beq	3481f1a0 <inflate+0x13c8>
                        "inflate:         literal '%c'\n" :
                        "inflate:         literal 0x%02x\n", this.val));
                state->mode = LIT;
                break;
            }
            if (this.op & 32) {
3481ecf0:	e3130020 	tst	r3, #32
3481ecf4:	0a000001 	beq	3481ed00 <inflate+0xf28>
                Tracevv((stderr, "inflate:         end of block\n"));
                state->mode = TYPE;
3481ecf8:	e3a0300b 	mov	r3, #11
3481ecfc:	ea000127 	b	3481f1a0 <inflate+0x13c8>
                break;
            }
            if (this.op & 64) {
3481ed00:	e3130040 	tst	r3, #64	; 0x40
                strm->msg = (char *)"invalid literal/length code";
3481ed04:	159f31ec 	ldrne	r3, [pc, #492]	; 3481eef8 <inflate+0x1120>
            if (this.op & 32) {
                Tracevv((stderr, "inflate:         end of block\n"));
                state->mode = TYPE;
                break;
            }
            if (this.op & 64) {
3481ed08:	1a000122 	bne	3481f198 <inflate+0x13c0>
                strm->msg = (char *)"invalid literal/length code";
                state->mode = BAD;
                break;
            }
            state->extra = (unsigned)(this.op) & 15;
3481ed0c:	e203300f 	and	r3, r3, #15
3481ed10:	e5843048 	str	r3, [r4, #72]	; 0x48
            state->mode = LENEXT;
3481ed14:	e3a03013 	mov	r3, #19
3481ed18:	e5843000 	str	r3, [r4]
        case LENEXT:
            if (state->extra) {
3481ed1c:	e5943048 	ldr	r3, [r4, #72]	; 0x48
3481ed20:	e3530000 	cmp	r3, #0
3481ed24:	11a02009 	movne	r2, r9
3481ed28:	1a000006 	bne	3481ed48 <inflate+0xf70>
3481ed2c:	ea000011 	b	3481ed78 <inflate+0xfa0>
                NEEDBITS(state->extra);
3481ed30:	e3570000 	cmp	r7, #0
3481ed34:	0a000127 	beq	3481f1d8 <inflate+0x1400>
3481ed38:	e4d21001 	ldrb	r1, [r2], #1
3481ed3c:	e2477001 	sub	r7, r7, #1
3481ed40:	e0866511 	add	r6, r6, r1, lsl r5
3481ed44:	e2855008 	add	r5, r5, #8
3481ed48:	e1550003 	cmp	r5, r3
3481ed4c:	e1a09002 	mov	r9, r2
3481ed50:	3afffff6 	bcc	3481ed30 <inflate+0xf58>
                state->length += BITS(state->extra);
3481ed54:	e3a0c001 	mov	ip, #1
3481ed58:	e1a0231c 	lsl	r2, ip, r3
3481ed5c:	e2422001 	sub	r2, r2, #1
3481ed60:	e0062002 	and	r2, r6, r2
                DROPBITS(state->extra);
3481ed64:	e1a06336 	lsr	r6, r6, r3
            state->extra = (unsigned)(this.op) & 15;
            state->mode = LENEXT;
        case LENEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
3481ed68:	e5941040 	ldr	r1, [r4, #64]	; 0x40
                DROPBITS(state->extra);
3481ed6c:	e0635005 	rsb	r5, r3, r5
            state->extra = (unsigned)(this.op) & 15;
            state->mode = LENEXT;
        case LENEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->length += BITS(state->extra);
3481ed70:	e0812002 	add	r2, r1, r2
3481ed74:	e5842040 	str	r2, [r4, #64]	; 0x40
                DROPBITS(state->extra);
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
3481ed78:	e3a03014 	mov	r3, #20
3481ed7c:	e5843000 	str	r3, [r4]
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
3481ed80:	e5943058 	ldr	r3, [r4, #88]	; 0x58
3481ed84:	e3a01001 	mov	r1, #1
3481ed88:	e1a03311 	lsl	r3, r1, r3
3481ed8c:	e5940050 	ldr	r0, [r4, #80]	; 0x50
3481ed90:	e2433001 	sub	r3, r3, #1
3481ed94:	e58d000c 	str	r0, [sp, #12]
3481ed98:	e59dc00c 	ldr	ip, [sp, #12]
3481ed9c:	e58d3028 	str	r3, [sp, #40]	; 0x28
3481eda0:	e1a00009 	mov	r0, r9
3481eda4:	e59d2028 	ldr	r2, [sp, #40]	; 0x28
3481eda8:	e1a09000 	mov	r9, r0
3481edac:	e0063002 	and	r3, r6, r2
3481edb0:	e08c1103 	add	r1, ip, r3, lsl #2
3481edb4:	e7dc2103 	ldrb	r2, [ip, r3, lsl #2]
3481edb8:	e5d13001 	ldrb	r3, [r1, #1]
3481edbc:	e1d110b2 	ldrh	r1, [r1, #2]
                if ((unsigned)(this.bits) <= bits) break;
3481edc0:	e1530005 	cmp	r3, r5
            }
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
3481edc4:	e58d1024 	str	r1, [sp, #36]	; 0x24
                if ((unsigned)(this.bits) <= bits) break;
3481edc8:	e1a01003 	mov	r1, r3
3481edcc:	9a000006 	bls	3481edec <inflate+0x1014>
                PULLBYTE();
3481edd0:	e3570000 	cmp	r7, #0
3481edd4:	0a0000ff 	beq	3481f1d8 <inflate+0x1400>
3481edd8:	e4d03001 	ldrb	r3, [r0], #1
3481eddc:	e2477001 	sub	r7, r7, #1
3481ede0:	e0866513 	add	r6, r6, r3, lsl r5
3481ede4:	e2855008 	add	r5, r5, #8
            }
3481ede8:	eaffffed 	b	3481eda4 <inflate+0xfcc>
3481edec:	e58dc00c 	str	ip, [sp, #12]
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481edf0:	e59dc024 	ldr	ip, [sp, #36]	; 0x24
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
3481edf4:	e31200f0 	tst	r2, #240	; 0xf0
            Tracevv((stderr, "inflate:         length %u\n", state->length));
            state->mode = DIST;
        case DIST:
            for (;;) {
                this = state->distcode[BITS(state->distbits)];
                if ((unsigned)(this.bits) <= bits) break;
3481edf8:	e58dc034 	str	ip, [sp, #52]	; 0x34
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
3481edfc:	1a00001e 	bne	3481ee7c <inflate+0x10a4>
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
                            (BITS(last.bits + last.op) >> last.bits)];
3481ee00:	e0832002 	add	r2, r3, r2
3481ee04:	e3a03001 	mov	r3, #1
3481ee08:	e1a02213 	lsl	r2, r3, r2
3481ee0c:	e59dc00c 	ldr	ip, [sp, #12]
3481ee10:	e2422001 	sub	r2, r2, #1
3481ee14:	e58d2030 	str	r2, [sp, #48]	; 0x30
3481ee18:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481ee1c:	e59d0030 	ldr	r0, [sp, #48]	; 0x30
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
3481ee20:	e59d2034 	ldr	r2, [sp, #52]	; 0x34
                            (BITS(last.bits + last.op) >> last.bits)];
3481ee24:	e0063000 	and	r3, r6, r0
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
3481ee28:	e0823133 	add	r3, r2, r3, lsr r1
3481ee2c:	e08c0103 	add	r0, ip, r3, lsl #2
3481ee30:	e7dc2103 	ldrb	r2, [ip, r3, lsl #2]
3481ee34:	e5d03001 	ldrb	r3, [r0, #1]
3481ee38:	e1d000b2 	ldrh	r0, [r0, #2]
                            (BITS(last.bits + last.op) >> last.bits)];
3481ee3c:	e59d9028 	ldr	r9, [sp, #40]	; 0x28
                PULLBYTE();
            }
            if ((this.op & 0xf0) == 0) {
                last = this;
                for (;;) {
                    this = state->distcode[last.val +
3481ee40:	e58d0024 	str	r0, [sp, #36]	; 0x24
                            (BITS(last.bits + last.op) >> last.bits)];
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
3481ee44:	e0810003 	add	r0, r1, r3
3481ee48:	e1500005 	cmp	r0, r5
3481ee4c:	9a000008 	bls	3481ee74 <inflate+0x109c>
                    PULLBYTE();
3481ee50:	e3570000 	cmp	r7, #0
3481ee54:	0a0000df 	beq	3481f1d8 <inflate+0x1400>
3481ee58:	e1a00009 	mov	r0, r9
3481ee5c:	e4d03001 	ldrb	r3, [r0], #1
3481ee60:	e2477001 	sub	r7, r7, #1
3481ee64:	e0866513 	add	r6, r6, r3, lsl r5
3481ee68:	e58d0028 	str	r0, [sp, #40]	; 0x28
3481ee6c:	e2855008 	add	r5, r5, #8
                }
3481ee70:	eaffffe9 	b	3481ee1c <inflate+0x1044>
                DROPBITS(last.bits);
3481ee74:	e1a06136 	lsr	r6, r6, r1
3481ee78:	e0615005 	rsb	r5, r1, r5
            }
            DROPBITS(this.bits);
            if (this.op & 64) {
3481ee7c:	e3120040 	tst	r2, #64	; 0x40
                    if ((unsigned)(last.bits + this.bits) <= bits) break;
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
3481ee80:	e1a06336 	lsr	r6, r6, r3
3481ee84:	e0635005 	rsb	r5, r3, r5
            if (this.op & 64) {
                strm->msg = (char *)"invalid distance code";
3481ee88:	159f306c 	ldrne	r3, [pc, #108]	; 3481eefc <inflate+0x1124>
                    PULLBYTE();
                }
                DROPBITS(last.bits);
            }
            DROPBITS(this.bits);
            if (this.op & 64) {
3481ee8c:	1a0000c1 	bne	3481f198 <inflate+0x13c0>
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)this.val;
3481ee90:	e59d1024 	ldr	r1, [sp, #36]	; 0x24
            state->extra = (unsigned)(this.op) & 15;
3481ee94:	e202200f 	and	r2, r2, #15
            state->mode = DISTEXT;
3481ee98:	e3a03015 	mov	r3, #21
            if (this.op & 64) {
                strm->msg = (char *)"invalid distance code";
                state->mode = BAD;
                break;
            }
            state->offset = (unsigned)this.val;
3481ee9c:	e5841044 	str	r1, [r4, #68]	; 0x44
            state->extra = (unsigned)(this.op) & 15;
3481eea0:	e5842048 	str	r2, [r4, #72]	; 0x48
            state->mode = DISTEXT;
3481eea4:	e5843000 	str	r3, [r4]
        case DISTEXT:
            if (state->extra) {
3481eea8:	e5943048 	ldr	r3, [r4, #72]	; 0x48
3481eeac:	e3530000 	cmp	r3, #0
3481eeb0:	11a02009 	movne	r2, r9
3481eeb4:	1a00001a 	bne	3481ef24 <inflate+0x114c>
3481eeb8:	ea000025 	b	3481ef54 <inflate+0x117c>
3481eebc:	348280c2 	.word	0x348280c2
3481eec0:	348280f4 	.word	0x348280f4
3481eec4:	348280d9 	.word	0x348280d9
3481eec8:	34828108 	.word	0x34828108
3481eecc:	34828121 	.word	0x34828121
3481eed0:	34821f04 	.word	0x34821f04
3481eed4:	34822704 	.word	0x34822704
3481eed8:	34828135 	.word	0x34828135
3481eedc:	34828148 	.word	0x34828148
3481eee0:	34828165 	.word	0x34828165
3481eee4:	34821e04 	.word	0x34821e04
3481eee8:	34828189 	.word	0x34828189
3481eeec:	348281a2 	.word	0x348281a2
3481eef0:	348281bc 	.word	0x348281bc
3481eef4:	348281d8 	.word	0x348281d8
3481eef8:	348280a6 	.word	0x348280a6
3481eefc:	34828090 	.word	0x34828090
3481ef00:	34828072 	.word	0x34828072
3481ef04:	348281ee 	.word	0x348281ee
3481ef08:	34828203 	.word	0x34828203
                NEEDBITS(state->extra);
3481ef0c:	e3570000 	cmp	r7, #0
3481ef10:	0a0000b0 	beq	3481f1d8 <inflate+0x1400>
3481ef14:	e4d21001 	ldrb	r1, [r2], #1
3481ef18:	e2477001 	sub	r7, r7, #1
3481ef1c:	e0866511 	add	r6, r6, r1, lsl r5
3481ef20:	e2855008 	add	r5, r5, #8
3481ef24:	e1550003 	cmp	r5, r3
3481ef28:	e1a09002 	mov	r9, r2
3481ef2c:	3afffff6 	bcc	3481ef0c <inflate+0x1134>
                state->offset += BITS(state->extra);
3481ef30:	e3a0c001 	mov	ip, #1
3481ef34:	e1a0231c 	lsl	r2, ip, r3
3481ef38:	e2422001 	sub	r2, r2, #1
3481ef3c:	e0062002 	and	r2, r6, r2
                DROPBITS(state->extra);
3481ef40:	e1a06336 	lsr	r6, r6, r3
            state->extra = (unsigned)(this.op) & 15;
            state->mode = DISTEXT;
        case DISTEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
3481ef44:	e5941044 	ldr	r1, [r4, #68]	; 0x44
                DROPBITS(state->extra);
3481ef48:	e0635005 	rsb	r5, r3, r5
            state->extra = (unsigned)(this.op) & 15;
            state->mode = DISTEXT;
        case DISTEXT:
            if (state->extra) {
                NEEDBITS(state->extra);
                state->offset += BITS(state->extra);
3481ef4c:	e0812002 	add	r2, r1, r2
3481ef50:	e5842044 	str	r2, [r4, #68]	; 0x44
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
#endif
            if (state->offset > state->whave + out - left) {
3481ef54:	e594302c 	ldr	r3, [r4, #44]	; 0x2c
3481ef58:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
3481ef5c:	e5942044 	ldr	r2, [r4, #68]	; 0x44
3481ef60:	e0803003 	add	r3, r0, r3
3481ef64:	e06b3003 	rsb	r3, fp, r3
3481ef68:	e1520003 	cmp	r2, r3
                strm->msg = (char *)"invalid distance too far back";
3481ef6c:	851f3074 	ldrhi	r3, [pc, #-116]	; 3481ef00 <inflate+0x1128>
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
#endif
            if (state->offset > state->whave + out - left) {
3481ef70:	8a000088 	bhi	3481f198 <inflate+0x13c0>
                strm->msg = (char *)"invalid distance too far back";
                state->mode = BAD;
                break;
            }
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
            state->mode = MATCH;
3481ef74:	e3a03016 	mov	r3, #22
3481ef78:	e5843000 	str	r3, [r4]
        case MATCH:
            if (left == 0) goto inf_leave;
3481ef7c:	e35b0000 	cmp	fp, #0
3481ef80:	0a000094 	beq	3481f1d8 <inflate+0x1400>
            copy = out - left;
3481ef84:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
3481ef88:	e06b2001 	rsb	r2, fp, r1
            if (state->offset > copy) {         /* copy from window */
3481ef8c:	e5941044 	ldr	r1, [r4, #68]	; 0x44
3481ef90:	e1510002 	cmp	r1, r2
                else
                    from = state->window + (state->write - copy);
                if (copy > state->length) copy = state->length;
            }
            else {                              /* copy from output */
                from = put - state->offset;
3481ef94:	959d2020 	ldrls	r2, [sp, #32]
3481ef98:	90611002 	rsbls	r1, r1, r2
                copy = state->length;
3481ef9c:	95942040 	ldrls	r2, [r4, #64]	; 0x40
            Tracevv((stderr, "inflate:         distance %u\n", state->offset));
            state->mode = MATCH;
        case MATCH:
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
3481efa0:	9a00000b 	bls	3481efd4 <inflate+0x11fc>
                copy = state->offset - copy;
                if (copy > state->write) {
3481efa4:	e5943030 	ldr	r3, [r4, #48]	; 0x30
            state->mode = MATCH;
        case MATCH:
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
3481efa8:	e0622001 	rsb	r2, r2, r1
                if (copy > state->write) {
3481efac:	e1520003 	cmp	r2, r3
                    copy -= state->write;
                    from = state->window + (state->wsize - copy);
3481efb0:	85941028 	ldrhi	r1, [r4, #40]	; 0x28
            if (left == 0) goto inf_leave;
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
                if (copy > state->write) {
                    copy -= state->write;
3481efb4:	80632002 	rsbhi	r2, r3, r2
                    from = state->window + (state->wsize - copy);
                }
                else
                    from = state->window + (state->write - copy);
3481efb8:	90621003 	rsbls	r1, r2, r3
3481efbc:	e5940034 	ldr	r0, [r4, #52]	; 0x34
                if (copy > state->length) copy = state->length;
3481efc0:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            copy = out - left;
            if (state->offset > copy) {         /* copy from window */
                copy = state->offset - copy;
                if (copy > state->write) {
                    copy -= state->write;
                    from = state->window + (state->wsize - copy);
3481efc4:	80621001 	rsbhi	r1, r2, r1
                }
                else
                    from = state->window + (state->write - copy);
3481efc8:	e0801001 	add	r1, r0, r1
                if (copy > state->length) copy = state->length;
3481efcc:	e1520003 	cmp	r2, r3
3481efd0:	21a02003 	movcs	r2, r3
                from = put - state->offset;
                copy = state->length;
            }
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
3481efd4:	e5943040 	ldr	r3, [r4, #64]	; 0x40
                    from = state->window + (state->write - copy);
                if (copy > state->length) copy = state->length;
            }
            else {                              /* copy from output */
                from = put - state->offset;
                copy = state->length;
3481efd8:	e152000b 	cmp	r2, fp
3481efdc:	21a0200b 	movcs	r2, fp
            }
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
3481efe0:	e0623003 	rsb	r3, r2, r3
3481efe4:	e5843040 	str	r3, [r4, #64]	; 0x40
            else {                              /* copy from output */
                from = put - state->offset;
                copy = state->length;
            }
            if (copy > left) copy = left;
            left -= copy;
3481efe8:	e062b00b 	rsb	fp, r2, fp
            state->length -= copy;
3481efec:	e3a03000 	mov	r3, #0
            do {
                *put++ = *from++;
3481eff0:	e7d10003 	ldrb	r0, [r1, r3]
3481eff4:	e59dc020 	ldr	ip, [sp, #32]
3481eff8:	e7cc0003 	strb	r0, [ip, r3]
3481effc:	e2833001 	add	r3, r3, #1
            } while (--copy);
3481f000:	e1520003 	cmp	r2, r3
3481f004:	1afffff9 	bne	3481eff0 <inflate+0x1218>
            if (state->length == 0) state->mode = LEN;
3481f008:	e5943040 	ldr	r3, [r4, #64]	; 0x40
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
            do {
                *put++ = *from++;
            } while (--copy);
3481f00c:	e08cc002 	add	ip, ip, r2
            if (state->length == 0) state->mode = LEN;
3481f010:	e3530000 	cmp	r3, #0
            if (copy > left) copy = left;
            left -= copy;
            state->length -= copy;
            do {
                *put++ = *from++;
            } while (--copy);
3481f014:	e58dc020 	str	ip, [sp, #32]
            if (state->length == 0) state->mode = LEN;
3481f018:	02833012 	addeq	r3, r3, #18
3481f01c:	0a00005f 	beq	3481f1a0 <inflate+0x13c8>
3481f020:	eafffb8b 	b	3481de54 <inflate+0x7c>
            break;
        case LIT:
            if (left == 0) goto inf_leave;
3481f024:	e35b0000 	cmp	fp, #0
3481f028:	0a00006a 	beq	3481f1d8 <inflate+0x1400>
            *put++ = (unsigned char)(state->length);
3481f02c:	e5943040 	ldr	r3, [r4, #64]	; 0x40
3481f030:	e59d0020 	ldr	r0, [sp, #32]
            left--;
3481f034:	e24bb001 	sub	fp, fp, #1
            } while (--copy);
            if (state->length == 0) state->mode = LEN;
            break;
        case LIT:
            if (left == 0) goto inf_leave;
            *put++ = (unsigned char)(state->length);
3481f038:	e4c03001 	strb	r3, [r0], #1
3481f03c:	e58d0020 	str	r0, [sp, #32]
            left--;
            state->mode = LEN;
3481f040:	e3a03012 	mov	r3, #18
3481f044:	ea000055 	b	3481f1a0 <inflate+0x13c8>
            break;
        case CHECK:
            if (state->wrap) {
3481f048:	e5943008 	ldr	r3, [r4, #8]
3481f04c:	e3530000 	cmp	r3, #0
3481f050:	11a03009 	movne	r3, r9
3481f054:	1a000006 	bne	3481f074 <inflate+0x129c>
3481f058:	ea000037 	b	3481f13c <inflate+0x1364>
                NEEDBITS(32);
3481f05c:	e3570000 	cmp	r7, #0
3481f060:	0a00005c 	beq	3481f1d8 <inflate+0x1400>
3481f064:	e4d32001 	ldrb	r2, [r3], #1
3481f068:	e2477001 	sub	r7, r7, #1
3481f06c:	e0866512 	add	r6, r6, r2, lsl r5
3481f070:	e2855008 	add	r5, r5, #8
3481f074:	e355001f 	cmp	r5, #31
3481f078:	e1a09003 	mov	r9, r3
3481f07c:	9afffff6 	bls	3481f05c <inflate+0x1284>
                out -= left;
3481f080:	e59d102c 	ldr	r1, [sp, #44]	; 0x2c
                strm->total_out += out;
3481f084:	e59a3014 	ldr	r3, [sl, #20]
            state->mode = LEN;
            break;
        case CHECK:
            if (state->wrap) {
                NEEDBITS(32);
                out -= left;
3481f088:	e06b2001 	rsb	r2, fp, r1
                strm->total_out += out;
3481f08c:	e0833002 	add	r3, r3, r2
3481f090:	e58a3014 	str	r3, [sl, #20]
                state->total += out;
3481f094:	e594301c 	ldr	r3, [r4, #28]
                if (out)
3481f098:	e3520000 	cmp	r2, #0
        case CHECK:
            if (state->wrap) {
                NEEDBITS(32);
                out -= left;
                strm->total_out += out;
                state->total += out;
3481f09c:	e0833002 	add	r3, r3, r2
3481f0a0:	e584301c 	str	r3, [r4, #28]
                if (out)
3481f0a4:	0a00000e 	beq	3481f0e4 <inflate+0x130c>
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
3481f0a8:	e5943010 	ldr	r3, [r4, #16]
3481f0ac:	e2621000 	rsb	r1, r2, #0
3481f0b0:	e3530000 	cmp	r3, #0
3481f0b4:	0a000004 	beq	3481f0cc <inflate+0x12f4>
3481f0b8:	e59d3020 	ldr	r3, [sp, #32]
3481f0bc:	e5940018 	ldr	r0, [r4, #24]
3481f0c0:	e0831001 	add	r1, r3, r1
3481f0c4:	ebffec20 	bl	3481a14c <crc32>
3481f0c8:	ea000003 	b	3481f0dc <inflate+0x1304>
3481f0cc:	e59dc020 	ldr	ip, [sp, #32]
3481f0d0:	e5940018 	ldr	r0, [r4, #24]
3481f0d4:	e08c1001 	add	r1, ip, r1
3481f0d8:	ebfffa84 	bl	3481daf0 <adler32>
                NEEDBITS(32);
                out -= left;
                strm->total_out += out;
                state->total += out;
                if (out)
                    strm->adler = state->check =
3481f0dc:	e5840018 	str	r0, [r4, #24]
3481f0e0:	e58a0034 	str	r0, [sl, #52]	; 0x34
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
3481f0e4:	e5943010 	ldr	r3, [r4, #16]
3481f0e8:	e3530000 	cmp	r3, #0
#endif
                     REVERSE(hold)) != state->check) {
3481f0ec:	01a02426 	lsreq	r2, r6, #8
3481f0f0:	01a01c26 	lsreq	r1, r6, #24
3481f0f4:	02022cff 	andeq	r2, r2, #65280	; 0xff00
3481f0f8:	00811c06 	addeq	r1, r1, r6, lsl #24
3481f0fc:	02063cff 	andeq	r3, r6, #65280	; 0xff00
3481f100:	00812002 	addeq	r2, r1, r2
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
3481f104:	00823403 	addeq	r3, r2, r3, lsl #8
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481f108:	e5942018 	ldr	r2, [r4, #24]
#ifdef GUNZIP
                     state->flags ? hold :
3481f10c:	11a03006 	movne	r3, r6
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481f110:	e1530002 	cmp	r3, r2
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
3481f114:	03a05000 	moveq	r5, #0
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481f118:	058db02c 	streq	fp, [sp, #44]	; 0x2c
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
                    state->mode = BAD;
                    break;
                }
                INITBITS();
3481f11c:	01a06005 	moveq	r6, r5
                state->total += out;
                if (out)
                    strm->adler = state->check =
                        UPDATE(state->check, put - out, out);
                out = left;
                if ((
3481f120:	0a000005 	beq	3481f13c <inflate+0x1364>
#ifdef GUNZIP
                     state->flags ? hold :
#endif
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
3481f124:	e51f3228 	ldr	r3, [pc, #-552]	; 3481ef04 <inflate+0x112c>
                    state->mode = BAD;
                    break;
3481f128:	e58db02c 	str	fp, [sp, #44]	; 0x2c
                if ((
#ifdef GUNZIP
                     state->flags ? hold :
#endif
                     REVERSE(hold)) != state->check) {
                    strm->msg = (char *)"incorrect data check";
3481f12c:	e58a3018 	str	r3, [sl, #24]
                    state->mode = BAD;
3481f130:	e3a0301b 	mov	r3, #27
3481f134:	e5843000 	str	r3, [r4]
                    break;
3481f138:	eafffb45 	b	3481de54 <inflate+0x7c>
                }
                INITBITS();
                Tracev((stderr, "inflate:   check matches trailer\n"));
            }
#ifdef GUNZIP
            state->mode = LENGTH;
3481f13c:	e3a03019 	mov	r3, #25
3481f140:	e5843000 	str	r3, [r4]
        case LENGTH:
            if (state->wrap && state->flags) {
3481f144:	e5943008 	ldr	r3, [r4, #8]
3481f148:	e3530000 	cmp	r3, #0
3481f14c:	0a000017 	beq	3481f1b0 <inflate+0x13d8>
3481f150:	e5943010 	ldr	r3, [r4, #16]
3481f154:	e3530000 	cmp	r3, #0
3481f158:	0a000014 	beq	3481f1b0 <inflate+0x13d8>
3481f15c:	e1a03009 	mov	r3, r9
3481f160:	ea000005 	b	3481f17c <inflate+0x13a4>
                NEEDBITS(32);
3481f164:	e3570000 	cmp	r7, #0
3481f168:	0a00001a 	beq	3481f1d8 <inflate+0x1400>
3481f16c:	e4d32001 	ldrb	r2, [r3], #1
3481f170:	e2477001 	sub	r7, r7, #1
3481f174:	e0866512 	add	r6, r6, r2, lsl r5
3481f178:	e2855008 	add	r5, r5, #8
3481f17c:	e355001f 	cmp	r5, #31
3481f180:	e1a09003 	mov	r9, r3
3481f184:	9afffff6 	bls	3481f164 <inflate+0x138c>
                if (hold != (state->total & 0xffffffffUL)) {
3481f188:	e594301c 	ldr	r3, [r4, #28]
3481f18c:	e1560003 	cmp	r6, r3
3481f190:	0a000004 	beq	3481f1a8 <inflate+0x13d0>
                    strm->msg = (char *)"incorrect length check";
3481f194:	e51f3294 	ldr	r3, [pc, #-660]	; 3481ef08 <inflate+0x1130>
3481f198:	e58a3018 	str	r3, [sl, #24]
                    state->mode = BAD;
3481f19c:	e3a0301b 	mov	r3, #27
3481f1a0:	e5843000 	str	r3, [r4]
3481f1a4:	eafffb2a 	b	3481de54 <inflate+0x7c>
                    break;
                }
                INITBITS();
3481f1a8:	e3a05000 	mov	r5, #0
3481f1ac:	e1a06005 	mov	r6, r5
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
3481f1b0:	e3a0301a 	mov	r3, #26
        case DONE:
            ret = Z_STREAM_END;
3481f1b4:	e3a00001 	mov	r0, #1
                }
                INITBITS();
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
3481f1b8:	e5843000 	str	r3, [r4]
        case DONE:
            ret = Z_STREAM_END;
3481f1bc:	e58d001c 	str	r0, [sp, #28]
3481f1c0:	ea000004 	b	3481f1d8 <inflate+0x1400>
            goto inf_leave;
        case BAD:
            ret = Z_DATA_ERROR;
3481f1c4:	e3e01002 	mvn	r1, #2
3481f1c8:	e58d101c 	str	r1, [sp, #28]
3481f1cc:	ea000001 	b	3481f1d8 <inflate+0x1400>
                Tracev((stderr, "inflate:   length matches trailer\n"));
            }
#endif
            state->mode = DONE;
        case DONE:
            ret = Z_STREAM_END;
3481f1d0:	e3a02001 	mov	r2, #1
3481f1d4:	e58d201c 	str	r2, [sp, #28]
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
3481f1d8:	e59d3020 	ldr	r3, [sp, #32]
3481f1dc:	e58ab010 	str	fp, [sl, #16]
3481f1e0:	e58a300c 	str	r3, [sl, #12]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
3481f1e4:	e5943028 	ldr	r3, [r4, #40]	; 0x28
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
3481f1e8:	e58a9000 	str	r9, [sl]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
3481f1ec:	e3530000 	cmp	r3, #0
       If there was no progress during the inflate() call, return a buffer
       error.  Call updatewindow() to create and/or update the window state.
       Note: a memory error from inflate() is non-recoverable.
     */
  inf_leave:
    RESTORE();
3481f1f0:	e58a7004 	str	r7, [sl, #4]
3481f1f4:	e5846038 	str	r6, [r4, #56]	; 0x38
3481f1f8:	e584503c 	str	r5, [r4, #60]	; 0x3c
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
3481f1fc:	1a000005 	bne	3481f218 <inflate+0x1440>
3481f200:	e5943000 	ldr	r3, [r4]
3481f204:	e3530017 	cmp	r3, #23
3481f208:	8a000048 	bhi	3481f330 <inflate+0x1558>
3481f20c:	e59dc02c 	ldr	ip, [sp, #44]	; 0x2c
3481f210:	e15c000b 	cmp	ip, fp
3481f214:	0a000045 	beq	3481f330 <inflate+0x1558>
unsigned out;
{
    struct inflate_state FAR *state;
    unsigned copy, dist;

    state = (struct inflate_state FAR *)strm->state;
3481f218:	e59a501c 	ldr	r5, [sl, #28]

    /* if it hasn't been done already, allocate space for the window */
    if (state->window == Z_NULL) {
3481f21c:	e5953034 	ldr	r3, [r5, #52]	; 0x34
3481f220:	e3530000 	cmp	r3, #0
3481f224:	1a000008 	bne	3481f24c <inflate+0x1474>
        state->window = (unsigned char FAR *)
                        ZALLOC(strm, 1U << state->wbits,
3481f228:	e5951024 	ldr	r1, [r5, #36]	; 0x24
3481f22c:	e3a02001 	mov	r2, #1
3481f230:	e59a3020 	ldr	r3, [sl, #32]
3481f234:	e59a0028 	ldr	r0, [sl, #40]	; 0x28
3481f238:	e1a01112 	lsl	r1, r2, r1
3481f23c:	e12fff33 	blx	r3
                               sizeof(unsigned char));
        if (state->window == Z_NULL) return 1;
3481f240:	e3500000 	cmp	r0, #0

    state = (struct inflate_state FAR *)strm->state;

    /* if it hasn't been done already, allocate space for the window */
    if (state->window == Z_NULL) {
        state->window = (unsigned char FAR *)
3481f244:	e5850034 	str	r0, [r5, #52]	; 0x34
                        ZALLOC(strm, 1U << state->wbits,
                               sizeof(unsigned char));
        if (state->window == Z_NULL) return 1;
3481f248:	0a000034 	beq	3481f320 <inflate+0x1548>
    }

    /* if window not in use yet, initialize */
    if (state->wsize == 0) {
3481f24c:	e5953028 	ldr	r3, [r5, #40]	; 0x28
3481f250:	e3530000 	cmp	r3, #0
3481f254:	1a000005 	bne	3481f270 <inflate+0x1498>
        state->wsize = 1U << state->wbits;
3481f258:	e5952024 	ldr	r2, [r5, #36]	; 0x24
3481f25c:	e3a01001 	mov	r1, #1
3481f260:	e1a02211 	lsl	r2, r1, r2
        state->write = 0;
3481f264:	e5853030 	str	r3, [r5, #48]	; 0x30
        if (state->window == Z_NULL) return 1;
    }

    /* if window not in use yet, initialize */
    if (state->wsize == 0) {
        state->wsize = 1U << state->wbits;
3481f268:	e5852028 	str	r2, [r5, #40]	; 0x28
        state->write = 0;
        state->whave = 0;
3481f26c:	e585302c 	str	r3, [r5, #44]	; 0x2c
    }

    /* copy state->wsize or less output bytes into the circular window */
    copy = out - strm->avail_out;
3481f270:	e59a6010 	ldr	r6, [sl, #16]
3481f274:	e59d002c 	ldr	r0, [sp, #44]	; 0x2c
    if (copy >= state->wsize) {
3481f278:	e5952028 	ldr	r2, [r5, #40]	; 0x28
        state->write = 0;
        state->whave = 0;
    }

    /* copy state->wsize or less output bytes into the circular window */
    copy = out - strm->avail_out;
3481f27c:	e0666000 	rsb	r6, r6, r0
    if (copy >= state->wsize) {
3481f280:	e1560002 	cmp	r6, r2
3481f284:	e59a100c 	ldr	r1, [sl, #12]
3481f288:	3a000005 	bcc	3481f2a4 <inflate+0x14cc>
        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
3481f28c:	e5950034 	ldr	r0, [r5, #52]	; 0x34
3481f290:	e0621001 	rsb	r1, r2, r1
3481f294:	ebfff32e 	bl	3481bf54 <memcpy>
        state->write = 0;
3481f298:	e3a03000 	mov	r3, #0
3481f29c:	e5853030 	str	r3, [r5, #48]	; 0x30
3481f2a0:	ea000010 	b	3481f2e8 <inflate+0x1510>
        state->whave = state->wsize;
    }
    else {
        dist = state->wsize - state->write;
3481f2a4:	e5953030 	ldr	r3, [r5, #48]	; 0x30
        if (dist > copy) dist = copy;
        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
3481f2a8:	e5950034 	ldr	r0, [r5, #52]	; 0x34
        zmemcpy(state->window, strm->next_out - state->wsize, state->wsize);
        state->write = 0;
        state->whave = state->wsize;
    }
    else {
        dist = state->wsize - state->write;
3481f2ac:	e0637002 	rsb	r7, r3, r2
3481f2b0:	e1560007 	cmp	r6, r7
3481f2b4:	31a07006 	movcc	r7, r6
        if (dist > copy) dist = copy;
        zmemcpy(state->window + state->write, strm->next_out - copy, dist);
3481f2b8:	e0661001 	rsb	r1, r6, r1
3481f2bc:	e0800003 	add	r0, r0, r3
3481f2c0:	e1a02007 	mov	r2, r7
3481f2c4:	ebfff322 	bl	3481bf54 <memcpy>
        copy -= dist;
        if (copy) {
3481f2c8:	e0566007 	subs	r6, r6, r7
3481f2cc:	0a000008 	beq	3481f2f4 <inflate+0x151c>
            zmemcpy(state->window, strm->next_out - copy, copy);
3481f2d0:	e59a100c 	ldr	r1, [sl, #12]
3481f2d4:	e5950034 	ldr	r0, [r5, #52]	; 0x34
3481f2d8:	e0661001 	rsb	r1, r6, r1
3481f2dc:	e1a02006 	mov	r2, r6
3481f2e0:	ebfff31b 	bl	3481bf54 <memcpy>
            state->write = copy;
3481f2e4:	e5856030 	str	r6, [r5, #48]	; 0x30
            state->whave = state->wsize;
3481f2e8:	e5953028 	ldr	r3, [r5, #40]	; 0x28
3481f2ec:	e585302c 	str	r3, [r5, #44]	; 0x2c
3481f2f0:	ea00000e 	b	3481f330 <inflate+0x1558>
        }
        else {
            state->write += dist;
3481f2f4:	e5953030 	ldr	r3, [r5, #48]	; 0x30
            if (state->write == state->wsize) state->write = 0;
3481f2f8:	e5952028 	ldr	r2, [r5, #40]	; 0x28
            zmemcpy(state->window, strm->next_out - copy, copy);
            state->write = copy;
            state->whave = state->wsize;
        }
        else {
            state->write += dist;
3481f2fc:	e0873003 	add	r3, r7, r3
            if (state->write == state->wsize) state->write = 0;
3481f300:	e1530002 	cmp	r3, r2
            zmemcpy(state->window, strm->next_out - copy, copy);
            state->write = copy;
            state->whave = state->wsize;
        }
        else {
            state->write += dist;
3481f304:	e5853030 	str	r3, [r5, #48]	; 0x30
            if (state->write == state->wsize) state->write = 0;
            if (state->whave < state->wsize) state->whave += dist;
3481f308:	e595302c 	ldr	r3, [r5, #44]	; 0x2c
            state->write = copy;
            state->whave = state->wsize;
        }
        else {
            state->write += dist;
            if (state->write == state->wsize) state->write = 0;
3481f30c:	05856030 	streq	r6, [r5, #48]	; 0x30
            if (state->whave < state->wsize) state->whave += dist;
3481f310:	e1530002 	cmp	r3, r2
3481f314:	30877003 	addcc	r7, r7, r3
3481f318:	3585702c 	strcc	r7, [r5, #44]	; 0x2c
3481f31c:	ea000003 	b	3481f330 <inflate+0x1558>
     */
  inf_leave:
    RESTORE();
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
        if (updatewindow(strm, out)) {
            state->mode = MEM;
3481f320:	e3a0301c 	mov	r3, #28
3481f324:	e5843000 	str	r3, [r4]
            return Z_MEM_ERROR;
3481f328:	e3e01003 	mvn	r1, #3
3481f32c:	ea00003b 	b	3481f420 <inflate+0x1648>
        }
    in -= strm->avail_in;
    out -= strm->avail_out;
3481f330:	e59a6010 	ldr	r6, [sl, #16]
3481f334:	e59d302c 	ldr	r3, [sp, #44]	; 0x2c
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
        if (updatewindow(strm, out)) {
            state->mode = MEM;
            return Z_MEM_ERROR;
        }
    in -= strm->avail_in;
3481f338:	e59a5004 	ldr	r5, [sl, #4]
3481f33c:	e59d2038 	ldr	r2, [sp, #56]	; 0x38
    out -= strm->avail_out;
3481f340:	e0666003 	rsb	r6, r6, r3
    strm->total_in += in;
3481f344:	e59a3008 	ldr	r3, [sl, #8]
    if (state->wsize || (state->mode < CHECK && out != strm->avail_out))
        if (updatewindow(strm, out)) {
            state->mode = MEM;
            return Z_MEM_ERROR;
        }
    in -= strm->avail_in;
3481f348:	e0655002 	rsb	r5, r5, r2
    out -= strm->avail_out;
    strm->total_in += in;
3481f34c:	e0833005 	add	r3, r3, r5
3481f350:	e58a3008 	str	r3, [sl, #8]
    strm->total_out += out;
3481f354:	e59a3014 	ldr	r3, [sl, #20]
3481f358:	e0833006 	add	r3, r3, r6
3481f35c:	e58a3014 	str	r3, [sl, #20]
    state->total += out;
3481f360:	e594301c 	ldr	r3, [r4, #28]
3481f364:	e0833006 	add	r3, r3, r6
3481f368:	e584301c 	str	r3, [r4, #28]
    if (state->wrap && out)
3481f36c:	e5943008 	ldr	r3, [r4, #8]
3481f370:	e3560000 	cmp	r6, #0
3481f374:	13530000 	cmpne	r3, #0
3481f378:	0a00000f 	beq	3481f3bc <inflate+0x15e4>
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
3481f37c:	e5943010 	ldr	r3, [r4, #16]
3481f380:	e59a100c 	ldr	r1, [sl, #12]
3481f384:	e3530000 	cmp	r3, #0
3481f388:	e2663000 	rsb	r3, r6, #0
3481f38c:	0a000004 	beq	3481f3a4 <inflate+0x15cc>
3481f390:	e5940018 	ldr	r0, [r4, #24]
3481f394:	e0811003 	add	r1, r1, r3
3481f398:	e1a02006 	mov	r2, r6
3481f39c:	ebffeb6a 	bl	3481a14c <crc32>
3481f3a0:	ea000003 	b	3481f3b4 <inflate+0x15dc>
3481f3a4:	e5940018 	ldr	r0, [r4, #24]
3481f3a8:	e0811003 	add	r1, r1, r3
3481f3ac:	e1a02006 	mov	r2, r6
3481f3b0:	ebfff9ce 	bl	3481daf0 <adler32>
    out -= strm->avail_out;
    strm->total_in += in;
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
3481f3b4:	e5840018 	str	r0, [r4, #24]
3481f3b8:	e58a0034 	str	r0, [sl, #52]	; 0x34
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
3481f3bc:	e5943004 	ldr	r3, [r4, #4]
3481f3c0:	e594203c 	ldr	r2, [r4, #60]	; 0x3c
3481f3c4:	e3530000 	cmp	r3, #0
3481f3c8:	13a03040 	movne	r3, #64	; 0x40
3481f3cc:	03a03000 	moveq	r3, #0
3481f3d0:	e0833002 	add	r3, r3, r2
3481f3d4:	e5942000 	ldr	r2, [r4]
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
3481f3d8:	e59dc03c 	ldr	ip, [sp, #60]	; 0x3c
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
3481f3dc:	e352000b 	cmp	r2, #11
3481f3e0:	03a02080 	moveq	r2, #128	; 0x80
3481f3e4:	13a02000 	movne	r2, #0
3481f3e8:	e0833002 	add	r3, r3, r2
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
3481f3ec:	e1966005 	orrs	r6, r6, r5
    strm->total_out += out;
    state->total += out;
    if (state->wrap && out)
        strm->adler = state->check =
            UPDATE(state->check, strm->next_out - out, out);
    strm->data_type = state->bits + (state->last ? 64 : 0) +
3481f3f0:	e58a302c 	str	r3, [sl, #44]	; 0x2c
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
3481f3f4:	13a03000 	movne	r3, #0
3481f3f8:	03a03001 	moveq	r3, #1
3481f3fc:	e35c0004 	cmp	ip, #4
3481f400:	03833001 	orreq	r3, r3, #1
3481f404:	e3530000 	cmp	r3, #0
3481f408:	0a00000d 	beq	3481f444 <inflate+0x166c>
        ret = Z_BUF_ERROR;
3481f40c:	e59d001c 	ldr	r0, [sp, #28]
3481f410:	e3500000 	cmp	r0, #0
3481f414:	03e00004 	mvneq	r0, #4
3481f418:	e58d001c 	str	r0, [sp, #28]
3481f41c:	ea000008 	b	3481f444 <inflate+0x166c>
    static const unsigned short order[19] = /* permutation of code lengths */
        {16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15};

    if (strm == Z_NULL || strm->state == Z_NULL ||
        (strm->next_in == Z_NULL && strm->avail_in != 0))
        return Z_STREAM_ERROR;
3481f420:	e58d101c 	str	r1, [sp, #28]
3481f424:	ea000006 	b	3481f444 <inflate+0x166c>
3481f428:	e3e02001 	mvn	r2, #1
3481f42c:	e58d201c 	str	r2, [sp, #28]
3481f430:	ea000003 	b	3481f444 <inflate+0x166c>
3481f434:	e58d301c 	str	r3, [sp, #28]
3481f438:	ea000001 	b	3481f444 <inflate+0x166c>
            goto inf_leave;
        case MEM:
            return Z_MEM_ERROR;
        case SYNC:
        default:
            return Z_STREAM_ERROR;
3481f43c:	e3e0c001 	mvn	ip, #1
3481f440:	e58dc01c 	str	ip, [sp, #28]
    strm->data_type = state->bits + (state->last ? 64 : 0) +
                      (state->mode == TYPE ? 128 : 0);
    if (((in == 0 && out == 0) || flush == Z_FINISH) && ret == Z_OK)
        ret = Z_BUF_ERROR;
    return ret;
}
3481f444:	e59d001c 	ldr	r0, [sp, #28]
3481f448:	e28dd048 	add	sp, sp, #72	; 0x48
3481f44c:	e8bd8ef0 	pop	{r4, r5, r6, r7, r9, sl, fp, pc}

3481f450 <_TEXT_BASE>:
3481f450:	34800000 	.word	0x34800000

3481f454 <lowlevel_init>:
_TEXT_BASE:
	.word	CONFIG_SYS_TEXT_BASE

	.globl lowlevel_init
lowlevel_init:
	mov	r11, lr
3481f454:	e1a0b00e 	mov	fp, lr

	/* r5 has always zero */
	mov	r5, #0
3481f458:	e3a05000 	mov	r5, #0

	ldr	r7, =S5PC100_GPIO_BASE
3481f45c:	e59f73e4 	ldr	r7, [pc, #996]	; 3481f848 <uart_asm_init+0x84>
	ldr	r8, =S5PC100_GPIO_BASE
3481f460:	e59f83e0 	ldr	r8, [pc, #992]	; 3481f848 <uart_asm_init+0x84>
	/* Read CPU ID */
	ldr	r2, =S5PC110_PRO_ID
3481f464:	e3a0220e 	mov	r2, #-536870912	; 0xe0000000
	ldr	r0, [r2]
3481f468:	e5920000 	ldr	r0, [r2]
	mov	r1, #0x00010000
3481f46c:	e3a01801 	mov	r1, #65536	; 0x10000
	and	r0, r0, r1
3481f470:	e0000001 	and	r0, r0, r1
	cmp	r0, r5
3481f474:	e1500005 	cmp	r0, r5
	beq	100f
3481f478:	0a000000 	beq	3481f480 <lowlevel_init+0x2c>
	ldr	r8, =S5PC110_GPIO_BASE
3481f47c:	e59f83c8 	ldr	r8, [pc, #968]	; 3481f84c <uart_asm_init+0x88>
100:
	/* Turn on KEY_LED_ON [GPJ4(1)] XMSMWEN */
	cmp	r7, r8
3481f480:	e1570008 	cmp	r7, r8
	beq	skip_check_didle			@ Support C110 only
3481f484:	0a000005 	beq	3481f4a0 <skip_check_didle>

	ldr	r0, =S5PC110_RST_STAT
3481f488:	e59f03c0 	ldr	r0, [pc, #960]	; 3481f850 <uart_asm_init+0x8c>
	ldr	r1, [r0]
3481f48c:	e5901000 	ldr	r1, [r0]
	and	r1, r1, #0x000D0000
3481f490:	e201180d 	and	r1, r1, #851968	; 0xd0000
	cmp	r1, #(0x1 << 19)			@ DEEPIDLE_WAKEUP
3481f494:	e3510702 	cmp	r1, #524288	; 0x80000
	beq	didle_wakeup
3481f498:	0a000064 	beq	3481f630 <didle_wakeup>
	cmp	r7, r8
3481f49c:	e1570008 	cmp	r7, r8

3481f4a0 <skip_check_didle>:

skip_check_didle:
	addeq	r0, r8, #0x280				@ S5PC100_GPIO_J4
3481f4a0:	02880d0a 	addeq	r0, r8, #640	; 0x280
	addne	r0, r8, #0x2C0				@ S5PC110_GPIO_J4
3481f4a4:	12880d0b 	addne	r0, r8, #704	; 0x2c0
	ldr	r1, [r0, #0x0]				@ GPIO_CON_OFFSET
3481f4a8:	e5901000 	ldr	r1, [r0]
	bic	r1, r1, #(0xf << 4)			@ 1 * 4-bit
3481f4ac:	e3c110f0 	bic	r1, r1, #240	; 0xf0
	orr	r1, r1, #(0x1 << 4)
3481f4b0:	e3811010 	orr	r1, r1, #16
	str	r1, [r0, #0x0]				@ GPIO_CON_OFFSET
3481f4b4:	e5801000 	str	r1, [r0]

	ldr	r1, [r0, #0x4]				@ GPIO_DAT_OFFSET
3481f4b8:	e5901004 	ldr	r1, [r0, #4]
	bic	r1, r1, #(1 << 1)
3481f4bc:	e3c11002 	bic	r1, r1, #2
	str	r1, [r0, #0x4]				@ GPIO_DAT_OFFSET
3481f4c0:	e5801004 	str	r1, [r0, #4]

	/* Don't setup at s5pc100 */
	beq	100f
3481f4c4:	0a00002e 	beq	3481f584 <skip_check_didle+0xe4>
	 *	0xF1D0_0000
	 *	0xF1E0_0000
	 *	0xF1F0_0000
	 *	0xFAF0_0000
	 */
	ldr     r0, =0xe0f00000
3481f4c8:	e59f0384 	ldr	r0, [pc, #900]	; 3481f854 <uart_asm_init+0x90>
	ldr     r1, [r0]
3481f4cc:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3481f4d0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
3481f4d4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xe1f00000
3481f4d8:	e59f0378 	ldr	r0, [pc, #888]	; 3481f858 <uart_asm_init+0x94>
	ldr     r1, [r0]
3481f4dc:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3481f4e0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
3481f4e4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1800000
3481f4e8:	e59f036c 	ldr	r0, [pc, #876]	; 3481f85c <uart_asm_init+0x98>
	ldr     r1, [r0]
3481f4ec:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3481f4f0:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
3481f4f4:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1900000
3481f4f8:	e59f0360 	ldr	r0, [pc, #864]	; 3481f860 <uart_asm_init+0x9c>
	ldr     r1, [r0]
3481f4fc:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3481f500:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
3481f504:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1a00000
3481f508:	e59f0354 	ldr	r0, [pc, #852]	; 3481f864 <uart_asm_init+0xa0>
	ldr     r1, [r0]
3481f50c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3481f510:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
3481f514:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1b00000
3481f518:	e59f0348 	ldr	r0, [pc, #840]	; 3481f868 <uart_asm_init+0xa4>
	ldr     r1, [r0]
3481f51c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3481f520:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
3481f524:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1c00000
3481f528:	e59f033c 	ldr	r0, [pc, #828]	; 3481f86c <uart_asm_init+0xa8>
	ldr     r1, [r0]
3481f52c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3481f530:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
3481f534:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1d00000
3481f538:	e59f0330 	ldr	r0, [pc, #816]	; 3481f870 <uart_asm_init+0xac>
	ldr     r1, [r0]
3481f53c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3481f540:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
3481f544:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1e00000
3481f548:	e59f0324 	ldr	r0, [pc, #804]	; 3481f874 <uart_asm_init+0xb0>
	ldr     r1, [r0]
3481f54c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3481f550:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
3481f554:	e5801000 	str	r1, [r0]

	ldr     r0, =0xf1f00000
3481f558:	e59f0318 	ldr	r0, [pc, #792]	; 3481f878 <uart_asm_init+0xb4>
	ldr     r1, [r0]
3481f55c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3481f560:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
3481f564:	e5801000 	str	r1, [r0]

	ldr     r0, =0xfaf00000
3481f568:	e59f030c 	ldr	r0, [pc, #780]	; 3481f87c <uart_asm_init+0xb8>
	ldr     r1, [r0]
3481f56c:	e5901000 	ldr	r1, [r0]
	bic     r1, r1, #0x1
3481f570:	e3c11001 	bic	r1, r1, #1
	str     r1, [r0]
3481f574:	e5801000 	str	r1, [r0]

	/*
	 * Diable ABB block to reduce sleep current at low temperature
	 * Note that it's hidden register setup don't modify it
	 */
	ldr	r0, =0xE010C300
3481f578:	e59f0300 	ldr	r0, [pc, #768]	; 3481f880 <uart_asm_init+0xbc>
	ldr	r1, =0x00800000
3481f57c:	e3a01502 	mov	r1, #8388608	; 0x800000
	str	r1, [r0]
3481f580:	e5801000 	str	r1, [r0]

100:
	/* IO retension release */
	ldreq	r0, =S5PC100_OTHERS			@ 0xE0108200
3481f584:	059f02f8 	ldreq	r0, [pc, #760]	; 3481f884 <uart_asm_init+0xc0>
	ldrne	r0, =S5PC110_OTHERS			@ 0xE010E000
3481f588:	159f02f8 	ldrne	r0, [pc, #760]	; 3481f888 <uart_asm_init+0xc4>
	ldr	r1, [r0]
3481f58c:	e5901000 	ldr	r1, [r0]
	ldreq	r2, =(1 << 31)				@ IO_RET_REL
3481f590:	03a02102 	moveq	r2, #-2147483648	; 0x80000000
	ldrne	r2, =((1 << 31) | (1 << 30) | (1 << 29) | (1 << 28))
3481f594:	13a0220f 	movne	r2, #-268435456	; 0xf0000000
	orr	r1, r1, r2
3481f598:	e1811002 	orr	r1, r1, r2
	/* Do not release retention here for S5PC110 */
	streq	r1, [r0]
3481f59c:	05801000 	streq	r1, [r0]

	/* Disable Watchdog */
	ldreq	r0, =S5PC100_WATCHDOG_BASE		@ 0xEA200000
3481f5a0:	059f02e4 	ldreq	r0, [pc, #740]	; 3481f88c <uart_asm_init+0xc8>
	ldrne	r0, =S5PC110_WATCHDOG_BASE		@ 0xE2700000
3481f5a4:	159f02e4 	ldrne	r0, [pc, #740]	; 3481f890 <uart_asm_init+0xcc>
	str	r5, [r0]
3481f5a8:	e5805000 	str	r5, [r0]

	/* setting SRAM */
	ldreq	r0, =S5PC100_SROMC_BASE
3481f5ac:	03a004e7 	moveq	r0, #-419430400	; 0xe7000000
	ldrne	r0, =S5PC110_SROMC_BASE
3481f5b0:	13a0033a 	movne	r0, #-402653184	; 0xe8000000
	ldr	r1, =0x9
3481f5b4:	e3a01009 	mov	r1, #9
	str	r1, [r0]
3481f5b8:	e5801000 	str	r1, [r0]

	/* S5PC100 has 3 groups of interrupt sources */
	ldreq	r0, =S5PC100_VIC0_BASE			@ 0xE4000000
3481f5bc:	03a00339 	moveq	r0, #-469762048	; 0xe4000000
	ldrne	r0, =S5PC110_VIC0_BASE			@ 0xF2000000
3481f5c0:	13a004f2 	movne	r0, #-234881024	; 0xf2000000
	add	r1, r0, #0x00100000
3481f5c4:	e2801601 	add	r1, r0, #1048576	; 0x100000
	add	r2, r0, #0x00200000
3481f5c8:	e2802602 	add	r2, r0, #2097152	; 0x200000

	/* Disable all interrupts (VIC0, VIC1 and VIC2) */
	mvn	r3, #0x0
3481f5cc:	e3e03000 	mvn	r3, #0
	str	r3, [r0, #0x14]				@ INTENCLEAR
3481f5d0:	e5803014 	str	r3, [r0, #20]
	str	r3, [r1, #0x14]				@ INTENCLEAR
3481f5d4:	e5813014 	str	r3, [r1, #20]
	str	r3, [r2, #0x14]				@ INTENCLEAR
3481f5d8:	e5823014 	str	r3, [r2, #20]

	/* Set all interrupts as IRQ */
	str	r5, [r0, #0xc]				@ INTSELECT
3481f5dc:	e580500c 	str	r5, [r0, #12]
	str	r5, [r1, #0xc]				@ INTSELECT
3481f5e0:	e581500c 	str	r5, [r1, #12]
	str	r5, [r2, #0xc]				@ INTSELECT
3481f5e4:	e582500c 	str	r5, [r2, #12]

	/* Pending Interrupt Clear */
	str	r5, [r0, #0xf00]			@ INTADDRESS
3481f5e8:	e5805f00 	str	r5, [r0, #3840]	; 0xf00
	str	r5, [r1, #0xf00]			@ INTADDRESS
3481f5ec:	e5815f00 	str	r5, [r1, #3840]	; 0xf00
	str	r5, [r2, #0xf00]			@ INTADDRESS
3481f5f0:	e5825f00 	str	r5, [r2, #3840]	; 0xf00

	/* for UART */
	bl	uart_asm_init
3481f5f4:	eb000072 	bl	3481f7c4 <uart_asm_init>

	bl	internal_ram_init
3481f5f8:	eb00006c 	bl	3481f7b0 <internal_ram_init>

	cmp	r7, r8
3481f5fc:	e1570008 	cmp	r7, r8
	/* Clear wakeup status register */
	ldreq	r0, =S5PC100_WAKEUP_STAT
3481f600:	059f028c 	ldreq	r0, [pc, #652]	; 3481f894 <uart_asm_init+0xd0>
	ldrne	r0, =S5PC110_WAKEUP_STAT
3481f604:	159f028c 	ldrne	r0, [pc, #652]	; 3481f898 <uart_asm_init+0xd4>
	ldr	r1, [r0]
3481f608:	e5901000 	ldr	r1, [r0]
	str	r1, [r0]
3481f60c:	e5801000 	str	r1, [r0]

	/* IO retension release */
	ldreq	r0, =S5PC100_OTHERS			@ 0xE0108200
3481f610:	059f026c 	ldreq	r0, [pc, #620]	; 3481f884 <uart_asm_init+0xc0>
	ldrne	r0, =S5PC110_OTHERS			@ 0xE010E000
3481f614:	159f026c 	ldrne	r0, [pc, #620]	; 3481f888 <uart_asm_init+0xc4>
	ldr	r1, [r0]
3481f618:	e5901000 	ldr	r1, [r0]
	ldreq	r2, =(1 << 31)				@ IO_RET_REL
3481f61c:	03a02102 	moveq	r2, #-2147483648	; 0x80000000
	ldrne	r2, =((1 << 31) | (1 << 30) | (1 << 29) | (1 << 28))
3481f620:	13a0220f 	movne	r2, #-268435456	; 0xf0000000
	orr	r1, r1, r2
3481f624:	e1811002 	orr	r1, r1, r2
	str	r1, [r0]
3481f628:	e5801000 	str	r1, [r0]

	b	1f
3481f62c:	ea00000c 	b	3481f664 <lockloop+0x30>

3481f630 <didle_wakeup>:

didle_wakeup:
	/* Wait when APLL is locked */
	ldr	r0, =0xE0100100			@ S5PC110_APLL_CON
3481f630:	e59f0264 	ldr	r0, [pc, #612]	; 3481f89c <uart_asm_init+0xd8>

3481f634 <lockloop>:
lockloop:
	ldr	r1, [r0]
3481f634:	e5901000 	ldr	r1, [r0]
	and	r1, r1, #(1 << 29)
3481f638:	e2011202 	and	r1, r1, #536870912	; 0x20000000
	cmp	r1, #(1 << 29)
3481f63c:	e3510202 	cmp	r1, #536870912	; 0x20000000
	bne	lockloop
3481f640:	1afffffb 	bne	3481f634 <lockloop>

	ldr	r0, =S5PC110_INFORM0
3481f644:	e59f0254 	ldr	r0, [pc, #596]	; 3481f8a0 <uart_asm_init+0xdc>
	ldr	r1, [r0]
3481f648:	e5901000 	ldr	r1, [r0]
	mov	pc, r1
3481f64c:	e1a0f001 	mov	pc, r1
	nop
3481f650:	e320f000 	nop	{0}
	nop
3481f654:	e320f000 	nop	{0}
	nop
3481f658:	e320f000 	nop	{0}
	nop
3481f65c:	e320f000 	nop	{0}
	nop
3481f660:	e320f000 	nop	{0}

1:
	mov	lr, r11
3481f664:	e1a0e00b 	mov	lr, fp
	mov	pc, lr
3481f668:	e1a0f00e 	mov	pc, lr

3481f66c <system_clock_init>:
/*
 * system_clock_init: Initialize core clock and bus clock.
 * void system_clock_init(void)
 */
system_clock_init:
	ldr	r0, =S5PC110_CLOCK_BASE		@ 0xE0100000
3481f66c:	e59f0230 	ldr	r0, [pc, #560]	; 3481f8a4 <uart_asm_init+0xe0>

	/* Check S5PC100 */
	cmp	r7, r8
3481f670:	e1570008 	cmp	r7, r8
	bne	110f
3481f674:	1a00001b 	bne	3481f6e8 <system_clock_init+0x7c>
100:
	/* Set Lock Time */
	ldr	r1, =0xe10			@ Locktime : 0xe10 = 3600
3481f678:	e3a01ee1 	mov	r1, #3600	; 0xe10
	str	r1, [r0, #0x000]		@ S5PC100_APLL_LOCK
3481f67c:	e5801000 	str	r1, [r0]
	str	r1, [r0, #0x004]		@ S5PC100_MPLL_LOCK
3481f680:	e5801004 	str	r1, [r0, #4]
	str	r1, [r0, #0x008]		@ S5PC100_EPLL_LOCK
3481f684:	e5801008 	str	r1, [r0, #8]
	str	r1, [r0, #0x00C]		@ S5PC100_HPLL_LOCK
3481f688:	e580100c 	str	r1, [r0, #12]

	/* S5P_APLL_CON */
	ldr	r1, =0x81bc0400		@ SDIV 0, PDIV 4, MDIV 444 (1333MHz)
3481f68c:	e59f1214 	ldr	r1, [pc, #532]	; 3481f8a8 <uart_asm_init+0xe4>
	str	r1, [r0, #0x100]
3481f690:	e5801100 	str	r1, [r0, #256]	; 0x100
	/* S5P_MPLL_CON */
	ldr	r1, =0x80590201		@ SDIV 1, PDIV 2, MDIV 89 (267MHz)
3481f694:	e59f1210 	ldr	r1, [pc, #528]	; 3481f8ac <uart_asm_init+0xe8>
	str	r1, [r0, #0x104]
3481f698:	e5801104 	str	r1, [r0, #260]	; 0x104
	/* S5P_EPLL_CON */
	ldr	r1, =0x80870303		@ SDIV 3, PDIV 3, MDIV 135 (67.5MHz)
3481f69c:	e59f120c 	ldr	r1, [pc, #524]	; 3481f8b0 <uart_asm_init+0xec>
	str	r1, [r0, #0x108]
3481f6a0:	e5801108 	str	r1, [r0, #264]	; 0x108
	/* S5P_HPLL_CON */
	ldr	r1, =0x80600603		@ SDIV 3, PDIV 6, MDIV 96
3481f6a4:	e59f1208 	ldr	r1, [pc, #520]	; 3481f8b4 <uart_asm_init+0xf0>
	str	r1, [r0, #0x10C]
3481f6a8:	e580110c 	str	r1, [r0, #268]	; 0x10c

	ldr     r1, [r0, #0x300]
3481f6ac:	e5901300 	ldr	r1, [r0, #768]	; 0x300
	ldr     r2, =0x00003fff
3481f6b0:	e59f2200 	ldr	r2, [pc, #512]	; 3481f8b8 <uart_asm_init+0xf4>
	bic     r1, r1, r2
3481f6b4:	e1c11002 	bic	r1, r1, r2
	ldr     r2, =0x00011301
3481f6b8:	e59f21fc 	ldr	r2, [pc, #508]	; 3481f8bc <uart_asm_init+0xf8>

	orr	r1, r1, r2
3481f6bc:	e1811002 	orr	r1, r1, r2
	str	r1, [r0, #0x300]
3481f6c0:	e5801300 	str	r1, [r0, #768]	; 0x300
	ldr     r1, [r0, #0x304]
3481f6c4:	e5901304 	ldr	r1, [r0, #772]	; 0x304
	ldr     r2, =0x00011110
3481f6c8:	e59f21f0 	ldr	r2, [pc, #496]	; 3481f8c0 <uart_asm_init+0xfc>
	orr     r1, r1, r2
3481f6cc:	e1811002 	orr	r1, r1, r2
	str     r1, [r0, #0x304]
3481f6d0:	e5801304 	str	r1, [r0, #772]	; 0x304
	ldr     r1, =0x00000001
3481f6d4:	e3a01001 	mov	r1, #1
	str     r1, [r0, #0x308]
3481f6d8:	e5801308 	str	r1, [r0, #776]	; 0x308

	/* Set Source Clock */
	ldr	r1, =0x00001111			@ A, M, E, HPLL Muxing
3481f6dc:	e59f11e0 	ldr	r1, [pc, #480]	; 3481f8c4 <uart_asm_init+0x100>
	str	r1, [r0, #0x200]		@ S5PC1XX_CLK_SRC0
3481f6e0:	e5801200 	str	r1, [r0, #512]	; 0x200

	b	200f
3481f6e4:	ea00002d 	b	3481f7a0 <system_clock_init+0x134>
110:
	ldr	r0, =0xE010C000			@ S5PC110_PWR_CFG
3481f6e8:	e59f01d8 	ldr	r0, [pc, #472]	; 3481f8c8 <uart_asm_init+0x104>

	/* Set OSC_FREQ value */
	ldr	r1, =0xf
3481f6ec:	e3a0100f 	mov	r1, #15
	str	r1, [r0, #0x100]		@ S5PC110_OSC_FREQ
3481f6f0:	e5801100 	str	r1, [r0, #256]	; 0x100

	/* Set MTC_STABLE value */
	ldr	r1, =0xffffffff
3481f6f4:	e3e01000 	mvn	r1, #0
	str	r1, [r0, #0x110]		@ S5PC110_MTC_STABLE
3481f6f8:	e5801110 	str	r1, [r0, #272]	; 0x110

	/* Set CLAMP_STABLE value */
	ldr	r1, =0x3ff03ff
3481f6fc:	e59f11c8 	ldr	r1, [pc, #456]	; 3481f8cc <uart_asm_init+0x108>
	str	r1, [r0, #0x114]		@ S5PC110_CLAMP_STABLE
3481f700:	e5801114 	str	r1, [r0, #276]	; 0x114

	ldr	r0, =S5PC110_CLOCK_BASE		@ 0xE0100000
3481f704:	e59f0198 	ldr	r0, [pc, #408]	; 3481f8a4 <uart_asm_init+0xe0>

	/* Set Clock divider */
	ldr	r1, =0x14131330			@ 1:1:4:4, 1:4:5
3481f708:	e59f11c0 	ldr	r1, [pc, #448]	; 3481f8d0 <uart_asm_init+0x10c>
	str	r1, [r0, #0x300]
3481f70c:	e5801300 	str	r1, [r0, #768]	; 0x300
	ldr	r1, =0x11110111			@ UART[3210]: MMC[3210]
3481f710:	e59f11bc 	ldr	r1, [pc, #444]	; 3481f8d4 <uart_asm_init+0x110>
	str	r1, [r0, #0x310]
3481f714:	e5801310 	str	r1, [r0, #784]	; 0x310

	/* Set Lock Time */
	ldr	r1, =0x2cf			@ Locktime : 30us
3481f718:	e59f11b8 	ldr	r1, [pc, #440]	; 3481f8d8 <uart_asm_init+0x114>
	str	r1, [r0, #0x000]		@ S5PC110_APLL_LOCK
3481f71c:	e5801000 	str	r1, [r0]
	ldr	r1, =0xe10			@ Locktime : 0xe10 = 3600
3481f720:	e3a01ee1 	mov	r1, #3600	; 0xe10
	str	r1, [r0, #0x008]		@ S5PC110_MPLL_LOCK
3481f724:	e5801008 	str	r1, [r0, #8]
	str	r1, [r0, #0x010]		@ S5PC110_EPLL_LOCK
3481f728:	e5801010 	str	r1, [r0, #16]
	str	r1, [r0, #0x020]		@ S5PC110_VPLL_LOCK
3481f72c:	e5801020 	str	r1, [r0, #32]

	/* S5PC110_APLL_CON */
	ldr	r1, =0x80C80601			@ 800MHz
3481f730:	e59f11a4 	ldr	r1, [pc, #420]	; 3481f8dc <uart_asm_init+0x118>
	str	r1, [r0, #0x100]
3481f734:	e5801100 	str	r1, [r0, #256]	; 0x100
	/* S5PC110_MPLL_CON */
	ldr	r1, =0x829B0C01			@ 667MHz
3481f738:	e59f11a0 	ldr	r1, [pc, #416]	; 3481f8e0 <uart_asm_init+0x11c>
	str	r1, [r0, #0x108]
3481f73c:	e5801108 	str	r1, [r0, #264]	; 0x108
	/* S5PC110_EPLL_CON */
	ldr	r1, =0x80600602			@  96MHz VSEL 0 P 6 M 96 S 2
3481f740:	e59f119c 	ldr	r1, [pc, #412]	; 3481f8e4 <uart_asm_init+0x120>
	str	r1, [r0, #0x110]
3481f744:	e5801110 	str	r1, [r0, #272]	; 0x110
	/* S5PC110_VPLL_CON */
	ldr	r1, =0x806C0603			@  54MHz
3481f748:	e59f1198 	ldr	r1, [pc, #408]	; 3481f8e8 <uart_asm_init+0x124>
	str	r1, [r0, #0x120]
3481f74c:	e5801120 	str	r1, [r0, #288]	; 0x120

	/* Set Source Clock */
	ldr	r1, =0x10001111			@ A, M, E, VPLL Muxing
3481f750:	e59f1194 	ldr	r1, [pc, #404]	; 3481f8ec <uart_asm_init+0x128>
	str	r1, [r0, #0x200]		@ S5PC1XX_CLK_SRC0
3481f754:	e5801200 	str	r1, [r0, #512]	; 0x200

	/* OneDRAM(DMC0) clock setting */
	ldr	r1, =0x01000000			@ ONEDRAM_SEL[25:24] 1 SCLKMPLL
3481f758:	e3a01401 	mov	r1, #16777216	; 0x1000000
	str	r1, [r0, #0x218]		@ S5PC110_CLK_SRC6
3481f75c:	e5801218 	str	r1, [r0, #536]	; 0x218
	ldr	r1, =0x30000000			@ ONEDRAM_RATIO[31:28] 3 + 1
3481f760:	e3a01203 	mov	r1, #805306368	; 0x30000000
	str	r1, [r0, #0x318]		@ S5PC110_CLK_DIV6
3481f764:	e5801318 	str	r1, [r0, #792]	; 0x318

	/* XCLKOUT = XUSBXTI 24MHz */
	add	r2, r0, #0xE000			@ S5PC110_OTHERS
3481f768:	e2802a0e 	add	r2, r0, #57344	; 0xe000
	ldr     r1, [r2]
3481f76c:	e5921000 	ldr	r1, [r2]
	orr	r1, r1, #(0x3 << 8)		@ CLKOUT[9:8] 3 XUSBXTI
3481f770:	e3811c03 	orr	r1, r1, #768	; 0x300
	str	r1, [r2]
3481f774:	e5821000 	str	r1, [r2]

	/* CLK_IP0 */
	ldr	r1, =0x8fefeeb			@ DMC[1:0] PDMA0[3] IMEM[5]
3481f778:	e59f1170 	ldr	r1, [pc, #368]	; 3481f8f0 <uart_asm_init+0x12c>
	str	r1, [r0, #0x460]		@ S5PC110_CLK_IP0
3481f77c:	e5801460 	str	r1, [r0, #1120]	; 0x460

	/* CLK_IP1 */
	ldr	r1, =0xe9fdf0f9			@ FIMD[0] USBOTG[16]
3481f780:	e59f116c 	ldr	r1, [pc, #364]	; 3481f8f4 <uart_asm_init+0x130>
						@ NANDXL[24]
	str	r1, [r0, #0x464]		@ S5PC110_CLK_IP1
3481f784:	e5801464 	str	r1, [r0, #1124]	; 0x464

	/* CLK_IP2 */
	ldr	r1, =0xf75f7fc			@ CORESIGHT[8] MODEM[9]
3481f788:	e59f1168 	ldr	r1, [pc, #360]	; 3481f8f8 <uart_asm_init+0x134>
						@ HOSTIF[10] HSMMC0[16]
						@ HSMMC2[18] VIC[27:24]
	str	r1, [r0, #0x468]		@ S5PC110_CLK_IP2
3481f78c:	e5801468 	str	r1, [r0, #1128]	; 0x468

	/* CLK_IP3 */
	ldr	r1, =0x8eff038c			@ I2C[8:6]
3481f790:	e59f1164 	ldr	r1, [pc, #356]	; 3481f8fc <uart_asm_init+0x138>
						@ SYSTIMER[16] UART0[17]
						@ UART1[18] UART2[19]
						@ UART3[20] WDT[22]
						@ PWM[23] GPIO[26] SYSCON[27]
	str	r1, [r0, #0x46c]		@ S5PC110_CLK_IP3
3481f794:	e580146c 	str	r1, [r0, #1132]	; 0x46c

	/* CLK_IP4 */
	ldr	r1, =0xfffffff1			@ CHIP_ID[0] TZPC[8:5]
3481f798:	e3e0100e 	mvn	r1, #14
	str	r1, [r0, #0x470]		@ S5PC110_CLK_IP3
3481f79c:	e5801470 	str	r1, [r0, #1136]	; 0x470

200:
	/* wait at least 200us to stablize all clock */
	mov	r2, #0x10000
3481f7a0:	e3a02801 	mov	r2, #65536	; 0x10000
1:	subs	r2, r2, #1
3481f7a4:	e2522001 	subs	r2, r2, #1
	bne	1b
3481f7a8:	1afffffd 	bne	3481f7a4 <system_clock_init+0x138>

	mov	pc, lr
3481f7ac:	e1a0f00e 	mov	pc, lr

3481f7b0 <internal_ram_init>:

internal_ram_init:
	ldreq	r0, =0xE3800000
3481f7b0:	059f0148 	ldreq	r0, [pc, #328]	; 3481f900 <uart_asm_init+0x13c>
	ldrne	r0, =0xF1500000
3481f7b4:	159f0148 	ldrne	r0, [pc, #328]	; 3481f904 <uart_asm_init+0x140>
	ldr	r1, =0x0
3481f7b8:	e3a01000 	mov	r1, #0
	str	r1, [r0]
3481f7bc:	e5801000 	str	r1, [r0]

	mov	pc, lr
3481f7c0:	e1a0f00e 	mov	pc, lr

3481f7c4 <uart_asm_init>:
/*
 * uart_asm_init: Initialize UART's pins
 */
uart_asm_init:
	/* set GPIO to enable UART0-UART4 */
	mov	r0, r8
3481f7c4:	e1a00008 	mov	r0, r8
	ldr	r1, =0x22222222
3481f7c8:	e59f1138 	ldr	r1, [pc, #312]	; 3481f908 <uart_asm_init+0x144>
	str	r1, [r0, #0x0]			@ S5PC100_GPIO_A0_OFFSET
3481f7cc:	e5801000 	str	r1, [r0]
	ldr	r1, =0x00002222
3481f7d0:	e59f1134 	ldr	r1, [pc, #308]	; 3481f90c <uart_asm_init+0x148>
	str	r1, [r0, #0x20]			@ S5PC100_GPIO_A1_OFFSET
3481f7d4:	e5801020 	str	r1, [r0, #32]

	/* Check S5PC100 */
	cmp	r7, r8
3481f7d8:	e1570008 	cmp	r7, r8
	bne	110f
3481f7dc:	1a00000c 	bne	3481f814 <uart_asm_init+0x50>

	/* UART_SEL GPK0[5] at S5PC100 */
	add	r0, r8, #0x2A0			@ S5PC100_GPIO_K0_OFFSET
3481f7e0:	e2880e2a 	add	r0, r8, #672	; 0x2a0
	ldr	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
3481f7e4:	e5901000 	ldr	r1, [r0]
	bic	r1, r1, #(0xf << 20)		@ 20 = 5 * 4-bit
3481f7e8:	e3c1160f 	bic	r1, r1, #15728640	; 0xf00000
	orr	r1, r1, #(0x1 << 20)		@ Output
3481f7ec:	e3811601 	orr	r1, r1, #1048576	; 0x100000
	str	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
3481f7f0:	e5801000 	str	r1, [r0]

	ldr	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
3481f7f4:	e5901008 	ldr	r1, [r0, #8]
	bic	r1, r1, #(0x3 << 10)		@ 10 = 5 * 2-bit
3481f7f8:	e3c11b03 	bic	r1, r1, #3072	; 0xc00
	orr	r1, r1, #(0x2 << 10)		@ Pull-up enabled
3481f7fc:	e3811b02 	orr	r1, r1, #2048	; 0x800
	str	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
3481f800:	e5801008 	str	r1, [r0, #8]

	ldr	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
3481f804:	e5901004 	ldr	r1, [r0, #4]
	orr	r1, r1, #(1 << 5)		@ 5 = 5 * 1-bit
3481f808:	e3811020 	orr	r1, r1, #32
	str	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
3481f80c:	e5801004 	str	r1, [r0, #4]

	b	200f
3481f810:	ea00000b 	b	3481f844 <uart_asm_init+0x80>
	/*
	 * Note that the following address
	 * 0xE020'0360 is reserved address at S5PC100
	 */
	/* UART_SEL MP0_5[7] at S5PC110 */
	add	r0, r8, #0x360			@ S5PC110_GPIO_MP0_5_OFFSET
3481f814:	e2880e36 	add	r0, r8, #864	; 0x360
	ldr	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
3481f818:	e5901000 	ldr	r1, [r0]
	bic	r1, r1, #(0xf << 28)		@ 28 = 7 * 4-bit
3481f81c:	e3c1120f 	bic	r1, r1, #-268435456	; 0xf0000000
	orr	r1, r1, #(0x1 << 28)		@ Output
3481f820:	e3811201 	orr	r1, r1, #268435456	; 0x10000000
	str	r1, [r0, #0x0]			@ S5PC1XX_GPIO_CON_OFFSET
3481f824:	e5801000 	str	r1, [r0]

	ldr	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
3481f828:	e5901008 	ldr	r1, [r0, #8]
	bic	r1, r1, #(0x3 << 14)		@ 14 = 7 * 2-bit
3481f82c:	e3c11903 	bic	r1, r1, #49152	; 0xc000
	orr	r1, r1, #(0x2 << 14)		@ Pull-up enabled
3481f830:	e3811902 	orr	r1, r1, #32768	; 0x8000
	str	r1, [r0, #0x8]			@ S5PC1XX_GPIO_PULL_OFFSET
3481f834:	e5801008 	str	r1, [r0, #8]

	ldr	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
3481f838:	e5901004 	ldr	r1, [r0, #4]
	orr	r1, r1, #(1 << 7)		@ 7 = 7 * 1-bit
3481f83c:	e3811080 	orr	r1, r1, #128	; 0x80
	str	r1, [r0, #0x4]			@ S5PC1XX_GPIO_DAT_OFFSET
3481f840:	e5801004 	str	r1, [r0, #4]
200:
	mov	pc, lr
3481f844:	e1a0f00e 	mov	pc, lr
3481f848:	e0300000 	.word	0xe0300000
3481f84c:	e0200000 	.word	0xe0200000
3481f850:	e010a000 	.word	0xe010a000
3481f854:	e0f00000 	.word	0xe0f00000
3481f858:	e1f00000 	.word	0xe1f00000
3481f85c:	f1800000 	.word	0xf1800000
3481f860:	f1900000 	.word	0xf1900000
3481f864:	f1a00000 	.word	0xf1a00000
3481f868:	f1b00000 	.word	0xf1b00000
3481f86c:	f1c00000 	.word	0xf1c00000
3481f870:	f1d00000 	.word	0xf1d00000
3481f874:	f1e00000 	.word	0xf1e00000
3481f878:	f1f00000 	.word	0xf1f00000
3481f87c:	faf00000 	.word	0xfaf00000
3481f880:	e010c300 	.word	0xe010c300
3481f884:	e0108200 	.word	0xe0108200
3481f888:	e010e000 	.word	0xe010e000
3481f88c:	ea200000 	.word	0xea200000
3481f890:	e2700000 	.word	0xe2700000
3481f894:	e0108304 	.word	0xe0108304
3481f898:	e010c200 	.word	0xe010c200
3481f89c:	e0100100 	.word	0xe0100100
3481f8a0:	e010f000 	.word	0xe010f000
3481f8a4:	e0100000 	.word	0xe0100000
3481f8a8:	81bc0400 	.word	0x81bc0400
3481f8ac:	80590201 	.word	0x80590201
3481f8b0:	80870303 	.word	0x80870303
3481f8b4:	80600603 	.word	0x80600603
3481f8b8:	00003fff 	.word	0x00003fff
3481f8bc:	00011301 	.word	0x00011301
3481f8c0:	00011110 	.word	0x00011110
3481f8c4:	00001111 	.word	0x00001111
3481f8c8:	e010c000 	.word	0xe010c000
3481f8cc:	03ff03ff 	.word	0x03ff03ff
3481f8d0:	14131330 	.word	0x14131330
3481f8d4:	11110111 	.word	0x11110111
3481f8d8:	000002cf 	.word	0x000002cf
3481f8dc:	80c80601 	.word	0x80c80601
3481f8e0:	829b0c01 	.word	0x829b0c01
3481f8e4:	80600602 	.word	0x80600602
3481f8e8:	806c0603 	.word	0x806c0603
3481f8ec:	10001111 	.word	0x10001111
3481f8f0:	08fefeeb 	.word	0x08fefeeb
3481f8f4:	e9fdf0f9 	.word	0xe9fdf0f9
3481f8f8:	0f75f7fc 	.word	0x0f75f7fc
3481f8fc:	8eff038c 	.word	0x8eff038c
3481f900:	e3800000 	.word	0xe3800000
3481f904:	f1500000 	.word	0xf1500000
3481f908:	22222222 	.word	0x22222222
3481f90c:	00002222 	.word	0x00002222

3481f910 <s5pc1xx_phy_control>:
}
#endif

#ifdef CONFIG_USB_GADGET
static int s5pc1xx_phy_control(int on)
{
3481f910:	e92d4070 	push	{r4, r5, r6, lr}
3481f914:	e1a06000 	mov	r6, r0
	int ret;
	static int status;
	struct pmic *p = get_pmic();
3481f918:	ebffc4ad 	bl	34810bd4 <get_pmic>
3481f91c:	e1a05000 	mov	r5, r0

	if (pmic_probe(p))
3481f920:	ebffc508 	bl	34810d48 <pmic_probe>
3481f924:	e3500000 	cmp	r0, #0
3481f928:	1a00002c 	bne	3481f9e0 <s5pc1xx_phy_control+0xd0>
		return -1;

	if (on && !status) {
3481f92c:	e3560000 	cmp	r6, #0
3481f930:	e59f40b0 	ldr	r4, [pc, #176]	; 3481f9e8 <s5pc1xx_phy_control+0xd8>
3481f934:	0a000011 	beq	3481f980 <s5pc1xx_phy_control+0x70>
3481f938:	e5943000 	ldr	r3, [r4]
3481f93c:	e3530000 	cmp	r3, #0
3481f940:	1a000022 	bne	3481f9d0 <s5pc1xx_phy_control+0xc0>
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
3481f944:	e3a01011 	mov	r1, #17
3481f948:	e3a02004 	mov	r2, #4
3481f94c:	e2833001 	add	r3, r3, #1
3481f950:	e1a00005 	mov	r0, r5
3481f954:	ebffc488 	bl	34810b7c <pmic_set_output>
				      MAX8998_LDO3, LDO_ON);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
3481f958:	e3a03001 	mov	r3, #1
3481f95c:	e1a00005 	mov	r0, r5
3481f960:	e3a01012 	mov	r1, #18
3481f964:	e3a02020 	mov	r2, #32
3481f968:	ebffc483 	bl	34810b7c <pmic_set_output>
				      MAX8998_LDO8, LDO_ON);
		if (ret) {
3481f96c:	e3500000 	cmp	r0, #0
			puts("MAX8998 LDO setting error!\n");
			return -1;
		}
		status = 1;
3481f970:	03a03001 	moveq	r3, #1
3481f974:	05843000 	streq	r3, [r4]
	if (on && !status) {
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
				      MAX8998_LDO3, LDO_ON);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
				      MAX8998_LDO8, LDO_ON);
		if (ret) {
3481f978:	0a000014 	beq	3481f9d0 <s5pc1xx_phy_control+0xc0>
3481f97c:	ea00000f 	b	3481f9c0 <s5pc1xx_phy_control+0xb0>
			puts("MAX8998 LDO setting error!\n");
			return -1;
		}
		status = 1;
	} else if (!on && status) {
3481f980:	e5943000 	ldr	r3, [r4]
3481f984:	e3530000 	cmp	r3, #0
3481f988:	0a000010 	beq	3481f9d0 <s5pc1xx_phy_control+0xc0>
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
3481f98c:	e3a01011 	mov	r1, #17
3481f990:	e3a02004 	mov	r2, #4
3481f994:	e1a03006 	mov	r3, r6
3481f998:	e1a00005 	mov	r0, r5
3481f99c:	ebffc476 	bl	34810b7c <pmic_set_output>
				      MAX8998_LDO3, LDO_OFF);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
3481f9a0:	e1a00005 	mov	r0, r5
3481f9a4:	e3a01012 	mov	r1, #18
3481f9a8:	e3a02020 	mov	r2, #32
3481f9ac:	e1a03006 	mov	r3, r6
3481f9b0:	ebffc471 	bl	34810b7c <pmic_set_output>
				      MAX8998_LDO8, LDO_OFF);
		if (ret) {
3481f9b4:	e3500000 	cmp	r0, #0
			puts("MAX8998 LDO setting error!\n");
			return -1;
		}
		status = 0;
3481f9b8:	05840000 	streq	r0, [r4]
	} else if (!on && status) {
		ret = pmic_set_output(p, MAX8998_REG_ONOFF1,
				      MAX8998_LDO3, LDO_OFF);
		ret = pmic_set_output(p, MAX8998_REG_ONOFF2,
				      MAX8998_LDO8, LDO_OFF);
		if (ret) {
3481f9bc:	0a000003 	beq	3481f9d0 <s5pc1xx_phy_control+0xc0>
			puts("MAX8998 LDO setting error!\n");
3481f9c0:	e59f0024 	ldr	r0, [pc, #36]	; 3481f9ec <s5pc1xx_phy_control+0xdc>
3481f9c4:	ebffa5dc 	bl	3480913c <puts>
			return -1;
3481f9c8:	e3e00000 	mvn	r0, #0
3481f9cc:	e8bd8070 	pop	{r4, r5, r6, pc}
		}
		status = 0;
	}
	udelay(10000);
3481f9d0:	e3020710 	movw	r0, #10000	; 0x2710
3481f9d4:	ebfff1e9 	bl	3481c180 <udelay>

	return 0;
3481f9d8:	e3a00000 	mov	r0, #0
3481f9dc:	e8bd8070 	pop	{r4, r5, r6, pc}
	int ret;
	static int status;
	struct pmic *p = get_pmic();

	if (pmic_probe(p))
		return -1;
3481f9e0:	e3e00000 	mvn	r0, #0
		status = 0;
	}
	udelay(10000);

	return 0;
}
3481f9e4:	e8bd8070 	pop	{r4, r5, r6, pc}
3481f9e8:	3482bc60 	.word	0x3482bc60
3481f9ec:	3482828e 	.word	0x3482828e

3481f9f0 <board_init>:
DECLARE_GLOBAL_DATA_PTR;

static struct s5pc110_gpio *s5pc110_gpio;

int board_init(void)
{
3481f9f0:	e92d4008 	push	{r3, lr}
	/* Set Initial global variables */
	s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;
3481f9f4:	e59f2028 	ldr	r2, [pc, #40]	; 3481fa24 <board_init+0x34>
3481f9f8:	e59f3028 	ldr	r3, [pc, #40]	; 3481fa28 <board_init+0x38>

	gd->bd->bi_arch_number = MACH_TYPE_GONI;
3481f9fc:	e3001b2e 	movw	r1, #2862	; 0xb2e
static struct s5pc110_gpio *s5pc110_gpio;

int board_init(void)
{
	/* Set Initial global variables */
	s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;
3481fa00:	e5832004 	str	r2, [r3, #4]

	gd->bd->bi_arch_number = MACH_TYPE_GONI;
3481fa04:	e5982000 	ldr	r2, [r8]
	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
3481fa08:	e5983000 	ldr	r3, [r8]
int board_init(void)
{
	/* Set Initial global variables */
	s5pc110_gpio = (struct s5pc110_gpio *)S5PC110_GPIO_BASE;

	gd->bd->bi_arch_number = MACH_TYPE_GONI;
3481fa0c:	e5821004 	str	r1, [r2, #4]
	gd->bd->bi_boot_params = PHYS_SDRAM_1 + 0x100;
3481fa10:	e59f2014 	ldr	r2, [pc, #20]	; 3481fa2c <board_init+0x3c>
3481fa14:	e5832008 	str	r2, [r3, #8]

#if defined(CONFIG_PMIC)
	pmic_init();
3481fa18:	ebffc4d8 	bl	34810d80 <pmic_init>
#endif
	return 0;
}
3481fa1c:	e3a00000 	mov	r0, #0
3481fa20:	e8bd8008 	pop	{r3, pc}
3481fa24:	e0200000 	.word	0xe0200000
3481fa28:	3482bc60 	.word	0x3482bc60
3481fa2c:	30000100 	.word	0x30000100

3481fa30 <dram_init>:

int dram_init(void)
{
	gd->ram_size = PHYS_SDRAM_1_SIZE + PHYS_SDRAM_2_SIZE +
3481fa30:	e3a0241d 	mov	r2, #486539264	; 0x1d000000
3481fa34:	e5882038 	str	r2, [r8, #56]	; 0x38
			PHYS_SDRAM_3_SIZE;

	return 0;
}
3481fa38:	e3a00000 	mov	r0, #0
3481fa3c:	e12fff1e 	bx	lr

3481fa40 <dram_init_banksize>:

void dram_init_banksize(void)
{
	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
3481fa40:	e5982000 	ldr	r2, [r8]
3481fa44:	e3a01203 	mov	r1, #805306368	; 0x30000000
3481fa48:	e5821018 	str	r1, [r2, #24]
	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
3481fa4c:	e5982000 	ldr	r2, [r8]
3481fa50:	e28114d5 	add	r1, r1, #-721420288	; 0xd5000000
3481fa54:	e582101c 	str	r1, [r2, #28]
	gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
3481fa58:	e5982000 	ldr	r2, [r8]
3481fa5c:	e281143b 	add	r1, r1, #989855744	; 0x3b000000
3481fa60:	e5821020 	str	r1, [r2, #32]
	gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
3481fa64:	e5982000 	ldr	r2, [r8]
3481fa68:	e281120d 	add	r1, r1, #-805306368	; 0xd0000000
3481fa6c:	e5821024 	str	r1, [r2, #36]	; 0x24
	gd->bd->bi_dram[2].start = PHYS_SDRAM_3;
3481fa70:	e5982000 	ldr	r2, [r8]
3481fa74:	e2811101 	add	r1, r1, #1073741824	; 0x40000000
	gd->bd->bi_dram[2].size = PHYS_SDRAM_3_SIZE;
3481fa78:	e5983000 	ldr	r3, [r8]
{
	gd->bd->bi_dram[0].start = PHYS_SDRAM_1;
	gd->bd->bi_dram[0].size = PHYS_SDRAM_1_SIZE;
	gd->bd->bi_dram[1].start = PHYS_SDRAM_2;
	gd->bd->bi_dram[1].size = PHYS_SDRAM_2_SIZE;
	gd->bd->bi_dram[2].start = PHYS_SDRAM_3;
3481fa7c:	e5821028 	str	r1, [r2, #40]	; 0x28
	gd->bd->bi_dram[2].size = PHYS_SDRAM_3_SIZE;
3481fa80:	e3a02302 	mov	r2, #134217728	; 0x8000000
3481fa84:	e583202c 	str	r2, [r3, #44]	; 0x2c
}
3481fa88:	e12fff1e 	bx	lr

3481fa8c <checkboard>:

#ifdef CONFIG_DISPLAY_BOARDINFO
int checkboard(void)
{
3481fa8c:	e92d4008 	push	{r3, lr}
	puts("Board:\tGoni\n");
3481fa90:	e59f0008 	ldr	r0, [pc, #8]	; 3481faa0 <checkboard+0x14>
3481fa94:	ebffa5a8 	bl	3480913c <puts>
	return 0;
}
3481fa98:	e3a00000 	mov	r0, #0
3481fa9c:	e8bd8008 	pop	{r3, pc}
3481faa0:	348282aa 	.word	0x348282aa

3481faa4 <board_mmc_init>:
#endif

#ifdef CONFIG_GENERIC_MMC
int board_mmc_init(bd_t *bis)
{
3481faa4:	e92d4070 	push	{r4, r5, r6, lr}
	int i;

	/* MASSMEMORY_EN: XMSMDATA7: GPJ2[7] output high */
	s5p_gpio_direction_output(&s5pc110_gpio->j2, 7, 1);
3481faa8:	e59f5098 	ldr	r5, [pc, #152]	; 3481fb48 <board_mmc_init+0xa4>
3481faac:	e3a01007 	mov	r1, #7
3481fab0:	e5950004 	ldr	r0, [r5, #4]
3481fab4:	e3a02001 	mov	r2, #1
3481fab8:	e2800d0a 	add	r0, r0, #640	; 0x280
3481fabc:	ebffc0cb 	bl	3480fdf0 <s5p_gpio_direction_output>
	 * GPG0[0]	SD_0_CLK
	 * GPG0[1]	SD_0_CMD
	 * GPG0[2]	SD_0_CDn	-> Not used
	 * GPG0[3:6]	SD_0_DATA[0:3]
	 */
	for (i = 0; i < 7; i++) {
3481fac0:	e3a04000 	mov	r4, #0
		if (i == 2)
3481fac4:	e3540002 	cmp	r4, #2
3481fac8:	0a00000e 	beq	3481fb08 <board_mmc_init+0x64>
			continue;
		/* GPG0[0:6] special function 2 */
		s5p_gpio_cfg_pin(&s5pc110_gpio->g0, i, 0x2);
3481facc:	e5950004 	ldr	r0, [r5, #4]
3481fad0:	e1a01004 	mov	r1, r4
3481fad4:	e2800e1a 	add	r0, r0, #416	; 0x1a0
3481fad8:	e3a02002 	mov	r2, #2
3481fadc:	ebffc0bc 	bl	3480fdd4 <s5p_gpio_cfg_pin>
		/* GPG0[0:6] pull disable */
		s5p_gpio_set_pull(&s5pc110_gpio->g0, i, GPIO_PULL_NONE);
3481fae0:	e5950004 	ldr	r0, [r5, #4]
3481fae4:	e1a01004 	mov	r1, r4
3481fae8:	e2800e1a 	add	r0, r0, #416	; 0x1a0
3481faec:	e3a02000 	mov	r2, #0
3481faf0:	ebffc0dc 	bl	3480fe68 <s5p_gpio_set_pull>
		/* GPG0[0:6] drv 4x */
		s5p_gpio_set_drv(&s5pc110_gpio->g0, i, GPIO_DRV_4X);
3481faf4:	e5950004 	ldr	r0, [r5, #4]
3481faf8:	e1a01004 	mov	r1, r4
3481fafc:	e2800e1a 	add	r0, r0, #416	; 0x1a0
3481fb00:	e3a02003 	mov	r2, #3
3481fb04:	ebffc0e0 	bl	3480fe8c <s5p_gpio_set_drv>
	 * GPG0[0]	SD_0_CLK
	 * GPG0[1]	SD_0_CMD
	 * GPG0[2]	SD_0_CDn	-> Not used
	 * GPG0[3:6]	SD_0_DATA[0:3]
	 */
	for (i = 0; i < 7; i++) {
3481fb08:	e2844001 	add	r4, r4, #1
3481fb0c:	e3540007 	cmp	r4, #7
3481fb10:	1affffeb 	bne	3481fac4 <board_mmc_init+0x20>
static inline int cpu_is_##type(void)			\
{							\
	return s5p_cpu_id == id ? 1 : 0;		\
}

IS_SAMSUNG_TYPE(s5pc100, 0xc100)
3481fb14:	e59f3030 	ldr	r3, [pc, #48]	; 3481fb4c <board_mmc_init+0xa8>
3481fb18:	e5933000 	ldr	r3, [r3]
}

SAMSUNG_BASE(clock, CLOCK_BASE)
SAMSUNG_BASE(gpio, GPIO_BASE)
SAMSUNG_BASE(pro_id, PRO_ID)
SAMSUNG_BASE(mmc, MMC_BASE)
3481fb1c:	e3530cc1 	cmp	r3, #49408	; 0xc100
3481fb20:	059f0028 	ldreq	r0, [pc, #40]	; 3481fb50 <board_mmc_init+0xac>
3481fb24:	0a000003 	beq	3481fb38 <board_mmc_init+0x94>
3481fb28:	e30c0110 	movw	r0, #49424	; 0xc110
3481fb2c:	e1530000 	cmp	r3, r0
3481fb30:	03a004eb 	moveq	r0, #-352321536	; 0xeb000000
3481fb34:	13a00000 	movne	r0, #0
int s5p_sdhci_init(u32 regbase, int index, int bus_width);

static inline unsigned int s5p_mmc_init(int index, int bus_width)
{
	unsigned int base = samsung_get_base_mmc() + (0x10000 * index);
	return s5p_sdhci_init(base, index, bus_width);
3481fb38:	e3a01000 	mov	r1, #0
3481fb3c:	e3a02004 	mov	r2, #4
		/* GPG0[0:6] drv 4x */
		s5p_gpio_set_drv(&s5pc110_gpio->g0, i, GPIO_DRV_4X);
	}

	return s5p_mmc_init(0, 4);
}
3481fb40:	e8bd4070 	pop	{r4, r5, r6, lr}
3481fb44:	eaffcc6e 	b	34812d04 <s5p_sdhci_init>
3481fb48:	3482bc60 	.word	0x3482bc60
3481fb4c:	348282ec 	.word	0x348282ec
3481fb50:	ed800000 	.word	0xed800000

3481fb54 <onenand_board_init>:
#include <linux/mtd/samsung_onenand.h>
#include <onenand_uboot.h>

void onenand_board_init(struct mtd_info *mtd)
{
	struct onenand_chip *this = mtd->priv;
3481fb54:	e5903094 	ldr	r3, [r0, #148]	; 0x94

	this->base = (void *)CONFIG_SYS_ONENAND_BASE;
3481fb58:	e3a0220b 	mov	r2, #-1342177280	; 0xb0000000
3481fb5c:	e5832000 	str	r2, [r3]
	this->options |= ONENAND_RUNTIME_BADBLOCK_CHECK;
3481fb60:	e593202c 	ldr	r2, [r3, #44]	; 0x2c
3481fb64:	e3822c02 	orr	r2, r2, #512	; 0x200
3481fb68:	e583202c 	str	r2, [r3, #44]	; 0x2c
	this->chip_probe = s5pc110_chip_probe;
3481fb6c:	e59f2004 	ldr	r2, [pc, #4]	; 3481fb78 <onenand_board_init+0x24>
3481fb70:	e5832070 	str	r2, [r3, #112]	; 0x70
}
3481fb74:	e12fff1e 	bx	lr
3481fb78:	34817c94 	.word	0x34817c94

3481fb7c <raise>:
 */

#include <common.h>

int raise (int signum)
{
3481fb7c:	e1a01000 	mov	r1, r0
3481fb80:	e92d4008 	push	{r3, lr}
	/* Even if printf() is available, it's large. Punt it for SPL builds */
#if !defined(CONFIG_SPL_BUILD)
	printf("raise: Signal # %d caught\n", signum);
3481fb84:	e59f0008 	ldr	r0, [pc, #8]	; 3481fb94 <raise+0x18>
3481fb88:	ebffa575 	bl	34809164 <printf>
#endif
	return 0;
}
3481fb8c:	e3a00000 	mov	r0, #0
3481fb90:	e8bd8008 	pop	{r3, pc}
3481fb94:	348282b7 	.word	0x348282b7

3481fb98 <__aeabi_unwind_cpp_pr0>:

/* Dummy function to avoid linker complaints */
void __aeabi_unwind_cpp_pr0(void)
{
};
3481fb98:	e12fff1e 	bx	lr

3481fb9c <__aeabi_unwind_cpp_pr1>:

void __aeabi_unwind_cpp_pr1(void)
{
};
3481fb9c:	e12fff1e 	bx	lr

3481fba0 <__udivsi3>:
3481fba0:	e2512001 	subs	r2, r1, #1
3481fba4:	012fff1e 	bxeq	lr
3481fba8:	3a000074 	bcc	3481fd80 <__udivsi3+0x1e0>
3481fbac:	e1500001 	cmp	r0, r1
3481fbb0:	9a00006b 	bls	3481fd64 <__udivsi3+0x1c4>
3481fbb4:	e1110002 	tst	r1, r2
3481fbb8:	0a00006c 	beq	3481fd70 <__udivsi3+0x1d0>
3481fbbc:	e16f3f10 	clz	r3, r0
3481fbc0:	e16f2f11 	clz	r2, r1
3481fbc4:	e0423003 	sub	r3, r2, r3
3481fbc8:	e273301f 	rsbs	r3, r3, #31
3481fbcc:	10833083 	addne	r3, r3, r3, lsl #1
3481fbd0:	e3a02000 	mov	r2, #0
3481fbd4:	108ff103 	addne	pc, pc, r3, lsl #2
3481fbd8:	e320f000 	nop	{0}
3481fbdc:	e1500f81 	cmp	r0, r1, lsl #31
3481fbe0:	e0a22002 	adc	r2, r2, r2
3481fbe4:	20400f81 	subcs	r0, r0, r1, lsl #31
3481fbe8:	e1500f01 	cmp	r0, r1, lsl #30
3481fbec:	e0a22002 	adc	r2, r2, r2
3481fbf0:	20400f01 	subcs	r0, r0, r1, lsl #30
3481fbf4:	e1500e81 	cmp	r0, r1, lsl #29
3481fbf8:	e0a22002 	adc	r2, r2, r2
3481fbfc:	20400e81 	subcs	r0, r0, r1, lsl #29
3481fc00:	e1500e01 	cmp	r0, r1, lsl #28
3481fc04:	e0a22002 	adc	r2, r2, r2
3481fc08:	20400e01 	subcs	r0, r0, r1, lsl #28
3481fc0c:	e1500d81 	cmp	r0, r1, lsl #27
3481fc10:	e0a22002 	adc	r2, r2, r2
3481fc14:	20400d81 	subcs	r0, r0, r1, lsl #27
3481fc18:	e1500d01 	cmp	r0, r1, lsl #26
3481fc1c:	e0a22002 	adc	r2, r2, r2
3481fc20:	20400d01 	subcs	r0, r0, r1, lsl #26
3481fc24:	e1500c81 	cmp	r0, r1, lsl #25
3481fc28:	e0a22002 	adc	r2, r2, r2
3481fc2c:	20400c81 	subcs	r0, r0, r1, lsl #25
3481fc30:	e1500c01 	cmp	r0, r1, lsl #24
3481fc34:	e0a22002 	adc	r2, r2, r2
3481fc38:	20400c01 	subcs	r0, r0, r1, lsl #24
3481fc3c:	e1500b81 	cmp	r0, r1, lsl #23
3481fc40:	e0a22002 	adc	r2, r2, r2
3481fc44:	20400b81 	subcs	r0, r0, r1, lsl #23
3481fc48:	e1500b01 	cmp	r0, r1, lsl #22
3481fc4c:	e0a22002 	adc	r2, r2, r2
3481fc50:	20400b01 	subcs	r0, r0, r1, lsl #22
3481fc54:	e1500a81 	cmp	r0, r1, lsl #21
3481fc58:	e0a22002 	adc	r2, r2, r2
3481fc5c:	20400a81 	subcs	r0, r0, r1, lsl #21
3481fc60:	e1500a01 	cmp	r0, r1, lsl #20
3481fc64:	e0a22002 	adc	r2, r2, r2
3481fc68:	20400a01 	subcs	r0, r0, r1, lsl #20
3481fc6c:	e1500981 	cmp	r0, r1, lsl #19
3481fc70:	e0a22002 	adc	r2, r2, r2
3481fc74:	20400981 	subcs	r0, r0, r1, lsl #19
3481fc78:	e1500901 	cmp	r0, r1, lsl #18
3481fc7c:	e0a22002 	adc	r2, r2, r2
3481fc80:	20400901 	subcs	r0, r0, r1, lsl #18
3481fc84:	e1500881 	cmp	r0, r1, lsl #17
3481fc88:	e0a22002 	adc	r2, r2, r2
3481fc8c:	20400881 	subcs	r0, r0, r1, lsl #17
3481fc90:	e1500801 	cmp	r0, r1, lsl #16
3481fc94:	e0a22002 	adc	r2, r2, r2
3481fc98:	20400801 	subcs	r0, r0, r1, lsl #16
3481fc9c:	e1500781 	cmp	r0, r1, lsl #15
3481fca0:	e0a22002 	adc	r2, r2, r2
3481fca4:	20400781 	subcs	r0, r0, r1, lsl #15
3481fca8:	e1500701 	cmp	r0, r1, lsl #14
3481fcac:	e0a22002 	adc	r2, r2, r2
3481fcb0:	20400701 	subcs	r0, r0, r1, lsl #14
3481fcb4:	e1500681 	cmp	r0, r1, lsl #13
3481fcb8:	e0a22002 	adc	r2, r2, r2
3481fcbc:	20400681 	subcs	r0, r0, r1, lsl #13
3481fcc0:	e1500601 	cmp	r0, r1, lsl #12
3481fcc4:	e0a22002 	adc	r2, r2, r2
3481fcc8:	20400601 	subcs	r0, r0, r1, lsl #12
3481fccc:	e1500581 	cmp	r0, r1, lsl #11
3481fcd0:	e0a22002 	adc	r2, r2, r2
3481fcd4:	20400581 	subcs	r0, r0, r1, lsl #11
3481fcd8:	e1500501 	cmp	r0, r1, lsl #10
3481fcdc:	e0a22002 	adc	r2, r2, r2
3481fce0:	20400501 	subcs	r0, r0, r1, lsl #10
3481fce4:	e1500481 	cmp	r0, r1, lsl #9
3481fce8:	e0a22002 	adc	r2, r2, r2
3481fcec:	20400481 	subcs	r0, r0, r1, lsl #9
3481fcf0:	e1500401 	cmp	r0, r1, lsl #8
3481fcf4:	e0a22002 	adc	r2, r2, r2
3481fcf8:	20400401 	subcs	r0, r0, r1, lsl #8
3481fcfc:	e1500381 	cmp	r0, r1, lsl #7
3481fd00:	e0a22002 	adc	r2, r2, r2
3481fd04:	20400381 	subcs	r0, r0, r1, lsl #7
3481fd08:	e1500301 	cmp	r0, r1, lsl #6
3481fd0c:	e0a22002 	adc	r2, r2, r2
3481fd10:	20400301 	subcs	r0, r0, r1, lsl #6
3481fd14:	e1500281 	cmp	r0, r1, lsl #5
3481fd18:	e0a22002 	adc	r2, r2, r2
3481fd1c:	20400281 	subcs	r0, r0, r1, lsl #5
3481fd20:	e1500201 	cmp	r0, r1, lsl #4
3481fd24:	e0a22002 	adc	r2, r2, r2
3481fd28:	20400201 	subcs	r0, r0, r1, lsl #4
3481fd2c:	e1500181 	cmp	r0, r1, lsl #3
3481fd30:	e0a22002 	adc	r2, r2, r2
3481fd34:	20400181 	subcs	r0, r0, r1, lsl #3
3481fd38:	e1500101 	cmp	r0, r1, lsl #2
3481fd3c:	e0a22002 	adc	r2, r2, r2
3481fd40:	20400101 	subcs	r0, r0, r1, lsl #2
3481fd44:	e1500081 	cmp	r0, r1, lsl #1
3481fd48:	e0a22002 	adc	r2, r2, r2
3481fd4c:	20400081 	subcs	r0, r0, r1, lsl #1
3481fd50:	e1500001 	cmp	r0, r1
3481fd54:	e0a22002 	adc	r2, r2, r2
3481fd58:	20400001 	subcs	r0, r0, r1
3481fd5c:	e1a00002 	mov	r0, r2
3481fd60:	e12fff1e 	bx	lr
3481fd64:	03a00001 	moveq	r0, #1
3481fd68:	13a00000 	movne	r0, #0
3481fd6c:	e12fff1e 	bx	lr
3481fd70:	e16f2f11 	clz	r2, r1
3481fd74:	e262201f 	rsb	r2, r2, #31
3481fd78:	e1a00230 	lsr	r0, r0, r2
3481fd7c:	e12fff1e 	bx	lr
3481fd80:	e3500000 	cmp	r0, #0
3481fd84:	13e00000 	mvnne	r0, #0
3481fd88:	ea0000ac 	b	34820040 <__aeabi_ldiv0>

3481fd8c <__aeabi_uidivmod>:
3481fd8c:	e3510000 	cmp	r1, #0
3481fd90:	0afffffa 	beq	3481fd80 <__udivsi3+0x1e0>
3481fd94:	e92d4003 	push	{r0, r1, lr}
3481fd98:	ebffff80 	bl	3481fba0 <__udivsi3>
3481fd9c:	e8bd4006 	pop	{r1, r2, lr}
3481fda0:	e0030092 	mul	r3, r2, r0
3481fda4:	e0411003 	sub	r1, r1, r3
3481fda8:	e12fff1e 	bx	lr

3481fdac <__divsi3>:
3481fdac:	e3510000 	cmp	r1, #0
3481fdb0:	0a000081 	beq	3481ffbc <.divsi3_skip_div0_test+0x208>

3481fdb4 <.divsi3_skip_div0_test>:
3481fdb4:	e020c001 	eor	ip, r0, r1
3481fdb8:	42611000 	rsbmi	r1, r1, #0
3481fdbc:	e2512001 	subs	r2, r1, #1
3481fdc0:	0a000070 	beq	3481ff88 <.divsi3_skip_div0_test+0x1d4>
3481fdc4:	e1b03000 	movs	r3, r0
3481fdc8:	42603000 	rsbmi	r3, r0, #0
3481fdcc:	e1530001 	cmp	r3, r1
3481fdd0:	9a00006f 	bls	3481ff94 <.divsi3_skip_div0_test+0x1e0>
3481fdd4:	e1110002 	tst	r1, r2
3481fdd8:	0a000071 	beq	3481ffa4 <.divsi3_skip_div0_test+0x1f0>
3481fddc:	e16f2f13 	clz	r2, r3
3481fde0:	e16f0f11 	clz	r0, r1
3481fde4:	e0402002 	sub	r2, r0, r2
3481fde8:	e272201f 	rsbs	r2, r2, #31
3481fdec:	10822082 	addne	r2, r2, r2, lsl #1
3481fdf0:	e3a00000 	mov	r0, #0
3481fdf4:	108ff102 	addne	pc, pc, r2, lsl #2
3481fdf8:	e320f000 	nop	{0}
3481fdfc:	e1530f81 	cmp	r3, r1, lsl #31
3481fe00:	e0a00000 	adc	r0, r0, r0
3481fe04:	20433f81 	subcs	r3, r3, r1, lsl #31
3481fe08:	e1530f01 	cmp	r3, r1, lsl #30
3481fe0c:	e0a00000 	adc	r0, r0, r0
3481fe10:	20433f01 	subcs	r3, r3, r1, lsl #30
3481fe14:	e1530e81 	cmp	r3, r1, lsl #29
3481fe18:	e0a00000 	adc	r0, r0, r0
3481fe1c:	20433e81 	subcs	r3, r3, r1, lsl #29
3481fe20:	e1530e01 	cmp	r3, r1, lsl #28
3481fe24:	e0a00000 	adc	r0, r0, r0
3481fe28:	20433e01 	subcs	r3, r3, r1, lsl #28
3481fe2c:	e1530d81 	cmp	r3, r1, lsl #27
3481fe30:	e0a00000 	adc	r0, r0, r0
3481fe34:	20433d81 	subcs	r3, r3, r1, lsl #27
3481fe38:	e1530d01 	cmp	r3, r1, lsl #26
3481fe3c:	e0a00000 	adc	r0, r0, r0
3481fe40:	20433d01 	subcs	r3, r3, r1, lsl #26
3481fe44:	e1530c81 	cmp	r3, r1, lsl #25
3481fe48:	e0a00000 	adc	r0, r0, r0
3481fe4c:	20433c81 	subcs	r3, r3, r1, lsl #25
3481fe50:	e1530c01 	cmp	r3, r1, lsl #24
3481fe54:	e0a00000 	adc	r0, r0, r0
3481fe58:	20433c01 	subcs	r3, r3, r1, lsl #24
3481fe5c:	e1530b81 	cmp	r3, r1, lsl #23
3481fe60:	e0a00000 	adc	r0, r0, r0
3481fe64:	20433b81 	subcs	r3, r3, r1, lsl #23
3481fe68:	e1530b01 	cmp	r3, r1, lsl #22
3481fe6c:	e0a00000 	adc	r0, r0, r0
3481fe70:	20433b01 	subcs	r3, r3, r1, lsl #22
3481fe74:	e1530a81 	cmp	r3, r1, lsl #21
3481fe78:	e0a00000 	adc	r0, r0, r0
3481fe7c:	20433a81 	subcs	r3, r3, r1, lsl #21
3481fe80:	e1530a01 	cmp	r3, r1, lsl #20
3481fe84:	e0a00000 	adc	r0, r0, r0
3481fe88:	20433a01 	subcs	r3, r3, r1, lsl #20
3481fe8c:	e1530981 	cmp	r3, r1, lsl #19
3481fe90:	e0a00000 	adc	r0, r0, r0
3481fe94:	20433981 	subcs	r3, r3, r1, lsl #19
3481fe98:	e1530901 	cmp	r3, r1, lsl #18
3481fe9c:	e0a00000 	adc	r0, r0, r0
3481fea0:	20433901 	subcs	r3, r3, r1, lsl #18
3481fea4:	e1530881 	cmp	r3, r1, lsl #17
3481fea8:	e0a00000 	adc	r0, r0, r0
3481feac:	20433881 	subcs	r3, r3, r1, lsl #17
3481feb0:	e1530801 	cmp	r3, r1, lsl #16
3481feb4:	e0a00000 	adc	r0, r0, r0
3481feb8:	20433801 	subcs	r3, r3, r1, lsl #16
3481febc:	e1530781 	cmp	r3, r1, lsl #15
3481fec0:	e0a00000 	adc	r0, r0, r0
3481fec4:	20433781 	subcs	r3, r3, r1, lsl #15
3481fec8:	e1530701 	cmp	r3, r1, lsl #14
3481fecc:	e0a00000 	adc	r0, r0, r0
3481fed0:	20433701 	subcs	r3, r3, r1, lsl #14
3481fed4:	e1530681 	cmp	r3, r1, lsl #13
3481fed8:	e0a00000 	adc	r0, r0, r0
3481fedc:	20433681 	subcs	r3, r3, r1, lsl #13
3481fee0:	e1530601 	cmp	r3, r1, lsl #12
3481fee4:	e0a00000 	adc	r0, r0, r0
3481fee8:	20433601 	subcs	r3, r3, r1, lsl #12
3481feec:	e1530581 	cmp	r3, r1, lsl #11
3481fef0:	e0a00000 	adc	r0, r0, r0
3481fef4:	20433581 	subcs	r3, r3, r1, lsl #11
3481fef8:	e1530501 	cmp	r3, r1, lsl #10
3481fefc:	e0a00000 	adc	r0, r0, r0
3481ff00:	20433501 	subcs	r3, r3, r1, lsl #10
3481ff04:	e1530481 	cmp	r3, r1, lsl #9
3481ff08:	e0a00000 	adc	r0, r0, r0
3481ff0c:	20433481 	subcs	r3, r3, r1, lsl #9
3481ff10:	e1530401 	cmp	r3, r1, lsl #8
3481ff14:	e0a00000 	adc	r0, r0, r0
3481ff18:	20433401 	subcs	r3, r3, r1, lsl #8
3481ff1c:	e1530381 	cmp	r3, r1, lsl #7
3481ff20:	e0a00000 	adc	r0, r0, r0
3481ff24:	20433381 	subcs	r3, r3, r1, lsl #7
3481ff28:	e1530301 	cmp	r3, r1, lsl #6
3481ff2c:	e0a00000 	adc	r0, r0, r0
3481ff30:	20433301 	subcs	r3, r3, r1, lsl #6
3481ff34:	e1530281 	cmp	r3, r1, lsl #5
3481ff38:	e0a00000 	adc	r0, r0, r0
3481ff3c:	20433281 	subcs	r3, r3, r1, lsl #5
3481ff40:	e1530201 	cmp	r3, r1, lsl #4
3481ff44:	e0a00000 	adc	r0, r0, r0
3481ff48:	20433201 	subcs	r3, r3, r1, lsl #4
3481ff4c:	e1530181 	cmp	r3, r1, lsl #3
3481ff50:	e0a00000 	adc	r0, r0, r0
3481ff54:	20433181 	subcs	r3, r3, r1, lsl #3
3481ff58:	e1530101 	cmp	r3, r1, lsl #2
3481ff5c:	e0a00000 	adc	r0, r0, r0
3481ff60:	20433101 	subcs	r3, r3, r1, lsl #2
3481ff64:	e1530081 	cmp	r3, r1, lsl #1
3481ff68:	e0a00000 	adc	r0, r0, r0
3481ff6c:	20433081 	subcs	r3, r3, r1, lsl #1
3481ff70:	e1530001 	cmp	r3, r1
3481ff74:	e0a00000 	adc	r0, r0, r0
3481ff78:	20433001 	subcs	r3, r3, r1
3481ff7c:	e35c0000 	cmp	ip, #0
3481ff80:	42600000 	rsbmi	r0, r0, #0
3481ff84:	e12fff1e 	bx	lr
3481ff88:	e13c0000 	teq	ip, r0
3481ff8c:	42600000 	rsbmi	r0, r0, #0
3481ff90:	e12fff1e 	bx	lr
3481ff94:	33a00000 	movcc	r0, #0
3481ff98:	01a00fcc 	asreq	r0, ip, #31
3481ff9c:	03800001 	orreq	r0, r0, #1
3481ffa0:	e12fff1e 	bx	lr
3481ffa4:	e16f2f11 	clz	r2, r1
3481ffa8:	e262201f 	rsb	r2, r2, #31
3481ffac:	e35c0000 	cmp	ip, #0
3481ffb0:	e1a00233 	lsr	r0, r3, r2
3481ffb4:	42600000 	rsbmi	r0, r0, #0
3481ffb8:	e12fff1e 	bx	lr
3481ffbc:	e3500000 	cmp	r0, #0
3481ffc0:	c3e00102 	mvngt	r0, #-2147483648	; 0x80000000
3481ffc4:	b3a00102 	movlt	r0, #-2147483648	; 0x80000000
3481ffc8:	ea00001c 	b	34820040 <__aeabi_ldiv0>

3481ffcc <__aeabi_idivmod>:
3481ffcc:	e3510000 	cmp	r1, #0
3481ffd0:	0afffff9 	beq	3481ffbc <.divsi3_skip_div0_test+0x208>
3481ffd4:	e92d4003 	push	{r0, r1, lr}
3481ffd8:	ebffff75 	bl	3481fdb4 <.divsi3_skip_div0_test>
3481ffdc:	e8bd4006 	pop	{r1, r2, lr}
3481ffe0:	e0030092 	mul	r3, r2, r0
3481ffe4:	e0411003 	sub	r1, r1, r3
3481ffe8:	e12fff1e 	bx	lr

3481ffec <__lshrdi3>:
3481ffec:	e2523020 	subs	r3, r2, #32
3481fff0:	e262c020 	rsb	ip, r2, #32
3481fff4:	41a00230 	lsrmi	r0, r0, r2
3481fff8:	51a00331 	lsrpl	r0, r1, r3
3481fffc:	41800c11 	orrmi	r0, r0, r1, lsl ip
34820000:	e1a01231 	lsr	r1, r1, r2
34820004:	e12fff1e 	bx	lr

34820008 <__ashrdi3>:
34820008:	e2523020 	subs	r3, r2, #32
3482000c:	e262c020 	rsb	ip, r2, #32
34820010:	41a00230 	lsrmi	r0, r0, r2
34820014:	51a00351 	asrpl	r0, r1, r3
34820018:	41800c11 	orrmi	r0, r0, r1, lsl ip
3482001c:	e1a01251 	asr	r1, r1, r2
34820020:	e12fff1e 	bx	lr

34820024 <__ashldi3>:
34820024:	e2523020 	subs	r3, r2, #32
34820028:	e262c020 	rsb	ip, r2, #32
3482002c:	41a01211 	lslmi	r1, r1, r2
34820030:	51a01310 	lslpl	r1, r0, r3
34820034:	41811c30 	orrmi	r1, r1, r0, lsr ip
34820038:	e1a00210 	lsl	r0, r0, r2
3482003c:	e12fff1e 	bx	lr

34820040 <__aeabi_ldiv0>:
34820040:	e92d4002 	push	{r1, lr}
34820044:	e3a00008 	mov	r0, #8
34820048:	ebfffecb 	bl	3481fb7c <raise>
3482004c:	e8bd8002 	pop	{r1, pc}
